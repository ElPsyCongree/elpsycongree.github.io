<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    
    <meta name="keywords" content="leinlin, ARIA, Hexo">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="leinlin的小笔记" type="application/atom+xml" />
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-light.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/clipboard.min.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    
    <script defer type="text/javascript" src="https://cdn.staticfile.org/MathJax/MathJax-2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code"]
      }
    });
    </script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += " has-jax";
      }
    });
    </script>
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var cb = null;
      var els = $(".post figure.highlight");
      if (els.length) {
        // Enabled Hexo highlight line number.
        $(els).each(function (i, e) {
          // $(e).before("<button class=\"copy button\">复制</button>");
          $(e).before([
            "<div class=\"code-titlebar\">",
              "<div class=\"titlebar-left\">",
                "<button class=\"copy\">复制</button>",
              "</div>",
            "</div>"
          ].join(""));
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              return trigger.parentNode.parentNode.nextElementSibling.firstChild.firstChild.firstChild.lastChild.firstChild.firstChild;
          }
        });
      } else {
        // Disabled Hexo highlight line number.
        els = $(".post pre code");
        $(els).each(function (i, e) {
          // Add button before pre, not code.
          // $(e).parent().before("<button class=\"copy button\">复制</button>");
          $(e).before([
            "<div class=\"code-titlebar\">",
              "<div class=\"titlebar-left\">",
                "<button class=\"copy\" >复制</button>",
              "</div>",
              "<div class=\"titlebar-right\">",
                "<button class=\"button-dot dot-minimize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-maximize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-close\" aria-label=\"Decoration\"></button>",
              "</div>",
            "</div>"
          ].join(""));
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              return trigger.parentNode.parentNode.nextElementSibling;
          }
        });
      }
      cb.on("success", function (e) {
        e.clearSelection();
        var trigger = e.trigger;
        // Change button text as a user tip.
        trigger.innerHTML = "已复制";
        $(trigger).addClass("copied");
        // Change button text back;
        setTimeout(function () {
          trigger.innerHTML = "复制";
          $(trigger).removeClass("copied");
        }, 1500);
      });
    });
    </script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>leinlin的小笔记</title>
  <meta name="generator" content="Hexo 6.2.0"></head>
  <body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"  data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">leinlin的小笔记</a></h1>
        <h2 class="subtitle"></h2>
      </div>
      
    </div>
    <nav id="nav" class="nav">
      <a id="nav-toggle" class="nav-toggle" aria-hidden="true"><i class="fas fa-bars" aria-label="切换导航栏"></i></a>
      <ul id="menu" role="menubar" aria-hidden="false">
        
        <li role="menuitem"><a href="/" class="current"><i class="fas fa-home"></i><span class="menu-text">首页</span></a></li>
        
        <li role="menuitem"><a href="/categories/"><i class="fas fa-th-list"></i><span class="menu-text">分类</span></a></li>
        
      </ul>
    </nav>
  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            

<div id="index" class="index page">
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2023/06/02/Shader/ShaderModel%E4%B8%8EES%E7%89%88%E6%9C%AC%E5%92%8CGPU%E7%89%B9%E6%80%A7%E7%9A%84%E5%85%B3%E7%B3%BB/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2023/06/02/Shader/ShaderModel%E4%B8%8EES%E7%89%88%E6%9C%AC%E5%92%8CGPU%E7%89%B9%E6%80%A7%E7%9A%84%E5%85%B3%E7%B3%BB/" itemprop="url">ShaderModel与ES版本和GPU特性的关系</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2023-06-02T12:00:14+08:00">2023-06-02 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="ShaderModel与ES版本和GPU特性的关系"><a href="#ShaderModel与ES版本和GPU特性的关系" class="headerlink" title="ShaderModel与ES版本和GPU特性的关系"></a>ShaderModel与ES版本和GPU特性的关系</h1><h2 id="Opengl版本和功能的对应"><a href="#Opengl版本和功能的对应" class="headerlink" title="Opengl版本和功能的对应"></a>Opengl版本和功能的对应</h2><p><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/History_of_OpenGL">Opengl网站</a></p>
<h3 id="OpenGL-4-0-2010"><a href="#OpenGL-4-0-2010" class="headerlink" title="OpenGL 4.0 (2010)"></a>OpenGL 4.0 (2010)</h3><table>
<thead>
<tr>
<th align="center">Addition</th>
<th align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Extension#Core_Extensions">Core Extension</a></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Shading language 4.00</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/texture_query_lod.txt">ARB_texture_query_lod</a>, <a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/gpu_shader5.txt">ARB_gpu_shader5</a>, <a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/gpu_shader_fp64.txt">ARB_gpu_shader_fp64</a>, <a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/shader_subroutine.txt">ARB_shader_subroutine</a>, <a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/texture_gather.txt">ARB_texture_gather</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Indirect_Drawing">Indirect Drawing</a>, without multidraw</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/draw_indirect.txt">ARB_draw_indirect</a></td>
</tr>
<tr>
<td align="center">Request minimum number of fragment inputs</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/sample_shading.txt">ARB_sample_shading</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Tessellation">Tessellation</a>, with shader stages</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/tessellation_shader.txt">ARB_tessellation_shader</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Buffer_Texture">Buffer Texture</a> formats RGB32F, RGB32I, RGB32UI</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/texture_buffer_object_rgb32.txt">ARB_texture_buffer_object_rgb32</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Cubemap_Array_Texture">Cubemap Array Texture</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/texture_cube_map_array.txt">ARB_texture_cube_map_array</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Transform_Feedback">Transform Feedback</a> objects and multiple feedback stream output.</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/transform_feedback2.txt">ARB_transform_feedback2</a>, <a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/transform_feedback3.txt">ARB_transform_feedback3</a></td>
</tr>
<tr>
<td align="center">Addition</td>
<td align="center">Promoted from</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Draw_Buffer_Blend">Individual blend equations for each color output</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/draw_buffers_blend.txt">ARB_draw_buffers_blend</a></td>
</tr>
</tbody></table>
<h3 id="OpenGL-3-3-2010"><a href="#OpenGL-3-3-2010" class="headerlink" title="OpenGL 3.3 (2010)"></a>OpenGL 3.3 (2010)</h3><table>
<thead>
<tr>
<th align="center">Addition</th>
<th align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Extension#Core_Extensions">Core Extension</a></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Shading language 3.30</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/shader_bit_encoding.txt">ARB_shader_bit_encoding</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Dual_Source_Blending">Dual-source blending</a>.</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/blend_func_extended.txt">ARB_blend_func_extended</a></td>
</tr>
<tr>
<td align="center">Shader-defined locations for <a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Layout_Vertex_Attribute">attributes</a> and <a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Layout_Fragment_Output">fragment shader outputs</a>.</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/explicit_attrib_location.txt">ARB_explicit_attrib_location</a></td>
</tr>
<tr>
<td align="center">Simple boolean <a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Occlusion_Query">Occlusion Query</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/occlusion_query2.txt">ARB_occlusion_query2</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Sampler_Object">Sampler Objects</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/sampler_objects.txt">ARB_sampler_objects</a></td>
</tr>
<tr>
<td align="center">A new <a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Image_Format">image format</a> for unsigned 10.10.10.2 colors</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/texture_rgb10_a2ui.txt">ARB_texture_rgb10_a2ui</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Texture_Swizzle">Texture swizzle</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/texture_swizzle.txt">ARB_texture_swizzle</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Timer_Query">Timer queries</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/timer_query.txt">ARB_timer_query</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Instanced_Array">Instanced arrays</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/instanced_arrays.txt">ARB_instanced_arrays</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Vertex_Format_Type">Vertex attributes 2.10.10.10</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/vertex_type_2_10_10_10_rev.txt">ARB_vertex_type_2_10_10_10_rev</a></td>
</tr>
</tbody></table>
<h3 id="OpenGL-3-2-2009"><a href="#OpenGL-3-2-2009" class="headerlink" title="OpenGL 3.2 (2009)"></a>OpenGL 3.2 (2009)</h3><ul>
<li>Core and compatibility profiles</li>
<li>Shading language 1.50</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Addition</th>
<th align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Extension#Core_Extensions">Core Extension</a></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/D3D_Vertex_Format_Compatibility">D3D compatible color vertex component ordering</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/vertex_array_bgra.txt">ARB_vertex_array_bgra</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Draw_Base_Index">Drawing command allowing modification of the base vertex index</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/draw_elements_base_vertex.txt">ARB_draw_elements_base_vertex</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Fragment_Shader#System_inputs">Shader fragment coordinate convention control</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/fragment_coord_conventions.txt">ARB_fragment_coord_conventions</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Provoking_Vertex">Provoking vertex control</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/provoking_vertex.txt">ARB_provoking_vertex</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Seamless_Cubemap">Seamless cube map filtering</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/seamless_cube_map.txt">ARB_seamless_cube_map</a></td>
</tr>
<tr>
<td align="center">Multisampled textures and texture samplers for specific sample locations</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/texture_multisample.txt">ARB_texture_multisample</a></td>
</tr>
<tr>
<td align="center">Fragment <a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Depth_Clamp">Depth Clamping</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/depth_clamp.txt">ARB_depth_clamp</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Sync_Object">Fence sync objects</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/sync.txt">ARB_sync</a></td>
</tr>
<tr>
<td align="center">Addition</td>
<td align="center">Promoted from</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Geometry_Shader">Geometry Shaders</a>, as well as input&#x2F;output <a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Interface_Block">Interface Blocks</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/geometry_shader4.txt">ARB_geometry_shader4</a>, heavily modified.</td>
</tr>
</tbody></table>
<h3 id="OpenGL-3-1-2009"><a href="#OpenGL-3-1-2009" class="headerlink" title="OpenGL 3.1 (2009)"></a>OpenGL 3.1 (2009)</h3><ul>
<li>All features deprecated in OpenGL 3.0 are removed except wide lines</li>
<li>Shading language 1.40</li>
<li>SNORM texture component formats</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Addition</th>
<th align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Extension#Core_Extensions">Core Extension</a></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object">Uniform Buffer Objects</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/uniform_buffer_object.txt">ARB_uniform_buffer_object</a></td>
</tr>
<tr>
<td align="center">Addition</td>
<td align="center">Promoted from</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Instancing">Instanced rendering with a per instance counter accessible to vertex shaders</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/draw_instanced.txt">ARB_draw_instanced</a></td>
</tr>
<tr>
<td align="center">Data copying between buffer objects</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/EXT/copy_buffer.txt">EXT_copy_buffer</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Primitive_restart">Primitive restart</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/NV/primitive_restart.txt">NV_primitive_restart</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Buffer_Texture">Buffer Textures</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/texture_buffer_object.txt">ARB_texture_buffer_object</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Rectangle_Texture">Rectangle Textures</a></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/texture_rectangle.txt">ARB_texture_rectangle</a></td>
</tr>
</tbody></table>
<h2 id="Microsoft对ShaderModel的定义"><a href="#Microsoft对ShaderModel的定义" class="headerlink" title="Microsoft对ShaderModel的定义"></a>Microsoft对ShaderModel的定义</h2><p>HLSL的ShaderModel主要表示不同版本的Shader支持的语言、功能特性。（The HLSL shader model is a versioning approach indicating which new features are added to the language. </p>
<p>应用和游戏可以针对某个版本通用的功能进行开发，硬件和驱动工程师也可以针对这个版本的特性进行支持。</p>
<p>不同的ShaderModel版本：不同的处理阶段（Geometry etc）、约束、处理能力、向下兼容情况。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509654(v=vs.85).aspx">Shader Model 1</a>. This was the first shader model created in DirectX. It introduced vertex and pixel shaders to the first implementation of the programmable pipeline.</li>
<li><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509655(v=vs.85).aspx">Shader Model 2</a>. Adds new intrinsics and increases limits on registers and instructions.</li>
<li><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509656(v=vs.85).aspx">Shader Model 3</a>. Adds new intrinsics and increases limits on registers and instructions.</li>
<li><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509657(v=vs.85).aspx">Shader Model 4</a>. This is a superset of the capabilities in Shader Model 3, except that Shader Model 4 doesn’t support the features in Shader Model 1. It has been designed using a common-shader core that gives a common set of features to all programmable shaders, which are only programmable using HLSL. It adds new shader profiles to target geometry shaders.</li>
<li><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471356(v=vs.85).aspx">Shader Model 5</a>. This is a superset of shader model 4 and adds new resources, compute shaders and tessellation.</li>
<li><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn933277(v=vs.85).aspx">Shader Model 5.1</a>. This is functionally very similar to Shader Model 5; the main change is more flexibility in resource selection by allowing indexing of arrays of descriptors from within a shader.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/microsoft/DirectXShaderCompiler/wiki/Shader-Model-6.0">Shader Model 6.0</a>. This is a superset of shader model 5.1 with some deprecated language elements and with the addition of wave intrinsics and 64-bit integers for arithmetic.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/microsoft/DirectXShaderCompiler/wiki/Shader-Model-6.1">Shader Model 6.1</a>. This is a superset of shader model 6.0 that adds support for SV_ViewID, barycentric semantics and the GetAttributeAtVertex intrinsic.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/microsoft/DirectXShaderCompiler/wiki/Shader-Model-6.2">Shader Model 6.2</a>. Adds support for float16 (as opposed to minfloat16) and denorm mode selection.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/microsoft/DirectXShaderCompiler/wiki/Shader-Model-6.3">Shader Model 6.3</a>. Adds support for DirectX Raytracing (DXR), including libraries and linking.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/microsoft/DirectXShaderCompiler/wiki/Shader-Model-6.4">Shader Model 6.4</a>. Adds low-precision packed dot product intrinsics, and support for library sub-objects to simplify raytracing.</li>
</ul>
<p>Differences between Direct3D 9 and Direct3D 10:<br>Direct3D 9 introduced shader models 1, 2, and 3.<br>Direct3D 10 introduced shader model 4.<br>Direct3D 10.1 introduced shader model 4.1.</p>
<h2 id="Unity对不同版本的定义"><a href="#Unity对不同版本的定义" class="headerlink" title="Unity对不同版本的定义"></a>Unity对不同版本的定义</h2><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html">https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html</a></p>
<p>Here is the list of shader models supported, with roughly increasing set of capabilities (and in some cases higher platform&#x2F;GPU requirements):</p>
<h4 id="pragma-target-2-0"><a href="#pragma-target-2-0" class="headerlink" title="#pragma target 2.0"></a>#pragma target 2.0</h4><ul>
<li>Works on all platforms supported by Unity. DX9 shader model 2.0.</li>
<li>Limited amount of arithmetic &amp; texture instructions; 8 interpolators; no vertex texture sampling; no derivatives in <strong>fragment shaders</strong><br>; no explicit <strong>LOD</strong><br> texture sampling.</li>
</ul>
<h4 id="pragma-target-2-5-default"><a href="#pragma-target-2-5-default" class="headerlink" title="#pragma target 2.5 (default)"></a>#pragma target 2.5 (default)</h4><ul>
<li>Almost the same as 3.0 target (see below), except still only has 8 interpolators, and does not have explicit LOD texture sampling.</li>
<li>Compiles into DX11 feature level 9.3 on Windows Phone.</li>
</ul>
<h4 id="pragma-target-3-0"><a href="#pragma-target-3-0" class="headerlink" title="#pragma target 3.0"></a>#pragma target 3.0</h4><ul>
<li>DX9 shader model 3.0: derivative instructions, texture LOD sampling, 10 interpolators, more math&#x2F;texture instructions allowed.</li>
<li>Not supported on DX11 feature level 9.x GPUs (e.g. most Windows Phone devices).</li>
<li>Might not be fully supported by some OpenGL ES 2.0 devices, depending on driver extensions present and features used.</li>
</ul>
<h4 id="pragma-target-3-5-or-es3-0"><a href="#pragma-target-3-5-or-es3-0" class="headerlink" title="#pragma target 3.5 (or es3.0)"></a>#pragma target 3.5 (or es3.0)</h4><ul>
<li>OpenGL ES 3.0 capabilities (DX10 SM4.0 on D3D platforms, just without geometry shaders).</li>
<li>Not supported on DX11 9.x (WinPhone), OpenGL ES 2.0.</li>
<li>Supported on DX11+, OpenGL 3.2+, OpenGL ES 3+, Metal, Vulkan, PS4&#x2F;XB1 consoles.</li>
<li>Native integer operations in shaders, texture arrays and so on.</li>
</ul>
<h4 id="pragma-target-4-0"><a href="#pragma-target-4-0" class="headerlink" title="#pragma target 4.0"></a>#pragma target 4.0</h4><ul>
<li>DX11 shader model 4.0.</li>
<li>Not supported on DX11 9.x (WinPhone), OpenGL ES 2.0&#x2F;3.0&#x2F;3.1, Metal.</li>
<li>Supported on DX11+, OpenGL 3.2+, OpenGL ES 3.1+AEP, Vulkan, PS4&#x2F;XB1 consoles.</li>
<li>Has geometry shaders and everything that <code>es3.0</code> target has.</li>
</ul>
<h4 id="pragma-target-4-5-or-es3-1"><a href="#pragma-target-4-5-or-es3-1" class="headerlink" title="#pragma target 4.5 (or es3.1)"></a>#pragma target 4.5 (or es3.1)</h4><ul>
<li>OpenGL ES 3.1 capabilities (DX11 SM5.0 on D3D platforms, just without tessellation shaders).</li>
<li>Not supported on DX11 before SM5.0, OpenGL before 4.3 (i.e. Mac), OpenGL ES 2.0&#x2F;3.0.</li>
<li>Supported on DX11+ SM5.0, OpenGL 4.3+, OpenGL ES 3.1, Metal, Vulkan, PS4&#x2F;XB1 consoles.</li>
<li>Has compute shaders, random access texture writes, atomics and so on. No geometry or tessellation shaders.</li>
</ul>
<h4 id="pragma-target-4-6-or-gl4-1"><a href="#pragma-target-4-6-or-gl4-1" class="headerlink" title="#pragma target 4.6 (or gl4.1)"></a>#pragma target 4.6 (or gl4.1)</h4><ul>
<li>OpenGL 4.1 capabilities (DX11 SM5.0 on D3D platforms, just without compute shaders). This is basically the highest OpenGL level supported by Macs.</li>
<li>Not supported on DX11 before SM5.0, OpenGL before 4.1, OpenGL ES 2.0&#x2F;3.0&#x2F;3.1, Metal.</li>
<li>Supported on DX11+ SM5.0, OpenGL 4.1+, OpenGL ES 3.1+AEP, Vulkan, Metal (without geometry), PS4&#x2F;XB1 consoles.</li>
</ul>
<h4 id="pragma-target-5-0"><a href="#pragma-target-5-0" class="headerlink" title="#pragma target 5.0"></a>#pragma target 5.0</h4><ul>
<li>DX11 shader model 5.0.</li>
<li>Not supported on DX11 before SM5.0, OpenGL before 4.3 (i.e. Mac), OpenGL ES 2.0&#x2F;3.0&#x2F;3.1, Metal.</li>
<li>Supported on DX11+ SM5.0, OpenGL 4.3+, OpenGL ES 3.1+AEP, Vulkan, Metal (without geometry), PS4&#x2F;XB1 consoles.</li>
</ul>

      
      <p align="right"><a class="morebtn" href="/2023/06/02/Shader/ShaderModel%E4%B8%8EES%E7%89%88%E6%9C%AC%E5%92%8CGPU%E7%89%B9%E6%80%A7%E7%9A%84%E5%85%B3%E7%B3%BB/" title="ShaderModel与ES版本和GPU特性的关系">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2023/06/02/Shader/Shader%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2023/06/02/Shader/Shader%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/" itemprop="url">Shader函数重载问题</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2023-06-02T12:00:14+08:00">2023-06-02 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="Shader函数重载问题"><a href="#Shader函数重载问题" class="headerlink" title="Shader函数重载问题"></a>Shader函数重载问题</h1><p>目前在编写shader的时候发现：</p>
<p>Shader函数可以重载（和c++一样的OverLoad）</p>
<p>GLSL的说明：</p>
<p><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)">https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)</a></p>
<p>Metal的说明：</p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf">https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf</a></p>
<p>但是发现重载函数互相调用会失败。</p>
<p>目前没有查到具体文献，和那些平台有限制。</p>
<p>在几个地方进行了实验：</p>
<p>ShaderToy（Glsl），是正常的：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">vec4 <span class="hljs-title function_">contrast</span><span class="hljs-params">(vec4 col, <span class="hljs-type">float</span> x,<span class="hljs-type">float</span> y)</span> &#123;<br>	<span class="hljs-keyword">return</span> x * (col - <span class="hljs-number">0.5</span>) + <span class="hljs-number">0.5</span>+y;<br>&#125;<br><br>vec4 <span class="hljs-title function_">contrast</span><span class="hljs-params">(vec4 col, <span class="hljs-type">float</span> x)</span> &#123;<br>    <span class="hljs-keyword">return</span> contrast( col,  x,<span class="hljs-number">110.0f</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Valkun，是正常的：</p>
<p><img src="/../../images/Shader%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/1574822744053.png" alt="1574822744053"></p>
<p>目前没有Metal的测试环境。</p>

      
      <p align="right"><a class="morebtn" href="/2023/06/02/Shader/Shader%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/" title="Shader函数重载问题">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2023/06/02/Shader/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E7%9F%A9%E9%98%B5%E8%A1%8C%E5%88%97%E4%B8%BB%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%BD%B1%E5%93%8D/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2023/06/02/Shader/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E7%9F%A9%E9%98%B5%E8%A1%8C%E5%88%97%E4%B8%BB%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%BD%B1%E5%93%8D/" itemprop="url">不同图形API矩阵行列主序及其影响</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2023-06-02T12:00:14+08:00">2023-06-02 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="不同图形API矩阵行列主序及其影响"><a href="#不同图形API矩阵行列主序及其影响" class="headerlink" title="不同图形API矩阵行列主序及其影响"></a>不同图形API矩阵行列主序及其影响</h1><p>矩阵的行主序和列主序影响了空间变换是矩阵乘法的使用方式。</p>
<p>Opengl的矩阵使用列主序，(参考资料](<a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Data_Type_(GLSL))%E3%80%82">https://www.khronos.org/opengl/wiki/Data_Type_(GLSL))。</a></p>
<ul>
<li>mat<em>n</em>x<em>m</em>: A matrix with <em>n</em> columns and <em>m</em> rows. OpenGL uses column-major matrices, which is standard for mathematics users. Example: mat3x4.</li>
<li>mat<em>n</em>: A matrix with <em>n</em> columns and <em>n</em> rows. Shorthand for mat<em>n</em>x<em>n</em></li>
</ul>
<p>例子：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">mat3 theMatrix;<br>theMatrix[<span class="hljs-number">1</span>] = vec3(<span class="hljs-number">3.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">3.0</span>); <span class="hljs-comment">// Sets the second column to all 3.0s</span><br>theMatrix[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">16.0</span>; <span class="hljs-comment">// Sets the first entry of the third column to 16.0.</span><br></code></pre></td></tr></table></figure>

<p>D3D使用的是行主序：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">matrix &lt;<span class="hljs-type">float</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&gt; fMatrix = &#123; <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.1</span>, <span class="hljs-comment">// row 1</span><br>                                 <span class="hljs-number">2.1f</span>, <span class="hljs-number">2.2f</span> <span class="hljs-comment">// row 2</span><br>                               &#125;;<br></code></pre></td></tr></table></figure>

<p>具体使用矩阵时，要注意CPU端buffer的定义方式和矩阵乘法统一即可。</p>
<p>使用不同的图形API时，CPU设置Buffer：</p>
<p>假如View矩阵在CPU端是行主序，直接Copy到Buffer，那么D3D是正常的，但是Opengl就变成了列主序。此时，View空间变换：D3D需要进行mul（V,vector）,Opengl就是需要mul（vector，V）。</p>
<p>使用不同的图形API时，Shader当中构造矩阵：</p>
<p>需要注意opengl的m01,指的是第一列第二行。</p>

      
      <p align="right"><a class="morebtn" href="/2023/06/02/Shader/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E7%9F%A9%E9%98%B5%E8%A1%8C%E5%88%97%E4%B8%BB%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%BD%B1%E5%93%8D/" title="不同图形API矩阵行列主序及其影响">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2023/06/02/Shader/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2023/06/02/Shader/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/" itemprop="url">GPU浮点数的精确度以及注意事项</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2023-06-02T12:00:14+08:00">2023-06-02 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <!-- TOC -->



<p>- <a href="#gpu%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6%E4%BB%A5%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">GPU浮点数的精确度以及注意事项</a></p>
<p>​    - <a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8">浮点数的作用</a></p>
<p>​    - <a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9B%9E%E9%A1%BE">浮点数回顾</a></p>
<p>​    - <a href="#%E6%A0%87%E5%87%86%E5%92%8C%E4%BD%8E%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0">标准和低精度浮点数</a></p>
<p>​    - <a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%8C%83%E5%9B%B4%E8%A7%A3%E9%87%8A">浮点数范围解释</a></p>
<p>​    - <a href="#%E4%BD%8E%E7%B2%BE%E5%BA%A6%E5%B0%BE%E6%95%B0%E4%BD%8D%E9%97%AE%E9%A2%98%E4%B8%BE%E4%BE%8B">低精度尾数位问题举例</a></p>
<p>​    - <a href="#%E4%BD%8E%E7%B2%BE%E5%BA%A6%E5%B0%BE%E6%95%B0%E4%BD%8D%E9%97%AE%E9%A2%98%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%A4%BA">低精度尾数位问题可视化展示</a></p>
<p>​    - <a href="#%E4%BD%8E%E7%B2%BE%E5%BA%A6%E4%B8%8D%E5%9D%87%E5%8C%80%E5%B0%BE%E6%95%B0%E4%BD%8D%E9%95%BF%E5%BA%A6%E9%97%AE%E9%A2%98">低精度不均匀尾数位长度问题</a></p>
<p>​    - <a href="#%E9%A2%9C%E8%89%B2%E7%BC%A9%E6%94%BE%E5%A4%B1%E6%95%88">颜色缩放失效</a></p>
<!-- /TOC -->

<h1 id="GPU浮点数的精确度以及注意事项"><a href="#GPU浮点数的精确度以及注意事项" class="headerlink" title="GPU浮点数的精确度以及注意事项"></a>GPU浮点数的精确度以及注意事项</h1><p>​		在hdr的开发流程中，pbr的灯光计算结果和特效的亮度理论上是没有上限，但是需要保存到Color Buffer当中，这就涉及到Color Buffer的数据精度，通常Color Buffer的格式是R11G11B10F。所以需要进行Min操作，来保证保存到RT当中的数据没有溢出，因为计算的精度通常是half或者float要比保存的精确度高。所以会有一些问题，下面找到了资料来讨论Float精确度相关的问题。</p>
<p>​		内容主要摘录一部分自：<a target="_blank" rel="noopener" href="https://bartwronski.com/2017/04/02/small-float-formats-r11g11b10f-precision/">参考链接</a>，并作了补充和例子说明，本文主要为了说明Color Buffer浮点数范围问题，原文对误差部分做了更详细的讨论。</p>
<h2 id="浮点数的作用"><a href="#浮点数的作用" class="headerlink" title="浮点数的作用"></a>浮点数的作用</h2><p>通常颜色在渲染中的表示不是整型，而是浮点数。浮点数有很大的浮动范围可以用于：</p>
<ul>
<li>编码HDR的颜色和记录光照。</li>
<li>当操作多个颜色的混合滤波需要分数。</li>
<li>在黑暗区域不通过Gamma编码也可以表示更大的精确度。</li>
<li>需要量化边界相对误差</li>
<li>浮点数是GPU的自然表示（GPU很长一段时间没有整数的支持，并且用浮点数模拟，并且现在整数的操作比浮点数慢）。</li>
</ul>
<p>​		即便浮点数十分重要，但是我们很少存储32bit的浮点数值，即便是HDR的颜色。因为内存带宽和性能两部分的限制。内存带宽和缓存通常是重要的资源，最基础的经验法则是： “ALU is cheap, memory access is expensive”。即便是最简单的内存访问操作也需要上百个时钟周期的延迟。并且纹理单元的开销更高，应为需要滤波等开销很高的操作。</p>
<p>​		因此，渲染程序员通常使用低精度的浮点数格式来保存浮点数。两个最常用的是RGBA16F(4通道的16bit的单精度浮点数)和R11G11B10F（R和G通道使用11bit，B通道使用10bit）。</p>
<p>​		下面先分析IEEE的32bit浮点数和上述浮点数格式的区别：</p>
<h2 id="浮点数回顾"><a href="#浮点数回顾" class="headerlink" title="浮点数回顾"></a>浮点数回顾</h2><p>​	浮点数的表示方式：</p>
<ul>
<li><p>符号位<strong>sign</strong>：一个bit用来表示符号位。在数据最前面的一个bit，可选。</p>
</li>
<li><p>指数位<strong>exponent</strong>：多个Bit用来表示2的指数幂和剩余的数相乘，<strong>阶码是有偏移的，单精度偏移是127（0000001 表示 -126 11111110 表示127 而全0和全1有特殊用处），双精度是1024。 11bit和10bit 指数位5位偏移应该是15</strong></p>
</li>
<li><p>尾数位<strong>mantissa</strong>：多个bit用来表示数据的表示小数部分，和指数位结果相乘，通常假设小数点前整数位是1（<strong>这个是IEEE 754标准，其他标准也可能会约定小点后第一位始终是1</strong>）。例如：如果尾数位是01011000 ，那么他表示的数是：1.01011000</p>
<p>所以最终表示是数是：</p>
</li>
</ul>
<p>$$ sign(\pm 1)*2^{decoded exponent} *1.mantissa  $$</p>
<p>​		<strong>参见对指数位的说明，对很多特殊的编码，指数位使用了特殊的值。这里只讨论一个：0的编码，通过将指数和尾数都设置成0，由于符号位可以设置，所以会存在两个0 （+0 和-0）。</strong></p>
<p>​		浮点数是一种非常聪明的表示法，它具有许多很好的属性（例如，正浮点数可以解释为整数可以直观的排序或计算最小&#x2F;最大，并且整数0对应于正的浮点数0）。然而，伴随而来的是许多精度问题，这些问题并不总是最直观的。下面来谈论这些问题。</p>
<h2 id="标准和低精度浮点数"><a href="#标准和低精度浮点数" class="headerlink" title="标准和低精度浮点数"></a>标准和低精度浮点数</h2><p>​		下面是常用的浮点数格式和编码方式。</p>
<table>
<thead>
<tr>
<th><strong>Bit depth</strong></th>
<th><strong>Sign bit present?</strong></th>
<th><strong>Exponent bits</strong></th>
<th><strong>Mantissa bits</strong></th>
</tr>
</thead>
<tbody><tr>
<td>32</td>
<td>Yes</td>
<td>8</td>
<td>23</td>
</tr>
<tr>
<td>16</td>
<td>Yes</td>
<td>5</td>
<td>10</td>
</tr>
<tr>
<td>11</td>
<td>No</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>10</td>
<td>No</td>
<td>5</td>
<td>5</td>
</tr>
</tbody></table>
<p>​		可以发现一些规律：</p>
<ul>
<li>11和10位的浮点数没有符号位，主要是由于本身精确度并不高，并且通常被图形API用作保存颜色的格式，所以没有必要使用符号位。</li>
<li><strong>16bit的half类型和11bit、10bit有相同的指数位。但是有符号位，整数和负数有相同的范围。5位的指数位可以保证最大到64500到65500之间（见下方解释）</strong></li>
</ul>
<h2 id="浮点数范围解释"><a href="#浮点数范围解释" class="headerlink" title="浮点数范围解释"></a>浮点数范围解释</h2><p>​		<strong>这里主要讨论16bit、11bit和10bit的浮点数上限，因为32bit的浮点数完成光照计算之后要进行Min操作，然后才能保存到RT当中，所以Min的操作数十分关键。</strong></p>
<p>​		由于这三个类型的指数位都相同，所以上限依赖于<strong>尾数位的数量</strong>：</p>
<ul>
<li><p>16位的float，尾数最大可以表示1.1111111111 ，十进制为1.9990234375；5位指数位，计算偏移15，那么最大可以表示11110 &#x3D;15，指数部分就是32768，最大的数就是32768*1.9990234375，约为65,504。</p>
</li>
<li><p>11bit的浮点数，尾数最大可以表示1.111111，十进制为1.984375；5位指数位，计算偏移15，那么最大可以表示11110 &#x3D;15，指数部分就是32768，最大数就是32768*1.984375&#x3D; 65,024  。</p>
</li>
<li><p>10bit的浮点数，尾数最大可以表示1.11111，十进制为1.96875；5位指数位，计算偏移15，那么最大可以表示11110 &#x3D;15，指数部分就是32768，最大为32768*1.96875&#x3D;64,512‬）</p>
</li>
</ul>
<p><strong>综上所述在保存数据的时候如果不清楚引擎当中如何设置hdr Color buffer类型，Min的上限设置成64500是最安全的。</strong></p>
<h2 id="低精度尾数位问题举例"><a href="#低精度尾数位问题举例" class="headerlink" title="低精度尾数位问题举例"></a>低精度尾数位问题举例</h2><p>首先看一个用8位整数表示0-1的例子：</p>
<p>N[252&#x2F;255, 8] &#x3D;  0.98823529</p>
<p>N[253&#x2F;255, 8] &#x3D;  0.99215686</p>
<p>N[254&#x2F;255, 8] &#x3D;  0.99607843</p>
<p>接下来用二进制小数表示他们：</p>
<p>BaseForm[N[2*252&#x2F;255, 8], 2] &#x3D; 1.<strong>11111</strong>00111111001111110100</p>
<p>BaseForm[N[2*253&#x2F;255, 8], 2] &#x3D; 1.<strong>11111</strong>01111111011111111000</p>
<p>BaseForm[N[2*254&#x2F;255, 8], 2] &#x3D; 1.<strong>11111</strong>10111111101111111100</p>
<p>​		我高亮了前五位小数位。我们知道10bit的浮点数只有5bit的尾数位，可以发现10bit的浮点数甚至不能精确地表示8bit整型颜色（因为5bit尾数不足以区分这三个颜色，<strong>主要原因有效位太短</strong>）。于此同时，你能够看到下一位是不同的，因此在11bit的浮点数中可以被区分出来，这就会造成白色的错误表示。</p>
<h2 id="低精度尾数位问题可视化展示"><a href="#低精度尾数位问题可视化展示" class="headerlink" title="低精度尾数位问题可视化展示"></a>低精度尾数位问题可视化展示</h2><p>好的，我们知道低位数的浮点数甚至不能准确地表示简单的8位亮度。但是会差到什么程度呢？</p>
<p>我们创建了尾数位的可视化效果。</p>
<p><img src="/../../images/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/10bit_floatvs8bit_linear.png" alt="10bit_floatvs8bit_linear.png"></p>
<p>随着数值增大误差也快速增加。</p>
<p>我们通常不使用8bit的线性值保存颜色， 因为为了节省精度，保存人眼更敏感的部分（暗部），所以用Gamma。下面是考虑了Gamma编码的误差结果。</p>
<p><img src="/../../images/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/10bit_floatvs8bit_srgb.png" alt="10bit_floatvs8bit_srgb.png"></p>
<p>​		<strong>这部分主要展示了不同的数据有效位对于颜色误差的影响。为什么随着数据变大误差会变大？因为数据越大需要的有效位数越多，但是可用的有效位又是固定的，所以会呈现上面的效果。</strong></p>
<h2 id="低精度不均匀尾数位长度问题"><a href="#低精度不均匀尾数位长度问题" class="headerlink" title="低精度不均匀尾数位长度问题"></a>低精度不均匀尾数位长度问题</h2><p>由于R11G11B10类型的浮点数有不均的尾数，我们量化他们的区别。</p>
<p><img src="/../../images/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/11bit_float_vs_10bit_float.png" alt="11bit_float_vs_10bit_float.png"></p>
<p>数值越大误差越大。</p>
<p><img src="/../../images/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/11bit_float_vs_10bit_float_smallerrange.png" alt="11bit_float_vs_10bit_float_smallerrange.png"></p>
<p>这种误差意味着什么？下面是从0.5到0.6的颜色变化，产生了错误的饱和度。</p>
<p><img src="/../../images/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/gradient_quantized.png" alt="gradient_quantized.png"></p>
<p>如何显示器好，这个效果会更加明显，例如hdr显示器有更加精确的显示范围和色域，可以看到：</p>
<p><img src="/../../images/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/gradient_quantized_contrast.png" alt="gradient_quantized_contrast.png"></p>
<p><strong>可以通过改变颜色动态范围和dithering来修正这样的效果。</strong></p>
<h2 id="颜色缩放失效"><a href="#颜色缩放失效" class="headerlink" title="颜色缩放失效"></a>颜色缩放失效</h2><p>​		有一个常见的错误关键，乘上一个大数就可以对浮点数进行编码提升精确度，然后解码。这是无效的。下面是量化数据：</p>
<p><img src="/../../images/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/8bitsrgb_vs_10float_relative_vs_premultiplied.png" alt="8bitsrgb_vs_10float_relative_vs_premultiplied.png"></p>
<p>​		<strong>可以看到没有区别，这是因为有效位数没有变化，所以表示的精度也没有变化。也就是说尾数位没有变化，变化的只有指数位。</strong></p>
<p>​		我们可以设置不同的缩放值看看误差，误差也只是左右移动了：</p>
<p><img src="/../../images/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/8bitsrgb_vs_10float_relative_vs_premultiplied_smaller.png" alt="8bitsrgb_vs_10float_relative_vs_premultiplied_smaller.png"></p>

      
      <p align="right"><a class="morebtn" href="/2023/06/02/Shader/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/" title="GPU浮点数的精确度以及注意事项">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2023/06/02/UnityEffect/%E5%9C%A8Polygon%E6%B8%B2%E6%9F%93%E5%BD%93%E4%B8%AD%E4%BD%BF%E7%94%A8SDF%E6%95%88%E6%9E%9C/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2023/06/02/UnityEffect/%E5%9C%A8Polygon%E6%B8%B2%E6%9F%93%E5%BD%93%E4%B8%AD%E4%BD%BF%E7%94%A8SDF%E6%95%88%E6%9E%9C/" itemprop="url">在Unity渲染当中使用SDF</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2023-06-02T12:00:14+08:00">2023-06-02 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="在Unity渲染当中使用SDF"><a href="#在Unity渲染当中使用SDF" class="headerlink" title="在Unity渲染当中使用SDF"></a>在Unity渲染当中使用SDF</h1><p>SDF通常是在光线追踪场景当中使用，不过最近尝试在unity当中使用这个技术。</p>
<p>尝试的出发点就是：宇宙魔方。</p>
<p><img src="/../../images/img/81a5d8936ced30636c3cf43e532234e3174375fd.jpg" alt="81a5d8936ced30636c3cf43e532234e3174375fd"></p>
<p>他的效果就是正方体内部有一个可以看得到的球体。</p>
<p>最简单的思路就是：使用一个透明的正方体，内部放一个自发光的球体。他的问题在于如果大量使用可能会提升overdraw和drawcall。如果想做扭曲和折射更是需要一个额外的grabpass或者别的渲染流程。如果遇到不透明的水晶，但是内部有自发光物质时。如何控制不透明物质漏出内部的自发光球体是很大的问题。</p>
<p>所以，我尝试了SDF，结果如下：</p>
<p><img src="/../../images/img/2019623-134856.jpg" alt="2019623-134856"></p>
<p>我们可以看到，同一个材质可以应用到任何模型上，并且他们都是不透明物体，可以有自己的材质同时还能维持内部自发光效果。同时由于光线经过不同的表面产生的折射效果也很容易就可以实现。</p>
<p>实现方式就是以物体表面为起点，沿视线方向（用法线扰动视线方向来模拟折射）进行SDF渲染，由于只有一个球体所以速度非常快。</p>
<p>他的扩展就是可以使用不同的SDF函数来生成不同的基础图形。</p>

      
      <p align="right"><a class="morebtn" href="/2023/06/02/UnityEffect/%E5%9C%A8Polygon%E6%B8%B2%E6%9F%93%E5%BD%93%E4%B8%AD%E4%BD%BF%E7%94%A8SDF%E6%95%88%E6%9E%9C/" title="在Unity渲染当中使用SDF">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2023/06/02/UnityEffect/%E4%BF%AE%E6%94%B9UnityHDRP%E7%AE%A1%E7%BA%BF%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%80%AA%E7%89%A9%E7%8C%8E%E4%BA%BA%E4%B8%96%E7%95%8C%E4%B8%AD%E5%AE%A0%E7%89%A9%E6%AF%9B%E5%8F%91%E6%95%88%E6%9E%9C/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2023/06/02/UnityEffect/%E4%BF%AE%E6%94%B9UnityHDRP%E7%AE%A1%E7%BA%BF%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%80%AA%E7%89%A9%E7%8C%8E%E4%BA%BA%E4%B8%96%E7%95%8C%E4%B8%AD%E5%AE%A0%E7%89%A9%E6%AF%9B%E5%8F%91%E6%95%88%E6%9E%9C/" itemprop="url">修改UnityHDRP管线来实现怪物猎人世界中宠物毛发效果</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2023-06-02T12:00:14+08:00">2023-06-02 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="修改UnityHDRP管线来实现怪物猎人世界中宠物毛发效果"><a href="#修改UnityHDRP管线来实现怪物猎人世界中宠物毛发效果" class="headerlink" title="修改UnityHDRP管线来实现怪物猎人世界中宠物毛发效果"></a>修改UnityHDRP管线来实现怪物猎人世界中宠物毛发效果</h1><p>这里主要是以怪物猎人宠物毛发为例，介绍如何从美术需求分析开始，进行引擎修改工作。</p>
<p>后边的内容重点介绍对于管线的修改方法，而具体的模糊算法和参数不做详细说明。</p>
<h2 id="毛发实现分析"><a href="#毛发实现分析" class="headerlink" title="毛发实现分析"></a>毛发实现分析</h2><p>参考内容、需求只有下面的ppt： </p>
<p><img src="/../../images/img/2019620-161347.jpg" alt="2019620-161347"></p>
<p><img src="/../../images/img/2019620-161423.jpg" alt="2019620-161423"></p>
<p>对其分析的结果：计算一张运动模糊的数据。对接结果进行模糊。</p>
<ol start="0">
<li><p>需要<strong>一张模糊走向图</strong>（毛发的走向）和<strong>一张黑色的噪点图</strong>（毛发的疏密、阴影）。</p>
</li>
<li><p>运动模糊不变，改变黑色噪点的tiling值可以改变他的毛发密度。</p>
</li>
<li><p>需要一个运动模糊的采样次数，控制毛发的精细度。</p>
</li>
<li><p>需要一个运动模糊的距离控制毛发长度。</p>
</li>
</ol>
<p>所以需求分析的结果就是一套类似运动模糊的实现方案。后面介绍如何修改管线来实现这一套方案。</p>
<h2 id="HDRP实现方案"><a href="#HDRP实现方案" class="headerlink" title="HDRP实现方案"></a>HDRP实现方案</h2><h3 id="HDRP-render当中添加渲染毛发走向"><a href="#HDRP-render当中添加渲染毛发走向" class="headerlink" title="HDRP render当中添加渲染毛发走向"></a>HDRP render当中添加渲染毛发走向</h3><p>首先在HDRP当中考虑添加一个专门绘制毛发的pass，类似MotionVector Pass。下面的代码需要添加到HDRenderPipeline.cs当中：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">RenderObjectsFurVectors</span><span class="hljs-params">(CullingResults cullResults, HDCamera hdCamera, ScriptableRenderContext renderContext, CommandBuffer cmd)</span><br>&#123;<br>    using (new ProfilingSample(cmd, <span class="hljs-string">&quot;Objects Fur Vectors Rendering&quot;</span>, CustomSamplerId.ObjectsMotionVector.GetSampler()))<br>    &#123;<br>        <span class="hljs-comment">// 需要清理FurVectorbuffer</span><br>        HDUtils.SetRenderTarget(cmd, hdCamera, m_SharedRTManager.GetFurVectorsPassBuffersRTI(hdCamera.frameSettings), m_SharedRTManager.GetDepthStencilBuffer(), ClearFlag.Color, Color.clear);<br>        HDUtils.SetRenderTarget(cmd, hdCamera, m_SharedRTManager.GetFurVectorsPassBuffersRTI(hdCamera.frameSettings), m_SharedRTManager.GetDepthStencilBuffer(hdCamera.frameSettings.IsEnabled(FrameSettingsField.MSAA)));<br>        RenderOpaqueRenderList(cullResults, hdCamera, renderContext, cmd, HDShaderPassNames.s_FurVectorsName, PerObjectData.None);<br>    &#125;<br>&#125;<br><br>... ...<br>    <br><span class="hljs-comment">// 在正确的位置插入要渲染的内容</span><br><span class="hljs-keyword">if</span> (shouldRenderMotionVectorAfterGBuffer)<br>&#123;<br>    <span class="hljs-comment">// See the call RenderObjectsMotionVectors() above and comment</span><br>    RenderObjectsMotionVectors(cullingResults, hdCamera, renderContext, cmd);<br>&#125;<br>RenderObjectsFurVectors(cullingResults, hdCamera, renderContext, cmd); <span class="hljs-comment">// ++++++</span><br></code></pre></td></tr></table></figure>

<p>加入记录渲染毛发走向的RT，在文件SharedRTManager.cs当中：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c">RTHandleSystem.RTHandle m_NormalRT = null;<br>RTHandleSystem.RTHandle m_FurVectorsRT = null; <span class="hljs-comment">//+++++++++</span><br>RTHandleSystem.RTHandle m_MotionVectorsRT = null;<br><br>... ...<br>    <br><span class="hljs-keyword">if</span> (m_MotionVectorsSupport)<br>&#123;<br>    ... ...<br>&#125;<br>m_FurVectorsRT = RTHandles.Alloc(Vector2.one, filterMode: FilterMode.Point, colorFormat: Builtin.GetMotionVectorFormat(), xrInstancing: <span class="hljs-literal">true</span>, useDynamicScale: <span class="hljs-literal">true</span>, name: <span class="hljs-string">&quot;FurVectors&quot;</span>);   <span class="hljs-comment">//+++++++++</span><br><br>... ...<br>    <br><span class="hljs-keyword">if</span> (m_MotionVectorsSupport)<br>&#123;<br>    RTHandles.Release(m_MotionVectorsRT);<br>    <span class="hljs-keyword">if</span> (m_MSAASupported)<br>    &#123;<br>        RTHandles.Release(m_MotionVectorsMSAART);<br>    &#125;<br>&#125;<br><br>RTHandles.Release(m_FurVectorsRT);  <span class="hljs-comment">//+++++++++</span><br><br>... ...<br>    <br>public RenderTargetIdentifier[] GetFurVectorsPassBuffersRTI(FrameSettings frameSettings)<br>&#123;<br>    m_RTIDs1[<span class="hljs-number">0</span>] = m_FurVectorsRT.nameID;<br>    <span class="hljs-keyword">return</span> m_RTIDs1;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>加入毛发渲染pass name, 在文件HDStringConstant.cs当中:</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-type">static</span> readonly <span class="hljs-built_in">string</span> s_MotionVectorsStr = <span class="hljs-string">&quot;MotionVectors&quot;</span>;<br>public <span class="hljs-type">static</span> readonly <span class="hljs-built_in">string</span> s_FurVectorsStr = <span class="hljs-string">&quot;FurVectors&quot;</span>; <span class="hljs-comment">//+++++++++</span><br>... ...<br><br>public <span class="hljs-type">static</span> readonly ShaderTagId s_MotionVectorsName = new ShaderTagId(s_MotionVectorsStr);<br>public <span class="hljs-type">static</span> readonly ShaderTagId s_FurVectorsName = new ShaderTagId(s_FurVectorsStr);   <span class="hljs-comment">//+++++++++</span><br></code></pre></td></tr></table></figure>

<h3 id="添加渲染毛发走向的Shader"><a href="#添加渲染毛发走向的Shader" class="headerlink" title="添加渲染毛发走向的Shader"></a>添加渲染毛发走向的Shader</h3><p>因为毛发走向只需要一个向量，这里用最简单的Pass制作。</p>
<p>需要加的就只是一个 LightMode&#x3D;FurVectors的pass</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">Pass&#123;<br>    Name <span class="hljs-string">&quot;FurVectors&quot;</span><br>    Tags &#123;<span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;FurVectors&quot;</span>&#125;  <span class="hljs-comment">// RenderPipeline通过LightMode来识别要渲染的pass</span><br><br>    Blend One Zero, One Zero<br>    Cull Back<br>    ZTest LEqual<br>	ZWrite On<br>	HLSLPROGRAM<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> target 4.5</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> only_renderers d3d11 ps4 xboxone vulkan metal switch</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile_instancing</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex Vert</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment Frag</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl&quot;</span></span><br><br>    <span class="hljs-keyword">struct</span> AttributesMesh<br>    &#123;<br>        float3 positionOS   : POSITION;<br>        float3 normalOS     : NORMAL;<br>        float2 uv0          : TEXCOORD0;<br>        UNITY_VERTEX_INPUT_INSTANCE_ID<br>    &#125;;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span></span><br><span class="hljs-class">    &#123;</span><br>        float4 position:SV_Position;<br>        float2 uv:TEXCOORD0;<br>        float3 furRootCS: TEXCOORD1;<br>        float3 furTailCS: TEXCOORD2;<br>    &#125;;<br>    <br>    v2f <span class="hljs-title function_">Vert</span><span class="hljs-params">( AttributesMesh v)</span><br>    &#123;<br>        v2f o = (v2f)<span class="hljs-number">0</span>;<br>        o.uv = v.uv0.xy;<br>        float3 normalWS =  TransformObjectToWorldNormal(v.normalOS);<br>        float3 positionRWS = TransformObjectToWorld(v.positionOS);<br>        o.position = TransformWorldToHClip(positionRWS);<br>		<span class="hljs-comment">// 为了测试，先沿法线向量计算模糊向量</span><br>        o.furRootCS = mul(_NonJitteredViewProjMatrix, float4(positionRWS, <span class="hljs-number">1.0</span>)).xyw;<br>        o.furTailCS = mul(_NonJitteredViewProjMatrix, float4(positionRWS + normalWS, <span class="hljs-number">1.0</span>)).xyw;<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br><br>    real4 <span class="hljs-title function_">Frag</span><span class="hljs-params">(v2f i)</span>:SV_Target0&#123;<br>        float2 furRootCS = i.furRootCS.xy / i.furRootCS.z;<br>        float2 furTailCS = i.furTailCS.xy / i.furTailCS.z;<br>        real2 motionVec = (furRootCS.xy - furTailCS.xy);<br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_UV_STARTS_AT_TOP</span><br>        motionVec.y = -motionVec.y;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-keyword">return</span> float4( motionVec * <span class="hljs-number">0.5</span> ,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    &#125;<br>    ENDHLSL<br>&#125;<br></code></pre></td></tr></table></figure>

<p>把上面的Pass加到任意一个HDRP的shader当中并不会影响原始界面的显示，下面灰色物体是加入了FurVectorsPass的Unlit材质：</p>
<p><img src="/../../images/img/2019620-195422.jpg" alt="2019620-195422"></p>
<p>可以在FrameDebug当中看到渲染结果，多出了FurVectorsPass，并且还有SRP Batch加持：</p>
<p><img src="/../../images/img/2019620-191918.jpg" alt="2019620-191918"></p>
<p>可以看到他输出的内容是一个屏幕空间的向量，之后就可以直接用于毛发方向模糊的后处理：</p>
<p><img src="/../../images/img/2019620-192742.jpg" alt="2019620-192742"></p>
<p>最后为了在后处理中访问到，还需要把这个纹理设置成全局纹理，在HDStringConstants.cs中添加：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-type">static</span> readonly <span class="hljs-type">int</span> _CameraDepthTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_CameraDepthTexture&quot;</span>);<br>public <span class="hljs-type">static</span> readonly <span class="hljs-type">int</span> _CameraMotionVectorsTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_CameraMotionVectorsTexture&quot;</span>);<br>public <span class="hljs-type">static</span> readonly <span class="hljs-type">int</span> _CameraMotionVectorsSize = Shader.PropertyToID(<span class="hljs-string">&quot;_CameraMotionVectorsSize&quot;</span>);<br>public <span class="hljs-type">static</span> readonly <span class="hljs-type">int</span> _CameraMotionVectorsScale = Shader.PropertyToID(<span class="hljs-string">&quot;_CameraMotionVectorsScale&quot;</span>);<br>public <span class="hljs-type">static</span> readonly <span class="hljs-type">int</span> _FullScreenDebugMode = Shader.PropertyToID(<span class="hljs-string">&quot;_FullScreenDebugMode&quot;</span>);<br><br>public <span class="hljs-type">static</span> readonly <span class="hljs-type">int</span> _FurVectorsTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_FurVectorsTexture&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>在HDRenderPipeline.cs的PushGlobalParams方法中添加：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (hdCamera.frameSettings.IsEnabled(FrameSettingsField.MotionVectors))<br>&#123;<br>   ... ...<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>   ... ...<br>&#125;<br><br>cmd.SetGlobalTexture(HDShaderIDs._FurVectorsTexture,m_SharedRTManager.GetFurVectorsBuffer());  <span class="hljs-comment">// +++++++++++++++++++++++++++++++</span><br></code></pre></td></tr></table></figure>

<h3 id="使用毛发走向图进行方向模糊的后处理"><a href="#使用毛发走向图进行方向模糊的后处理" class="headerlink" title="使用毛发走向图进行方向模糊的后处理"></a>使用毛发走向图进行方向模糊的后处理</h3><p>这里直接进行简单的向量模糊处理，我们通过修改HDRP的PostSystem实现。这里使用computeShader进行计算。</p>
<p>首先我们需要添加渲染毛发的compute Shader绘制代码：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (m_MotionBlur.IsActive() &amp;&amp; m_AnimatedMaterialsEnabled &amp;&amp; !m_ResetHistory)<br>&#123;<br>	... ...<br>&#125;<br><br><span class="hljs-comment">// 在motionblur后面添加</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>)<br>&#123;<br>    using (new ProfilingSample(cmd, <span class="hljs-string">&quot;Fur Blur&quot;</span>, CustomSamplerId.FurBlur.GetSampler()))<br>    &#123;<br>        var destination = m_Pool.Get(Vector2.one, k_ColorFormat);<br>        DoFurBlur(cmd, camera, source, destination);<br>        PoolSource(ref source, destination);<br>    &#125;<br>&#125;<br><br>... ...<br><span class="hljs-meta">#region Fur Blur</span><br><span class="hljs-comment">// 下面的内容就可以将结果写入到最终位置上，这里还是一切从简，先不用特殊的参数，先把核心的模糊计算加上</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DoFurBlur</span><span class="hljs-params">(CommandBuffer cmd, HDCamera camera, RTHandle source, RTHandle destination)</span><br>&#123;<br>    var cs = m_Resources.shaders.furBlurCS;<br>    var kernel = cs.FindKernel(<span class="hljs-string">&quot;FurBlurKernel&quot;</span>);<br>    cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._InputTexture, source);<br>    cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._OutputTexture, destination);<br>    cmd.DispatchCompute(cs, kernel, (camera.actualWidth + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>, (camera.actualHeight + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>, camera.computePassCount);<br>&#125;<br><span class="hljs-meta">#endregion</span><br></code></pre></td></tr></table></figure>

<p>添加Sampler, 在HDCustomSamplerId.cs当中：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">DepthOfFieldGatherNear,<br>DepthOfFieldPreCombine,<br>DepthOfFieldCombine,<br>FurBlur, <span class="hljs-comment">// +++++++++++++</span><br>MotionBlur,<br></code></pre></td></tr></table></figure>

<p>添加FurBlur的computeShader，在RenederPipelineResources中.cs</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">[Reload(<span class="hljs-string">&quot;PostProcessing/Shaders/MotionBlur.compute&quot;</span>)]<br>public ComputeShader motionBlurCS;<br>[Reload(<span class="hljs-string">&quot;PostProcessing/Shaders/FurBlur.compute&quot;</span>)]<br>public ComputeShader furBlurCS;   <span class="hljs-comment">// +++++++++++++++</span><br></code></pre></td></tr></table></figure>

<p>最后，还需要编写实际计算的computeShader：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> kernel FurBlurKernel</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/FXAA.hlsl&quot;</span></span><br><br><br>RW_TEXTURE2D_X(float3, _OutputTexture);<br>TEXTURE2D_X(_InputTexture);<br>TEXTURE2D_X(_FurVectorsTexture);<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">使用_FurVectorsTexture当中的向量对_InputTexture进行向量模糊处理。最终结果输出到_OutputTexture。</span><br><span class="hljs-comment">*/</span><br>[numthreads(<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>)]<br><span class="hljs-type">void</span> <span class="hljs-title function_">FurBlurKernel</span><span class="hljs-params">(uint3 dispatchThreadId : SV_DispatchThreadID)</span><br>&#123;<br>    UNITY_STEREO_ASSIGN_COMPUTE_EYE_INDEX(dispatchThreadId.z);<br>    uint2 positionSS = dispatchThreadId.xy;<br>    float2 positionNDC = positionSS * _ScreenSize.zw + (<span class="hljs-number">0.5</span> * _ScreenSize.zw); <br>    float3 outColor = Load(_InputTexture, positionSS, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    _OutputTexture[COORD_TEXTURE2D_X(positionSS)] = outColor;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码稍作修改就能得到有毛发区域的模糊效果，至于具体控制参数、模糊算法细节并不难，这里略过。</p>

      
      <p align="right"><a class="morebtn" href="/2023/06/02/UnityEffect/%E4%BF%AE%E6%94%B9UnityHDRP%E7%AE%A1%E7%BA%BF%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%80%AA%E7%89%A9%E7%8C%8E%E4%BA%BA%E4%B8%96%E7%95%8C%E4%B8%AD%E5%AE%A0%E7%89%A9%E6%AF%9B%E5%8F%91%E6%95%88%E6%9E%9C/" title="修改UnityHDRP管线来实现怪物猎人世界中宠物毛发效果">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2023/06/02/Unity/EnlightenBaking/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2023/06/02/Unity/EnlightenBaking/" itemprop="url">Enlighten</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2023-06-02T12:00:14+08:00">2023-06-02 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="Enlighten"><a href="#Enlighten" class="headerlink" title="Enlighten"></a>Enlighten</h1><p>Unity的Enlighten的lightmap烘焙有<strong>三个设置</strong>位置:</p>
<p>全场景设置：</p>
<p><img src="/img/lightmap_globalsetting.jpg" alt="lightmap_globalsetting"></p>
<p>模型设置：</p>
<p><img src="/img/lightmap_objectsetting.jpg" alt="lightmap_objectsetting"></p>
<p>右键创建lightmap parameter:</p>
<p><img src="/img/lightmap_lightparamtersetting.jpg" alt="lightmap_lightparamtersetting"></p>
<p>Enlighten需要进行合理的设置才能够达到高效和高质量，如果使用默认设置几乎不能达到要求。</p>
<p>​	国内大部分游戏使用Prograssive渐进烘焙，<strong>实际上Enlighten通过正确的设置参数，速度是可以保证的，并且效果更好，国外AAA以及UE4作品都是用Enlighten烘焙的。后面讲解如何正确的使用Enlighten。达到高效和高质量的结果。</strong></p>
<h2 id="Enlighten和Prograssive直观对比"><a href="#Enlighten和Prograssive直观对比" class="headerlink" title="Enlighten和Prograssive直观对比"></a>Enlighten和Prograssive直观对比</h2><p>简单测试一下不同渲染器不同设置之间的差别。</p>
<p>使用默认参数，70秒，Enlighten烘焙的间接光：</p>
<p><img src="/../../images/img/lightmap_bakedemo2.jpg" alt="lightmap_bakedemo2"></p>
<p>使用默认参数，18秒，Progressive烘焙的间接光：</p>
<p><img src="/../../images/img/lightmap_bakedemo3.jpg" alt="lightmap_bakedemo3"></p>
<p>经过参数调整，3秒，Enlighten烘焙的间接光：</p>
<p><img src="/../../images/img/lightmap_bakedemo1.jpg" alt="lightmap_bakedemo1"></p>
<p>经过参数调整，8秒，Progressive烘焙的间接光：</p>
<p><img src="/../../images/img/lightmap_bakedemo4.jpg" alt="lightmap_bakedemo4"></p>
<p>​	可以看到只要进行正确的调整,Enlighten是可以<strong>在更合理的时间达到比较好的效果</strong>，而Progressive的调整，比如降低direct采样数或者反弹数就会明显的让Lightmap变黑、变得生硬。</p>
<h2 id="基本功能（这部分内容和Unity有差异）"><a href="#基本功能（这部分内容和Unity有差异）" class="headerlink" title="基本功能（这部分内容和Unity有差异）"></a>基本功能（这部分内容和Unity有差异）</h2><p>官方说明（和Unity集成后不太一样）：</p>
<ol>
<li>Enlighten 只计算反射光（间接光）。</li>
<li>不计算直接光和阴影。</li>
<li>Enlighten是CPU上的异步计算。</li>
</ol>
<p>Enlighten的输出（和Unity集成后不太一样）：</p>
<ol>
<li>高质量的可以实时更新的GI。</li>
<li>漫反射间接光：lightmaps 和lightprobes。</li>
<li>高管反射：cubemap</li>
<li>比传统bake分辨率低。</li>
</ol>
<p>下面是一个官方参考的设置的大小，包括texel大小和lightprobef分布，绿色表示是动态物体：</p>
<p><img src="/../../images/img/lightmap_bake2.jpg" alt="lightmap_bake2"><img src="/../../images/img/lightmap_bake1.jpg" alt="lightmap_bake1"></p>
<h2 id="Cluster烘焙原理说明"><a href="#Cluster烘焙原理说明" class="headerlink" title="Cluster烘焙原理说明"></a>Cluster烘焙原理说明</h2><h3 id="Enlighten的好处"><a href="#Enlighten的好处" class="headerlink" title="Enlighten的好处"></a>Enlighten的好处</h3><ul>
<li>有效的区域光：自发光表面可以作为一个区域光。</li>
<li>平滑的工作流：迭代速度快。</li>
<li>灵活及时反映的光照：实时间接光可以相应灯光的变化。</li>
</ul>
<h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><ol>
<li>设置场景</li>
<li>预计算</li>
<li>灯光照亮</li>
</ol>
<h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>GI使用一个复杂的公式描述：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rendering_equation">Rendering equation</a></p>
<p><img src="/../../images/img/lightmap_fomula.jpg" alt="lightmap_fomula"></p>
<p>这个公式非常复杂，wiki当中有详细的描述。这里简单的描述一下：</p>
<p>$L_0$表示物体在位置$x$处，超$w_o$方向，对于波长$\lambda$的波的，在$t$时间中的光辐射率。</p>
<p>$L_e$是自发光的光辐射量。</p>
<p>$f_r$ 是<strong>brdf函数</strong>，描述入射光$w_i$的表面属性。</p>
<p>$L_i$是入射光的辐射量</p>
<p>$w_i * n$ 衰减因子。</p>
<p>总的描述一下就是：<strong>反射的光线 &#x3D; 自发光 + 所有入射光被反射的和</strong></p>
<p>上面的公式很复杂，但是可以通过很多方法进行估算。</p>
<p>Enlighten简化了这个问题：<strong>假设元素是静态的、有限的、并且只传递漫反射。</strong>这个方法叫做辐射度（radiosity）。</p>
<ol>
<li>Enlighten移除了材质依赖：也就是去掉了brdf函数，把积分中的内容变成一个form fractor。</li>
<li>form fractor描述了光从元素i离开到达元素j的百分比。</li>
<li>积分就变成了（from fractor* 对应元素的辐射率）的和，然后再加上自发光。</li>
<li>我们可以在多帧中处理这个离散的数学问题，同时需要运行多次达到收敛。不过求解这个问题和帧率是完全独立的，人眼对间接光的变化并不敏感。</li>
</ol>
<p>最终的简化结果：</p>
<p>$$ B_i &#x3D; L_e + \rho_i  \sum <em>{j&#x3D;1}^{n}F</em>{ij}L_j$$</p>
<p>$B_i $ 表示i点的光$L_e$ 表示从<strong>cluster</strong> i上发射的自发光。（光是靠cluster计算的）。</p>
<p>$\rho_i$表示材质属性</p>
<p>$n$ 是<strong>budget</strong>：一个cluster 最多接受几个cluster的辐射。</p>
<p>$F_ij$  from fractor：从cluster i到cluster j可以传递多少能量。</p>
<p>$L_j$ 是从cluster j当中释放出的光。（上一帧，这个算法是逐帧迭代的）。</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><ol>
<li><p>首先场景当中的几何体会被划分成可以并行计算的<strong>System</strong>（based on proximity and Lightmap Parameters， sharing the same realtime lightmap）。<strong>System之间可以并行</strong>。</p>
<p>下面是System Scene View：</p>
<p><img src="/../../images/img/lightmap_GIUI_system.png" alt="lightmap_GIUI_system"></p>
</li>
<li><p>每一个System会分割成离散的<strong>Cluster</strong>。</p>
</li>
</ol>
<p>Enlighten就是使用这些Clusters计算间接光的，因为每一帧需要进行积分，所以cluster数量越多，计算开销成$$O(n^2)$$。</p>
<p>Cluster的大小需要比lightmap的pixel大。比例在LightMap Paramter当中设置：<strong>Cluster Resolution</strong>。这个参数内存敏感，如果这个比例设置不正确，将Geometry设置成cluster的步骤将会消耗大量内存。</p>
<p>下面是Cluster Scene View：</p>
<p><img src="/../../images/img/lightmap_GIUI_cluster.png" alt="lightmap_GIUI_cluster"></p>
<ol start="3">
<li>预计算，需要计算Cluster之间的可见性。</li>
<li>当对<strong>每一个点</strong>计算间接光时，每个像素可见的cluster已经完成了预先计算。运行时，只要将这些cluster求和即可。</li>
</ol>
<h3 id="Culster和System"><a href="#Culster和System" class="headerlink" title="Culster和System"></a>Culster和System</h3><p>Enlighten将世界看做由很多Cluster组成的。Cluster是计算光照的基本单位。</p>
<p>Cluster并不是只属于一个System，而是可以在System之间传递。</p>
<p>在光照传输阶段，计算的是cluster之间的可见性。</p>
<p><strong>Irradiance Quality</strong>在lightmap paramenter中设置。描述了在预计算阶段，针对每一个lightmap texel 要发射多少条ray，来计算有多少个cluster对这个texelhui产生影响。数量越多，找到的cluster越精确，只影响预计算效率。不影响运行时效率。</p>
<p><strong>Irradiance budget</strong>在lightmap paramenter中设置。通过发射ray找到每一个lightmap texel关联的cluster之后，记录form fractor的数量。如果太小可能遗漏应该计算的光线。</p>
<h2 id="烘焙参数"><a href="#烘焙参数" class="headerlink" title="烘焙参数"></a>烘焙参数</h2><p>对于上一部分的流程，这里接招几个和bake性能有关的重要参数。</p>
<p>由于有三个位置可以设置Enlighten的烘焙，下面就分三部分介绍：</p>
<h3 id="针对场景的总体设置：LightMapping-Setting"><a href="#针对场景的总体设置：LightMapping-Setting" class="headerlink" title="针对场景的总体设置：LightMapping Setting"></a>针对场景的总体设置：LightMapping Setting</h3><p>详细解释见<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/GI-Enlighten.html">官方说明</a>，下面只对重要参数进行说明。</p>
<p><img src="/../../images/img/lightmap_globalsetting.jpg" alt="lightmap_globalsetting"></p>
<p><strong>LightMapper</strong> ：使用哪个烘焙，这里只讨论Enlighten。</p>
<p><strong>Indrection Resolution</strong> ： 一米多少个Cluster。<strong>越小越快。</strong></p>
<p><strong>Lightmap Resolution</strong> ： 一米多少个lightmap pixel。<strong>越小越快</strong></p>
<p>注：当我们把上面两个值都设置成1 的时候，切换cluster scene view和baked lightmap，发现cluster比lightmap pixel要大。这是因为<strong>在LightmapParameters当中Cluster Resolution</strong>也会对cluster产生影响。如果把物体的Cluster Resolution也设置为1，那么Cluster和LightMap Pixel的大小就是1:1。</p>
<p>注：因为预计算是计算每一个pixel对于哪些cluster可见，所以开销就是Indrection Resolution*Lightmap Resolution。</p>
<h3 id="针对GameObject的设置：LightMapping"><a href="#针对GameObject的设置：LightMapping" class="headerlink" title="针对GameObject的设置：LightMapping"></a>针对GameObject的设置：LightMapping</h3><p><strong>Scale In Lightmap</strong> 在Lightmap当中的缩放，并不影响计算进度，只影响算完之后如何存储。通过合理的设置可以减少lightmap的总数。</p>
<p><strong>这部分的参数和uv分布有关系，暂时略过。</strong></p>
<p><img src="/../../images/img/lightmap_objectsetting.jpg" alt="lightmap_objectsetting"></p>
<h3 id="可以选择的全局配置文件：LightMapParameter"><a href="#可以选择的全局配置文件：LightMapParameter" class="headerlink" title="可以选择的全局配置文件：LightMapParameter"></a>可以选择的全局配置文件：LightMapParameter</h3><p>详细解释见：<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/class-LightmapParameters.html">官方文档</a></p>
<p><strong>Resolution</strong>： 直接和全局的Indrection Resolution和Lightmap Resolution相乘。 <strong>越小越快，默认为1</strong></p>
<p><strong>Cluster Resolution</strong> ：Indrection Resolution和Lightmap Resolution的比例。这个只会方法Cluster的大小，默认0.5，也就是Cluster当中包括了4个texel。<strong>越小越快，默认0.5</strong></p>
<p><strong>Irradiance Quality</strong> ：描述了在预计算阶段，针对每一个lightmap texel 要发射多少条ray，来计算有多少个cluster对这个texelhui产生影响。数量越多，找到的cluster越精确，<strong>只影响预计算效率。不影响运行时效率。</strong> <strong>越小越快</strong></p>
<p><strong>Irradiance budget</strong> ：通过发射ray找到每一个lightmap texel关联的cluster之后，记录form fractor的数量。如果太小可能遗漏应该计算的光线。<strong>对bake时间没有影响</strong></p>
<p>其他内容见文档。</p>
<p><img src="/../../images/img/lightmap_lightparamtersetting.jpg" alt="lightmap_lightparamtersetting"></p>
<h3 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h3><ol>
<li><p>和Enlighten相关的内容，除了Culster计算光照、System之间可以并行、Pixel计算可见性之外。还有一部分是uv相关的设置，这部分对性能影响不大之后再分析。</p>
</li>
<li><p>对于树叶、草等有零碎的cluster和uv chart的物体，一定要特殊处理，使用实时光。或者重分uv。不然会产生极大的烘焙开销。</p>
</li>
<li><p>要合理使用lightmapping paramter对不同类型的物体的进行设置，尤其是cluster和pixel的大小。</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://blogs.unity3d.com/2016/09/28/in-development-progressive-lightmapper/">https://blogs.unity3d.com/2016/09/28/in-development-progressive-lightmapper/</a></p>
<p><a target="_blank" rel="noopener" href="https://enlighten.atlassian.net/wiki/spaces/UEF309/pages/525467659/How+Enlighten+works">https://enlighten.atlassian.net/wiki/spaces/UEF309/pages/525467659/How+Enlighten+works</a></p>
<p><a target="_blank" rel="noopener" href="https://www.siliconstudio.co.jp/middleware/enlighten/en/blog/2018/20180406/pdf/gdc2018-enlighten-global-illumination-that-scales.pdf">https://www.siliconstudio.co.jp/middleware/enlighten/en/blog/2018/20180406/pdf/gdc2018-enlighten-global-illumination-that-scales.pdf</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/uploads/ExpertGuides/Using_Enlighten_with_Unity.pdf">https://docs.unity3d.com/uploads/ExpertGuides/Using_Enlighten_with_Unity.pdf</a></p>

      
      <p align="right"><a class="morebtn" href="/2023/06/02/Unity/EnlightenBaking/" title="Enlighten">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2023/06/02/Unity/HDRPShader%E5%BD%93%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E7%B3%BB%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2023/06/02/Unity/HDRPShader%E5%BD%93%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E7%B3%BB%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/" itemprop="url">Light Loop</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2023-06-02T12:00:14+08:00">2023-06-02 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="HDRP-Shader当中的坐标系变化矩阵"><a href="#HDRP-Shader当中的坐标系变化矩阵" class="headerlink" title="HDRP Shader当中的坐标系变化矩阵"></a>HDRP Shader当中的坐标系变化矩阵</h1><p>​	在HDRP当中Shader当中所有的内置矩阵（例如：UNITY_MATRIX_M）都发生了变化。这部分内容不再通过内置的代码设置，而是在SRP当中设置，我们可以看到这些参数是如何传递到Shader当中的。下面详细介绍写的坐标系变化矩阵。</p>
<h1 id="C-设置部分"><a href="#C-设置部分" class="headerlink" title="C#设置部分"></a>C#设置部分</h1><p>先来看一下矩阵传入Shader的c#代码：</p>
<p>略</p>
<h1 id="Shader当中的基础坐标变化"><a href="#Shader当中的基础坐标变化" class="headerlink" title="Shader当中的基础坐标变化"></a>Shader当中的基础坐标变化</h1><p>在一个Shader中最基础的就是模型坐标到剪裁空间 ：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">TransformObjectToWorld(v.vertex); <span class="hljs-comment">// UNITY_MATRIX_M</span><br>TransformWorldToHClip(positionWS); <span class="hljs-comment">// UNITY_MATRIX_VP</span><br></code></pre></td></tr></table></figure>

<p>HDRP中，目前我看到的是没有了UNITY_MATRIX_MVP而是需要两步转化。</p>
<h1 id="Shader当中坐标系变换"><a href="#Shader当中坐标系变换" class="headerlink" title="Shader当中坐标系变换"></a>Shader当中坐标系变换</h1><h2 id="Shader当中坐标系宏定义的位置"><a href="#Shader当中坐标系宏定义的位置" class="headerlink" title="Shader当中坐标系宏定义的位置"></a>Shader当中坐标系宏定义的位置</h2><p>在文件ShaderVariablesMatrixDefsHDCamera.hlsl中保存的是和摄像机相关的矩阵的宏，如下。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UNITY_SHADER_VARIABLES_MATRIX_DEFS_LEGACY_UNITY_INCLUDED</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">error</span> Mixing HDCamera and legacy Unity matrix definitions</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> UNITY_SHADER_VARIABLES_MATRIX_DEFS_HDCAMERA_INCLUDED</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_SHADER_VARIABLES_MATRIX_DEFS_HDCAMERA_INCLUDED</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(USING_STEREO_MATRICES)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_V     _ViewMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_V   _InvViewMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_P     OptimizeProjectionMatrix(_ProjMatrixStereo[unity_StereoEyeIndex])</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_P   _InvProjMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_VP    _ViewProjMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_VP  _InvViewProjMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_UNJITTERED_VP _ViewProjMatrixStereo[unity_StereoEyeIndex] <span class="hljs-comment">// Since VR doesn&#x27;t need to add jitter, just use normal VP matrix</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_PREV_VP _PrevViewProjMatrixStereo[unity_StereoEyeIndex]</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_V     _ViewMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_V   _InvViewMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_P     OptimizeProjectionMatrix(_ProjMatrix)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_P   _InvProjMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_VP    _ViewProjMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_VP  _InvViewProjMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_UNJITTERED_VP _NonJitteredViewProjMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_PREV_VP _PrevViewProjMatrix</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// USING_STEREO_MATRICES</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// UNITY_SHADER_VARIABLES_MATRIX_DEFS_HDCAMERA_INCLUDED</span></span><br><br></code></pre></td></tr></table></figure>

<p>在ShaderVariables.cginc中保存了所有原始矩阵的定义，如下：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ================================</span><br><span class="hljs-comment">//     PER FRAME CONSTANTS</span><br><span class="hljs-comment">// ================================</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(USING_STEREO_MATRICES)</span><br>float4x4 glstate_matrix_projection;<br>float4x4 unity_MatrixV;<br>float4x4 unity_MatrixInvV;<br>float4x4 unity_MatrixVP;<br>float4 unity_StereoScaleOffset;<br><span class="hljs-type">int</span> unity_StereoEyeIndex;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// ================================</span><br><span class="hljs-comment">//     PER VIEW CONSTANTS</span><br><span class="hljs-comment">// ================================</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> all affine matrices should be 3x4.</span><br>float4x4 _ViewMatrix;<br>float4x4 _InvViewMatrix;<br>float4x4 _ProjMatrix;<br>float4x4 _InvProjMatrix;<br>float4x4 _ViewProjMatrix;<br>float4x4 _InvViewProjMatrix;<br>float4x4 _NonJitteredViewProjMatrix;<br>float4x4 _PrevViewProjMatrix;       <span class="hljs-comment">// non-jittered</span><br><br>...<br>    <br>float4x4 <span class="hljs-title function_">GetRawUnityObjectToWorld</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> unity_ObjectToWorld; &#125;<br>float4x4 <span class="hljs-title function_">GetRawUnityWorldToObject</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> unity_WorldToObject; &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_M     ApplyCameraTranslationToMatrix(GetRawUnityObjectToWorld())</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_M   ApplyCameraTranslationToInverseMatrix(GetRawUnityWorldToObject())</span><br></code></pre></td></tr></table></figure>

<p>​	可以看到所有的View变化和投影变换都设置了对应的逆矩阵，方便了我们进行操作。</p>
<p>​	<strong>这里需要重要说明的是UNITY_MATRIX_V矩阵和 UNITY_MATRIX_I_V矩阵忽略了摄像机的平移。而UNITY_MATRIX_M和UNITY_MATRIX_I_M 加入了摄像机的平移。</strong>也就是说用这组矩阵是无法从摄像机空间恢复出真实的世界坐标的。也无法从世界坐标转换到真实的摄像机坐标的，模型坐标到世界坐标也是同理。</p>
<p>​	UNITY_MATRIX_V和UNITY_MATRIX_I_V矩阵内容如下图，可以看到平移分量没有了。</p>
<p><img src="/img/UNITY_MATRIX_I_V.jpg"></p>
<p>​	如果我们想要从深度中恢复真实的世界坐标要使用：<strong>unity_MatrixV</strong>矩阵。</p>
<p>​	如果要用模型坐标得到世界坐标怎么办？我们用ShaderGraph来制作一个直接输出世界坐标的Graph。如下图：</p>
<p><img src="/img/ObjectToWorld.jpg"></p>
<p>​	通过查看生成的代码，ShaderGraph的制作方案是：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 首先通过矩阵计算有摄像机偏移的世界坐标。</span><br>UNITY_MATRIX_M<br><span class="hljs-comment">// 然后通过下面这个函数去除掉摄像机的影响，得到真实的世界坐标。</span><br>float3 <span class="hljs-title function_">GetAbsolutePositionWS</span><span class="hljs-params">(float3 positionRWS)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (SHADEROPTIONS_CAMERA_RELATIVE_RENDERING != 0)</span><br>    positionRWS += _WorldSpaceCameraPos;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> positionRWS;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​	还有一个地方需要注意，在UnityHDRP的Shader当中有命名为<strong>positionRWS</strong>的世界坐标，R的意思就是说这个世界坐标包含了相对于摄像机的位移。</p>

      
      <p align="right"><a class="morebtn" href="/2023/06/02/Unity/HDRPShader%E5%BD%93%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E7%B3%BB%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/" title="Light Loop">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2023/06/02/Unity/HDRP%E4%B8%ADHairShader%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2023/06/02/Unity/HDRP%E4%B8%ADHairShader%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/" itemprop="url">HDRP HairShader代码结构</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2023-06-02T12:00:14+08:00">2023-06-02 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="HDRP-HairShader代码结构"><a href="#HDRP-HairShader代码结构" class="headerlink" title="HDRP HairShader代码结构"></a>HDRP HairShader代码结构</h1><p>Hair只能在前向渲染阶段渲染，使用下面两个Pass：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123;<br>    LightMode = DepthForwardOnly<br>    LightMode = ForwardOnly<br>&#125;<br></code></pre></td></tr></table></figure>

<p>头发有一个特殊的Stencil</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">Stencil<br>&#123;<br>   WriteMask <span class="hljs-number">7</span><br>   Ref  <span class="hljs-number">2</span><br>   Comp Always<br>   Pass Replace<br>&#125;<br></code></pre></td></tr></table></figure>

<p>##透明和不透明有所区别</p>
<p>混合方式上的区别</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//透明</span><br>            Blend One OneMinusSrcAlpha <br>            ZTest LEqual <span class="hljs-comment">// 正常的深度渲染，注意这个时候也可以提前绘制深度。</span><br>            ZWrite Off<br><span class="hljs-comment">//不透明</span><br>            Blend One Zero  <span class="hljs-comment">// 直接覆盖</span><br>            ZTest Equal  <span class="hljs-comment">// 因为会提前绘制深度，所以需要和原本深度值相等才能绘制</span><br>            ZWrite On<br><span class="hljs-comment">// 在原本的shader当中如果开启blend默认编程了透明？</span><br></code></pre></td></tr></table></figure>

<p>透明不透明的宏定义区别</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 透明加不透明</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _SURFACE_TYPE_TRANSPARENT 1</span><br><span class="hljs-comment">// 透明部分</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _BLENDMODE_ALPHA 1   <span class="hljs-comment">// 开启 混合</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1  <span class="hljs-comment">// ??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _ENABLE_FOG_ON_TRANSPARENT 1  <span class="hljs-comment">// 开启透明物体上的雾</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _SPECULAR_OCCLUSION_FROM_AO 1 <span class="hljs-comment">// AO 对高光生效</span></span><br></code></pre></td></tr></table></figure>

<p>下面是关于分割光线的 split Lighting 是什么</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// If we use subsurface scattering, enable output split lighting (for forward pass)</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) &amp;&amp; !defined(_SURFACE_TYPE_TRANSPARENT) <span class="hljs-comment">// 子表面散射 并且不是半透明物体</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OUTPUT_SPLIT_LIGHTING  <span class="hljs-comment">// 分割光线？？？</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<h2 id="头发渲染部分代码"><a href="#头发渲染部分代码" class="headerlink" title="头发渲染部分代码"></a>头发渲染部分代码</h2><h3 id="Shader-Pass-Forward"><a href="#Shader-Pass-Forward" class="headerlink" title="Shader Pass Forward"></a>Shader Pass Forward</h3><p>头发的Pass文件：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassForward.hlsl&quot;</span></span><br></code></pre></td></tr></table></figure>

<p>也就是说头发使用的事一般的前向渲染的Pass描述。</p>
<p>####Vert</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这部分是通用的代码</span><br>PackedVaryingsType <span class="hljs-title function_">Vert</span><span class="hljs-params">(AttributesMesh inputMesh)</span><br>&#123;<br>    VaryingsType varyingsType;<br>    varyingsType.vmesh = VertMesh(inputMesh);<br>    <span class="hljs-keyword">return</span> PackVaryingsType(varyingsType);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/VertMesh.hlsl&quot;</span></span><br><span class="hljs-comment">//使用的上面的内容用来计算Vert当中的参数。</span><br></code></pre></td></tr></table></figure>

<p>####Frag</p>
<p>下面是去掉了debug信息的Frag代码：</p>
<p>如果使用了SSS效果并且没有使用半透则会进入OUTPUT_SPLIT_LIGHTING的部分，看起来是分开了高光和漫反射颜色，以及SSS的某个特殊buffer。</p>
<p>否则就是用一个单独的颜色。</p>
<p>这里有个_DEPTHOFFSET_ON，暂时不考虑。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Frag</span><span class="hljs-params">(PackedVaryingsToPS packedInput,</span><br><span class="hljs-params">        #ifdef OUTPUT_SPLIT_LIGHTING  <span class="hljs-comment">//使用分割光线</span></span><br><span class="hljs-params">            out float4 outColor : SV_Target0,  <span class="hljs-comment">// outSpecularLighting</span></span><br><span class="hljs-params">            out float4 outDiffuseLighting : SV_Target1,</span><br><span class="hljs-params">            OUTPUT_SSSBUFFER(outSSSBuffer)</span><br><span class="hljs-params">        #<span class="hljs-keyword">else</span></span><br><span class="hljs-params">            out float4 outColor : SV_Target0  <span class="hljs-comment">// 没有SSS效果的一个输出颜色。</span></span><br><span class="hljs-params">        #endif</span><br><span class="hljs-params">        #ifdef _DEPTHOFFSET_ON</span><br><span class="hljs-params">            , out <span class="hljs-type">float</span> outputDepth : SV_Depth</span><br><span class="hljs-params">        #endif</span><br><span class="hljs-params">          )</span><br>&#123;<br>    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(packedInput);<br>    FragInputs input = UnpackVaryingsMeshToFragInputs(packedInput.vmesh);<br><br>    uint2 tileIndex = uint2(input.positionSS.xy) / GetTileSize();<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(UNITY_SINGLE_PASS_STEREO)</span><br>    tileIndex.x -= unity_StereoEyeIndex * _NumTileClusteredX;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// input.positionSS is SV_Position</span><br>    PositionInputs posInput = GetPositionInput_Stereo(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS.xyz, tileIndex, unity_StereoEyeIndex); <span class="hljs-comment">// 计算屏幕坐标 视口坐标 纹理坐标等内容（ComputeShader也会用这个函数）。</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> VARYINGS_NEED_POSITION_WS</span><br>    float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-comment">// Unused</span><br>    float3 V = float3(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// Avoid the division by 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    SurfaceData surfaceData;<br>    BuiltinData builtinData;<br>    <br>    <span class="hljs-comment">// 纹理属性的计算</span><br>    GetSurfaceAndBuiltinData(input, V, posInput, surfaceData, builtinData);<br>	<span class="hljs-comment">// 材质参数计算</span><br>    BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);<br><br>    PreLightData preLightData = GetPreLightData(V, posInput, bsdfData);<br>	<span class="hljs-comment">// 定义输出颜色</span><br>    outColor = float4(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br><br><br>    &#123;<br>    <span class="hljs-comment">//透明和不透明物体单独处理</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _SURFACE_TYPE_TRANSPARENT</span><br>        uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_OPAQUE;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-comment">// 将要分别计算的高光和漫反射光</span><br>        float3 diffuseLighting;<br>        float3 specularLighting;<br>	<br>	<span class="hljs-comment">// 进入光照循环计算光照</span><br>        LightLoop(V, posInput, preLightData, bsdfData, builtinData, featureFlags, diffuseLighting, specularLighting);<br>	<span class="hljs-comment">// 此时就返回了计算好的高光和 漫反射光</span><br>	<span class="hljs-comment">// 进行全局的缩放</span><br>        diffuseLighting *= GetCurrentExposureMultiplier();<br>        specularLighting *= GetCurrentExposureMultiplier();<br>	<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OUTPUT_SPLIT_LIGHTING</span><br>	<span class="hljs-comment">// 如果开启SSS 并且需要分割光照（通过参数判断），则把两个光照分开。</span><br>        <span class="hljs-keyword">if</span> (_EnableSubsurfaceScattering != <span class="hljs-number">0</span> &amp;&amp; ShouldOutputSplitLighting(bsdfData))<br>        &#123;<br>            outColor = float4(specularLighting, <span class="hljs-number">1.0</span>);<br>            outDiffuseLighting = float4(TagLightingForSSS(diffuseLighting), <span class="hljs-number">1.0</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>        	<span class="hljs-comment">//如果不需要SSS，或者不需要分割光照，就把两个颜色都合并到Specular里面。</span><br>            outColor = float4(diffuseLighting + specularLighting, <span class="hljs-number">1.0</span>);<br>            outDiffuseLighting = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 这里面写入一些 SSS需要用到的属性。</span><br>        ENCODE_INTO_SSSBUFFER(surfaceData, posInput.positionSS, outSSSBuffer);<br>        <span class="hljs-comment">// 如果分割颜色就，在Gbuffer结束时统一计算大气散射。</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        outColor = ApplyBlendMode(diffuseLighting, specularLighting, builtinData.opacity);<br>        <br>        <span class="hljs-comment">// 如果不分割颜色 就直接计算大气散射。</span><br>        outColor = EvaluateAtmosphericScattering(posInput, V, outColor);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br><br><span class="hljs-comment">// 忽略</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _DEPTHOFFSET_ON</span><br>    outputDepth = posInput.deviceDepth;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="LightLoop"><a href="#LightLoop" class="headerlink" title="LightLoop"></a>LightLoop</h4><p>具体Shader的光照循环部分，参见光照循环文档</p>

      
      <p align="right"><a class="morebtn" href="/2023/06/02/Unity/HDRP%E4%B8%ADHairShader%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/" title="HDRP HairShader代码结构">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2023/06/02/Unity/HDRPLightLoop/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2023/06/02/Unity/HDRPLightLoop/" itemprop="url">Light Loop</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2023-06-02T12:00:14+08:00">2023-06-02 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="Light-Loop"><a href="#Light-Loop" class="headerlink" title="Light Loop"></a>Light Loop</h1><p>unity HDRP的Shader当中LightLoop是最终的光照计算函数部分。</p>
<p>Deferred Light的光照计算会经过这个函数。ForwarOnly的光照阶段也会经过这个函数。现在对着个函数进行详细的讲解。</p>
<p>LightLoop主要包含三个部分：</p>
<ol>
<li>LightLoop.hlsl 是LightLoop的具体实现</li>
<li>LightLoopDef.hlsl是针对LightLoop当中的常用的工具和函数</li>
<li>针对不同的材质，需要一个提供函数的xxx.hlsl文件，提供了在不同材质下LightLoop进行不同的光照计算。</li>
</ol>
<h2 id="LightLoop主循环"><a href="#LightLoop主循环" class="headerlink" title="LightLoop主循环"></a>LightLoop主循环</h2><p>下面是去掉Debug内容的LightLoop主循环的内容：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">LightLoop</span><span class="hljs-params">( float3 V, PositionInputs posInput, PreLightData preLightData, BSDFData bsdfData, BuiltinData builtinData, uint featureFlags,</span><br><span class="hljs-params">                out float3 diffuseLighting, <span class="hljs-comment">// 返回的两种光照</span></span><br><span class="hljs-params">                out float3 specularLighting)</span><span class="hljs-comment">// 返回的两种光照</span><br>&#123;<br>    <span class="hljs-comment">// 保存了主要信息。</span><br>    LightLoopContext context;<br>	<br>    <span class="hljs-comment">// 读取阴影相关内容。</span><br>    context.shadowContext    = InitShadowContext();<br>    context.contactShadow    = InitContactShadow(posInput);<br>    context.shadowValue      = <span class="hljs-number">1</span>;<br>    context.sampleReflection = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// First of all we compute the shadow value of the directional light to reduce the VGPR pressure</span><br>    <span class="hljs-comment">// 标注了使用LightLoop计算的类型的类型  通过LightFeature和Flag进行各种匹配。</span><br>    <span class="hljs-comment">// 这里表示这种材质类型需要计算直线光？？？</span><br>    <span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_DIRECTIONAL)<br>    &#123;<br>        <span class="hljs-comment">// Evaluate sun shadows.</span><br>        <span class="hljs-keyword">if</span> (_DirectionalShadowIndex &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            DirectionalLightData light = _DirectionalLightDatas[_DirectionalShadowIndex];<br><br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> this will cause us to load from the normal buffer first. Does this cause a performance problem?</span><br>            <span class="hljs-comment">// Also, the light direction is not consistent with the sun disk highlight hack, which modifies the light vector.</span><br>            <span class="hljs-type">float</span>  NdotL            = dot(bsdfData.normalWS, -light.forward);<br>            float3 shadowBiasNormal = GetNormalForShadowBias(bsdfData);<br>            <span class="hljs-type">bool</span>   evaluateShadows  = (NdotL &gt; <span class="hljs-number">0</span>);<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> MATERIAL_INCLUDE_TRANSMISSION</span><br>            <span class="hljs-keyword">if</span> (MaterialSupportsTransmission(bsdfData))<br>            &#123;<br>                <span class="hljs-comment">// We support some kind of transmission.</span><br>                <span class="hljs-keyword">if</span> (HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_TRANSMISSION_MODE_THIN_THICKNESS))<br>                &#123;<br>                    <span class="hljs-comment">// We always evaluate shadows.</span><br>                    evaluateShadows = <span class="hljs-literal">true</span>;<br><br>                    <span class="hljs-comment">// Care must be taken to bias in the direction of the light.</span><br>                    shadowBiasNormal *= FastSign(NdotL);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">// We only evaluate shadows for reflection, transmission shadows are handled separately.</span><br>                &#125;<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>            <span class="hljs-keyword">if</span> (evaluateShadows)<br>            &#123;<br>                context.shadowValue = EvaluateRuntimeSunShadow(context, posInput, light, shadowBiasNormal);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// This struct is define in the material. the Lightloop must not access it</span><br>    <span class="hljs-comment">// PostEvaluateBSDF call at the end will convert Lighting to diffuse and specular lighting</span><br>    AggregateLighting aggregateLighting;<br>    ZERO_INITIALIZE(AggregateLighting, aggregateLighting); <span class="hljs-comment">// LightLoop is in charge of initializing the struct</span><br><br>    uint i = <span class="hljs-number">0</span>; <span class="hljs-comment">// Declare once to avoid the D3D11 compiler warning.</span><br><br>    <span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_DIRECTIONAL)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; _DirectionalLightCount; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (IsMatchingLightLayer(_DirectionalLightDatas[i].lightLayers, builtinData.renderingLayers))<br>            &#123;<br>                DirectLighting lighting = EvaluateBSDF_Directional(context, V, posInput, preLightData, _DirectionalLightDatas[i], bsdfData, builtinData);<br>                AccumulateDirectLighting(lighting, aggregateLighting);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>     <span class="hljs-comment">// 这里表示这种材质类型需要计算PUNCTUAL光？？？</span><br>    <span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_PUNCTUAL)<br>    &#123;<br>        uint lightCount, lightStart;<br>        <span class="hljs-type">bool</span> fastPath = <span class="hljs-literal">false</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LIGHTLOOP_DISABLE_TILE_AND_CLUSTER</span><br>        GetCountAndStart(posInput, LIGHTCATEGORY_PUNCTUAL, lightStart, lightCount);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>        <span class="hljs-comment">// Fast path is when we all pixels in a wave are accessing same tile or cluster.</span><br>        uint lightStartLane0 = WaveReadLaneFirst(lightStart);<br>        fastPath = WaveActiveAllTrue(lightStart == lightStartLane0); <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span>   <span class="hljs-comment">// LIGHTLOOP_DISABLE_TILE_AND_CLUSTER</span></span><br>        lightCount = _PunctualLightCount;<br>        lightStart = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>        <span class="hljs-keyword">if</span> (fastPath)<br>        &#123;<br>            lightStart = lightStartLane0;<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">// Scalarized loop. All lights that are in a tile/cluster touched by any pixel in the wave are loaded (scalar load), only the one relevant to current thread/pixel are processed.</span><br>        <span class="hljs-comment">// For clarity, the following code will follow the convention: variables starting with s_ are meant to be wave uniform (meant for scalar register),</span><br>        <span class="hljs-comment">// v_ are variables that might have different value for each thread in the wave (meant for vector registers).</span><br>        <span class="hljs-comment">// This will perform more loads than it is supposed to, however, the benefits should offset the downside, especially given that light data accessed should be largely coherent.</span><br>        <span class="hljs-comment">// Note that the above is valid only if wave intriniscs are supported.</span><br>        uint v_lightListOffset = <span class="hljs-number">0</span>;<br>        uint v_lightIdx = lightStart;<br><br>        <span class="hljs-keyword">while</span> (v_lightListOffset &lt; lightCount)<br>        &#123;<br>            v_lightIdx = FetchIndex(lightStart, v_lightListOffset);<br>            uint s_lightIdx = v_lightIdx;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>            <span class="hljs-keyword">if</span> (!fastPath)<br>            &#123;<br>                <span class="hljs-comment">// If we are not in fast path, v_lightIdx is not scalar, so we need to query the Min value across the wave. </span><br>                s_lightIdx = WaveActiveMin(v_lightIdx);<br>                <span class="hljs-comment">// If WaveActiveMin returns 0xffffffff it means that all lanes are actually dead, so we can safely ignore the loop and move forward.</span><br>               <span class="hljs-comment">// This could happen as an helper lane could reach this point, hence having a valid v_lightIdx, but their values will be ignored by the WaveActiveMin</span><br>                <span class="hljs-keyword">if</span> (s_lightIdx == <span class="hljs-number">-1</span>)<br>                &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// Note that the WaveReadLaneFirst should not be needed, but the compiler might insist in putting the result in VGPR.</span><br>            <span class="hljs-comment">// However, we are certain at this point that the index is scalar.</span><br>            s_lightIdx = WaveReadLaneFirst(s_lightIdx);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>            LightData s_lightData = FetchLight(s_lightIdx);<br><br>            <span class="hljs-comment">// If current scalar and vector light index match, we process the light. The v_lightListOffset for current thread is increased.</span><br>            <span class="hljs-comment">// Note that the following should really be ==, however, since helper lanes are not considered by WaveActiveMin, such helper lanes could</span><br>            <span class="hljs-comment">// end up with a unique v_lightIdx value that is smaller than s_lightIdx hence being stuck in a loop. All the active lanes will not have this problem.</span><br>            <span class="hljs-keyword">if</span> (s_lightIdx &gt;= v_lightIdx)<br>            &#123;<br>                v_lightListOffset++;<br>                <span class="hljs-keyword">if</span> (IsMatchingLightLayer(s_lightData.lightLayers, builtinData.renderingLayers))<br>                &#123;<br>                    DirectLighting lighting = EvaluateBSDF_Punctual(context, V, posInput, preLightData, s_lightData, bsdfData, builtinData);<br>                    AccumulateDirectLighting(lighting, aggregateLighting);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>	<br>    <br>    <br>     <span class="hljs-comment">// 这里表示这种材质类型需要计算区域光？？？</span><br>    <span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_AREA)<br>    &#123;<br>        uint lightCount, lightStart;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LIGHTLOOP_DISABLE_TILE_AND_CLUSTER</span><br>        GetCountAndStart(posInput, LIGHTCATEGORY_AREA, lightStart, lightCount);<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        lightCount = _AreaLightCount;<br>        lightStart = _PunctualLightCount;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">// COMPILER BEHAVIOR WARNING!</span><br>        <span class="hljs-comment">// If rectangle lights are before line lights, the compiler will duplicate light matrices in VGPR because they are used differently between the two types of lights.</span><br>        <span class="hljs-comment">// By keeping line lights first we avoid this behavior and save substantial register pressure.</span><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This is based on the current Lit.shader and can be different for any other way of implementing area lights, how to be generic and ensure performance ?</span><br><br>        <span class="hljs-keyword">if</span> (lightCount &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            i = <span class="hljs-number">0</span>;<br><br>            uint      last      = lightCount - <span class="hljs-number">1</span>;<br>            LightData lightData = FetchLight(lightStart, i);<br><br>            <span class="hljs-keyword">while</span> (i &lt;= last &amp;&amp; lightData.lightType == GPULIGHTTYPE_TUBE)<br>            &#123;<br>                lightData.lightType = GPULIGHTTYPE_TUBE; <span class="hljs-comment">// Enforce constant propagation</span><br>                lightData.cookieIndex = <span class="hljs-number">-1</span>;              <span class="hljs-comment">// Enforce constant propagation</span><br><br>                <span class="hljs-keyword">if</span> (IsMatchingLightLayer(lightData.lightLayers, builtinData.renderingLayers))<br>                &#123;<br>                    DirectLighting lighting = EvaluateBSDF_Area(context, V, posInput, preLightData, lightData, bsdfData, builtinData);<br>                    AccumulateDirectLighting(lighting, aggregateLighting);<br>                &#125;<br><br>                lightData = FetchLight(lightStart, min(++i, last));<br>            &#125;<br><br>            <span class="hljs-keyword">while</span> (i &lt;= last) <span class="hljs-comment">// GPULIGHTTYPE_RECTANGLE</span><br>            &#123;<br>                lightData.lightType = GPULIGHTTYPE_RECTANGLE; <span class="hljs-comment">// Enforce constant propagation</span><br><br>                <span class="hljs-keyword">if</span> (IsMatchingLightLayer(lightData.lightLayers, builtinData.renderingLayers))<br>                &#123;<br>                    DirectLighting lighting = EvaluateBSDF_Area(context, V, posInput, preLightData, lightData, bsdfData, builtinData);<br>                    AccumulateDirectLighting(lighting, aggregateLighting);<br>                &#125;<br><br>                lightData = FetchLight(lightStart, min(++i, last));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Define macro for a better understanding of the loop</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> this code is now much harder to understand...</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVALUATE_BSDF_ENV_SKY(envLightData, TYPE, type) \</span><br><span class="hljs-meta">        IndirectLighting lighting = EvaluateBSDF_Env(context, V, posInput, preLightData, envLightData, bsdfData, envLightData.influenceShapeType, MERGE_NAME(GPUIMAGEBASEDLIGHTINGTYPE_, TYPE), MERGE_NAME(type, HierarchyWeight)); \</span><br><span class="hljs-meta">        AccumulateIndirectLighting(lighting, aggregateLighting);</span><br><br><span class="hljs-comment">// Environment cubemap test lightlayers, sky don&#x27;t test it</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVALUATE_BSDF_ENV(envLightData, TYPE, type) <span class="hljs-keyword">if</span> (IsMatchingLightLayer(envLightData.lightLayers, builtinData.renderingLayers)) &#123; EVALUATE_BSDF_ENV_SKY(envLightData, TYPE, type) &#125;</span><br><br>    <span class="hljs-comment">// First loop iteration</span><br>    <span class="hljs-comment">// 开启任何一个特殊效果：环境探针，天空球，屏幕空间反射，屏幕空间折射！！！</span><br>    <span class="hljs-keyword">if</span> (featureFlags &amp; (LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_SSREFRACTION | LIGHTFEATUREFLAGS_SSREFLECTION))<br>    &#123;<br>        <span class="hljs-type">float</span> reflectionHierarchyWeight = <span class="hljs-number">0.0</span>; <span class="hljs-comment">// Max: 1.0</span><br>        <span class="hljs-type">float</span> refractionHierarchyWeight = _EnableSSRefraction ? <span class="hljs-number">0.0</span> : <span class="hljs-number">1.0</span>; <span class="hljs-comment">// Max: 1.0</span><br><br>        uint envLightStart, envLightCount;<br><br>        <span class="hljs-type">bool</span> fastPath = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// Fetch first env light to provide the scene proxy for screen space computation</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LIGHTLOOP_DISABLE_TILE_AND_CLUSTER</span><br>        GetCountAndStart(posInput, LIGHTCATEGORY_ENV, envLightStart, envLightCount);<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>        <span class="hljs-comment">// Fast path is when we all pixels in a wave is accessing same tile or cluster.</span><br>        uint envStartFirstLane = WaveReadLaneFirst(envLightStart);<br>        fastPath = WaveActiveAllTrue(envLightStart == envStartFirstLane); <br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span>   <span class="hljs-comment">// LIGHTLOOP_DISABLE_TILE_AND_CLUSTER</span></span><br>        envLightCount = _EnvLightCount;<br>        envLightStart = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">// Reflection / Refraction hierarchy is</span><br>        <span class="hljs-comment">//  1. Screen Space Refraction / Reflection</span><br>        <span class="hljs-comment">//  2. Environment Reflection / Refraction</span><br>        <span class="hljs-comment">//  3. Sky Reflection / Refraction</span><br><br>        <span class="hljs-comment">// Apply SSR.</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(_SURFACE_TYPE_TRANSPARENT) &amp;&amp; !defined(_DISABLE_SSR)</span><br>        &#123;<br>            IndirectLighting indirect = EvaluateBSDF_ScreenSpaceReflection(posInput, preLightData, bsdfData,<br>                                                                           reflectionHierarchyWeight);<br>            AccumulateIndirectLighting(indirect, aggregateLighting);<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        EnvLightData envLightData;<br>        <span class="hljs-keyword">if</span> (envLightCount &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            envLightData = FetchEnvLight(envLightStart, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            envLightData = InitSkyEnvLightData(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 计算屏幕空间折射 需要开启屏幕空间折射</span><br>        <span class="hljs-keyword">if</span> ((featureFlags &amp; LIGHTFEATUREFLAGS_SSREFRACTION) &amp;&amp; (_EnableSSRefraction &gt; <span class="hljs-number">0</span>))<br>        &#123;<br>            IndirectLighting lighting = EvaluateBSDF_ScreenspaceRefraction(context, V, posInput, preLightData, bsdfData, envLightData, refractionHierarchyWeight);<br>            AccumulateIndirectLighting(lighting, aggregateLighting);<br>        &#125;<br><br>        <span class="hljs-comment">// Reflection probes are sorted by volume (in the increasing order).</span><br>        <br>     <span class="hljs-comment">// 这里表示这种材质类型需要计算环境光：反射探针？</span><br>        <span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_ENV)<br>        &#123;<br>            context.sampleReflection = SINGLE_PASS_CONTEXT_SAMPLE_REFLECTION_PROBES;<br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>            <span class="hljs-keyword">if</span> (fastPath)<br>            &#123;<br>                envLightStart = envStartFirstLane;<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>            <span class="hljs-comment">// Scalarized loop, same rationale of the punctual light version</span><br>            uint v_envLightListOffset = <span class="hljs-number">0</span>;<br>            uint v_envLightIdx = envLightStart;<br>            <span class="hljs-keyword">while</span> (v_envLightListOffset &lt; envLightCount)<br>            &#123;<br>                v_envLightIdx = FetchIndex(envLightStart, v_envLightListOffset);<br>                uint s_envLightIdx = v_envLightIdx;<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>                <span class="hljs-keyword">if</span> (!fastPath)<br>                &#123;<br>                    s_envLightIdx = WaveActiveMin(v_envLightIdx);<br>                    <span class="hljs-comment">// If we are not in fast path, s_envLightIdx is not scalar</span><br>                   <span class="hljs-comment">// If WaveActiveMin returns 0xffffffff it means that all lanes are actually dead, so we can safely ignore the loop and move forward.</span><br>                   <span class="hljs-comment">// This could happen as an helper lane could reach this point, hence having a valid v_lightIdx, but their values will be ignored by the WaveActiveMin</span><br>                    <span class="hljs-keyword">if</span> (s_envLightIdx == <span class="hljs-number">-1</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// Note that the WaveReadLaneFirst should not be needed, but the compiler might insist in putting the result in VGPR.</span><br>                <span class="hljs-comment">// However, we are certain at this point that the index is scalar.</span><br>                s_envLightIdx = WaveReadLaneFirst(s_envLightIdx);<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>                EnvLightData s_envLightData = FetchEnvLight(s_envLightIdx);    <span class="hljs-comment">// Scalar load.</span><br><br>                <span class="hljs-comment">// If current scalar and vector light index match, we process the light. The v_envLightListOffset for current thread is increased.</span><br>                <span class="hljs-comment">// Note that the following should really be ==, however, since helper lanes are not considered by WaveActiveMin, such helper lanes could</span><br>                <span class="hljs-comment">// end up with a unique v_envLightIdx value that is smaller than s_envLightIdx hence being stuck in a loop. All the active lanes will not have this problem.</span><br>                <span class="hljs-keyword">if</span> (s_envLightIdx &gt;= v_envLightIdx)<br>                &#123;<br>                    v_envLightListOffset++;<br>                    <span class="hljs-keyword">if</span> (reflectionHierarchyWeight &lt; <span class="hljs-number">1.0</span>)<br>                    &#123;<br>                        EVALUATE_BSDF_ENV(s_envLightData, REFLECTION, reflection);<br>                    &#125;<br>                    <span class="hljs-comment">// Refraction probe and reflection probe will process exactly the same weight. It will be good for performance to be able to share this computation</span><br>                    <span class="hljs-comment">// However it is hard to deal with the fact that reflectionHierarchyWeight and refractionHierarchyWeight have not the same values, they are independent</span><br>                    <span class="hljs-comment">// The refraction probe is rarely used and happen only with sphere shape and high IOR. So we accept the slow path that use more simple code and</span><br>                    <span class="hljs-comment">// doesn&#x27;t affect the performance of the reflection which is more important.</span><br>                    <span class="hljs-comment">// We reuse LIGHTFEATUREFLAGS_SSREFRACTION flag as refraction is mainly base on the screen. Would be a waste to not use screen and only cubemap.</span><br>                    <span class="hljs-keyword">if</span> ((featureFlags &amp; LIGHTFEATUREFLAGS_SSREFRACTION) &amp;&amp; (refractionHierarchyWeight &lt; <span class="hljs-number">1.0</span>))<br>                    &#123;<br>                        EVALUATE_BSDF_ENV(s_envLightData, REFRACTION, refraction);<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Only apply the sky IBL if the sky texture is available</span><br>        <span class="hljs-keyword">if</span> ((featureFlags &amp; LIGHTFEATUREFLAGS_SKY) &amp;&amp; _EnvLightSkyEnabled)<br>        &#123;<br>            <span class="hljs-comment">// The sky is a single cubemap texture separate from the reflection probe texture array (different resolution and compression)</span><br>            context.sampleReflection = SINGLE_PASS_CONTEXT_SAMPLE_SKY;<br><br>            <span class="hljs-comment">// The sky data are generated on the fly so the compiler can optimize the code</span><br>            EnvLightData envLightSky = InitSkyEnvLightData(<span class="hljs-number">0</span>);<br><br>            <span class="hljs-comment">// Only apply the sky if we haven&#x27;t yet accumulated enough IBL lighting.</span><br>            <span class="hljs-keyword">if</span> (reflectionHierarchyWeight &lt; <span class="hljs-number">1.0</span>)<br>            &#123;<br>                EVALUATE_BSDF_ENV_SKY(envLightSky, REFLECTION, reflection);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> ((featureFlags &amp; LIGHTFEATUREFLAGS_SSREFRACTION) &amp;&amp; (refractionHierarchyWeight &lt; <span class="hljs-number">1.0</span>))<br>            &#123;<br>                EVALUATE_BSDF_ENV_SKY(envLightSky, REFRACTION, refraction);<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> EVALUATE_BSDF_ENV</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> EVALUATE_BSDF_ENV_SKY    </span><br><br>    <span class="hljs-comment">// Also Apply indiret diffuse (GI)</span><br>    <span class="hljs-comment">// PostEvaluateBSDF will perform any operation wanted by the material and sum everything into diffuseLighting and specularLighting</span><br>    PostEvaluateBSDF(   context, V, posInput, preLightData, bsdfData, builtinData, aggregateLighting,<br>                        diffuseLighting, specularLighting);<br><br>    <span class="hljs-comment">//ApplyDebug(context, posInput.positionWS, diffuseLighting, specularLighting);</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面大概标注了主循环是什么，看起来很复杂，下面每一个部分诸葛分析。</p>
<p>##AggregateLighting</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DirectLighting</span></span><br><span class="hljs-class">&#123;</span><br>    float3 diffuse;<br>    float3 specular;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IndirectLighting</span></span><br><span class="hljs-class">&#123;</span><br>    float3 specularReflected;<br>    float3 specularTransmitted;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AggregateLighting</span></span><br><span class="hljs-class">&#123;</span><br>    DirectLighting   direct;<br>    IndirectLighting indirect;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="LightFeature"><a href="#LightFeature" class="headerlink" title="LightFeature"></a>LightFeature</h2><p>在外部透明物体和不透明物体有不同的featureFlags:</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIGHT_FEATURE_MASK_FLAGS (16773120)             111111111111000000000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIGHT_FEATURE_MASK_FLAGS_OPAQUE (16642048)      111111011111000000000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT (16510976) 111110111111000000000000</span><br><br></code></pre></td></tr></table></figure>

<p>在ShaderPassForward当中有这样一段代码：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _SURFACE_TYPE_TRANSPARENT</span><br>        uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_OPAQUE;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>主要用于标注不同光照计算的特性</p>
<p>使用的地方有限：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span> D:\srp\ScriptableRenderPipeline\com.unity.render-pipelines.high-definition\Runtime\Lighting\Deferred.shader:<br>  LightLoop(V, posInput, preLightData, bsdfData, builtinData, LIGHT_FEATURE_MASK_FLAGS_OPAQUE, diffuseLighting, specularLighting);<br><br><span class="hljs-number">2.</span> D:\srp\ScriptableRenderPipeline\com.unity.render-pipelines.high-definition\Runtime\Lighting\LightLoop\DeferredTile.shader:<br>  LightLoop(V, posInput, preLightData, bsdfData, builtinData, LIGHT_FEATURE_MASK_FLAGS_OPAQUE, diffuseLighting, specularLighting);<br><br><span class="hljs-number">3.</span> D:\srp\ScriptableRenderPipeline\com.unity.render-pipelines.high-definition\Runtime\RenderPipeline\ShaderPass\ShaderPassForward.hlsl:<br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _SURFACE_TYPE_TRANSPARENT</span><br>    uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_OPAQUE;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    float3 diffuseLighting;<br></code></pre></td></tr></table></figure>

<p>还找到了 下面一段代码</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> uint kFeatureVariantFlags[NUM_FEATURE_VARIANTS] =<br>&#123;<br>    <span class="hljs-comment">// Precomputed illumination (no dynamic lights) for all material types</span><br>    <span class="hljs-comment">/*  0 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIAL_FEATURE_MASK_FLAGS,<br><br>    <span class="hljs-comment">/*  1 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/*  2 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_AREA | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/*  3 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/*  4 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/*  5 */</span> LIGHT_FEATURE_MASK_FLAGS_OPAQUE | MATERIALFEATUREFLAGS_LIT_STANDARD,<br><br>    <span class="hljs-comment">// Standard with SSS and Transmission</span><br>    <span class="hljs-comment">/*  6 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING | MATERIALFEATUREFLAGS_LIT_TRANSMISSION | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/*  7 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_AREA | MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING | MATERIALFEATUREFLAGS_LIT_TRANSMISSION | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/*  8 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING | MATERIALFEATUREFLAGS_LIT_TRANSMISSION | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/*  9 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING | MATERIALFEATUREFLAGS_LIT_TRANSMISSION | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 10 */</span> LIGHT_FEATURE_MASK_FLAGS_OPAQUE | MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING | MATERIALFEATUREFLAGS_LIT_TRANSMISSION | MATERIALFEATUREFLAGS_LIT_STANDARD,<br><br>    <span class="hljs-comment">// Anisotropy</span><br>    <span class="hljs-comment">/* 11 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | MATERIALFEATUREFLAGS_LIT_ANISOTROPY | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 12 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_AREA | MATERIALFEATUREFLAGS_LIT_ANISOTROPY | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 13 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_ANISOTROPY | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 14 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_ANISOTROPY | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 15 */</span> LIGHT_FEATURE_MASK_FLAGS_OPAQUE | MATERIALFEATUREFLAGS_LIT_ANISOTROPY | MATERIALFEATUREFLAGS_LIT_STANDARD,<br><br>    <span class="hljs-comment">// Standard with clear coat</span><br>    <span class="hljs-comment">/* 16 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | MATERIALFEATUREFLAGS_LIT_CLEAR_COAT | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 17 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_AREA | MATERIALFEATUREFLAGS_LIT_CLEAR_COAT | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 18 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_CLEAR_COAT | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 19 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_CLEAR_COAT | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 20 */</span> LIGHT_FEATURE_MASK_FLAGS_OPAQUE | MATERIALFEATUREFLAGS_LIT_CLEAR_COAT | MATERIALFEATUREFLAGS_LIT_STANDARD,<br><br>    <span class="hljs-comment">// Standard with Iridescence</span><br>    <span class="hljs-comment">/* 21 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | MATERIALFEATUREFLAGS_LIT_IRIDESCENCE | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 22 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_AREA | MATERIALFEATUREFLAGS_LIT_IRIDESCENCE | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 23 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_IRIDESCENCE | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 24 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_IRIDESCENCE | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 25 */</span> LIGHT_FEATURE_MASK_FLAGS_OPAQUE | MATERIALFEATUREFLAGS_LIT_IRIDESCENCE | MATERIALFEATUREFLAGS_LIT_STANDARD,<br><br>    <span class="hljs-comment">/* 26 */</span> LIGHT_FEATURE_MASK_FLAGS_OPAQUE | MATERIAL_FEATURE_MASK_FLAGS, <span class="hljs-comment">// Catch all case with MATERIAL_FEATURE_MASK_FLAGS is needed in case we disable material classification</span><br>&#125;;<br></code></pre></td></tr></table></figure>





<h2 id="直线光部分"><a href="#直线光部分" class="headerlink" title="直线光部分"></a>直线光部分</h2><p>下面对直线光部分的代码分析, <strong>因为直线光是全部照亮的所以不使用Tiled</strong>:</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这个if用来计算直线光阴影： 输出到 context.shadowValue当中 </span><br><span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_DIRECTIONAL)<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     LIGHTFEATUREFLAGS_DIRECTIONAL         =          100000000000000</span><br><span class="hljs-comment">     LIGHT_FEATURE_MASK_FLAGS_OPAQUE       = 111111011111000000000000</span><br><span class="hljs-comment">     LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT  = 111110111111000000000000</span><br><span class="hljs-comment">    下面两个是透明和不透明支持不一样的,也就是：透明不支持反射，不透明不支持折射。</span><br><span class="hljs-comment">     LIGHTFEATUREFLAGS_SSREFRACTION        =       100000000000000000</span><br><span class="hljs-comment">     LIGHTFEATUREFLAGS_SSREFLECTION        =      1000000000000000000  </span><br><span class="hljs-comment">    */</span><br>&#123;<br>    <span class="hljs-comment">// Evaluate sun shadows.</span><br>    <span class="hljs-keyword">if</span> (_DirectionalShadowIndex &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 太阳光信息，_DirectionalShadowIndex说明见标题：_DirectionalShadowIndex。</span><br>        DirectionalLightData light = _DirectionalLightDatas[_DirectionalShadowIndex];<br><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> this will cause us to load from the normal buffer first. Does this cause a performance problem?</span><br>        <span class="hljs-comment">// Also, the light direction is not consistent with the sun disk highlight hack, which modifies the light vector.</span><br>        <span class="hljs-type">float</span>  NdotL            = dot(bsdfData.normalWS, -light.forward);<br>        float3 shadowBiasNormal = GetNormalForShadowBias(bsdfData);<br>        <span class="hljs-type">bool</span>   evaluateShadows  = (NdotL &gt; <span class="hljs-number">0</span>);  <span class="hljs-comment">// 只有迎光面需要计算阴影</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> MATERIAL_INCLUDE_TRANSMISSION</span><br>        <span class="hljs-keyword">if</span> (MaterialSupportsTransmission(bsdfData))<br>        &#123;<br>            <span class="hljs-comment">// We support some kind of transmission.</span><br>            <span class="hljs-keyword">if</span> (HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_TRANSMISSION_MODE_THIN_THICKNESS))<br>            &#123;<br>                <span class="hljs-comment">// We always evaluate shadows.</span><br>                evaluateShadows = <span class="hljs-literal">true</span>;<br><br>                <span class="hljs-comment">// Care must be taken to bias in the direction of the light.</span><br>                shadowBiasNormal *= FastSign(NdotL);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// We only evaluate shadows for reflection, transmission shadows are handled separately.</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-comment">// 计算阴影值</span><br>        <span class="hljs-keyword">if</span> (evaluateShadows)<br>        &#123;<br>            context.shadowValue = EvaluateRuntimeSunShadow(context, posInput, light, shadowBiasNormal);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// This struct is define in the material. the Lightloop must not access it</span><br><span class="hljs-comment">// PostEvaluateBSDF call at the end will convert Lighting to diffuse and specular lighting</span><br><span class="hljs-comment">// 主要用来积累计算不同的光照，内容见：AggregateLighting二级目录</span><br>AggregateLighting aggregateLighting;<br>ZERO_INITIALIZE(AggregateLighting, aggregateLighting); <br><br>uint i = <span class="hljs-number">0</span>; <br><br><span class="hljs-comment">// 积累直线光</span><br><span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_DIRECTIONAL)<br>&#123;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; _DirectionalLightCount; ++i)<br>    &#123;<br>        <span class="hljs-comment">// 光照层过滤，制定光照照在不同的物体上。</span><br>        <span class="hljs-keyword">if</span> (IsMatchingLightLayer(_DirectionalLightDatas[i].lightLayers, builtinData.renderingLayers))<br>        &#123;<br>            <span class="hljs-comment">// 这里是计算直线光  ，考虑一下Tiledlight在哪里产生作用？？</span><br>            DirectLighting lighting = EvaluateBSDF_Directional(context, V, posInput, preLightData, _DirectionalLightDatas[i], bsdfData, builtinData);<br>            <br>            <span class="hljs-comment">// 叠加光</span><br>            AccumulateDirectLighting(lighting, aggregateLighting);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>###_DirectionalShadowIndex</p>
<p>下面主要说明了_DirectionalShadowIndex是用来标注太阳光的索引。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">D:\srp\ScriptableRenderPipeline\com.unity.render-pipelines.high-definition\Runtime\Lighting\LightLoop\LightLoop.cs:<br> <span class="hljs-number">2605</span>                  <span class="hljs-keyword">if</span> (sunLightShadow)<br> <span class="hljs-number">2606</span>                  &#123;<br> <span class="hljs-number">2607</span>:                     cmd.SetGlobalInt(HDShaderIDs._DirectionalShadowIndex, m_CurrentShadowSortedSunLightIndex);<br> <span class="hljs-number">2608</span>                  &#125;<br> <span class="hljs-number">2609</span>                  <span class="hljs-keyword">else</span><br> <span class="hljs-number">2610</span>                  &#123;<br> <span class="hljs-number">2611</span>:                     cmd.SetGlobalInt(HDShaderIDs._DirectionalShadowIndex, <span class="hljs-number">-1</span>);<br> <span class="hljs-number">2612</span>                  &#125;<br></code></pre></td></tr></table></figure>

<p>###EvaluateBSDF_Directional</p>
<p>这个主要用来输入光源参数、材质参数，得到最终的光的颜色。</p>
<p>这个函数包含在各种光照模型中：</p>
<p>Hair.hlsl</p>
<p>Fabric.hlsl</p>
<p>AxF.hlsl</p>
<p>Lit.hlsl</p>
<p>StackLit.hlsl</p>
<p>这里先看Lit.hlsl当中如何实现的。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>DirectLighting <span class="hljs-title function_">EvaluateBSDF_Directional</span><span class="hljs-params">(LightLoopContext lightLoopContext,</span><br><span class="hljs-params">                                        float3 V, PositionInputs posInput, PreLightData preLightData,</span><br><span class="hljs-params">                                        DirectionalLightData lightData, BSDFData bsdfData,</span><br><span class="hljs-params">                                        BuiltinData builtinData)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> ShadeSurface_Directional(lightLoopContext, posInput, builtinData, preLightData, lightData,<br>                                    bsdfData, bsdfData.normalWS, V);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再看头发</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">DirectLighting <span class="hljs-title function_">EvaluateBSDF_Directional</span><span class="hljs-params">(LightLoopContext lightLoopContext,</span><br><span class="hljs-params">                                        float3 V, PositionInputs posInput, PreLightData preLightData,</span><br><span class="hljs-params">                                        DirectionalLightData lightData, BSDFData bsdfData,</span><br><span class="hljs-params">                                        BuiltinData builtinData)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> ShadeSurface_Directional(lightLoopContext, posInput, builtinData, preLightData, lightData,<br>                                    bsdfData, bsdfData.normalWS, V);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>他们都引入了一个ShadeSurface_Directional</p>
<h3 id="ShadeSurface-Directional"><a href="#ShadeSurface-Directional" class="headerlink" title="ShadeSurface_Directional"></a>ShadeSurface_Directional</h3><p>ShadeSurface_Directional在同一个函数当中。</p>
<p>Lighting\SurfaceShading.hlsl</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c">DirectLighting <span class="hljs-title function_">ShadeSurface_Directional</span><span class="hljs-params">(LightLoopContext lightLoopContext,</span><br><span class="hljs-params">                                        PositionInputs posInput, BuiltinData builtinData,</span><br><span class="hljs-params">                                        PreLightData preLightData, DirectionalLightData light,</span><br><span class="hljs-params">                                        BSDFData bsdfData, float3 N, float3 V)</span><br>&#123;<br>    DirectLighting lighting;<br>    ZERO_INITIALIZE(DirectLighting, lighting);<br><br>    float3 L     = ComputeSunLightDirection(light, N, V);<br>    <span class="hljs-type">float</span>  NdotL = dot(N, L); <span class="hljs-comment">// Do not saturate</span><br><br>    <span class="hljs-comment">// Note: We use NdotL here to early out, but in case of clear coat this is not correct. But we are OK with this</span><br>    <span class="hljs-type">bool</span> surfaceReflection = NdotL &gt; <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// Caution: this function modifies N, NdotL, contactShadowIndex and shadowMaskSelector.</span><br>    float3 transmittance = PreEvaluateDirectionalLightTransmission(bsdfData, light, N, NdotL);<br><br>    float3 color; <span class="hljs-type">float</span> attenuation;<br>    EvaluateLight_Directional(lightLoopContext, posInput, light, builtinData, N, L, NdotL,<br>                              color, attenuation);<br>	<br>    <span class="hljs-comment">// 这里就是根据雾的透视率和阴影计算光的颜色。</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> transmittance contributes to attenuation, how can we use it for early-out?</span><br>    <span class="hljs-keyword">if</span> (attenuation &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// We must clamp here, otherwise our disk light hack for smooth surfaces does not work.</span><br>        <span class="hljs-comment">// Explanation: for a perfectly smooth surface, lighting is only reflected if (NdotL = NdotV).</span><br>        <span class="hljs-comment">// This implies that (NdotH = 1).</span><br>        <span class="hljs-comment">// Due to the floating point arithmetic (see math in ComputeSunLightDirection() and</span><br>        <span class="hljs-comment">// GetBSDFAngle()), we will never arrive at this exact number, so no lighting will be reflected.</span><br>        <span class="hljs-comment">// If we increase the roughness somewhat, the trick still works.</span><br>        ClampRoughness(bsdfData, light.minRoughness);<br><br>        float3 diffuseBsdf, specularBsdf;<br>        BSDF(V, L, NdotL, posInput.positionWS, preLightData, bsdfData, diffuseBsdf, specularBsdf);<br>		<br>        <span class="hljs-comment">// 光的摄入方向。</span><br>        <span class="hljs-keyword">if</span> (surfaceReflection)<br>        &#123;<br>            attenuation    *= ComputeMicroShadowing(bsdfData, NdotL);<br>            <span class="hljs-type">float</span> intensity = attenuation * NdotL;<br><br>            lighting.diffuse  = diffuseBsdf  * (intensity * light.diffuseDimmer);<br>            lighting.specular = specularBsdf * (intensity * light.specularDimmer);<br>        &#125;<br>        <span class="hljs-comment">// 光在反面同时开启了透射。</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (MaterialSupportsTransmission(bsdfData))<br>        &#123;<br>             <span class="hljs-comment">// Apply wrapped lighting to better handle thin objects at grazing angles.</span><br>            <span class="hljs-comment">// 如果是材质支持透视？  则启用边缘光。</span><br>            <span class="hljs-type">float</span> wrapNdotL = ComputeWrappedDiffuseLighting(NdotL, TRANSMISSION_WRAP_LIGHT);<br>            <span class="hljs-type">float</span> intensity = attenuation * wrapNdotL;<br><br>            <span class="hljs-comment">// We use diffuse lighting for accumulation since it is going to be blurred during the SSS pass.</span><br>            <span class="hljs-comment">// Note: Disney&#x27;s LdoV term in &#x27;diffuseBsdf&#x27; does not hold a meaningful value</span><br>            <span class="hljs-comment">// in the context of transmission, but we keep it unaltered for performance reasons.</span><br>            lighting.diffuse  = transmittance * (diffuseBsdf * (intensity * light.diffuseDimmer));<br>            <span class="hljs-comment">// 高光没有透射光。</span><br>            lighting.specular = <span class="hljs-number">0</span>; <span class="hljs-comment">// No spec trans, the compiler should optimize</span><br>        &#125;<br><br>        <span class="hljs-comment">// Save ALU by applying light and cookie colors only once.</span><br>        lighting.diffuse  *= color;<br>        lighting.specular *= color;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> lighting;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="EvaluateLight-Directional"><a href="#EvaluateLight-Directional" class="headerlink" title="EvaluateLight_Directional"></a>EvaluateLight_Directional</h3><p>用来计算光,输入位置 ，光线，纹理和方向信息，输出光的颜色和衰减。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">EvaluateLight_Directional</span><span class="hljs-params">(LightLoopContext lightLoopContext, PositionInputs posInput,</span><br><span class="hljs-params">                               DirectionalLightData light, BuiltinData builtinData,</span><br><span class="hljs-params">                               float3 N, float3 L, <span class="hljs-type">float</span> NdotL,</span><br><span class="hljs-params">                               out float3 color, out <span class="hljs-type">float</span> attenuation)</span><br>&#123;<br>    <span class="hljs-comment">//light 信息是从外部C#设置的</span><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-comment">// 衰减由阴影和雾影响，颜色是Cookie</span><br>    color = attenuation = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// early Out  背面 和 光颜色削减为0  不进行光照。</span><br>    <span class="hljs-keyword">if</span> ((light.lightDimmer &lt;= <span class="hljs-number">0</span>) || (NdotL &lt;= <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 没有阴影开始</span><br>    float3 positionWS = posInput.positionWS;<br>    <span class="hljs-type">float</span>  shadow     = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">float</span>  shadowMask = <span class="hljs-number">1.0</span>;<br>	<br>    <span class="hljs-comment">// 读取光的信息 ，开始没有衰减</span><br>    color       = light.color;<br>    attenuation = <span class="hljs-number">1.0</span>;<br><br>    <span class="hljs-comment">// Height fog attenuation. 根据高度雾计算光照衰减。</span><br>    &#123;<br>        <span class="hljs-type">float</span> cosZenithAngle = L.y;<br>        <span class="hljs-type">float</span> fragmentHeight = posInput.positionWS.y;<br>        attenuation *= TransmittanceHeightFog(_HeightFogBaseExtinction, _HeightFogBaseHeight,<br>                                              _HeightFogExponents, cosZenithAngle, fragmentHeight);<br>    &#125;<br>	<br>    <span class="hljs-comment">// cookie 纹理</span><br>    <span class="hljs-keyword">if</span> (light.cookieIndex &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        float3 lightToSample = positionWS - light.positionRWS;<br>        float3 cookie = EvaluateCookie_Directional(lightLoopContext, light, lightToSample);<br><br>        color *= cookie; <span class="hljs-comment">// 用cookie衰减纹理。</span><br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SHADOWS_SHADOWMASK</span><br>    <span class="hljs-comment">// shadowMaskSelector.x is -1 if there is no shadow mask</span><br>    <span class="hljs-comment">// Note that we override shadow value (in case we don&#x27;t have any dynamic shadow)</span><br>    shadow = shadowMask = (light.shadowMaskSelector.x &gt;= <span class="hljs-number">0.0</span>) ? dot(BUILTIN_DATA_SHADOW_MASK, light.shadowMaskSelector) : <span class="hljs-number">1.0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">if</span> ((light.shadowIndex &gt;= <span class="hljs-number">0</span>) &amp;&amp; (light.shadowDimmer &gt; <span class="hljs-number">0</span>))<br>    &#123;<br>        shadow = lightLoopContext.shadowValue;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SHADOWS_SHADOWMASK</span><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Optimize this code! Currently it is a bit like brute force to get the last transistion and fade to shadow mask, but there is</span><br>        <span class="hljs-comment">// certainly more efficient to do</span><br>        <span class="hljs-comment">// We reuse the transition from the cascade system to fade between shadow mask at max distance</span><br>        uint  payloadOffset;<br>        real  fade;<br>        <span class="hljs-type">int</span> cascadeCount;<br>        <span class="hljs-type">int</span> shadowSplitIndex = <span class="hljs-number">0</span>;<br><br>        shadowSplitIndex = EvalShadow_GetSplitIndex(lightLoopContext.shadowContext, light.shadowIndex, positionWS, fade, cascadeCount);<br><br>        <span class="hljs-comment">// we have a fade caclulation for each cascade but we must lerp with shadow mask only for the last one</span><br>        <span class="hljs-comment">// if shadowSplitIndex is -1 it mean we are outside cascade and should return 1.0 to use shadowmask: saturate(-shadowSplitIndex) return 0 for &gt;= 0 and 1 for -1</span><br>        fade = ((shadowSplitIndex + <span class="hljs-number">1</span>) == cascadeCount) ? fade : saturate(-shadowSplitIndex);<br><br>        <span class="hljs-comment">// In the transition code (both dithering and blend) we use shadow = lerp( shadow, 1.0, fade ) for last transition</span><br>        <span class="hljs-comment">// mean if we expend the code we have (shadow * (1 - fade) + fade). Here to make transition with shadow mask</span><br>        <span class="hljs-comment">// we will remove fade and add fade * shadowMask which mean we do a lerp with shadow mask</span><br>        shadow = shadow - fade + fade * shadowMask;<br><br>        <span class="hljs-comment">// See comment in EvaluateBSDF_Punctual</span><br>        shadow = light.nonLightMappedOnly ? min(shadowMask, shadow) : shadow;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        shadow = lerp(shadowMask, shadow, light.shadowDimmer);<br>    &#125;<br><br>    <span class="hljs-comment">// Transparents have no contact shadow information</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _SURFACE_TYPE_TRANSPARENT</span><br>    shadow = min(shadow, GetContactShadow(lightLoopContext, light.contactShadowIndex));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>	<br>    attenuation *= shadow;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Point-和-Spot"><a href="#Point-和-Spot" class="headerlink" title="Point 和 Spot"></a>Point 和 Spot</h2><p>这两种灯光和距离相关，同时需要用到Tiled</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_PUNCTUAL)<br>&#123;<br>    uint lightCount, lightStart;<br>    <span class="hljs-type">bool</span> fastPath = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LIGHTLOOP_DISABLE_TILE_AND_CLUSTER</span><br>    GetCountAndStart(posInput, LIGHTCATEGORY_PUNCTUAL, lightStart, lightCount);<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>    <span class="hljs-comment">// Fast path is when we all pixels in a wave are accessing same tile or cluster.</span><br>    uint lightStartLane0 = WaveReadLaneFirst(lightStart);<br>    fastPath = WaveActiveAllTrue(lightStart == lightStartLane0); <br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span>   <span class="hljs-comment">// LIGHTLOOP_DISABLE_TILE_AND_CLUSTER</span></span><br>    lightCount = _PunctualLightCount;<br>    lightStart = <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>    <span class="hljs-keyword">if</span> (fastPath)<br>    &#123;<br>        lightStart = lightStartLane0;<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// Scalarized loop. All lights that are in a tile/cluster touched by any pixel in the wave are loaded (scalar load), only the one relevant to current thread/pixel are processed.</span><br>    <span class="hljs-comment">// For clarity, the following code will follow the convention: variables starting with s_ are meant to be wave uniform (meant for scalar register),</span><br>    <span class="hljs-comment">// v_ are variables that might have different value for each thread in the wave (meant for vector registers).</span><br>    <span class="hljs-comment">// This will perform more loads than it is supposed to, however, the benefits should offset the downside, especially given that light data accessed should be largely coherent.</span><br>    <span class="hljs-comment">// Note that the above is valid only if wave intriniscs are supported.</span><br>    uint v_lightListOffset = <span class="hljs-number">0</span>;<br>    uint v_lightIdx = lightStart;<br><br>    <span class="hljs-keyword">while</span> (v_lightListOffset &lt; lightCount)<br>    &#123;<br>        v_lightIdx = FetchIndex(lightStart, v_lightListOffset);<br>        uint s_lightIdx = v_lightIdx;<br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>        <span class="hljs-keyword">if</span> (!fastPath)<br>        &#123;<br>            <span class="hljs-comment">// If we are not in fast path, v_lightIdx is not scalar, so we need to query the Min value across the wave. </span><br>            s_lightIdx = WaveActiveMin(v_lightIdx);<br>            <span class="hljs-comment">// If WaveActiveMin returns 0xffffffff it means that all lanes are actually dead, so we can safely ignore the loop and move forward.</span><br>            <span class="hljs-comment">// This could happen as an helper lane could reach this point, hence having a valid v_lightIdx, but their values will be ignored by the WaveActiveMin</span><br>            <span class="hljs-keyword">if</span> (s_lightIdx == <span class="hljs-number">-1</span>)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// Note that the WaveReadLaneFirst should not be needed, but the compiler might insist in putting the result in VGPR.</span><br>        <span class="hljs-comment">// However, we are certain at this point that the index is scalar.</span><br>        s_lightIdx = WaveReadLaneFirst(s_lightIdx);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <br>        <span class="hljs-comment">// 上面一部分计算应该是 光源计算的Tiled算法有关。，这里获取到光照信息。</span><br>        LightData s_lightData = FetchLight(s_lightIdx);<br><br>        <span class="hljs-comment">// If current scalar and vector light index match, we process the light. The v_lightListOffset for current thread is increased.</span><br>        <span class="hljs-comment">// Note that the following should really be ==, however, since helper lanes are not considered by WaveActiveMin, such helper lanes could</span><br>        <span class="hljs-comment">// end up with a unique v_lightIdx value that is smaller than s_lightIdx hence being stuck in a loop. All the active lanes will not have this problem.</span><br>        <span class="hljs-keyword">if</span> (s_lightIdx &gt;= v_lightIdx)<br>        &#123;<br>            v_lightListOffset++;<br>            <span class="hljs-keyword">if</span> (IsMatchingLightLayer(s_lightData.lightLayers, builtinData.renderingLayers))<br>            &#123;<br>                DirectLighting lighting = EvaluateBSDF_Punctual(context, V, posInput, preLightData, s_lightData, bsdfData, builtinData);<br>                AccumulateDirectLighting(lighting, aggregateLighting);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="ShadeSurface-Punctual"><a href="#ShadeSurface-Punctual" class="headerlink" title="ShadeSurface_Punctual"></a>ShadeSurface_Punctual</h3><p>这个函数和指向光部分的一样</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c">DirectLighting <span class="hljs-title function_">ShadeSurface_Punctual</span><span class="hljs-params">(LightLoopContext lightLoopContext,</span><br><span class="hljs-params">                                     PositionInputs posInput, BuiltinData builtinData,</span><br><span class="hljs-params">                                     PreLightData preLightData, LightData light,</span><br><span class="hljs-params">                                     BSDFData bsdfData, float3 N, float3 V)</span><br>&#123;<br>    DirectLighting lighting;<br>    ZERO_INITIALIZE(DirectLighting, lighting);<br><br>    float3 L;<br>    float3 lightToSample;<br>    float4 distances; <span class="hljs-comment">// &#123;d, d^2, 1/d, d_proj&#125;</span><br>    GetPunctualLightVectors(posInput.positionWS, light, L, lightToSample, distances);<br><br>    <span class="hljs-type">float</span> NdotL = dot(N, L); <span class="hljs-comment">// Do not saturate</span><br><br>    <span class="hljs-comment">// Note: We use NdotL here to early out, but in case of clear coat this is not correct. But we are OK with this</span><br>    <span class="hljs-type">bool</span> surfaceReflection = NdotL &gt; <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// Caution: this function modifies N, NdotL, shadowIndex, contactShadowIndex and shadowMaskSelector. </span><br>    <span class="hljs-comment">// 计算光照投射</span><br>    float3 transmittance = PreEvaluatePunctualLightTransmission(lightLoopContext, posInput, bsdfData,<br>                                                                light, distances.x, N, L, NdotL);<br>    float3 color; <span class="hljs-type">float</span> attenuation;<br>    EvaluateLight_Punctual(lightLoopContext, posInput, light, builtinData, N, L, NdotL, lightToSample, distances,<br>                           color, attenuation);<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> transmittance contributes to attenuation, how can we use it for early-out?</span><br>    <span class="hljs-keyword">if</span> (attenuation &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// Simulate a sphere/disk light with this hack</span><br>        <span class="hljs-comment">// Note that it is not correct with our pre-computation of PartLambdaV (mean if we disable the optimization we will not have the</span><br>        <span class="hljs-comment">// same result) but we don&#x27;t care as it is a hack anyway</span><br>        ClampRoughness(bsdfData, light.minRoughness);<br><br>        float3 diffuseBsdf, specularBsdf;<br>        BSDF(V, L, NdotL, posInput.positionWS, preLightData, bsdfData, diffuseBsdf, specularBsdf);<br><br>        <span class="hljs-keyword">if</span> (surfaceReflection)<br>        &#123;<br>            <span class="hljs-type">float</span> intensity = attenuation * NdotL;<br><br>            lighting.diffuse  = diffuseBsdf  * (intensity * light.diffuseDimmer);<br>            lighting.specular = specularBsdf * (intensity * light.specularDimmer);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (MaterialSupportsTransmission(bsdfData))<br>        &#123;<br>             <span class="hljs-comment">// Apply wrapped lighting to better handle thin objects at grazing angles.</span><br>            <span class="hljs-type">float</span> wrapNdotL = ComputeWrappedDiffuseLighting(NdotL, TRANSMISSION_WRAP_LIGHT);<br>            <span class="hljs-type">float</span> intensity = attenuation * wrapNdotL;<br><br>            <span class="hljs-comment">// We use diffuse lighting for accumulation since it is going to be blurred during the SSS pass.</span><br>            <span class="hljs-comment">// Note: Disney&#x27;s LdoV term in &#x27;diffuseBsdf&#x27; does not hold a meaningful value</span><br>            <span class="hljs-comment">// in the context of transmission, but we keep it unaltered for performance reasons.</span><br>            lighting.diffuse  = transmittance * (diffuseBsdf * (intensity * light.diffuseDimmer));<br>            lighting.specular = <span class="hljs-number">0</span>; <span class="hljs-comment">// No spec trans, the compiler should optimize</span><br>        &#125;<br><br>        <span class="hljs-comment">// Save ALU by applying light and cookie colors only once.</span><br>        lighting.diffuse  *= color;<br>        lighting.specular *= color;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> lighting;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="PreEvaluatePunctualLightTransmission"><a href="#PreEvaluatePunctualLightTransmission" class="headerlink" title="PreEvaluatePunctualLightTransmission"></a>PreEvaluatePunctualLightTransmission</h3><p>这个函数用来计算光照的透射度，可能会修改法线。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// This function return transmittance to provide to EvaluateTransmission</span><br>float3 <span class="hljs-title function_">PreEvaluatePunctualLightTransmission</span><span class="hljs-params">(LightLoopContext lightLoopContext,</span><br><span class="hljs-params">                                            PositionInputs posInput, BSDFData bsdfData,</span><br><span class="hljs-params">                                            inout LightData light, <span class="hljs-type">float</span> distFrontFaceToLight,</span><br><span class="hljs-params">                                            inout float3 N, float3 L, inout <span class="hljs-type">float</span> NdotL)</span><br>&#123;<br>    float3 transmittance = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 判断功能是否开启 如果材质没有包含透射 就没有透射</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> MATERIAL_INCLUDE_TRANSMISSION</span><br>    <span class="hljs-comment">// 判断材质是否支持</span><br>    <span class="hljs-keyword">if</span> (MaterialSupportsTransmission(bsdfData))<br>    &#123;<br>        <span class="hljs-comment">// We support some kind of transmission.</span><br>        <span class="hljs-comment">// 背面才会生效。</span><br>        <span class="hljs-keyword">if</span> (NdotL &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">// And since the light is back-facing, it&#x27;s active.</span><br>            <span class="hljs-comment">// Care must be taken to bias in the direction of the light.</span><br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> change the sign of the bias: faster &amp; uses fewer VGPRs.</span><br>            <span class="hljs-comment">//扭转法线！！！！！！！！</span><br>            N = -N;<br><br>            <span class="hljs-comment">// We want to evaluate cookies and light attenuation, so we flip NdotL.</span><br>            <span class="hljs-comment">// 扭转计算结果</span><br>            NdotL = -NdotL;<br><br>            <span class="hljs-comment">// However, we don&#x27;t want baked or contact shadows.</span><br>            <br>            <span class="hljs-comment">// 关闭阴影</span><br>            light.contactShadowIndex   = <span class="hljs-number">-1</span>;<br>            light.shadowMaskSelector.x = <span class="hljs-number">-1</span>;<br>			<br>            <span class="hljs-comment">// 材质的透视度。</span><br>            transmittance = bsdfData.transmittance;<br>			<br>            <span class="hljs-comment">//</span><br>            <span class="hljs-keyword">if</span> (!HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_TRANSMISSION_MODE_THIN_THICKNESS) &amp;&amp; (light.shadowIndex &gt;= <span class="hljs-number">0</span>))<br>            &#123;<br>                <span class="hljs-comment">// We can compute thickness from shadow.</span><br>                <span class="hljs-comment">// Compute the distance from the light to the back face of the object along the light direction.</span><br>                <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> SHADOW BIAS.</span><br>                <span class="hljs-type">float</span> distBackFaceToLight = GetPunctualShadowClosestDistance(lightLoopContext.shadowContext, s_linear_clamp_sampler,<br>                                                                             posInput.positionWS, light.shadowIndex, L, light.positionRWS,<br>                                                                             light.lightType == GPULIGHTTYPE_POINT);<br><br>                <span class="hljs-comment">// Our subsurface scattering models use the semi-infinite planar slab assumption.</span><br>                <span class="hljs-comment">// Therefore, we need to find the thickness along the normal.</span><br>                <span class="hljs-comment">// Warning: based on the artist&#x27;s input, dependence on the NdotL has been disabled.</span><br>                <span class="hljs-type">float</span> thicknessInUnits       = (distFrontFaceToLight - distBackFaceToLight) <span class="hljs-comment">/* * -NdotL */</span>;<br>                <span class="hljs-type">float</span> thicknessInMeters      = thicknessInUnits * _WorldScales[bsdfData.diffusionProfile].x;<br>                <span class="hljs-type">float</span> thicknessInMillimeters = thicknessInMeters * MILLIMETERS_PER_METER;<br><br>                <span class="hljs-comment">// We need to make sure it&#x27;s not less than the baked thickness to minimize light leaking.</span><br>                <span class="hljs-type">float</span> thicknessDelta = max(<span class="hljs-number">0</span>, thicknessInMillimeters - bsdfData.thickness);<br><br>                float3 S = _ShapeParams[bsdfData.diffusionProfile].rgb;<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>                float3 expOneThird = <span class="hljs-built_in">exp</span>(((<span class="hljs-number">-1.0</span> / <span class="hljs-number">3.0</span>) * thicknessDelta) * S);<br>            <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>                <span class="hljs-comment">// Help the compiler. S is premultiplied by ((-1.0 / 3.0) * LOG2_E) on the CPU.</span><br>                float3 p = thicknessDelta * S;<br>                float3 expOneThird = exp2(p);<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>                <span class="hljs-comment">// Approximate the decrease of transmittance by e^(-1/3 * dt * S).</span><br>                transmittance *= expOneThird;<br><br>                <span class="hljs-comment">// Avoid double shadowing. <span class="hljs-doctag">TODO:</span> is there a faster option?</span><br>                light.shadowIndex = <span class="hljs-number">-1</span>;<br><br>                <span class="hljs-comment">// Note: we do not modify the distance to the light, or the light angle for the back face.</span><br>                <span class="hljs-comment">// This is a performance-saving optimization which makes sense as long as the thickness is small.</span><br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> transmittance;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="区域光部分"><a href="#区域光部分" class="headerlink" title="区域光部分"></a>区域光部分</h2><p>##屏幕空间反射部分</p>
<h2 id="反射探针部分"><a href="#反射探针部分" class="headerlink" title="反射探针部分"></a>反射探针部分</h2><h2 id="天空球部分"><a href="#天空球部分" class="headerlink" title="天空球部分"></a>天空球部分</h2><h2 id="光照探针、lightmap"><a href="#光照探针、lightmap" class="headerlink" title="光照探针、lightmap"></a>光照探针、lightmap</h2><p>PostEvaluateBSDF计算了间接光</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PostEvaluateBSDF</span><span class="hljs-params">(  LightLoopContext lightLoopContext,</span><br><span class="hljs-params">                        float3 V, PositionInputs posInput,</span><br><span class="hljs-params">                        PreLightData preLightData, BSDFData bsdfData, BuiltinData builtinData, AggregateLighting lighting,</span><br><span class="hljs-params">                        out float3 diffuseLighting, out float3 specularLighting)</span><br>&#123;<br>    AmbientOcclusionFactor aoFactor;<br>    <span class="hljs-comment">// Use GTAOMultiBounce approximation for ambient occlusion (allow to get a tint from the baseColor)</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>    GetScreenSpaceAmbientOcclusion(posInput.positionSS, preLightData.NdotV, bsdfData.perceptualRoughness, bsdfData.ambientOcclusion, bsdfData.specularOcclusion, aoFactor);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    GetScreenSpaceAmbientOcclusionMultibounce(posInput.positionSS, preLightData.NdotV, bsdfData.perceptualRoughness, bsdfData.ambientOcclusion, bsdfData.specularOcclusion, bsdfData.diffuseColor, bsdfData.fresnel0, aoFactor);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">// AmbientOcclusion 技术需要了解一下</span><br>    ApplyAmbientOcclusionFactor(aoFactor, builtinData, lighting);<br><br>    <span class="hljs-comment">// Subsurface scattering mode</span><br>    <span class="hljs-comment">// SSS效果也是在这里应用的</span><br>    float3 modifiedDiffuseColor = GetModifiedDiffuseColorForSSS(bsdfData);<br><br>    <span class="hljs-comment">// Apply the albedo to the direct diffuse lighting (only once). The indirect (baked)</span><br>    <span class="hljs-comment">// diffuse lighting has already multiply the albedo in ModifyBakedDiffuseLighting().</span><br>    <span class="hljs-comment">// Note: In deferred bakeDiffuseLighting also contain emissive and in this case emissiveColor is 0</span><br>    <span class="hljs-comment">// 漫反射光包含了前面计算 经过模糊的SSS光， 烘焙的关照贴图和自发光。</span><br>    diffuseLighting = modifiedDiffuseColor * lighting.direct.diffuse + builtinData.bakeDiffuseLighting + builtinData.emissiveColor;<br><br>    <span class="hljs-comment">// If refraction is enable we use the transmittanceMask to lerp between current diffuse lighting and refraction value</span><br>    <span class="hljs-comment">// Physically speaking, transmittanceMask should be 1, but for artistic reasons, we let the value vary</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Note we also transfer the refracted light (lighting.indirect.specularTransmitted) into diffuseLighting</span><br>    <span class="hljs-comment">// since we know it won&#x27;t be further processed: it is called at the end of the LightLoop(), but doing this</span><br>    <span class="hljs-comment">// enables opacity to affect it (in ApplyBlendMode()) while the rest of specularLighting escapes it.</span><br>    <br>    <span class="hljs-comment">// 如果有折射则还需要和折射进行混合</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> HAS_REFRACTION</span><br>    diffuseLighting = lerp(diffuseLighting, lighting.indirect.specularTransmitted, bsdfData.transmittanceMask * _EnableSSRefraction);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<br>    <span class="hljs-comment">// 高光部分，直接高光，反射探针。</span><br>    specularLighting = lighting.direct.specular + lighting.indirect.specularReflected;<br>    <span class="hljs-comment">// Rescale the GGX to account for the multiple scattering.</span><br>    specularLighting *= <span class="hljs-number">1.0</span> + bsdfData.fresnel0 * preLightData.energyCompensation;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="GetPreLightData"><a href="#GetPreLightData" class="headerlink" title="GetPreLightData"></a>GetPreLightData</h2><p>预光照信息，保存了能量守恒等各种系数，一次性计算在后面需要的时候一次性使用。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>PreLightData <span class="hljs-title function_">GetPreLightData</span><span class="hljs-params">(float3 V, PositionInputs posInput, inout BSDFData bsdfData)</span><br>&#123;<br>    PreLightData preLightData;<br>    ZERO_INITIALIZE(PreLightData, preLightData);<br><br>    float3 N = bsdfData.normalWS;<br>    preLightData.NdotV = dot(N, V);<br>    preLightData.iblPerceptualRoughness = bsdfData.perceptualRoughness;<br><br>    <span class="hljs-type">float</span> NdotV = ClampNdotV(preLightData.NdotV);<br><br>    <span class="hljs-comment">// We modify the bsdfData.fresnel0 here for iridescence</span><br>    <span class="hljs-comment">// 修改frenel0是为了得到彩虹色高光效果。</span><br>    <span class="hljs-keyword">if</span> (HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_LIT_IRIDESCENCE))<br>    &#123;<br>        <span class="hljs-type">float</span> viewAngle = NdotV;<br>        <span class="hljs-type">float</span> topIor = <span class="hljs-number">1.0</span>; <span class="hljs-comment">// Default is air</span><br>        <span class="hljs-keyword">if</span> (HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_LIT_CLEAR_COAT))<br>        &#123;<br>            topIor = lerp(<span class="hljs-number">1.0</span>, CLEAR_COAT_IOR, bsdfData.coatMask);<br>            <span class="hljs-comment">// <span class="hljs-doctag">HACK:</span> Use the reflected direction to specify the Fresnel coefficient for pre-convolved envmaps</span><br>            viewAngle = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> + Sq(<span class="hljs-number">1.0</span> / topIor) * (Sq(dot(bsdfData.normalWS, V)) - <span class="hljs-number">1.0</span>));<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (bsdfData.iridescenceMask &gt; <span class="hljs-number">0.0</span>)<br>        &#123;<br>            bsdfData.fresnel0 = lerp(bsdfData.fresnel0, EvalIridescence(topIor, viewAngle, bsdfData.iridescenceThickness, bsdfData.fresnel0), bsdfData.iridescenceMask);<br>        &#125;<br>    &#125;<br>	<br>    <span class="hljs-comment">// 修改fresnel0为了clearcoat效果</span><br>    <span class="hljs-comment">// We modify the bsdfData.fresnel0 here for clearCoat</span><br>    <span class="hljs-keyword">if</span> (HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_LIT_CLEAR_COAT))<br>    &#123;<br>        <span class="hljs-comment">// Fresnel0 is deduced from interface between air and material (Assume to be 1.5 in Unity, or a metal).</span><br>        <span class="hljs-comment">// but here we go from clear coat (1.5) to material, we need to update fresnel0</span><br>        <span class="hljs-comment">// Note: Schlick is a poor approximation of Fresnel when ieta is 1 (1.5 / 1.5), schlick target 1.4 to 2.2 IOR.</span><br>        bsdfData.fresnel0 = lerp(bsdfData.fresnel0, ConvertF0ForAirInterfaceToF0ForClearCoat15(bsdfData.fresnel0), bsdfData.coatMask);<br><br>        preLightData.coatPartLambdaV = GetSmithJointGGXPartLambdaV(NdotV, CLEAR_COAT_ROUGHNESS);<br>        preLightData.coatIblR = reflect(-V, N);<br>        preLightData.coatIblF = F_Schlick(CLEAR_COAT_F0, NdotV) * bsdfData.coatMask;<br>    &#125;<br><br>    <span class="hljs-comment">// Handle IBL + area light + multiscattering.</span><br>    <span class="hljs-comment">// Note: use the not modified by anisotropy iblPerceptualRoughness here.</span><br>    <span class="hljs-type">float</span> specularReflectivity;<br>    GetPreIntegratedFGDGGXAndDisneyDiffuse(NdotV, preLightData.iblPerceptualRoughness, bsdfData.fresnel0, preLightData.specularFGD, preLightData.diffuseFGD, specularReflectivity);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_DIFFUSE_LAMBERT_BRDF</span><br>    preLightData.diffuseFGD = <span class="hljs-number">1.0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LIT_USE_GGX_ENERGY_COMPENSATION</span><br>    <span class="hljs-comment">// Ref: Practical multiple scattering compensation for microfacet models.</span><br>    <span class="hljs-comment">// We only apply the formulation for metals.</span><br>    <span class="hljs-comment">// For dielectrics, the change of reflectance is negligible.</span><br>    <span class="hljs-comment">// We deem the intensity difference of a couple of percent for high values of roughness</span><br>    <span class="hljs-comment">// to not be worth the cost of another precomputed table.</span><br>    <span class="hljs-comment">// Note: this formulation bakes the BSDF non-symmetric!</span><br>    preLightData.energyCompensation = <span class="hljs-number">1.0</span> / specularReflectivity - <span class="hljs-number">1.0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    preLightData.energyCompensation = <span class="hljs-number">0.0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// LIT_USE_GGX_ENERGY_COMPENSATION</span></span><br><br>    float3 iblN;<br><br>    <span class="hljs-comment">// We avoid divergent evaluation of the GGX, as that nearly doubles the cost.</span><br>    <span class="hljs-comment">// If the tile has anisotropy, all the pixels within the tile are evaluated as anisotropic.</span><br>    <span class="hljs-keyword">if</span> (HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_LIT_ANISOTROPY))<br>    &#123;<br>        <span class="hljs-type">float</span> TdotV = dot(bsdfData.tangentWS,   V);<br>        <span class="hljs-type">float</span> BdotV = dot(bsdfData.bitangentWS, V);<br><br>        preLightData.partLambdaV = GetSmithJointGGXAnisoPartLambdaV(TdotV, BdotV, NdotV, bsdfData.roughnessT, bsdfData.roughnessB);<br><br>        <span class="hljs-comment">// perceptualRoughness is use as input and output here</span><br>        GetGGXAnisotropicModifiedNormalAndRoughness(bsdfData.bitangentWS, bsdfData.tangentWS, N, V, bsdfData.anisotropy, preLightData.iblPerceptualRoughness, iblN, preLightData.iblPerceptualRoughness);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        preLightData.partLambdaV = GetSmithJointGGXPartLambdaV(NdotV, bsdfData.roughnessT);<br>        iblN = N;<br>    &#125;<br><br>    preLightData.iblR = reflect(-V, iblN);<br><br>    <span class="hljs-comment">// Area light</span><br>    <span class="hljs-comment">// UVs for sampling the LUTs</span><br>    <span class="hljs-type">float</span> theta = FastACosPos(NdotV); <span class="hljs-comment">// For Area light - UVs for sampling the LUTs</span><br>    float2 uv = Remap01ToHalfTexelCoord(float2(bsdfData.perceptualRoughness, theta * INV_HALF_PI), LTC_LUT_SIZE);<br><br>    <span class="hljs-comment">// Note we load the matrix transpose (avoid to have to transpose it in shader)</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_DIFFUSE_LAMBERT_BRDF</span><br>    preLightData.ltcTransformDiffuse = k_identity3x3;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-comment">// Get the inverse LTC matrix for Disney Diffuse</span><br>    preLightData.ltcTransformDiffuse      = <span class="hljs-number">0.0</span>;<br>    preLightData.ltcTransformDiffuse._m22 = <span class="hljs-number">1.0</span>;<br>    preLightData.ltcTransformDiffuse._m00_m02_m11_m20 = SAMPLE_TEXTURE2D_ARRAY_LOD(_LtcData, s_linear_clamp_sampler, uv, LTC_DISNEY_DIFFUSE_MATRIX_INDEX, <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// Get the inverse LTC matrix for GGX</span><br>    <span class="hljs-comment">// Note we load the matrix transpose (avoid to have to transpose it in shader)</span><br>    preLightData.ltcTransformSpecular      = <span class="hljs-number">0.0</span>;<br>    preLightData.ltcTransformSpecular._m22 = <span class="hljs-number">1.0</span>;<br>    preLightData.ltcTransformSpecular._m00_m02_m11_m20 = SAMPLE_TEXTURE2D_ARRAY_LOD(_LtcData, s_linear_clamp_sampler, uv, LTC_GGX_MATRIX_INDEX, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// Construct a right-handed view-dependent orthogonal basis around the normal</span><br>    preLightData.orthoBasisViewNormal = GetOrthoBasisViewNormal(V, N, preLightData.NdotV);<br><br>    preLightData.ltcTransformCoat = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">if</span> (HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_LIT_CLEAR_COAT))<br>    &#123;<br>        float2 uv = LTC_LUT_OFFSET + LTC_LUT_SCALE * float2(CLEAR_COAT_PERCEPTUAL_ROUGHNESS, theta * INV_HALF_PI);<br><br>        <span class="hljs-comment">// Get the inverse LTC matrix for GGX</span><br>        <span class="hljs-comment">// Note we load the matrix transpose (avoid to have to transpose it in shader)</span><br>        preLightData.ltcTransformCoat._m22 = <span class="hljs-number">1.0</span>;<br>        preLightData.ltcTransformCoat._m00_m02_m11_m20 = SAMPLE_TEXTURE2D_ARRAY_LOD(_LtcData, s_linear_clamp_sampler, uv, LTC_GGX_MATRIX_INDEX, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// refraction (forward only)</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> HAS_REFRACTION</span><br>    RefractionModelResult refraction = REFRACTION_MODEL(V, posInput, bsdfData);<br>    preLightData.transparentRefractV = refraction.rayWS;<br>    preLightData.transparentPositionWS = refraction.positionWS;<br>    preLightData.transparentTransmittance = <span class="hljs-built_in">exp</span>(-bsdfData.absorptionCoefficient * refraction.dist);<br>    <span class="hljs-comment">// Empirical remap to try to match a bit the refraction probe blurring for the fallback</span><br>    <span class="hljs-comment">// Use IblPerceptualRoughness so we can handle approx of clear coat.</span><br>    preLightData.transparentSSMipLevel = PositivePow(preLightData.iblPerceptualRoughness, <span class="hljs-number">1.3</span>) * uint(max(_ColorPyramidScale.z - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> preLightData;<br>&#125;<br></code></pre></td></tr></table></figure>


      
      <p align="right"><a class="morebtn" href="/2023/06/02/Unity/HDRPLightLoop/" title="Light Loop">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right" aria-label="下一页"></i></a>
  </nav>
  
  
  

<div class="comments" id="comments">
  
  
  
</div>



  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control"/>
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/avatar.jpg" alt="leinlin">
  
  <h1 class="author-name">leinlin</h1>
  <h2 class="author-description"></h2>
  <div class="site-count">
    
    
    
    
    <div class="categories-count count-block">
      <div class="site-count-title">分类</div>
      <div><a href="/categories/">20</a></div>
    </div>
    
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    <hr>
    <div class="social-link sidebar-item">
      <div><i class="far fa-address-card"></i>社交链接</p></div>
      <ul>
        
        <li><i class="fab fa-github"></i><a href="https://leinlin.github.com/" target="_blank">GitHub</a></li>
        
      </ul>
    </div>
    
    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <button id="back-to-top"><i class="fas fa-angle-double-up" aria-label="回到顶部"></i></button>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">leinlin</span><span class="year"><i class="far fa-copyright"></i>2023</span>
        </div>
        
        <div class="busuanzi">
          <span id="busuanzi_container_site_pv"><i class="fas fa-eye" aria-label="站点点击量" aria-hidden="false"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user" aria-label="站点用户数" aria-hidden="false"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv" aria-label="页面点击量" aria-hidden="false"></span></span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
