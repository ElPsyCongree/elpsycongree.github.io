<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ShaderModel与ES版本和GPU特性的关系</title>
      <link href="/2023/06/02/Shader/ShaderModel%E4%B8%8EES%E7%89%88%E6%9C%AC%E5%92%8CGPU%E7%89%B9%E6%80%A7%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2023/06/02/Shader/ShaderModel%E4%B8%8EES%E7%89%88%E6%9C%AC%E5%92%8CGPU%E7%89%B9%E6%80%A7%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="ShaderModel与ES版本和GPU特性的关系"><a href="#ShaderModel与ES版本和GPU特性的关系" class="headerlink" title="ShaderModel与ES版本和GPU特性的关系"></a>ShaderModel与ES版本和GPU特性的关系</h1><h2 id="Opengl版本和功能的对应"><a href="#Opengl版本和功能的对应" class="headerlink" title="Opengl版本和功能的对应"></a>Opengl版本和功能的对应</h2><p><a href="https://www.khronos.org/opengl/wiki/History_of_OpenGL">Opengl网站</a></p><h3 id="OpenGL-4-0-2010"><a href="#OpenGL-4-0-2010" class="headerlink" title="OpenGL 4.0 (2010)"></a>OpenGL 4.0 (2010)</h3><table><thead><tr><th align="center">Addition</th><th align="center"><a href="https://www.khronos.org/opengl/wiki/Extension#Core_Extensions">Core Extension</a></th></tr></thead><tbody><tr><td align="center">Shading language 4.00</td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/texture_query_lod.txt">ARB_texture_query_lod</a>, <a href="http://www.opengl.org/registry/specs/ARB/gpu_shader5.txt">ARB_gpu_shader5</a>, <a href="http://www.opengl.org/registry/specs/ARB/gpu_shader_fp64.txt">ARB_gpu_shader_fp64</a>, <a href="http://www.opengl.org/registry/specs/ARB/shader_subroutine.txt">ARB_shader_subroutine</a>, <a href="http://www.opengl.org/registry/specs/ARB/texture_gather.txt">ARB_texture_gather</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Indirect_Drawing">Indirect Drawing</a>, without multidraw</td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/draw_indirect.txt">ARB_draw_indirect</a></td></tr><tr><td align="center">Request minimum number of fragment inputs</td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/sample_shading.txt">ARB_sample_shading</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Tessellation">Tessellation</a>, with shader stages</td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/tessellation_shader.txt">ARB_tessellation_shader</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Buffer_Texture">Buffer Texture</a> formats RGB32F, RGB32I, RGB32UI</td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/texture_buffer_object_rgb32.txt">ARB_texture_buffer_object_rgb32</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Cubemap_Array_Texture">Cubemap Array Texture</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/texture_cube_map_array.txt">ARB_texture_cube_map_array</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Transform_Feedback">Transform Feedback</a> objects and multiple feedback stream output.</td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/transform_feedback2.txt">ARB_transform_feedback2</a>, <a href="http://www.opengl.org/registry/specs/ARB/transform_feedback3.txt">ARB_transform_feedback3</a></td></tr><tr><td align="center">Addition</td><td align="center">Promoted from</td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Draw_Buffer_Blend">Individual blend equations for each color output</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/draw_buffers_blend.txt">ARB_draw_buffers_blend</a></td></tr></tbody></table><h3 id="OpenGL-3-3-2010"><a href="#OpenGL-3-3-2010" class="headerlink" title="OpenGL 3.3 (2010)"></a>OpenGL 3.3 (2010)</h3><table><thead><tr><th align="center">Addition</th><th align="center"><a href="https://www.khronos.org/opengl/wiki/Extension#Core_Extensions">Core Extension</a></th></tr></thead><tbody><tr><td align="center">Shading language 3.30</td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/shader_bit_encoding.txt">ARB_shader_bit_encoding</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Dual_Source_Blending">Dual-source blending</a>.</td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/blend_func_extended.txt">ARB_blend_func_extended</a></td></tr><tr><td align="center">Shader-defined locations for <a href="https://www.khronos.org/opengl/wiki/Layout_Vertex_Attribute">attributes</a> and <a href="https://www.khronos.org/opengl/wiki/Layout_Fragment_Output">fragment shader outputs</a>.</td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/explicit_attrib_location.txt">ARB_explicit_attrib_location</a></td></tr><tr><td align="center">Simple boolean <a href="https://www.khronos.org/opengl/wiki/Occlusion_Query">Occlusion Query</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/occlusion_query2.txt">ARB_occlusion_query2</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Sampler_Object">Sampler Objects</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/sampler_objects.txt">ARB_sampler_objects</a></td></tr><tr><td align="center">A new <a href="https://www.khronos.org/opengl/wiki/Image_Format">image format</a> for unsigned 10.10.10.2 colors</td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/texture_rgb10_a2ui.txt">ARB_texture_rgb10_a2ui</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Texture_Swizzle">Texture swizzle</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/texture_swizzle.txt">ARB_texture_swizzle</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Timer_Query">Timer queries</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/timer_query.txt">ARB_timer_query</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Instanced_Array">Instanced arrays</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/instanced_arrays.txt">ARB_instanced_arrays</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Vertex_Format_Type">Vertex attributes 2.10.10.10</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/vertex_type_2_10_10_10_rev.txt">ARB_vertex_type_2_10_10_10_rev</a></td></tr></tbody></table><h3 id="OpenGL-3-2-2009"><a href="#OpenGL-3-2-2009" class="headerlink" title="OpenGL 3.2 (2009)"></a>OpenGL 3.2 (2009)</h3><ul><li>Core and compatibility profiles</li><li>Shading language 1.50</li></ul><table><thead><tr><th align="center">Addition</th><th align="center"><a href="https://www.khronos.org/opengl/wiki/Extension#Core_Extensions">Core Extension</a></th></tr></thead><tbody><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/D3D_Vertex_Format_Compatibility">D3D compatible color vertex component ordering</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/vertex_array_bgra.txt">ARB_vertex_array_bgra</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Draw_Base_Index">Drawing command allowing modification of the base vertex index</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/draw_elements_base_vertex.txt">ARB_draw_elements_base_vertex</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Fragment_Shader#System_inputs">Shader fragment coordinate convention control</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/fragment_coord_conventions.txt">ARB_fragment_coord_conventions</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Provoking_Vertex">Provoking vertex control</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/provoking_vertex.txt">ARB_provoking_vertex</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Seamless_Cubemap">Seamless cube map filtering</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/seamless_cube_map.txt">ARB_seamless_cube_map</a></td></tr><tr><td align="center">Multisampled textures and texture samplers for specific sample locations</td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/texture_multisample.txt">ARB_texture_multisample</a></td></tr><tr><td align="center">Fragment <a href="https://www.khronos.org/opengl/wiki/Depth_Clamp">Depth Clamping</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/depth_clamp.txt">ARB_depth_clamp</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Sync_Object">Fence sync objects</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/sync.txt">ARB_sync</a></td></tr><tr><td align="center">Addition</td><td align="center">Promoted from</td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Geometry_Shader">Geometry Shaders</a>, as well as input&#x2F;output <a href="https://www.khronos.org/opengl/wiki/Interface_Block">Interface Blocks</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/geometry_shader4.txt">ARB_geometry_shader4</a>, heavily modified.</td></tr></tbody></table><h3 id="OpenGL-3-1-2009"><a href="#OpenGL-3-1-2009" class="headerlink" title="OpenGL 3.1 (2009)"></a>OpenGL 3.1 (2009)</h3><ul><li>All features deprecated in OpenGL 3.0 are removed except wide lines</li><li>Shading language 1.40</li><li>SNORM texture component formats</li></ul><table><thead><tr><th align="center">Addition</th><th align="center"><a href="https://www.khronos.org/opengl/wiki/Extension#Core_Extensions">Core Extension</a></th></tr></thead><tbody><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object">Uniform Buffer Objects</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/uniform_buffer_object.txt">ARB_uniform_buffer_object</a></td></tr><tr><td align="center">Addition</td><td align="center">Promoted from</td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Instancing">Instanced rendering with a per instance counter accessible to vertex shaders</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/draw_instanced.txt">ARB_draw_instanced</a></td></tr><tr><td align="center">Data copying between buffer objects</td><td align="center"><a href="http://www.opengl.org/registry/specs/EXT/copy_buffer.txt">EXT_copy_buffer</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Primitive_restart">Primitive restart</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/NV/primitive_restart.txt">NV_primitive_restart</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Buffer_Texture">Buffer Textures</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/texture_buffer_object.txt">ARB_texture_buffer_object</a></td></tr><tr><td align="center"><a href="https://www.khronos.org/opengl/wiki/Rectangle_Texture">Rectangle Textures</a></td><td align="center"><a href="http://www.opengl.org/registry/specs/ARB/texture_rectangle.txt">ARB_texture_rectangle</a></td></tr></tbody></table><h2 id="Microsoft对ShaderModel的定义"><a href="#Microsoft对ShaderModel的定义" class="headerlink" title="Microsoft对ShaderModel的定义"></a>Microsoft对ShaderModel的定义</h2><p>HLSL的ShaderModel主要表示不同版本的Shader支持的语言、功能特性。（The HLSL shader model is a versioning approach indicating which new features are added to the language. </p><p>应用和游戏可以针对某个版本通用的功能进行开发，硬件和驱动工程师也可以针对这个版本的特性进行支持。</p><p>不同的ShaderModel版本：不同的处理阶段（Geometry etc）、约束、处理能力、向下兼容情况。</p><ul><li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509654(v=vs.85).aspx">Shader Model 1</a>. This was the first shader model created in DirectX. It introduced vertex and pixel shaders to the first implementation of the programmable pipeline.</li><li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509655(v=vs.85).aspx">Shader Model 2</a>. Adds new intrinsics and increases limits on registers and instructions.</li><li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509656(v=vs.85).aspx">Shader Model 3</a>. Adds new intrinsics and increases limits on registers and instructions.</li><li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509657(v=vs.85).aspx">Shader Model 4</a>. This is a superset of the capabilities in Shader Model 3, except that Shader Model 4 doesn’t support the features in Shader Model 1. It has been designed using a common-shader core that gives a common set of features to all programmable shaders, which are only programmable using HLSL. It adds new shader profiles to target geometry shaders.</li><li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471356(v=vs.85).aspx">Shader Model 5</a>. This is a superset of shader model 4 and adds new resources, compute shaders and tessellation.</li><li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn933277(v=vs.85).aspx">Shader Model 5.1</a>. This is functionally very similar to Shader Model 5; the main change is more flexibility in resource selection by allowing indexing of arrays of descriptors from within a shader.</li><li><a href="https://github.com/microsoft/DirectXShaderCompiler/wiki/Shader-Model-6.0">Shader Model 6.0</a>. This is a superset of shader model 5.1 with some deprecated language elements and with the addition of wave intrinsics and 64-bit integers for arithmetic.</li><li><a href="https://github.com/microsoft/DirectXShaderCompiler/wiki/Shader-Model-6.1">Shader Model 6.1</a>. This is a superset of shader model 6.0 that adds support for SV_ViewID, barycentric semantics and the GetAttributeAtVertex intrinsic.</li><li><a href="https://github.com/microsoft/DirectXShaderCompiler/wiki/Shader-Model-6.2">Shader Model 6.2</a>. Adds support for float16 (as opposed to minfloat16) and denorm mode selection.</li><li><a href="https://github.com/microsoft/DirectXShaderCompiler/wiki/Shader-Model-6.3">Shader Model 6.3</a>. Adds support for DirectX Raytracing (DXR), including libraries and linking.</li><li><a href="https://github.com/microsoft/DirectXShaderCompiler/wiki/Shader-Model-6.4">Shader Model 6.4</a>. Adds low-precision packed dot product intrinsics, and support for library sub-objects to simplify raytracing.</li></ul><p>Differences between Direct3D 9 and Direct3D 10:<br>Direct3D 9 introduced shader models 1, 2, and 3.<br>Direct3D 10 introduced shader model 4.<br>Direct3D 10.1 introduced shader model 4.1.</p><h2 id="Unity对不同版本的定义"><a href="#Unity对不同版本的定义" class="headerlink" title="Unity对不同版本的定义"></a>Unity对不同版本的定义</h2><p><a href="https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html">https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html</a></p><p>Here is the list of shader models supported, with roughly increasing set of capabilities (and in some cases higher platform&#x2F;GPU requirements):</p><h4 id="pragma-target-2-0"><a href="#pragma-target-2-0" class="headerlink" title="#pragma target 2.0"></a>#pragma target 2.0</h4><ul><li>Works on all platforms supported by Unity. DX9 shader model 2.0.</li><li>Limited amount of arithmetic &amp; texture instructions; 8 interpolators; no vertex texture sampling; no derivatives in <strong>fragment shaders</strong><br>; no explicit <strong>LOD</strong><br> texture sampling.</li></ul><h4 id="pragma-target-2-5-default"><a href="#pragma-target-2-5-default" class="headerlink" title="#pragma target 2.5 (default)"></a>#pragma target 2.5 (default)</h4><ul><li>Almost the same as 3.0 target (see below), except still only has 8 interpolators, and does not have explicit LOD texture sampling.</li><li>Compiles into DX11 feature level 9.3 on Windows Phone.</li></ul><h4 id="pragma-target-3-0"><a href="#pragma-target-3-0" class="headerlink" title="#pragma target 3.0"></a>#pragma target 3.0</h4><ul><li>DX9 shader model 3.0: derivative instructions, texture LOD sampling, 10 interpolators, more math&#x2F;texture instructions allowed.</li><li>Not supported on DX11 feature level 9.x GPUs (e.g. most Windows Phone devices).</li><li>Might not be fully supported by some OpenGL ES 2.0 devices, depending on driver extensions present and features used.</li></ul><h4 id="pragma-target-3-5-or-es3-0"><a href="#pragma-target-3-5-or-es3-0" class="headerlink" title="#pragma target 3.5 (or es3.0)"></a>#pragma target 3.5 (or es3.0)</h4><ul><li>OpenGL ES 3.0 capabilities (DX10 SM4.0 on D3D platforms, just without geometry shaders).</li><li>Not supported on DX11 9.x (WinPhone), OpenGL ES 2.0.</li><li>Supported on DX11+, OpenGL 3.2+, OpenGL ES 3+, Metal, Vulkan, PS4&#x2F;XB1 consoles.</li><li>Native integer operations in shaders, texture arrays and so on.</li></ul><h4 id="pragma-target-4-0"><a href="#pragma-target-4-0" class="headerlink" title="#pragma target 4.0"></a>#pragma target 4.0</h4><ul><li>DX11 shader model 4.0.</li><li>Not supported on DX11 9.x (WinPhone), OpenGL ES 2.0&#x2F;3.0&#x2F;3.1, Metal.</li><li>Supported on DX11+, OpenGL 3.2+, OpenGL ES 3.1+AEP, Vulkan, PS4&#x2F;XB1 consoles.</li><li>Has geometry shaders and everything that <code>es3.0</code> target has.</li></ul><h4 id="pragma-target-4-5-or-es3-1"><a href="#pragma-target-4-5-or-es3-1" class="headerlink" title="#pragma target 4.5 (or es3.1)"></a>#pragma target 4.5 (or es3.1)</h4><ul><li>OpenGL ES 3.1 capabilities (DX11 SM5.0 on D3D platforms, just without tessellation shaders).</li><li>Not supported on DX11 before SM5.0, OpenGL before 4.3 (i.e. Mac), OpenGL ES 2.0&#x2F;3.0.</li><li>Supported on DX11+ SM5.0, OpenGL 4.3+, OpenGL ES 3.1, Metal, Vulkan, PS4&#x2F;XB1 consoles.</li><li>Has compute shaders, random access texture writes, atomics and so on. No geometry or tessellation shaders.</li></ul><h4 id="pragma-target-4-6-or-gl4-1"><a href="#pragma-target-4-6-or-gl4-1" class="headerlink" title="#pragma target 4.6 (or gl4.1)"></a>#pragma target 4.6 (or gl4.1)</h4><ul><li>OpenGL 4.1 capabilities (DX11 SM5.0 on D3D platforms, just without compute shaders). This is basically the highest OpenGL level supported by Macs.</li><li>Not supported on DX11 before SM5.0, OpenGL before 4.1, OpenGL ES 2.0&#x2F;3.0&#x2F;3.1, Metal.</li><li>Supported on DX11+ SM5.0, OpenGL 4.1+, OpenGL ES 3.1+AEP, Vulkan, Metal (without geometry), PS4&#x2F;XB1 consoles.</li></ul><h4 id="pragma-target-5-0"><a href="#pragma-target-5-0" class="headerlink" title="#pragma target 5.0"></a>#pragma target 5.0</h4><ul><li>DX11 shader model 5.0.</li><li>Not supported on DX11 before SM5.0, OpenGL before 4.3 (i.e. Mac), OpenGL ES 2.0&#x2F;3.0&#x2F;3.1, Metal.</li><li>Supported on DX11+ SM5.0, OpenGL 4.3+, OpenGL ES 3.1+AEP, Vulkan, Metal (without geometry), PS4&#x2F;XB1 consoles.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shader函数重载问题</title>
      <link href="/2023/06/02/Shader/Shader%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2023/06/02/Shader/Shader%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Shader函数重载问题"><a href="#Shader函数重载问题" class="headerlink" title="Shader函数重载问题"></a>Shader函数重载问题</h1><p>目前在编写shader的时候发现：</p><p>Shader函数可以重载（和c++一样的OverLoad）</p><p>GLSL的说明：</p><p><a href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)">https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)</a></p><p>Metal的说明：</p><p><a href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf">https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf</a></p><p>但是发现重载函数互相调用会失败。</p><p>目前没有查到具体文献，和那些平台有限制。</p><p>在几个地方进行了实验：</p><p>ShaderToy（Glsl），是正常的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">vec4 <span class="hljs-title function_">contrast</span><span class="hljs-params">(vec4 col, <span class="hljs-type">float</span> x,<span class="hljs-type">float</span> y)</span> &#123;<br><span class="hljs-keyword">return</span> x * (col - <span class="hljs-number">0.5</span>) + <span class="hljs-number">0.5</span>+y;<br>&#125;<br><br>vec4 <span class="hljs-title function_">contrast</span><span class="hljs-params">(vec4 col, <span class="hljs-type">float</span> x)</span> &#123;<br>    <span class="hljs-keyword">return</span> contrast( col,  x,<span class="hljs-number">110.0f</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Valkun，是正常的：</p><p><img src="/../../images/Shader%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/1574822744053.png" alt="1574822744053"></p><p>目前没有Metal的测试环境。</p>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不同图形API矩阵行列主序及其影响</title>
      <link href="/2023/06/02/Shader/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E7%9F%A9%E9%98%B5%E8%A1%8C%E5%88%97%E4%B8%BB%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%BD%B1%E5%93%8D/"/>
      <url>/2023/06/02/Shader/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E7%9F%A9%E9%98%B5%E8%A1%8C%E5%88%97%E4%B8%BB%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%BD%B1%E5%93%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="不同图形API矩阵行列主序及其影响"><a href="#不同图形API矩阵行列主序及其影响" class="headerlink" title="不同图形API矩阵行列主序及其影响"></a>不同图形API矩阵行列主序及其影响</h1><p>矩阵的行主序和列主序影响了空间变换是矩阵乘法的使用方式。</p><p>Opengl的矩阵使用列主序，(参考资料](<a href="https://www.khronos.org/opengl/wiki/Data_Type_(GLSL))%E3%80%82">https://www.khronos.org/opengl/wiki/Data_Type_(GLSL))。</a></p><ul><li>mat<em>n</em>x<em>m</em>: A matrix with <em>n</em> columns and <em>m</em> rows. OpenGL uses column-major matrices, which is standard for mathematics users. Example: mat3x4.</li><li>mat<em>n</em>: A matrix with <em>n</em> columns and <em>n</em> rows. Shorthand for mat<em>n</em>x<em>n</em></li></ul><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">mat3 theMatrix;<br>theMatrix[<span class="hljs-number">1</span>] = vec3(<span class="hljs-number">3.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">3.0</span>); <span class="hljs-comment">// Sets the second column to all 3.0s</span><br>theMatrix[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">16.0</span>; <span class="hljs-comment">// Sets the first entry of the third column to 16.0.</span><br></code></pre></td></tr></table></figure><p>D3D使用的是行主序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">matrix &lt;<span class="hljs-type">float</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&gt; fMatrix = &#123; <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.1</span>, <span class="hljs-comment">// row 1</span><br>                                 <span class="hljs-number">2.1f</span>, <span class="hljs-number">2.2f</span> <span class="hljs-comment">// row 2</span><br>                               &#125;;<br></code></pre></td></tr></table></figure><p>具体使用矩阵时，要注意CPU端buffer的定义方式和矩阵乘法统一即可。</p><p>使用不同的图形API时，CPU设置Buffer：</p><p>假如View矩阵在CPU端是行主序，直接Copy到Buffer，那么D3D是正常的，但是Opengl就变成了列主序。此时，View空间变换：D3D需要进行mul（V,vector）,Opengl就是需要mul（vector，V）。</p><p>使用不同的图形API时，Shader当中构造矩阵：</p><p>需要注意opengl的m01,指的是第一列第二行。</p>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GPU浮点数的精确度以及注意事项</title>
      <link href="/2023/06/02/Shader/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/"/>
      <url>/2023/06/02/Shader/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><p>- <a href="#gpu%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6%E4%BB%A5%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">GPU浮点数的精确度以及注意事项</a></p><p>​    - <a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8">浮点数的作用</a></p><p>​    - <a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9B%9E%E9%A1%BE">浮点数回顾</a></p><p>​    - <a href="#%E6%A0%87%E5%87%86%E5%92%8C%E4%BD%8E%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0">标准和低精度浮点数</a></p><p>​    - <a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%8C%83%E5%9B%B4%E8%A7%A3%E9%87%8A">浮点数范围解释</a></p><p>​    - <a href="#%E4%BD%8E%E7%B2%BE%E5%BA%A6%E5%B0%BE%E6%95%B0%E4%BD%8D%E9%97%AE%E9%A2%98%E4%B8%BE%E4%BE%8B">低精度尾数位问题举例</a></p><p>​    - <a href="#%E4%BD%8E%E7%B2%BE%E5%BA%A6%E5%B0%BE%E6%95%B0%E4%BD%8D%E9%97%AE%E9%A2%98%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%A4%BA">低精度尾数位问题可视化展示</a></p><p>​    - <a href="#%E4%BD%8E%E7%B2%BE%E5%BA%A6%E4%B8%8D%E5%9D%87%E5%8C%80%E5%B0%BE%E6%95%B0%E4%BD%8D%E9%95%BF%E5%BA%A6%E9%97%AE%E9%A2%98">低精度不均匀尾数位长度问题</a></p><p>​    - <a href="#%E9%A2%9C%E8%89%B2%E7%BC%A9%E6%94%BE%E5%A4%B1%E6%95%88">颜色缩放失效</a></p><!-- /TOC --><h1 id="GPU浮点数的精确度以及注意事项"><a href="#GPU浮点数的精确度以及注意事项" class="headerlink" title="GPU浮点数的精确度以及注意事项"></a>GPU浮点数的精确度以及注意事项</h1><p>​在hdr的开发流程中，pbr的灯光计算结果和特效的亮度理论上是没有上限，但是需要保存到Color Buffer当中，这就涉及到Color Buffer的数据精度，通常Color Buffer的格式是R11G11B10F。所以需要进行Min操作，来保证保存到RT当中的数据没有溢出，因为计算的精度通常是half或者float要比保存的精确度高。所以会有一些问题，下面找到了资料来讨论Float精确度相关的问题。</p><p>​内容主要摘录一部分自：<a href="https://bartwronski.com/2017/04/02/small-float-formats-r11g11b10f-precision/">参考链接</a>，并作了补充和例子说明，本文主要为了说明Color Buffer浮点数范围问题，原文对误差部分做了更详细的讨论。</p><h2 id="浮点数的作用"><a href="#浮点数的作用" class="headerlink" title="浮点数的作用"></a>浮点数的作用</h2><p>通常颜色在渲染中的表示不是整型，而是浮点数。浮点数有很大的浮动范围可以用于：</p><ul><li>编码HDR的颜色和记录光照。</li><li>当操作多个颜色的混合滤波需要分数。</li><li>在黑暗区域不通过Gamma编码也可以表示更大的精确度。</li><li>需要量化边界相对误差</li><li>浮点数是GPU的自然表示（GPU很长一段时间没有整数的支持，并且用浮点数模拟，并且现在整数的操作比浮点数慢）。</li></ul><p>​即便浮点数十分重要，但是我们很少存储32bit的浮点数值，即便是HDR的颜色。因为内存带宽和性能两部分的限制。内存带宽和缓存通常是重要的资源，最基础的经验法则是： “ALU is cheap, memory access is expensive”。即便是最简单的内存访问操作也需要上百个时钟周期的延迟。并且纹理单元的开销更高，应为需要滤波等开销很高的操作。</p><p>​因此，渲染程序员通常使用低精度的浮点数格式来保存浮点数。两个最常用的是RGBA16F(4通道的16bit的单精度浮点数)和R11G11B10F（R和G通道使用11bit，B通道使用10bit）。</p><p>​下面先分析IEEE的32bit浮点数和上述浮点数格式的区别：</p><h2 id="浮点数回顾"><a href="#浮点数回顾" class="headerlink" title="浮点数回顾"></a>浮点数回顾</h2><p>​浮点数的表示方式：</p><ul><li><p>符号位<strong>sign</strong>：一个bit用来表示符号位。在数据最前面的一个bit，可选。</p></li><li><p>指数位<strong>exponent</strong>：多个Bit用来表示2的指数幂和剩余的数相乘，<strong>阶码是有偏移的，单精度偏移是127（0000001 表示 -126 11111110 表示127 而全0和全1有特殊用处），双精度是1024。 11bit和10bit 指数位5位偏移应该是15</strong></p></li><li><p>尾数位<strong>mantissa</strong>：多个bit用来表示数据的表示小数部分，和指数位结果相乘，通常假设小数点前整数位是1（<strong>这个是IEEE 754标准，其他标准也可能会约定小点后第一位始终是1</strong>）。例如：如果尾数位是01011000 ，那么他表示的数是：1.01011000</p><p>所以最终表示是数是：</p></li></ul><p>$$ sign(\pm 1)*2^{decoded exponent} *1.mantissa  $$</p><p>​<strong>参见对指数位的说明，对很多特殊的编码，指数位使用了特殊的值。这里只讨论一个：0的编码，通过将指数和尾数都设置成0，由于符号位可以设置，所以会存在两个0 （+0 和-0）。</strong></p><p>​浮点数是一种非常聪明的表示法，它具有许多很好的属性（例如，正浮点数可以解释为整数可以直观的排序或计算最小&#x2F;最大，并且整数0对应于正的浮点数0）。然而，伴随而来的是许多精度问题，这些问题并不总是最直观的。下面来谈论这些问题。</p><h2 id="标准和低精度浮点数"><a href="#标准和低精度浮点数" class="headerlink" title="标准和低精度浮点数"></a>标准和低精度浮点数</h2><p>​下面是常用的浮点数格式和编码方式。</p><table><thead><tr><th><strong>Bit depth</strong></th><th><strong>Sign bit present?</strong></th><th><strong>Exponent bits</strong></th><th><strong>Mantissa bits</strong></th></tr></thead><tbody><tr><td>32</td><td>Yes</td><td>8</td><td>23</td></tr><tr><td>16</td><td>Yes</td><td>5</td><td>10</td></tr><tr><td>11</td><td>No</td><td>5</td><td>6</td></tr><tr><td>10</td><td>No</td><td>5</td><td>5</td></tr></tbody></table><p>​可以发现一些规律：</p><ul><li>11和10位的浮点数没有符号位，主要是由于本身精确度并不高，并且通常被图形API用作保存颜色的格式，所以没有必要使用符号位。</li><li><strong>16bit的half类型和11bit、10bit有相同的指数位。但是有符号位，整数和负数有相同的范围。5位的指数位可以保证最大到64500到65500之间（见下方解释）</strong></li></ul><h2 id="浮点数范围解释"><a href="#浮点数范围解释" class="headerlink" title="浮点数范围解释"></a>浮点数范围解释</h2><p>​<strong>这里主要讨论16bit、11bit和10bit的浮点数上限，因为32bit的浮点数完成光照计算之后要进行Min操作，然后才能保存到RT当中，所以Min的操作数十分关键。</strong></p><p>​由于这三个类型的指数位都相同，所以上限依赖于<strong>尾数位的数量</strong>：</p><ul><li><p>16位的float，尾数最大可以表示1.1111111111 ，十进制为1.9990234375；5位指数位，计算偏移15，那么最大可以表示11110 &#x3D;15，指数部分就是32768，最大的数就是32768*1.9990234375，约为65,504。</p></li><li><p>11bit的浮点数，尾数最大可以表示1.111111，十进制为1.984375；5位指数位，计算偏移15，那么最大可以表示11110 &#x3D;15，指数部分就是32768，最大数就是32768*1.984375&#x3D; 65,024  。</p></li><li><p>10bit的浮点数，尾数最大可以表示1.11111，十进制为1.96875；5位指数位，计算偏移15，那么最大可以表示11110 &#x3D;15，指数部分就是32768，最大为32768*1.96875&#x3D;64,512‬）</p></li></ul><p><strong>综上所述在保存数据的时候如果不清楚引擎当中如何设置hdr Color buffer类型，Min的上限设置成64500是最安全的。</strong></p><h2 id="低精度尾数位问题举例"><a href="#低精度尾数位问题举例" class="headerlink" title="低精度尾数位问题举例"></a>低精度尾数位问题举例</h2><p>首先看一个用8位整数表示0-1的例子：</p><p>N[252&#x2F;255, 8] &#x3D;  0.98823529</p><p>N[253&#x2F;255, 8] &#x3D;  0.99215686</p><p>N[254&#x2F;255, 8] &#x3D;  0.99607843</p><p>接下来用二进制小数表示他们：</p><p>BaseForm[N[2*252&#x2F;255, 8], 2] &#x3D; 1.<strong>11111</strong>00111111001111110100</p><p>BaseForm[N[2*253&#x2F;255, 8], 2] &#x3D; 1.<strong>11111</strong>01111111011111111000</p><p>BaseForm[N[2*254&#x2F;255, 8], 2] &#x3D; 1.<strong>11111</strong>10111111101111111100</p><p>​我高亮了前五位小数位。我们知道10bit的浮点数只有5bit的尾数位，可以发现10bit的浮点数甚至不能精确地表示8bit整型颜色（因为5bit尾数不足以区分这三个颜色，<strong>主要原因有效位太短</strong>）。于此同时，你能够看到下一位是不同的，因此在11bit的浮点数中可以被区分出来，这就会造成白色的错误表示。</p><h2 id="低精度尾数位问题可视化展示"><a href="#低精度尾数位问题可视化展示" class="headerlink" title="低精度尾数位问题可视化展示"></a>低精度尾数位问题可视化展示</h2><p>好的，我们知道低位数的浮点数甚至不能准确地表示简单的8位亮度。但是会差到什么程度呢？</p><p>我们创建了尾数位的可视化效果。</p><p><img src="/../../images/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/10bit_floatvs8bit_linear.png" alt="10bit_floatvs8bit_linear.png"></p><p>随着数值增大误差也快速增加。</p><p>我们通常不使用8bit的线性值保存颜色， 因为为了节省精度，保存人眼更敏感的部分（暗部），所以用Gamma。下面是考虑了Gamma编码的误差结果。</p><p><img src="/../../images/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/10bit_floatvs8bit_srgb.png" alt="10bit_floatvs8bit_srgb.png"></p><p>​<strong>这部分主要展示了不同的数据有效位对于颜色误差的影响。为什么随着数据变大误差会变大？因为数据越大需要的有效位数越多，但是可用的有效位又是固定的，所以会呈现上面的效果。</strong></p><h2 id="低精度不均匀尾数位长度问题"><a href="#低精度不均匀尾数位长度问题" class="headerlink" title="低精度不均匀尾数位长度问题"></a>低精度不均匀尾数位长度问题</h2><p>由于R11G11B10类型的浮点数有不均的尾数，我们量化他们的区别。</p><p><img src="/../../images/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/11bit_float_vs_10bit_float.png" alt="11bit_float_vs_10bit_float.png"></p><p>数值越大误差越大。</p><p><img src="/../../images/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/11bit_float_vs_10bit_float_smallerrange.png" alt="11bit_float_vs_10bit_float_smallerrange.png"></p><p>这种误差意味着什么？下面是从0.5到0.6的颜色变化，产生了错误的饱和度。</p><p><img src="/../../images/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/gradient_quantized.png" alt="gradient_quantized.png"></p><p>如何显示器好，这个效果会更加明显，例如hdr显示器有更加精确的显示范围和色域，可以看到：</p><p><img src="/../../images/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/gradient_quantized_contrast.png" alt="gradient_quantized_contrast.png"></p><p><strong>可以通过改变颜色动态范围和dithering来修正这样的效果。</strong></p><h2 id="颜色缩放失效"><a href="#颜色缩放失效" class="headerlink" title="颜色缩放失效"></a>颜色缩放失效</h2><p>​有一个常见的错误关键，乘上一个大数就可以对浮点数进行编码提升精确度，然后解码。这是无效的。下面是量化数据：</p><p><img src="/../../images/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/8bitsrgb_vs_10float_relative_vs_premultiplied.png" alt="8bitsrgb_vs_10float_relative_vs_premultiplied.png"></p><p>​<strong>可以看到没有区别，这是因为有效位数没有变化，所以表示的精度也没有变化。也就是说尾数位没有变化，变化的只有指数位。</strong></p><p>​我们可以设置不同的缩放值看看误差，误差也只是左右移动了：</p><p><img src="/../../images/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6/8bitsrgb_vs_10float_relative_vs_premultiplied_smaller.png" alt="8bitsrgb_vs_10float_relative_vs_premultiplied_smaller.png"></p>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在Unity渲染当中使用SDF</title>
      <link href="/2023/06/02/UnityEffect/%E5%9C%A8Polygon%E6%B8%B2%E6%9F%93%E5%BD%93%E4%B8%AD%E4%BD%BF%E7%94%A8SDF%E6%95%88%E6%9E%9C/"/>
      <url>/2023/06/02/UnityEffect/%E5%9C%A8Polygon%E6%B8%B2%E6%9F%93%E5%BD%93%E4%B8%AD%E4%BD%BF%E7%94%A8SDF%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="在Unity渲染当中使用SDF"><a href="#在Unity渲染当中使用SDF" class="headerlink" title="在Unity渲染当中使用SDF"></a>在Unity渲染当中使用SDF</h1><p>SDF通常是在光线追踪场景当中使用，不过最近尝试在unity当中使用这个技术。</p><p>尝试的出发点就是：宇宙魔方。</p><p><img src="/../../images/img/81a5d8936ced30636c3cf43e532234e3174375fd.jpg" alt="81a5d8936ced30636c3cf43e532234e3174375fd"></p><p>他的效果就是正方体内部有一个可以看得到的球体。</p><p>最简单的思路就是：使用一个透明的正方体，内部放一个自发光的球体。他的问题在于如果大量使用可能会提升overdraw和drawcall。如果想做扭曲和折射更是需要一个额外的grabpass或者别的渲染流程。如果遇到不透明的水晶，但是内部有自发光物质时。如何控制不透明物质漏出内部的自发光球体是很大的问题。</p><p>所以，我尝试了SDF，结果如下：</p><p><img src="/../../images/img/2019623-134856.jpg" alt="2019623-134856"></p><p>我们可以看到，同一个材质可以应用到任何模型上，并且他们都是不透明物体，可以有自己的材质同时还能维持内部自发光效果。同时由于光线经过不同的表面产生的折射效果也很容易就可以实现。</p><p>实现方式就是以物体表面为起点，沿视线方向（用法线扰动视线方向来模拟折射）进行SDF渲染，由于只有一个球体所以速度非常快。</p><p>他的扩展就是可以使用不同的SDF函数来生成不同的基础图形。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>修改UnityHDRP管线来实现怪物猎人世界中宠物毛发效果</title>
      <link href="/2023/06/02/UnityEffect/%E4%BF%AE%E6%94%B9UnityHDRP%E7%AE%A1%E7%BA%BF%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%80%AA%E7%89%A9%E7%8C%8E%E4%BA%BA%E4%B8%96%E7%95%8C%E4%B8%AD%E5%AE%A0%E7%89%A9%E6%AF%9B%E5%8F%91%E6%95%88%E6%9E%9C/"/>
      <url>/2023/06/02/UnityEffect/%E4%BF%AE%E6%94%B9UnityHDRP%E7%AE%A1%E7%BA%BF%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%80%AA%E7%89%A9%E7%8C%8E%E4%BA%BA%E4%B8%96%E7%95%8C%E4%B8%AD%E5%AE%A0%E7%89%A9%E6%AF%9B%E5%8F%91%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="修改UnityHDRP管线来实现怪物猎人世界中宠物毛发效果"><a href="#修改UnityHDRP管线来实现怪物猎人世界中宠物毛发效果" class="headerlink" title="修改UnityHDRP管线来实现怪物猎人世界中宠物毛发效果"></a>修改UnityHDRP管线来实现怪物猎人世界中宠物毛发效果</h1><p>这里主要是以怪物猎人宠物毛发为例，介绍如何从美术需求分析开始，进行引擎修改工作。</p><p>后边的内容重点介绍对于管线的修改方法，而具体的模糊算法和参数不做详细说明。</p><h2 id="毛发实现分析"><a href="#毛发实现分析" class="headerlink" title="毛发实现分析"></a>毛发实现分析</h2><p>参考内容、需求只有下面的ppt： </p><p><img src="/../../images/img/2019620-161347.jpg" alt="2019620-161347"></p><p><img src="/../../images/img/2019620-161423.jpg" alt="2019620-161423"></p><p>对其分析的结果：计算一张运动模糊的数据。对接结果进行模糊。</p><ol start="0"><li><p>需要<strong>一张模糊走向图</strong>（毛发的走向）和<strong>一张黑色的噪点图</strong>（毛发的疏密、阴影）。</p></li><li><p>运动模糊不变，改变黑色噪点的tiling值可以改变他的毛发密度。</p></li><li><p>需要一个运动模糊的采样次数，控制毛发的精细度。</p></li><li><p>需要一个运动模糊的距离控制毛发长度。</p></li></ol><p>所以需求分析的结果就是一套类似运动模糊的实现方案。后面介绍如何修改管线来实现这一套方案。</p><h2 id="HDRP实现方案"><a href="#HDRP实现方案" class="headerlink" title="HDRP实现方案"></a>HDRP实现方案</h2><h3 id="HDRP-render当中添加渲染毛发走向"><a href="#HDRP-render当中添加渲染毛发走向" class="headerlink" title="HDRP render当中添加渲染毛发走向"></a>HDRP render当中添加渲染毛发走向</h3><p>首先在HDRP当中考虑添加一个专门绘制毛发的pass，类似MotionVector Pass。下面的代码需要添加到HDRenderPipeline.cs当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">RenderObjectsFurVectors</span><span class="hljs-params">(CullingResults cullResults, HDCamera hdCamera, ScriptableRenderContext renderContext, CommandBuffer cmd)</span><br>&#123;<br>    using (new ProfilingSample(cmd, <span class="hljs-string">&quot;Objects Fur Vectors Rendering&quot;</span>, CustomSamplerId.ObjectsMotionVector.GetSampler()))<br>    &#123;<br>        <span class="hljs-comment">// 需要清理FurVectorbuffer</span><br>        HDUtils.SetRenderTarget(cmd, hdCamera, m_SharedRTManager.GetFurVectorsPassBuffersRTI(hdCamera.frameSettings), m_SharedRTManager.GetDepthStencilBuffer(), ClearFlag.Color, Color.clear);<br>        HDUtils.SetRenderTarget(cmd, hdCamera, m_SharedRTManager.GetFurVectorsPassBuffersRTI(hdCamera.frameSettings), m_SharedRTManager.GetDepthStencilBuffer(hdCamera.frameSettings.IsEnabled(FrameSettingsField.MSAA)));<br>        RenderOpaqueRenderList(cullResults, hdCamera, renderContext, cmd, HDShaderPassNames.s_FurVectorsName, PerObjectData.None);<br>    &#125;<br>&#125;<br><br>... ...<br>    <br><span class="hljs-comment">// 在正确的位置插入要渲染的内容</span><br><span class="hljs-keyword">if</span> (shouldRenderMotionVectorAfterGBuffer)<br>&#123;<br>    <span class="hljs-comment">// See the call RenderObjectsMotionVectors() above and comment</span><br>    RenderObjectsMotionVectors(cullingResults, hdCamera, renderContext, cmd);<br>&#125;<br>RenderObjectsFurVectors(cullingResults, hdCamera, renderContext, cmd); <span class="hljs-comment">// ++++++</span><br></code></pre></td></tr></table></figure><p>加入记录渲染毛发走向的RT，在文件SharedRTManager.cs当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c">RTHandleSystem.RTHandle m_NormalRT = null;<br>RTHandleSystem.RTHandle m_FurVectorsRT = null; <span class="hljs-comment">//+++++++++</span><br>RTHandleSystem.RTHandle m_MotionVectorsRT = null;<br><br>... ...<br>    <br><span class="hljs-keyword">if</span> (m_MotionVectorsSupport)<br>&#123;<br>    ... ...<br>&#125;<br>m_FurVectorsRT = RTHandles.Alloc(Vector2.one, filterMode: FilterMode.Point, colorFormat: Builtin.GetMotionVectorFormat(), xrInstancing: <span class="hljs-literal">true</span>, useDynamicScale: <span class="hljs-literal">true</span>, name: <span class="hljs-string">&quot;FurVectors&quot;</span>);   <span class="hljs-comment">//+++++++++</span><br><br>... ...<br>    <br><span class="hljs-keyword">if</span> (m_MotionVectorsSupport)<br>&#123;<br>    RTHandles.Release(m_MotionVectorsRT);<br>    <span class="hljs-keyword">if</span> (m_MSAASupported)<br>    &#123;<br>        RTHandles.Release(m_MotionVectorsMSAART);<br>    &#125;<br>&#125;<br><br>RTHandles.Release(m_FurVectorsRT);  <span class="hljs-comment">//+++++++++</span><br><br>... ...<br>    <br>public RenderTargetIdentifier[] GetFurVectorsPassBuffersRTI(FrameSettings frameSettings)<br>&#123;<br>    m_RTIDs1[<span class="hljs-number">0</span>] = m_FurVectorsRT.nameID;<br>    <span class="hljs-keyword">return</span> m_RTIDs1;<br>&#125;<br></code></pre></td></tr></table></figure><p>加入毛发渲染pass name, 在文件HDStringConstant.cs当中:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-type">static</span> readonly <span class="hljs-built_in">string</span> s_MotionVectorsStr = <span class="hljs-string">&quot;MotionVectors&quot;</span>;<br>public <span class="hljs-type">static</span> readonly <span class="hljs-built_in">string</span> s_FurVectorsStr = <span class="hljs-string">&quot;FurVectors&quot;</span>; <span class="hljs-comment">//+++++++++</span><br>... ...<br><br>public <span class="hljs-type">static</span> readonly ShaderTagId s_MotionVectorsName = new ShaderTagId(s_MotionVectorsStr);<br>public <span class="hljs-type">static</span> readonly ShaderTagId s_FurVectorsName = new ShaderTagId(s_FurVectorsStr);   <span class="hljs-comment">//+++++++++</span><br></code></pre></td></tr></table></figure><h3 id="添加渲染毛发走向的Shader"><a href="#添加渲染毛发走向的Shader" class="headerlink" title="添加渲染毛发走向的Shader"></a>添加渲染毛发走向的Shader</h3><p>因为毛发走向只需要一个向量，这里用最简单的Pass制作。</p><p>需要加的就只是一个 LightMode&#x3D;FurVectors的pass</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">Pass&#123;<br>    Name <span class="hljs-string">&quot;FurVectors&quot;</span><br>    Tags &#123;<span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;FurVectors&quot;</span>&#125;  <span class="hljs-comment">// RenderPipeline通过LightMode来识别要渲染的pass</span><br><br>    Blend One Zero, One Zero<br>    Cull Back<br>    ZTest LEqual<br>ZWrite On<br>HLSLPROGRAM<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> target 4.5</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> only_renderers d3d11 ps4 xboxone vulkan metal switch</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile_instancing</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex Vert</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment Frag</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl&quot;</span></span><br><br>    <span class="hljs-keyword">struct</span> AttributesMesh<br>    &#123;<br>        float3 positionOS   : POSITION;<br>        float3 normalOS     : NORMAL;<br>        float2 uv0          : TEXCOORD0;<br>        UNITY_VERTEX_INPUT_INSTANCE_ID<br>    &#125;;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span></span><br><span class="hljs-class">    &#123;</span><br>        float4 position:SV_Position;<br>        float2 uv:TEXCOORD0;<br>        float3 furRootCS: TEXCOORD1;<br>        float3 furTailCS: TEXCOORD2;<br>    &#125;;<br>    <br>    v2f <span class="hljs-title function_">Vert</span><span class="hljs-params">( AttributesMesh v)</span><br>    &#123;<br>        v2f o = (v2f)<span class="hljs-number">0</span>;<br>        o.uv = v.uv0.xy;<br>        float3 normalWS =  TransformObjectToWorldNormal(v.normalOS);<br>        float3 positionRWS = TransformObjectToWorld(v.positionOS);<br>        o.position = TransformWorldToHClip(positionRWS);<br><span class="hljs-comment">// 为了测试，先沿法线向量计算模糊向量</span><br>        o.furRootCS = mul(_NonJitteredViewProjMatrix, float4(positionRWS, <span class="hljs-number">1.0</span>)).xyw;<br>        o.furTailCS = mul(_NonJitteredViewProjMatrix, float4(positionRWS + normalWS, <span class="hljs-number">1.0</span>)).xyw;<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br><br>    real4 <span class="hljs-title function_">Frag</span><span class="hljs-params">(v2f i)</span>:SV_Target0&#123;<br>        float2 furRootCS = i.furRootCS.xy / i.furRootCS.z;<br>        float2 furTailCS = i.furTailCS.xy / i.furTailCS.z;<br>        real2 motionVec = (furRootCS.xy - furTailCS.xy);<br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_UV_STARTS_AT_TOP</span><br>        motionVec.y = -motionVec.y;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-keyword">return</span> float4( motionVec * <span class="hljs-number">0.5</span> ,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    &#125;<br>    ENDHLSL<br>&#125;<br></code></pre></td></tr></table></figure><p>把上面的Pass加到任意一个HDRP的shader当中并不会影响原始界面的显示，下面灰色物体是加入了FurVectorsPass的Unlit材质：</p><p><img src="/../../images/img/2019620-195422.jpg" alt="2019620-195422"></p><p>可以在FrameDebug当中看到渲染结果，多出了FurVectorsPass，并且还有SRP Batch加持：</p><p><img src="/../../images/img/2019620-191918.jpg" alt="2019620-191918"></p><p>可以看到他输出的内容是一个屏幕空间的向量，之后就可以直接用于毛发方向模糊的后处理：</p><p><img src="/../../images/img/2019620-192742.jpg" alt="2019620-192742"></p><p>最后为了在后处理中访问到，还需要把这个纹理设置成全局纹理，在HDStringConstants.cs中添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-type">static</span> readonly <span class="hljs-type">int</span> _CameraDepthTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_CameraDepthTexture&quot;</span>);<br>public <span class="hljs-type">static</span> readonly <span class="hljs-type">int</span> _CameraMotionVectorsTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_CameraMotionVectorsTexture&quot;</span>);<br>public <span class="hljs-type">static</span> readonly <span class="hljs-type">int</span> _CameraMotionVectorsSize = Shader.PropertyToID(<span class="hljs-string">&quot;_CameraMotionVectorsSize&quot;</span>);<br>public <span class="hljs-type">static</span> readonly <span class="hljs-type">int</span> _CameraMotionVectorsScale = Shader.PropertyToID(<span class="hljs-string">&quot;_CameraMotionVectorsScale&quot;</span>);<br>public <span class="hljs-type">static</span> readonly <span class="hljs-type">int</span> _FullScreenDebugMode = Shader.PropertyToID(<span class="hljs-string">&quot;_FullScreenDebugMode&quot;</span>);<br><br>public <span class="hljs-type">static</span> readonly <span class="hljs-type">int</span> _FurVectorsTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_FurVectorsTexture&quot;</span>);<br></code></pre></td></tr></table></figure><p>在HDRenderPipeline.cs的PushGlobalParams方法中添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (hdCamera.frameSettings.IsEnabled(FrameSettingsField.MotionVectors))<br>&#123;<br>   ... ...<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>   ... ...<br>&#125;<br><br>cmd.SetGlobalTexture(HDShaderIDs._FurVectorsTexture,m_SharedRTManager.GetFurVectorsBuffer());  <span class="hljs-comment">// +++++++++++++++++++++++++++++++</span><br></code></pre></td></tr></table></figure><h3 id="使用毛发走向图进行方向模糊的后处理"><a href="#使用毛发走向图进行方向模糊的后处理" class="headerlink" title="使用毛发走向图进行方向模糊的后处理"></a>使用毛发走向图进行方向模糊的后处理</h3><p>这里直接进行简单的向量模糊处理，我们通过修改HDRP的PostSystem实现。这里使用computeShader进行计算。</p><p>首先我们需要添加渲染毛发的compute Shader绘制代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (m_MotionBlur.IsActive() &amp;&amp; m_AnimatedMaterialsEnabled &amp;&amp; !m_ResetHistory)<br>&#123;<br>... ...<br>&#125;<br><br><span class="hljs-comment">// 在motionblur后面添加</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>)<br>&#123;<br>    using (new ProfilingSample(cmd, <span class="hljs-string">&quot;Fur Blur&quot;</span>, CustomSamplerId.FurBlur.GetSampler()))<br>    &#123;<br>        var destination = m_Pool.Get(Vector2.one, k_ColorFormat);<br>        DoFurBlur(cmd, camera, source, destination);<br>        PoolSource(ref source, destination);<br>    &#125;<br>&#125;<br><br>... ...<br><span class="hljs-meta">#region Fur Blur</span><br><span class="hljs-comment">// 下面的内容就可以将结果写入到最终位置上，这里还是一切从简，先不用特殊的参数，先把核心的模糊计算加上</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DoFurBlur</span><span class="hljs-params">(CommandBuffer cmd, HDCamera camera, RTHandle source, RTHandle destination)</span><br>&#123;<br>    var cs = m_Resources.shaders.furBlurCS;<br>    var kernel = cs.FindKernel(<span class="hljs-string">&quot;FurBlurKernel&quot;</span>);<br>    cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._InputTexture, source);<br>    cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._OutputTexture, destination);<br>    cmd.DispatchCompute(cs, kernel, (camera.actualWidth + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>, (camera.actualHeight + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>, camera.computePassCount);<br>&#125;<br><span class="hljs-meta">#endregion</span><br></code></pre></td></tr></table></figure><p>添加Sampler, 在HDCustomSamplerId.cs当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">DepthOfFieldGatherNear,<br>DepthOfFieldPreCombine,<br>DepthOfFieldCombine,<br>FurBlur, <span class="hljs-comment">// +++++++++++++</span><br>MotionBlur,<br></code></pre></td></tr></table></figure><p>添加FurBlur的computeShader，在RenederPipelineResources中.cs</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">[Reload(<span class="hljs-string">&quot;PostProcessing/Shaders/MotionBlur.compute&quot;</span>)]<br>public ComputeShader motionBlurCS;<br>[Reload(<span class="hljs-string">&quot;PostProcessing/Shaders/FurBlur.compute&quot;</span>)]<br>public ComputeShader furBlurCS;   <span class="hljs-comment">// +++++++++++++++</span><br></code></pre></td></tr></table></figure><p>最后，还需要编写实际计算的computeShader：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> kernel FurBlurKernel</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/FXAA.hlsl&quot;</span></span><br><br><br>RW_TEXTURE2D_X(float3, _OutputTexture);<br>TEXTURE2D_X(_InputTexture);<br>TEXTURE2D_X(_FurVectorsTexture);<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">使用_FurVectorsTexture当中的向量对_InputTexture进行向量模糊处理。最终结果输出到_OutputTexture。</span><br><span class="hljs-comment">*/</span><br>[numthreads(<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>)]<br><span class="hljs-type">void</span> <span class="hljs-title function_">FurBlurKernel</span><span class="hljs-params">(uint3 dispatchThreadId : SV_DispatchThreadID)</span><br>&#123;<br>    UNITY_STEREO_ASSIGN_COMPUTE_EYE_INDEX(dispatchThreadId.z);<br>    uint2 positionSS = dispatchThreadId.xy;<br>    float2 positionNDC = positionSS * _ScreenSize.zw + (<span class="hljs-number">0.5</span> * _ScreenSize.zw); <br>    float3 outColor = Load(_InputTexture, positionSS, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    _OutputTexture[COORD_TEXTURE2D_X(positionSS)] = outColor;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码稍作修改就能得到有毛发区域的模糊效果，至于具体控制参数、模糊算法细节并不难，这里略过。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Enlighten</title>
      <link href="/2023/06/02/Unity/EnlightenBaking/"/>
      <url>/2023/06/02/Unity/EnlightenBaking/</url>
      
        <content type="html"><![CDATA[<h1 id="Enlighten"><a href="#Enlighten" class="headerlink" title="Enlighten"></a>Enlighten</h1><p>Unity的Enlighten的lightmap烘焙有<strong>三个设置</strong>位置:</p><p>全场景设置：</p><p><img src="/img/lightmap_globalsetting.jpg" alt="lightmap_globalsetting"></p><p>模型设置：</p><p><img src="/img/lightmap_objectsetting.jpg" alt="lightmap_objectsetting"></p><p>右键创建lightmap parameter:</p><p><img src="/img/lightmap_lightparamtersetting.jpg" alt="lightmap_lightparamtersetting"></p><p>Enlighten需要进行合理的设置才能够达到高效和高质量，如果使用默认设置几乎不能达到要求。</p><p>​国内大部分游戏使用Prograssive渐进烘焙，<strong>实际上Enlighten通过正确的设置参数，速度是可以保证的，并且效果更好，国外AAA以及UE4作品都是用Enlighten烘焙的。后面讲解如何正确的使用Enlighten。达到高效和高质量的结果。</strong></p><h2 id="Enlighten和Prograssive直观对比"><a href="#Enlighten和Prograssive直观对比" class="headerlink" title="Enlighten和Prograssive直观对比"></a>Enlighten和Prograssive直观对比</h2><p>简单测试一下不同渲染器不同设置之间的差别。</p><p>使用默认参数，70秒，Enlighten烘焙的间接光：</p><p><img src="/../../images/img/lightmap_bakedemo2.jpg" alt="lightmap_bakedemo2"></p><p>使用默认参数，18秒，Progressive烘焙的间接光：</p><p><img src="/../../images/img/lightmap_bakedemo3.jpg" alt="lightmap_bakedemo3"></p><p>经过参数调整，3秒，Enlighten烘焙的间接光：</p><p><img src="/../../images/img/lightmap_bakedemo1.jpg" alt="lightmap_bakedemo1"></p><p>经过参数调整，8秒，Progressive烘焙的间接光：</p><p><img src="/../../images/img/lightmap_bakedemo4.jpg" alt="lightmap_bakedemo4"></p><p>​可以看到只要进行正确的调整,Enlighten是可以<strong>在更合理的时间达到比较好的效果</strong>，而Progressive的调整，比如降低direct采样数或者反弹数就会明显的让Lightmap变黑、变得生硬。</p><h2 id="基本功能（这部分内容和Unity有差异）"><a href="#基本功能（这部分内容和Unity有差异）" class="headerlink" title="基本功能（这部分内容和Unity有差异）"></a>基本功能（这部分内容和Unity有差异）</h2><p>官方说明（和Unity集成后不太一样）：</p><ol><li>Enlighten 只计算反射光（间接光）。</li><li>不计算直接光和阴影。</li><li>Enlighten是CPU上的异步计算。</li></ol><p>Enlighten的输出（和Unity集成后不太一样）：</p><ol><li>高质量的可以实时更新的GI。</li><li>漫反射间接光：lightmaps 和lightprobes。</li><li>高管反射：cubemap</li><li>比传统bake分辨率低。</li></ol><p>下面是一个官方参考的设置的大小，包括texel大小和lightprobef分布，绿色表示是动态物体：</p><p><img src="/../../images/img/lightmap_bake2.jpg" alt="lightmap_bake2"><img src="/../../images/img/lightmap_bake1.jpg" alt="lightmap_bake1"></p><h2 id="Cluster烘焙原理说明"><a href="#Cluster烘焙原理说明" class="headerlink" title="Cluster烘焙原理说明"></a>Cluster烘焙原理说明</h2><h3 id="Enlighten的好处"><a href="#Enlighten的好处" class="headerlink" title="Enlighten的好处"></a>Enlighten的好处</h3><ul><li>有效的区域光：自发光表面可以作为一个区域光。</li><li>平滑的工作流：迭代速度快。</li><li>灵活及时反映的光照：实时间接光可以相应灯光的变化。</li></ul><h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><ol><li>设置场景</li><li>预计算</li><li>灯光照亮</li></ol><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>GI使用一个复杂的公式描述：<a href="https://en.wikipedia.org/wiki/Rendering_equation">Rendering equation</a></p><p><img src="/../../images/img/lightmap_fomula.jpg" alt="lightmap_fomula"></p><p>这个公式非常复杂，wiki当中有详细的描述。这里简单的描述一下：</p><p>$L_0$表示物体在位置$x$处，超$w_o$方向，对于波长$\lambda$的波的，在$t$时间中的光辐射率。</p><p>$L_e$是自发光的光辐射量。</p><p>$f_r$ 是<strong>brdf函数</strong>，描述入射光$w_i$的表面属性。</p><p>$L_i$是入射光的辐射量</p><p>$w_i * n$ 衰减因子。</p><p>总的描述一下就是：<strong>反射的光线 &#x3D; 自发光 + 所有入射光被反射的和</strong></p><p>上面的公式很复杂，但是可以通过很多方法进行估算。</p><p>Enlighten简化了这个问题：<strong>假设元素是静态的、有限的、并且只传递漫反射。</strong>这个方法叫做辐射度（radiosity）。</p><ol><li>Enlighten移除了材质依赖：也就是去掉了brdf函数，把积分中的内容变成一个form fractor。</li><li>form fractor描述了光从元素i离开到达元素j的百分比。</li><li>积分就变成了（from fractor* 对应元素的辐射率）的和，然后再加上自发光。</li><li>我们可以在多帧中处理这个离散的数学问题，同时需要运行多次达到收敛。不过求解这个问题和帧率是完全独立的，人眼对间接光的变化并不敏感。</li></ol><p>最终的简化结果：</p><p>$$ B_i &#x3D; L_e + \rho_i  \sum <em>{j&#x3D;1}^{n}F</em>{ij}L_j$$</p><p>$B_i $ 表示i点的光$L_e$ 表示从<strong>cluster</strong> i上发射的自发光。（光是靠cluster计算的）。</p><p>$\rho_i$表示材质属性</p><p>$n$ 是<strong>budget</strong>：一个cluster 最多接受几个cluster的辐射。</p><p>$F_ij$  from fractor：从cluster i到cluster j可以传递多少能量。</p><p>$L_j$ 是从cluster j当中释放出的光。（上一帧，这个算法是逐帧迭代的）。</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><ol><li><p>首先场景当中的几何体会被划分成可以并行计算的<strong>System</strong>（based on proximity and Lightmap Parameters， sharing the same realtime lightmap）。<strong>System之间可以并行</strong>。</p><p>下面是System Scene View：</p><p><img src="/../../images/img/lightmap_GIUI_system.png" alt="lightmap_GIUI_system"></p></li><li><p>每一个System会分割成离散的<strong>Cluster</strong>。</p></li></ol><p>Enlighten就是使用这些Clusters计算间接光的，因为每一帧需要进行积分，所以cluster数量越多，计算开销成$$O(n^2)$$。</p><p>Cluster的大小需要比lightmap的pixel大。比例在LightMap Paramter当中设置：<strong>Cluster Resolution</strong>。这个参数内存敏感，如果这个比例设置不正确，将Geometry设置成cluster的步骤将会消耗大量内存。</p><p>下面是Cluster Scene View：</p><p><img src="/../../images/img/lightmap_GIUI_cluster.png" alt="lightmap_GIUI_cluster"></p><ol start="3"><li>预计算，需要计算Cluster之间的可见性。</li><li>当对<strong>每一个点</strong>计算间接光时，每个像素可见的cluster已经完成了预先计算。运行时，只要将这些cluster求和即可。</li></ol><h3 id="Culster和System"><a href="#Culster和System" class="headerlink" title="Culster和System"></a>Culster和System</h3><p>Enlighten将世界看做由很多Cluster组成的。Cluster是计算光照的基本单位。</p><p>Cluster并不是只属于一个System，而是可以在System之间传递。</p><p>在光照传输阶段，计算的是cluster之间的可见性。</p><p><strong>Irradiance Quality</strong>在lightmap paramenter中设置。描述了在预计算阶段，针对每一个lightmap texel 要发射多少条ray，来计算有多少个cluster对这个texelhui产生影响。数量越多，找到的cluster越精确，只影响预计算效率。不影响运行时效率。</p><p><strong>Irradiance budget</strong>在lightmap paramenter中设置。通过发射ray找到每一个lightmap texel关联的cluster之后，记录form fractor的数量。如果太小可能遗漏应该计算的光线。</p><h2 id="烘焙参数"><a href="#烘焙参数" class="headerlink" title="烘焙参数"></a>烘焙参数</h2><p>对于上一部分的流程，这里接招几个和bake性能有关的重要参数。</p><p>由于有三个位置可以设置Enlighten的烘焙，下面就分三部分介绍：</p><h3 id="针对场景的总体设置：LightMapping-Setting"><a href="#针对场景的总体设置：LightMapping-Setting" class="headerlink" title="针对场景的总体设置：LightMapping Setting"></a>针对场景的总体设置：LightMapping Setting</h3><p>详细解释见<a href="https://docs.unity3d.com/Manual/GI-Enlighten.html">官方说明</a>，下面只对重要参数进行说明。</p><p><img src="/../../images/img/lightmap_globalsetting.jpg" alt="lightmap_globalsetting"></p><p><strong>LightMapper</strong> ：使用哪个烘焙，这里只讨论Enlighten。</p><p><strong>Indrection Resolution</strong> ： 一米多少个Cluster。<strong>越小越快。</strong></p><p><strong>Lightmap Resolution</strong> ： 一米多少个lightmap pixel。<strong>越小越快</strong></p><p>注：当我们把上面两个值都设置成1 的时候，切换cluster scene view和baked lightmap，发现cluster比lightmap pixel要大。这是因为<strong>在LightmapParameters当中Cluster Resolution</strong>也会对cluster产生影响。如果把物体的Cluster Resolution也设置为1，那么Cluster和LightMap Pixel的大小就是1:1。</p><p>注：因为预计算是计算每一个pixel对于哪些cluster可见，所以开销就是Indrection Resolution*Lightmap Resolution。</p><h3 id="针对GameObject的设置：LightMapping"><a href="#针对GameObject的设置：LightMapping" class="headerlink" title="针对GameObject的设置：LightMapping"></a>针对GameObject的设置：LightMapping</h3><p><strong>Scale In Lightmap</strong> 在Lightmap当中的缩放，并不影响计算进度，只影响算完之后如何存储。通过合理的设置可以减少lightmap的总数。</p><p><strong>这部分的参数和uv分布有关系，暂时略过。</strong></p><p><img src="/../../images/img/lightmap_objectsetting.jpg" alt="lightmap_objectsetting"></p><h3 id="可以选择的全局配置文件：LightMapParameter"><a href="#可以选择的全局配置文件：LightMapParameter" class="headerlink" title="可以选择的全局配置文件：LightMapParameter"></a>可以选择的全局配置文件：LightMapParameter</h3><p>详细解释见：<a href="https://docs.unity3d.com/Manual/class-LightmapParameters.html">官方文档</a></p><p><strong>Resolution</strong>： 直接和全局的Indrection Resolution和Lightmap Resolution相乘。 <strong>越小越快，默认为1</strong></p><p><strong>Cluster Resolution</strong> ：Indrection Resolution和Lightmap Resolution的比例。这个只会方法Cluster的大小，默认0.5，也就是Cluster当中包括了4个texel。<strong>越小越快，默认0.5</strong></p><p><strong>Irradiance Quality</strong> ：描述了在预计算阶段，针对每一个lightmap texel 要发射多少条ray，来计算有多少个cluster对这个texelhui产生影响。数量越多，找到的cluster越精确，<strong>只影响预计算效率。不影响运行时效率。</strong> <strong>越小越快</strong></p><p><strong>Irradiance budget</strong> ：通过发射ray找到每一个lightmap texel关联的cluster之后，记录form fractor的数量。如果太小可能遗漏应该计算的光线。<strong>对bake时间没有影响</strong></p><p>其他内容见文档。</p><p><img src="/../../images/img/lightmap_lightparamtersetting.jpg" alt="lightmap_lightparamtersetting"></p><h3 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h3><ol><li><p>和Enlighten相关的内容，除了Culster计算光照、System之间可以并行、Pixel计算可见性之外。还有一部分是uv相关的设置，这部分对性能影响不大之后再分析。</p></li><li><p>对于树叶、草等有零碎的cluster和uv chart的物体，一定要特殊处理，使用实时光。或者重分uv。不然会产生极大的烘焙开销。</p></li><li><p>要合理使用lightmapping paramter对不同类型的物体的进行设置，尤其是cluster和pixel的大小。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blogs.unity3d.com/2016/09/28/in-development-progressive-lightmapper/">https://blogs.unity3d.com/2016/09/28/in-development-progressive-lightmapper/</a></p><p><a href="https://enlighten.atlassian.net/wiki/spaces/UEF309/pages/525467659/How+Enlighten+works">https://enlighten.atlassian.net/wiki/spaces/UEF309/pages/525467659/How+Enlighten+works</a></p><p><a href="https://www.siliconstudio.co.jp/middleware/enlighten/en/blog/2018/20180406/pdf/gdc2018-enlighten-global-illumination-that-scales.pdf">https://www.siliconstudio.co.jp/middleware/enlighten/en/blog/2018/20180406/pdf/gdc2018-enlighten-global-illumination-that-scales.pdf</a></p><p><a href="https://docs.unity3d.com/uploads/ExpertGuides/Using_Enlighten_with_Unity.pdf">https://docs.unity3d.com/uploads/ExpertGuides/Using_Enlighten_with_Unity.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Light Loop</title>
      <link href="/2023/06/02/Unity/HDRPShader%E5%BD%93%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E7%B3%BB%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"/>
      <url>/2023/06/02/Unity/HDRPShader%E5%BD%93%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E7%B3%BB%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="HDRP-Shader当中的坐标系变化矩阵"><a href="#HDRP-Shader当中的坐标系变化矩阵" class="headerlink" title="HDRP Shader当中的坐标系变化矩阵"></a>HDRP Shader当中的坐标系变化矩阵</h1><p>​在HDRP当中Shader当中所有的内置矩阵（例如：UNITY_MATRIX_M）都发生了变化。这部分内容不再通过内置的代码设置，而是在SRP当中设置，我们可以看到这些参数是如何传递到Shader当中的。下面详细介绍写的坐标系变化矩阵。</p><h1 id="C-设置部分"><a href="#C-设置部分" class="headerlink" title="C#设置部分"></a>C#设置部分</h1><p>先来看一下矩阵传入Shader的c#代码：</p><p>略</p><h1 id="Shader当中的基础坐标变化"><a href="#Shader当中的基础坐标变化" class="headerlink" title="Shader当中的基础坐标变化"></a>Shader当中的基础坐标变化</h1><p>在一个Shader中最基础的就是模型坐标到剪裁空间 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">TransformObjectToWorld(v.vertex); <span class="hljs-comment">// UNITY_MATRIX_M</span><br>TransformWorldToHClip(positionWS); <span class="hljs-comment">// UNITY_MATRIX_VP</span><br></code></pre></td></tr></table></figure><p>HDRP中，目前我看到的是没有了UNITY_MATRIX_MVP而是需要两步转化。</p><h1 id="Shader当中坐标系变换"><a href="#Shader当中坐标系变换" class="headerlink" title="Shader当中坐标系变换"></a>Shader当中坐标系变换</h1><h2 id="Shader当中坐标系宏定义的位置"><a href="#Shader当中坐标系宏定义的位置" class="headerlink" title="Shader当中坐标系宏定义的位置"></a>Shader当中坐标系宏定义的位置</h2><p>在文件ShaderVariablesMatrixDefsHDCamera.hlsl中保存的是和摄像机相关的矩阵的宏，如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UNITY_SHADER_VARIABLES_MATRIX_DEFS_LEGACY_UNITY_INCLUDED</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">error</span> Mixing HDCamera and legacy Unity matrix definitions</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> UNITY_SHADER_VARIABLES_MATRIX_DEFS_HDCAMERA_INCLUDED</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_SHADER_VARIABLES_MATRIX_DEFS_HDCAMERA_INCLUDED</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(USING_STEREO_MATRICES)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_V     _ViewMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_V   _InvViewMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_P     OptimizeProjectionMatrix(_ProjMatrixStereo[unity_StereoEyeIndex])</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_P   _InvProjMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_VP    _ViewProjMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_VP  _InvViewProjMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_UNJITTERED_VP _ViewProjMatrixStereo[unity_StereoEyeIndex] <span class="hljs-comment">// Since VR doesn&#x27;t need to add jitter, just use normal VP matrix</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_PREV_VP _PrevViewProjMatrixStereo[unity_StereoEyeIndex]</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_V     _ViewMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_V   _InvViewMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_P     OptimizeProjectionMatrix(_ProjMatrix)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_P   _InvProjMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_VP    _ViewProjMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_VP  _InvViewProjMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_UNJITTERED_VP _NonJitteredViewProjMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_PREV_VP _PrevViewProjMatrix</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// USING_STEREO_MATRICES</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// UNITY_SHADER_VARIABLES_MATRIX_DEFS_HDCAMERA_INCLUDED</span></span><br><br></code></pre></td></tr></table></figure><p>在ShaderVariables.cginc中保存了所有原始矩阵的定义，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ================================</span><br><span class="hljs-comment">//     PER FRAME CONSTANTS</span><br><span class="hljs-comment">// ================================</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(USING_STEREO_MATRICES)</span><br>float4x4 glstate_matrix_projection;<br>float4x4 unity_MatrixV;<br>float4x4 unity_MatrixInvV;<br>float4x4 unity_MatrixVP;<br>float4 unity_StereoScaleOffset;<br><span class="hljs-type">int</span> unity_StereoEyeIndex;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// ================================</span><br><span class="hljs-comment">//     PER VIEW CONSTANTS</span><br><span class="hljs-comment">// ================================</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> all affine matrices should be 3x4.</span><br>float4x4 _ViewMatrix;<br>float4x4 _InvViewMatrix;<br>float4x4 _ProjMatrix;<br>float4x4 _InvProjMatrix;<br>float4x4 _ViewProjMatrix;<br>float4x4 _InvViewProjMatrix;<br>float4x4 _NonJitteredViewProjMatrix;<br>float4x4 _PrevViewProjMatrix;       <span class="hljs-comment">// non-jittered</span><br><br>...<br>    <br>float4x4 <span class="hljs-title function_">GetRawUnityObjectToWorld</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> unity_ObjectToWorld; &#125;<br>float4x4 <span class="hljs-title function_">GetRawUnityWorldToObject</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> unity_WorldToObject; &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_M     ApplyCameraTranslationToMatrix(GetRawUnityObjectToWorld())</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_M   ApplyCameraTranslationToInverseMatrix(GetRawUnityWorldToObject())</span><br></code></pre></td></tr></table></figure><p>​可以看到所有的View变化和投影变换都设置了对应的逆矩阵，方便了我们进行操作。</p><p>​<strong>这里需要重要说明的是UNITY_MATRIX_V矩阵和 UNITY_MATRIX_I_V矩阵忽略了摄像机的平移。而UNITY_MATRIX_M和UNITY_MATRIX_I_M 加入了摄像机的平移。</strong>也就是说用这组矩阵是无法从摄像机空间恢复出真实的世界坐标的。也无法从世界坐标转换到真实的摄像机坐标的，模型坐标到世界坐标也是同理。</p><p>​UNITY_MATRIX_V和UNITY_MATRIX_I_V矩阵内容如下图，可以看到平移分量没有了。</p><p><img src="/img/UNITY_MATRIX_I_V.jpg"></p><p>​如果我们想要从深度中恢复真实的世界坐标要使用：<strong>unity_MatrixV</strong>矩阵。</p><p>​如果要用模型坐标得到世界坐标怎么办？我们用ShaderGraph来制作一个直接输出世界坐标的Graph。如下图：</p><p><img src="/img/ObjectToWorld.jpg"></p><p>​通过查看生成的代码，ShaderGraph的制作方案是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 首先通过矩阵计算有摄像机偏移的世界坐标。</span><br>UNITY_MATRIX_M<br><span class="hljs-comment">// 然后通过下面这个函数去除掉摄像机的影响，得到真实的世界坐标。</span><br>float3 <span class="hljs-title function_">GetAbsolutePositionWS</span><span class="hljs-params">(float3 positionRWS)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (SHADEROPTIONS_CAMERA_RELATIVE_RENDERING != 0)</span><br>    positionRWS += _WorldSpaceCameraPos;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> positionRWS;<br>&#125;<br></code></pre></td></tr></table></figure><p>​还有一个地方需要注意，在UnityHDRP的Shader当中有命名为<strong>positionRWS</strong>的世界坐标，R的意思就是说这个世界坐标包含了相对于摄像机的位移。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HDRP HairShader代码结构</title>
      <link href="/2023/06/02/Unity/HDRP%E4%B8%ADHairShader%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"/>
      <url>/2023/06/02/Unity/HDRP%E4%B8%ADHairShader%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="HDRP-HairShader代码结构"><a href="#HDRP-HairShader代码结构" class="headerlink" title="HDRP HairShader代码结构"></a>HDRP HairShader代码结构</h1><p>Hair只能在前向渲染阶段渲染，使用下面两个Pass：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123;<br>    LightMode = DepthForwardOnly<br>    LightMode = ForwardOnly<br>&#125;<br></code></pre></td></tr></table></figure><p>头发有一个特殊的Stencil</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">Stencil<br>&#123;<br>   WriteMask <span class="hljs-number">7</span><br>   Ref  <span class="hljs-number">2</span><br>   Comp Always<br>   Pass Replace<br>&#125;<br></code></pre></td></tr></table></figure><p>##透明和不透明有所区别</p><p>混合方式上的区别</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//透明</span><br>            Blend One OneMinusSrcAlpha <br>            ZTest LEqual <span class="hljs-comment">// 正常的深度渲染，注意这个时候也可以提前绘制深度。</span><br>            ZWrite Off<br><span class="hljs-comment">//不透明</span><br>            Blend One Zero  <span class="hljs-comment">// 直接覆盖</span><br>            ZTest Equal  <span class="hljs-comment">// 因为会提前绘制深度，所以需要和原本深度值相等才能绘制</span><br>            ZWrite On<br><span class="hljs-comment">// 在原本的shader当中如果开启blend默认编程了透明？</span><br></code></pre></td></tr></table></figure><p>透明不透明的宏定义区别</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 透明加不透明</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _SURFACE_TYPE_TRANSPARENT 1</span><br><span class="hljs-comment">// 透明部分</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _BLENDMODE_ALPHA 1   <span class="hljs-comment">// 开启 混合</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1  <span class="hljs-comment">// ??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _ENABLE_FOG_ON_TRANSPARENT 1  <span class="hljs-comment">// 开启透明物体上的雾</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _SPECULAR_OCCLUSION_FROM_AO 1 <span class="hljs-comment">// AO 对高光生效</span></span><br></code></pre></td></tr></table></figure><p>下面是关于分割光线的 split Lighting 是什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// If we use subsurface scattering, enable output split lighting (for forward pass)</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) &amp;&amp; !defined(_SURFACE_TYPE_TRANSPARENT) <span class="hljs-comment">// 子表面散射 并且不是半透明物体</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OUTPUT_SPLIT_LIGHTING  <span class="hljs-comment">// 分割光线？？？</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="头发渲染部分代码"><a href="#头发渲染部分代码" class="headerlink" title="头发渲染部分代码"></a>头发渲染部分代码</h2><h3 id="Shader-Pass-Forward"><a href="#Shader-Pass-Forward" class="headerlink" title="Shader Pass Forward"></a>Shader Pass Forward</h3><p>头发的Pass文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassForward.hlsl&quot;</span></span><br></code></pre></td></tr></table></figure><p>也就是说头发使用的事一般的前向渲染的Pass描述。</p><p>####Vert</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这部分是通用的代码</span><br>PackedVaryingsType <span class="hljs-title function_">Vert</span><span class="hljs-params">(AttributesMesh inputMesh)</span><br>&#123;<br>    VaryingsType varyingsType;<br>    varyingsType.vmesh = VertMesh(inputMesh);<br>    <span class="hljs-keyword">return</span> PackVaryingsType(varyingsType);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/VertMesh.hlsl&quot;</span></span><br><span class="hljs-comment">//使用的上面的内容用来计算Vert当中的参数。</span><br></code></pre></td></tr></table></figure><p>####Frag</p><p>下面是去掉了debug信息的Frag代码：</p><p>如果使用了SSS效果并且没有使用半透则会进入OUTPUT_SPLIT_LIGHTING的部分，看起来是分开了高光和漫反射颜色，以及SSS的某个特殊buffer。</p><p>否则就是用一个单独的颜色。</p><p>这里有个_DEPTHOFFSET_ON，暂时不考虑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Frag</span><span class="hljs-params">(PackedVaryingsToPS packedInput,</span><br><span class="hljs-params">        #ifdef OUTPUT_SPLIT_LIGHTING  <span class="hljs-comment">//使用分割光线</span></span><br><span class="hljs-params">            out float4 outColor : SV_Target0,  <span class="hljs-comment">// outSpecularLighting</span></span><br><span class="hljs-params">            out float4 outDiffuseLighting : SV_Target1,</span><br><span class="hljs-params">            OUTPUT_SSSBUFFER(outSSSBuffer)</span><br><span class="hljs-params">        #<span class="hljs-keyword">else</span></span><br><span class="hljs-params">            out float4 outColor : SV_Target0  <span class="hljs-comment">// 没有SSS效果的一个输出颜色。</span></span><br><span class="hljs-params">        #endif</span><br><span class="hljs-params">        #ifdef _DEPTHOFFSET_ON</span><br><span class="hljs-params">            , out <span class="hljs-type">float</span> outputDepth : SV_Depth</span><br><span class="hljs-params">        #endif</span><br><span class="hljs-params">          )</span><br>&#123;<br>    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(packedInput);<br>    FragInputs input = UnpackVaryingsMeshToFragInputs(packedInput.vmesh);<br><br>    uint2 tileIndex = uint2(input.positionSS.xy) / GetTileSize();<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(UNITY_SINGLE_PASS_STEREO)</span><br>    tileIndex.x -= unity_StereoEyeIndex * _NumTileClusteredX;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// input.positionSS is SV_Position</span><br>    PositionInputs posInput = GetPositionInput_Stereo(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS.xyz, tileIndex, unity_StereoEyeIndex); <span class="hljs-comment">// 计算屏幕坐标 视口坐标 纹理坐标等内容（ComputeShader也会用这个函数）。</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> VARYINGS_NEED_POSITION_WS</span><br>    float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-comment">// Unused</span><br>    float3 V = float3(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// Avoid the division by 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    SurfaceData surfaceData;<br>    BuiltinData builtinData;<br>    <br>    <span class="hljs-comment">// 纹理属性的计算</span><br>    GetSurfaceAndBuiltinData(input, V, posInput, surfaceData, builtinData);<br><span class="hljs-comment">// 材质参数计算</span><br>    BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);<br><br>    PreLightData preLightData = GetPreLightData(V, posInput, bsdfData);<br><span class="hljs-comment">// 定义输出颜色</span><br>    outColor = float4(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br><br><br>    &#123;<br>    <span class="hljs-comment">//透明和不透明物体单独处理</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _SURFACE_TYPE_TRANSPARENT</span><br>        uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_OPAQUE;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">// 将要分别计算的高光和漫反射光</span><br>        float3 diffuseLighting;<br>        float3 specularLighting;<br><br><span class="hljs-comment">// 进入光照循环计算光照</span><br>        LightLoop(V, posInput, preLightData, bsdfData, builtinData, featureFlags, diffuseLighting, specularLighting);<br><span class="hljs-comment">// 此时就返回了计算好的高光和 漫反射光</span><br><span class="hljs-comment">// 进行全局的缩放</span><br>        diffuseLighting *= GetCurrentExposureMultiplier();<br>        specularLighting *= GetCurrentExposureMultiplier();<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OUTPUT_SPLIT_LIGHTING</span><br><span class="hljs-comment">// 如果开启SSS 并且需要分割光照（通过参数判断），则把两个光照分开。</span><br>        <span class="hljs-keyword">if</span> (_EnableSubsurfaceScattering != <span class="hljs-number">0</span> &amp;&amp; ShouldOutputSplitLighting(bsdfData))<br>        &#123;<br>            outColor = float4(specularLighting, <span class="hljs-number">1.0</span>);<br>            outDiffuseLighting = float4(TagLightingForSSS(diffuseLighting), <span class="hljs-number">1.0</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>        <span class="hljs-comment">//如果不需要SSS，或者不需要分割光照，就把两个颜色都合并到Specular里面。</span><br>            outColor = float4(diffuseLighting + specularLighting, <span class="hljs-number">1.0</span>);<br>            outDiffuseLighting = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 这里面写入一些 SSS需要用到的属性。</span><br>        ENCODE_INTO_SSSBUFFER(surfaceData, posInput.positionSS, outSSSBuffer);<br>        <span class="hljs-comment">// 如果分割颜色就，在Gbuffer结束时统一计算大气散射。</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        outColor = ApplyBlendMode(diffuseLighting, specularLighting, builtinData.opacity);<br>        <br>        <span class="hljs-comment">// 如果不分割颜色 就直接计算大气散射。</span><br>        outColor = EvaluateAtmosphericScattering(posInput, V, outColor);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br><br><span class="hljs-comment">// 忽略</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _DEPTHOFFSET_ON</span><br>    outputDepth = posInput.deviceDepth;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="LightLoop"><a href="#LightLoop" class="headerlink" title="LightLoop"></a>LightLoop</h4><p>具体Shader的光照循环部分，参见光照循环文档</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Light Loop</title>
      <link href="/2023/06/02/Unity/HDRPLightLoop/"/>
      <url>/2023/06/02/Unity/HDRPLightLoop/</url>
      
        <content type="html"><![CDATA[<h1 id="Light-Loop"><a href="#Light-Loop" class="headerlink" title="Light Loop"></a>Light Loop</h1><p>unity HDRP的Shader当中LightLoop是最终的光照计算函数部分。</p><p>Deferred Light的光照计算会经过这个函数。ForwarOnly的光照阶段也会经过这个函数。现在对着个函数进行详细的讲解。</p><p>LightLoop主要包含三个部分：</p><ol><li>LightLoop.hlsl 是LightLoop的具体实现</li><li>LightLoopDef.hlsl是针对LightLoop当中的常用的工具和函数</li><li>针对不同的材质，需要一个提供函数的xxx.hlsl文件，提供了在不同材质下LightLoop进行不同的光照计算。</li></ol><h2 id="LightLoop主循环"><a href="#LightLoop主循环" class="headerlink" title="LightLoop主循环"></a>LightLoop主循环</h2><p>下面是去掉Debug内容的LightLoop主循环的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">LightLoop</span><span class="hljs-params">( float3 V, PositionInputs posInput, PreLightData preLightData, BSDFData bsdfData, BuiltinData builtinData, uint featureFlags,</span><br><span class="hljs-params">                out float3 diffuseLighting, <span class="hljs-comment">// 返回的两种光照</span></span><br><span class="hljs-params">                out float3 specularLighting)</span><span class="hljs-comment">// 返回的两种光照</span><br>&#123;<br>    <span class="hljs-comment">// 保存了主要信息。</span><br>    LightLoopContext context;<br><br>    <span class="hljs-comment">// 读取阴影相关内容。</span><br>    context.shadowContext    = InitShadowContext();<br>    context.contactShadow    = InitContactShadow(posInput);<br>    context.shadowValue      = <span class="hljs-number">1</span>;<br>    context.sampleReflection = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// First of all we compute the shadow value of the directional light to reduce the VGPR pressure</span><br>    <span class="hljs-comment">// 标注了使用LightLoop计算的类型的类型  通过LightFeature和Flag进行各种匹配。</span><br>    <span class="hljs-comment">// 这里表示这种材质类型需要计算直线光？？？</span><br>    <span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_DIRECTIONAL)<br>    &#123;<br>        <span class="hljs-comment">// Evaluate sun shadows.</span><br>        <span class="hljs-keyword">if</span> (_DirectionalShadowIndex &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            DirectionalLightData light = _DirectionalLightDatas[_DirectionalShadowIndex];<br><br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> this will cause us to load from the normal buffer first. Does this cause a performance problem?</span><br>            <span class="hljs-comment">// Also, the light direction is not consistent with the sun disk highlight hack, which modifies the light vector.</span><br>            <span class="hljs-type">float</span>  NdotL            = dot(bsdfData.normalWS, -light.forward);<br>            float3 shadowBiasNormal = GetNormalForShadowBias(bsdfData);<br>            <span class="hljs-type">bool</span>   evaluateShadows  = (NdotL &gt; <span class="hljs-number">0</span>);<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> MATERIAL_INCLUDE_TRANSMISSION</span><br>            <span class="hljs-keyword">if</span> (MaterialSupportsTransmission(bsdfData))<br>            &#123;<br>                <span class="hljs-comment">// We support some kind of transmission.</span><br>                <span class="hljs-keyword">if</span> (HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_TRANSMISSION_MODE_THIN_THICKNESS))<br>                &#123;<br>                    <span class="hljs-comment">// We always evaluate shadows.</span><br>                    evaluateShadows = <span class="hljs-literal">true</span>;<br><br>                    <span class="hljs-comment">// Care must be taken to bias in the direction of the light.</span><br>                    shadowBiasNormal *= FastSign(NdotL);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">// We only evaluate shadows for reflection, transmission shadows are handled separately.</span><br>                &#125;<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>            <span class="hljs-keyword">if</span> (evaluateShadows)<br>            &#123;<br>                context.shadowValue = EvaluateRuntimeSunShadow(context, posInput, light, shadowBiasNormal);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// This struct is define in the material. the Lightloop must not access it</span><br>    <span class="hljs-comment">// PostEvaluateBSDF call at the end will convert Lighting to diffuse and specular lighting</span><br>    AggregateLighting aggregateLighting;<br>    ZERO_INITIALIZE(AggregateLighting, aggregateLighting); <span class="hljs-comment">// LightLoop is in charge of initializing the struct</span><br><br>    uint i = <span class="hljs-number">0</span>; <span class="hljs-comment">// Declare once to avoid the D3D11 compiler warning.</span><br><br>    <span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_DIRECTIONAL)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; _DirectionalLightCount; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (IsMatchingLightLayer(_DirectionalLightDatas[i].lightLayers, builtinData.renderingLayers))<br>            &#123;<br>                DirectLighting lighting = EvaluateBSDF_Directional(context, V, posInput, preLightData, _DirectionalLightDatas[i], bsdfData, builtinData);<br>                AccumulateDirectLighting(lighting, aggregateLighting);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>     <span class="hljs-comment">// 这里表示这种材质类型需要计算PUNCTUAL光？？？</span><br>    <span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_PUNCTUAL)<br>    &#123;<br>        uint lightCount, lightStart;<br>        <span class="hljs-type">bool</span> fastPath = <span class="hljs-literal">false</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LIGHTLOOP_DISABLE_TILE_AND_CLUSTER</span><br>        GetCountAndStart(posInput, LIGHTCATEGORY_PUNCTUAL, lightStart, lightCount);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>        <span class="hljs-comment">// Fast path is when we all pixels in a wave are accessing same tile or cluster.</span><br>        uint lightStartLane0 = WaveReadLaneFirst(lightStart);<br>        fastPath = WaveActiveAllTrue(lightStart == lightStartLane0); <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span>   <span class="hljs-comment">// LIGHTLOOP_DISABLE_TILE_AND_CLUSTER</span></span><br>        lightCount = _PunctualLightCount;<br>        lightStart = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>        <span class="hljs-keyword">if</span> (fastPath)<br>        &#123;<br>            lightStart = lightStartLane0;<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">// Scalarized loop. All lights that are in a tile/cluster touched by any pixel in the wave are loaded (scalar load), only the one relevant to current thread/pixel are processed.</span><br>        <span class="hljs-comment">// For clarity, the following code will follow the convention: variables starting with s_ are meant to be wave uniform (meant for scalar register),</span><br>        <span class="hljs-comment">// v_ are variables that might have different value for each thread in the wave (meant for vector registers).</span><br>        <span class="hljs-comment">// This will perform more loads than it is supposed to, however, the benefits should offset the downside, especially given that light data accessed should be largely coherent.</span><br>        <span class="hljs-comment">// Note that the above is valid only if wave intriniscs are supported.</span><br>        uint v_lightListOffset = <span class="hljs-number">0</span>;<br>        uint v_lightIdx = lightStart;<br><br>        <span class="hljs-keyword">while</span> (v_lightListOffset &lt; lightCount)<br>        &#123;<br>            v_lightIdx = FetchIndex(lightStart, v_lightListOffset);<br>            uint s_lightIdx = v_lightIdx;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>            <span class="hljs-keyword">if</span> (!fastPath)<br>            &#123;<br>                <span class="hljs-comment">// If we are not in fast path, v_lightIdx is not scalar, so we need to query the Min value across the wave. </span><br>                s_lightIdx = WaveActiveMin(v_lightIdx);<br>                <span class="hljs-comment">// If WaveActiveMin returns 0xffffffff it means that all lanes are actually dead, so we can safely ignore the loop and move forward.</span><br>               <span class="hljs-comment">// This could happen as an helper lane could reach this point, hence having a valid v_lightIdx, but their values will be ignored by the WaveActiveMin</span><br>                <span class="hljs-keyword">if</span> (s_lightIdx == <span class="hljs-number">-1</span>)<br>                &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// Note that the WaveReadLaneFirst should not be needed, but the compiler might insist in putting the result in VGPR.</span><br>            <span class="hljs-comment">// However, we are certain at this point that the index is scalar.</span><br>            s_lightIdx = WaveReadLaneFirst(s_lightIdx);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>            LightData s_lightData = FetchLight(s_lightIdx);<br><br>            <span class="hljs-comment">// If current scalar and vector light index match, we process the light. The v_lightListOffset for current thread is increased.</span><br>            <span class="hljs-comment">// Note that the following should really be ==, however, since helper lanes are not considered by WaveActiveMin, such helper lanes could</span><br>            <span class="hljs-comment">// end up with a unique v_lightIdx value that is smaller than s_lightIdx hence being stuck in a loop. All the active lanes will not have this problem.</span><br>            <span class="hljs-keyword">if</span> (s_lightIdx &gt;= v_lightIdx)<br>            &#123;<br>                v_lightListOffset++;<br>                <span class="hljs-keyword">if</span> (IsMatchingLightLayer(s_lightData.lightLayers, builtinData.renderingLayers))<br>                &#123;<br>                    DirectLighting lighting = EvaluateBSDF_Punctual(context, V, posInput, preLightData, s_lightData, bsdfData, builtinData);<br>                    AccumulateDirectLighting(lighting, aggregateLighting);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <br>    <br>     <span class="hljs-comment">// 这里表示这种材质类型需要计算区域光？？？</span><br>    <span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_AREA)<br>    &#123;<br>        uint lightCount, lightStart;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LIGHTLOOP_DISABLE_TILE_AND_CLUSTER</span><br>        GetCountAndStart(posInput, LIGHTCATEGORY_AREA, lightStart, lightCount);<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        lightCount = _AreaLightCount;<br>        lightStart = _PunctualLightCount;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">// COMPILER BEHAVIOR WARNING!</span><br>        <span class="hljs-comment">// If rectangle lights are before line lights, the compiler will duplicate light matrices in VGPR because they are used differently between the two types of lights.</span><br>        <span class="hljs-comment">// By keeping line lights first we avoid this behavior and save substantial register pressure.</span><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This is based on the current Lit.shader and can be different for any other way of implementing area lights, how to be generic and ensure performance ?</span><br><br>        <span class="hljs-keyword">if</span> (lightCount &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            i = <span class="hljs-number">0</span>;<br><br>            uint      last      = lightCount - <span class="hljs-number">1</span>;<br>            LightData lightData = FetchLight(lightStart, i);<br><br>            <span class="hljs-keyword">while</span> (i &lt;= last &amp;&amp; lightData.lightType == GPULIGHTTYPE_TUBE)<br>            &#123;<br>                lightData.lightType = GPULIGHTTYPE_TUBE; <span class="hljs-comment">// Enforce constant propagation</span><br>                lightData.cookieIndex = <span class="hljs-number">-1</span>;              <span class="hljs-comment">// Enforce constant propagation</span><br><br>                <span class="hljs-keyword">if</span> (IsMatchingLightLayer(lightData.lightLayers, builtinData.renderingLayers))<br>                &#123;<br>                    DirectLighting lighting = EvaluateBSDF_Area(context, V, posInput, preLightData, lightData, bsdfData, builtinData);<br>                    AccumulateDirectLighting(lighting, aggregateLighting);<br>                &#125;<br><br>                lightData = FetchLight(lightStart, min(++i, last));<br>            &#125;<br><br>            <span class="hljs-keyword">while</span> (i &lt;= last) <span class="hljs-comment">// GPULIGHTTYPE_RECTANGLE</span><br>            &#123;<br>                lightData.lightType = GPULIGHTTYPE_RECTANGLE; <span class="hljs-comment">// Enforce constant propagation</span><br><br>                <span class="hljs-keyword">if</span> (IsMatchingLightLayer(lightData.lightLayers, builtinData.renderingLayers))<br>                &#123;<br>                    DirectLighting lighting = EvaluateBSDF_Area(context, V, posInput, preLightData, lightData, bsdfData, builtinData);<br>                    AccumulateDirectLighting(lighting, aggregateLighting);<br>                &#125;<br><br>                lightData = FetchLight(lightStart, min(++i, last));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Define macro for a better understanding of the loop</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> this code is now much harder to understand...</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVALUATE_BSDF_ENV_SKY(envLightData, TYPE, type) \</span><br><span class="hljs-meta">        IndirectLighting lighting = EvaluateBSDF_Env(context, V, posInput, preLightData, envLightData, bsdfData, envLightData.influenceShapeType, MERGE_NAME(GPUIMAGEBASEDLIGHTINGTYPE_, TYPE), MERGE_NAME(type, HierarchyWeight)); \</span><br><span class="hljs-meta">        AccumulateIndirectLighting(lighting, aggregateLighting);</span><br><br><span class="hljs-comment">// Environment cubemap test lightlayers, sky don&#x27;t test it</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVALUATE_BSDF_ENV(envLightData, TYPE, type) <span class="hljs-keyword">if</span> (IsMatchingLightLayer(envLightData.lightLayers, builtinData.renderingLayers)) &#123; EVALUATE_BSDF_ENV_SKY(envLightData, TYPE, type) &#125;</span><br><br>    <span class="hljs-comment">// First loop iteration</span><br>    <span class="hljs-comment">// 开启任何一个特殊效果：环境探针，天空球，屏幕空间反射，屏幕空间折射！！！</span><br>    <span class="hljs-keyword">if</span> (featureFlags &amp; (LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_SSREFRACTION | LIGHTFEATUREFLAGS_SSREFLECTION))<br>    &#123;<br>        <span class="hljs-type">float</span> reflectionHierarchyWeight = <span class="hljs-number">0.0</span>; <span class="hljs-comment">// Max: 1.0</span><br>        <span class="hljs-type">float</span> refractionHierarchyWeight = _EnableSSRefraction ? <span class="hljs-number">0.0</span> : <span class="hljs-number">1.0</span>; <span class="hljs-comment">// Max: 1.0</span><br><br>        uint envLightStart, envLightCount;<br><br>        <span class="hljs-type">bool</span> fastPath = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// Fetch first env light to provide the scene proxy for screen space computation</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LIGHTLOOP_DISABLE_TILE_AND_CLUSTER</span><br>        GetCountAndStart(posInput, LIGHTCATEGORY_ENV, envLightStart, envLightCount);<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>        <span class="hljs-comment">// Fast path is when we all pixels in a wave is accessing same tile or cluster.</span><br>        uint envStartFirstLane = WaveReadLaneFirst(envLightStart);<br>        fastPath = WaveActiveAllTrue(envLightStart == envStartFirstLane); <br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span>   <span class="hljs-comment">// LIGHTLOOP_DISABLE_TILE_AND_CLUSTER</span></span><br>        envLightCount = _EnvLightCount;<br>        envLightStart = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">// Reflection / Refraction hierarchy is</span><br>        <span class="hljs-comment">//  1. Screen Space Refraction / Reflection</span><br>        <span class="hljs-comment">//  2. Environment Reflection / Refraction</span><br>        <span class="hljs-comment">//  3. Sky Reflection / Refraction</span><br><br>        <span class="hljs-comment">// Apply SSR.</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(_SURFACE_TYPE_TRANSPARENT) &amp;&amp; !defined(_DISABLE_SSR)</span><br>        &#123;<br>            IndirectLighting indirect = EvaluateBSDF_ScreenSpaceReflection(posInput, preLightData, bsdfData,<br>                                                                           reflectionHierarchyWeight);<br>            AccumulateIndirectLighting(indirect, aggregateLighting);<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        EnvLightData envLightData;<br>        <span class="hljs-keyword">if</span> (envLightCount &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            envLightData = FetchEnvLight(envLightStart, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            envLightData = InitSkyEnvLightData(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 计算屏幕空间折射 需要开启屏幕空间折射</span><br>        <span class="hljs-keyword">if</span> ((featureFlags &amp; LIGHTFEATUREFLAGS_SSREFRACTION) &amp;&amp; (_EnableSSRefraction &gt; <span class="hljs-number">0</span>))<br>        &#123;<br>            IndirectLighting lighting = EvaluateBSDF_ScreenspaceRefraction(context, V, posInput, preLightData, bsdfData, envLightData, refractionHierarchyWeight);<br>            AccumulateIndirectLighting(lighting, aggregateLighting);<br>        &#125;<br><br>        <span class="hljs-comment">// Reflection probes are sorted by volume (in the increasing order).</span><br>        <br>     <span class="hljs-comment">// 这里表示这种材质类型需要计算环境光：反射探针？</span><br>        <span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_ENV)<br>        &#123;<br>            context.sampleReflection = SINGLE_PASS_CONTEXT_SAMPLE_REFLECTION_PROBES;<br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>            <span class="hljs-keyword">if</span> (fastPath)<br>            &#123;<br>                envLightStart = envStartFirstLane;<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>            <span class="hljs-comment">// Scalarized loop, same rationale of the punctual light version</span><br>            uint v_envLightListOffset = <span class="hljs-number">0</span>;<br>            uint v_envLightIdx = envLightStart;<br>            <span class="hljs-keyword">while</span> (v_envLightListOffset &lt; envLightCount)<br>            &#123;<br>                v_envLightIdx = FetchIndex(envLightStart, v_envLightListOffset);<br>                uint s_envLightIdx = v_envLightIdx;<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>                <span class="hljs-keyword">if</span> (!fastPath)<br>                &#123;<br>                    s_envLightIdx = WaveActiveMin(v_envLightIdx);<br>                    <span class="hljs-comment">// If we are not in fast path, s_envLightIdx is not scalar</span><br>                   <span class="hljs-comment">// If WaveActiveMin returns 0xffffffff it means that all lanes are actually dead, so we can safely ignore the loop and move forward.</span><br>                   <span class="hljs-comment">// This could happen as an helper lane could reach this point, hence having a valid v_lightIdx, but their values will be ignored by the WaveActiveMin</span><br>                    <span class="hljs-keyword">if</span> (s_envLightIdx == <span class="hljs-number">-1</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// Note that the WaveReadLaneFirst should not be needed, but the compiler might insist in putting the result in VGPR.</span><br>                <span class="hljs-comment">// However, we are certain at this point that the index is scalar.</span><br>                s_envLightIdx = WaveReadLaneFirst(s_envLightIdx);<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>                EnvLightData s_envLightData = FetchEnvLight(s_envLightIdx);    <span class="hljs-comment">// Scalar load.</span><br><br>                <span class="hljs-comment">// If current scalar and vector light index match, we process the light. The v_envLightListOffset for current thread is increased.</span><br>                <span class="hljs-comment">// Note that the following should really be ==, however, since helper lanes are not considered by WaveActiveMin, such helper lanes could</span><br>                <span class="hljs-comment">// end up with a unique v_envLightIdx value that is smaller than s_envLightIdx hence being stuck in a loop. All the active lanes will not have this problem.</span><br>                <span class="hljs-keyword">if</span> (s_envLightIdx &gt;= v_envLightIdx)<br>                &#123;<br>                    v_envLightListOffset++;<br>                    <span class="hljs-keyword">if</span> (reflectionHierarchyWeight &lt; <span class="hljs-number">1.0</span>)<br>                    &#123;<br>                        EVALUATE_BSDF_ENV(s_envLightData, REFLECTION, reflection);<br>                    &#125;<br>                    <span class="hljs-comment">// Refraction probe and reflection probe will process exactly the same weight. It will be good for performance to be able to share this computation</span><br>                    <span class="hljs-comment">// However it is hard to deal with the fact that reflectionHierarchyWeight and refractionHierarchyWeight have not the same values, they are independent</span><br>                    <span class="hljs-comment">// The refraction probe is rarely used and happen only with sphere shape and high IOR. So we accept the slow path that use more simple code and</span><br>                    <span class="hljs-comment">// doesn&#x27;t affect the performance of the reflection which is more important.</span><br>                    <span class="hljs-comment">// We reuse LIGHTFEATUREFLAGS_SSREFRACTION flag as refraction is mainly base on the screen. Would be a waste to not use screen and only cubemap.</span><br>                    <span class="hljs-keyword">if</span> ((featureFlags &amp; LIGHTFEATUREFLAGS_SSREFRACTION) &amp;&amp; (refractionHierarchyWeight &lt; <span class="hljs-number">1.0</span>))<br>                    &#123;<br>                        EVALUATE_BSDF_ENV(s_envLightData, REFRACTION, refraction);<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Only apply the sky IBL if the sky texture is available</span><br>        <span class="hljs-keyword">if</span> ((featureFlags &amp; LIGHTFEATUREFLAGS_SKY) &amp;&amp; _EnvLightSkyEnabled)<br>        &#123;<br>            <span class="hljs-comment">// The sky is a single cubemap texture separate from the reflection probe texture array (different resolution and compression)</span><br>            context.sampleReflection = SINGLE_PASS_CONTEXT_SAMPLE_SKY;<br><br>            <span class="hljs-comment">// The sky data are generated on the fly so the compiler can optimize the code</span><br>            EnvLightData envLightSky = InitSkyEnvLightData(<span class="hljs-number">0</span>);<br><br>            <span class="hljs-comment">// Only apply the sky if we haven&#x27;t yet accumulated enough IBL lighting.</span><br>            <span class="hljs-keyword">if</span> (reflectionHierarchyWeight &lt; <span class="hljs-number">1.0</span>)<br>            &#123;<br>                EVALUATE_BSDF_ENV_SKY(envLightSky, REFLECTION, reflection);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> ((featureFlags &amp; LIGHTFEATUREFLAGS_SSREFRACTION) &amp;&amp; (refractionHierarchyWeight &lt; <span class="hljs-number">1.0</span>))<br>            &#123;<br>                EVALUATE_BSDF_ENV_SKY(envLightSky, REFRACTION, refraction);<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> EVALUATE_BSDF_ENV</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> EVALUATE_BSDF_ENV_SKY    </span><br><br>    <span class="hljs-comment">// Also Apply indiret diffuse (GI)</span><br>    <span class="hljs-comment">// PostEvaluateBSDF will perform any operation wanted by the material and sum everything into diffuseLighting and specularLighting</span><br>    PostEvaluateBSDF(   context, V, posInput, preLightData, bsdfData, builtinData, aggregateLighting,<br>                        diffuseLighting, specularLighting);<br><br>    <span class="hljs-comment">//ApplyDebug(context, posInput.positionWS, diffuseLighting, specularLighting);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面大概标注了主循环是什么，看起来很复杂，下面每一个部分诸葛分析。</p><p>##AggregateLighting</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DirectLighting</span></span><br><span class="hljs-class">&#123;</span><br>    float3 diffuse;<br>    float3 specular;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IndirectLighting</span></span><br><span class="hljs-class">&#123;</span><br>    float3 specularReflected;<br>    float3 specularTransmitted;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AggregateLighting</span></span><br><span class="hljs-class">&#123;</span><br>    DirectLighting   direct;<br>    IndirectLighting indirect;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LightFeature"><a href="#LightFeature" class="headerlink" title="LightFeature"></a>LightFeature</h2><p>在外部透明物体和不透明物体有不同的featureFlags:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIGHT_FEATURE_MASK_FLAGS (16773120)             111111111111000000000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIGHT_FEATURE_MASK_FLAGS_OPAQUE (16642048)      111111011111000000000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT (16510976) 111110111111000000000000</span><br><br></code></pre></td></tr></table></figure><p>在ShaderPassForward当中有这样一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _SURFACE_TYPE_TRANSPARENT</span><br>        uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_OPAQUE;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>主要用于标注不同光照计算的特性</p><p>使用的地方有限：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span> D:\srp\ScriptableRenderPipeline\com.unity.render-pipelines.high-definition\Runtime\Lighting\Deferred.shader:<br>  LightLoop(V, posInput, preLightData, bsdfData, builtinData, LIGHT_FEATURE_MASK_FLAGS_OPAQUE, diffuseLighting, specularLighting);<br><br><span class="hljs-number">2.</span> D:\srp\ScriptableRenderPipeline\com.unity.render-pipelines.high-definition\Runtime\Lighting\LightLoop\DeferredTile.shader:<br>  LightLoop(V, posInput, preLightData, bsdfData, builtinData, LIGHT_FEATURE_MASK_FLAGS_OPAQUE, diffuseLighting, specularLighting);<br><br><span class="hljs-number">3.</span> D:\srp\ScriptableRenderPipeline\com.unity.render-pipelines.high-definition\Runtime\RenderPipeline\ShaderPass\ShaderPassForward.hlsl:<br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _SURFACE_TYPE_TRANSPARENT</span><br>    uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_OPAQUE;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    float3 diffuseLighting;<br></code></pre></td></tr></table></figure><p>还找到了 下面一段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> uint kFeatureVariantFlags[NUM_FEATURE_VARIANTS] =<br>&#123;<br>    <span class="hljs-comment">// Precomputed illumination (no dynamic lights) for all material types</span><br>    <span class="hljs-comment">/*  0 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIAL_FEATURE_MASK_FLAGS,<br><br>    <span class="hljs-comment">/*  1 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/*  2 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_AREA | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/*  3 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/*  4 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/*  5 */</span> LIGHT_FEATURE_MASK_FLAGS_OPAQUE | MATERIALFEATUREFLAGS_LIT_STANDARD,<br><br>    <span class="hljs-comment">// Standard with SSS and Transmission</span><br>    <span class="hljs-comment">/*  6 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING | MATERIALFEATUREFLAGS_LIT_TRANSMISSION | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/*  7 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_AREA | MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING | MATERIALFEATUREFLAGS_LIT_TRANSMISSION | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/*  8 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING | MATERIALFEATUREFLAGS_LIT_TRANSMISSION | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/*  9 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING | MATERIALFEATUREFLAGS_LIT_TRANSMISSION | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 10 */</span> LIGHT_FEATURE_MASK_FLAGS_OPAQUE | MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING | MATERIALFEATUREFLAGS_LIT_TRANSMISSION | MATERIALFEATUREFLAGS_LIT_STANDARD,<br><br>    <span class="hljs-comment">// Anisotropy</span><br>    <span class="hljs-comment">/* 11 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | MATERIALFEATUREFLAGS_LIT_ANISOTROPY | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 12 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_AREA | MATERIALFEATUREFLAGS_LIT_ANISOTROPY | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 13 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_ANISOTROPY | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 14 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_ANISOTROPY | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 15 */</span> LIGHT_FEATURE_MASK_FLAGS_OPAQUE | MATERIALFEATUREFLAGS_LIT_ANISOTROPY | MATERIALFEATUREFLAGS_LIT_STANDARD,<br><br>    <span class="hljs-comment">// Standard with clear coat</span><br>    <span class="hljs-comment">/* 16 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | MATERIALFEATUREFLAGS_LIT_CLEAR_COAT | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 17 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_AREA | MATERIALFEATUREFLAGS_LIT_CLEAR_COAT | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 18 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_CLEAR_COAT | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 19 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_CLEAR_COAT | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 20 */</span> LIGHT_FEATURE_MASK_FLAGS_OPAQUE | MATERIALFEATUREFLAGS_LIT_CLEAR_COAT | MATERIALFEATUREFLAGS_LIT_STANDARD,<br><br>    <span class="hljs-comment">// Standard with Iridescence</span><br>    <span class="hljs-comment">/* 21 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | MATERIALFEATUREFLAGS_LIT_IRIDESCENCE | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 22 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_AREA | MATERIALFEATUREFLAGS_LIT_IRIDESCENCE | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 23 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_IRIDESCENCE | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 24 */</span> LIGHTFEATUREFLAGS_SKY | LIGHTFEATUREFLAGS_DIRECTIONAL | LIGHTFEATUREFLAGS_PUNCTUAL | LIGHTFEATUREFLAGS_ENV | LIGHTFEATUREFLAGS_SSREFLECTION | MATERIALFEATUREFLAGS_LIT_IRIDESCENCE | MATERIALFEATUREFLAGS_LIT_STANDARD,<br>    <span class="hljs-comment">/* 25 */</span> LIGHT_FEATURE_MASK_FLAGS_OPAQUE | MATERIALFEATUREFLAGS_LIT_IRIDESCENCE | MATERIALFEATUREFLAGS_LIT_STANDARD,<br><br>    <span class="hljs-comment">/* 26 */</span> LIGHT_FEATURE_MASK_FLAGS_OPAQUE | MATERIAL_FEATURE_MASK_FLAGS, <span class="hljs-comment">// Catch all case with MATERIAL_FEATURE_MASK_FLAGS is needed in case we disable material classification</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="直线光部分"><a href="#直线光部分" class="headerlink" title="直线光部分"></a>直线光部分</h2><p>下面对直线光部分的代码分析, <strong>因为直线光是全部照亮的所以不使用Tiled</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这个if用来计算直线光阴影： 输出到 context.shadowValue当中 </span><br><span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_DIRECTIONAL)<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     LIGHTFEATUREFLAGS_DIRECTIONAL         =          100000000000000</span><br><span class="hljs-comment">     LIGHT_FEATURE_MASK_FLAGS_OPAQUE       = 111111011111000000000000</span><br><span class="hljs-comment">     LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT  = 111110111111000000000000</span><br><span class="hljs-comment">    下面两个是透明和不透明支持不一样的,也就是：透明不支持反射，不透明不支持折射。</span><br><span class="hljs-comment">     LIGHTFEATUREFLAGS_SSREFRACTION        =       100000000000000000</span><br><span class="hljs-comment">     LIGHTFEATUREFLAGS_SSREFLECTION        =      1000000000000000000  </span><br><span class="hljs-comment">    */</span><br>&#123;<br>    <span class="hljs-comment">// Evaluate sun shadows.</span><br>    <span class="hljs-keyword">if</span> (_DirectionalShadowIndex &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 太阳光信息，_DirectionalShadowIndex说明见标题：_DirectionalShadowIndex。</span><br>        DirectionalLightData light = _DirectionalLightDatas[_DirectionalShadowIndex];<br><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> this will cause us to load from the normal buffer first. Does this cause a performance problem?</span><br>        <span class="hljs-comment">// Also, the light direction is not consistent with the sun disk highlight hack, which modifies the light vector.</span><br>        <span class="hljs-type">float</span>  NdotL            = dot(bsdfData.normalWS, -light.forward);<br>        float3 shadowBiasNormal = GetNormalForShadowBias(bsdfData);<br>        <span class="hljs-type">bool</span>   evaluateShadows  = (NdotL &gt; <span class="hljs-number">0</span>);  <span class="hljs-comment">// 只有迎光面需要计算阴影</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> MATERIAL_INCLUDE_TRANSMISSION</span><br>        <span class="hljs-keyword">if</span> (MaterialSupportsTransmission(bsdfData))<br>        &#123;<br>            <span class="hljs-comment">// We support some kind of transmission.</span><br>            <span class="hljs-keyword">if</span> (HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_TRANSMISSION_MODE_THIN_THICKNESS))<br>            &#123;<br>                <span class="hljs-comment">// We always evaluate shadows.</span><br>                evaluateShadows = <span class="hljs-literal">true</span>;<br><br>                <span class="hljs-comment">// Care must be taken to bias in the direction of the light.</span><br>                shadowBiasNormal *= FastSign(NdotL);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// We only evaluate shadows for reflection, transmission shadows are handled separately.</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-comment">// 计算阴影值</span><br>        <span class="hljs-keyword">if</span> (evaluateShadows)<br>        &#123;<br>            context.shadowValue = EvaluateRuntimeSunShadow(context, posInput, light, shadowBiasNormal);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// This struct is define in the material. the Lightloop must not access it</span><br><span class="hljs-comment">// PostEvaluateBSDF call at the end will convert Lighting to diffuse and specular lighting</span><br><span class="hljs-comment">// 主要用来积累计算不同的光照，内容见：AggregateLighting二级目录</span><br>AggregateLighting aggregateLighting;<br>ZERO_INITIALIZE(AggregateLighting, aggregateLighting); <br><br>uint i = <span class="hljs-number">0</span>; <br><br><span class="hljs-comment">// 积累直线光</span><br><span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_DIRECTIONAL)<br>&#123;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; _DirectionalLightCount; ++i)<br>    &#123;<br>        <span class="hljs-comment">// 光照层过滤，制定光照照在不同的物体上。</span><br>        <span class="hljs-keyword">if</span> (IsMatchingLightLayer(_DirectionalLightDatas[i].lightLayers, builtinData.renderingLayers))<br>        &#123;<br>            <span class="hljs-comment">// 这里是计算直线光  ，考虑一下Tiledlight在哪里产生作用？？</span><br>            DirectLighting lighting = EvaluateBSDF_Directional(context, V, posInput, preLightData, _DirectionalLightDatas[i], bsdfData, builtinData);<br>            <br>            <span class="hljs-comment">// 叠加光</span><br>            AccumulateDirectLighting(lighting, aggregateLighting);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>###_DirectionalShadowIndex</p><p>下面主要说明了_DirectionalShadowIndex是用来标注太阳光的索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">D:\srp\ScriptableRenderPipeline\com.unity.render-pipelines.high-definition\Runtime\Lighting\LightLoop\LightLoop.cs:<br> <span class="hljs-number">2605</span>                  <span class="hljs-keyword">if</span> (sunLightShadow)<br> <span class="hljs-number">2606</span>                  &#123;<br> <span class="hljs-number">2607</span>:                     cmd.SetGlobalInt(HDShaderIDs._DirectionalShadowIndex, m_CurrentShadowSortedSunLightIndex);<br> <span class="hljs-number">2608</span>                  &#125;<br> <span class="hljs-number">2609</span>                  <span class="hljs-keyword">else</span><br> <span class="hljs-number">2610</span>                  &#123;<br> <span class="hljs-number">2611</span>:                     cmd.SetGlobalInt(HDShaderIDs._DirectionalShadowIndex, <span class="hljs-number">-1</span>);<br> <span class="hljs-number">2612</span>                  &#125;<br></code></pre></td></tr></table></figure><p>###EvaluateBSDF_Directional</p><p>这个主要用来输入光源参数、材质参数，得到最终的光的颜色。</p><p>这个函数包含在各种光照模型中：</p><p>Hair.hlsl</p><p>Fabric.hlsl</p><p>AxF.hlsl</p><p>Lit.hlsl</p><p>StackLit.hlsl</p><p>这里先看Lit.hlsl当中如何实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>DirectLighting <span class="hljs-title function_">EvaluateBSDF_Directional</span><span class="hljs-params">(LightLoopContext lightLoopContext,</span><br><span class="hljs-params">                                        float3 V, PositionInputs posInput, PreLightData preLightData,</span><br><span class="hljs-params">                                        DirectionalLightData lightData, BSDFData bsdfData,</span><br><span class="hljs-params">                                        BuiltinData builtinData)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> ShadeSurface_Directional(lightLoopContext, posInput, builtinData, preLightData, lightData,<br>                                    bsdfData, bsdfData.normalWS, V);<br>&#125;<br></code></pre></td></tr></table></figure><p>再看头发</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">DirectLighting <span class="hljs-title function_">EvaluateBSDF_Directional</span><span class="hljs-params">(LightLoopContext lightLoopContext,</span><br><span class="hljs-params">                                        float3 V, PositionInputs posInput, PreLightData preLightData,</span><br><span class="hljs-params">                                        DirectionalLightData lightData, BSDFData bsdfData,</span><br><span class="hljs-params">                                        BuiltinData builtinData)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> ShadeSurface_Directional(lightLoopContext, posInput, builtinData, preLightData, lightData,<br>                                    bsdfData, bsdfData.normalWS, V);<br>&#125;<br></code></pre></td></tr></table></figure><p>他们都引入了一个ShadeSurface_Directional</p><h3 id="ShadeSurface-Directional"><a href="#ShadeSurface-Directional" class="headerlink" title="ShadeSurface_Directional"></a>ShadeSurface_Directional</h3><p>ShadeSurface_Directional在同一个函数当中。</p><p>Lighting\SurfaceShading.hlsl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c">DirectLighting <span class="hljs-title function_">ShadeSurface_Directional</span><span class="hljs-params">(LightLoopContext lightLoopContext,</span><br><span class="hljs-params">                                        PositionInputs posInput, BuiltinData builtinData,</span><br><span class="hljs-params">                                        PreLightData preLightData, DirectionalLightData light,</span><br><span class="hljs-params">                                        BSDFData bsdfData, float3 N, float3 V)</span><br>&#123;<br>    DirectLighting lighting;<br>    ZERO_INITIALIZE(DirectLighting, lighting);<br><br>    float3 L     = ComputeSunLightDirection(light, N, V);<br>    <span class="hljs-type">float</span>  NdotL = dot(N, L); <span class="hljs-comment">// Do not saturate</span><br><br>    <span class="hljs-comment">// Note: We use NdotL here to early out, but in case of clear coat this is not correct. But we are OK with this</span><br>    <span class="hljs-type">bool</span> surfaceReflection = NdotL &gt; <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// Caution: this function modifies N, NdotL, contactShadowIndex and shadowMaskSelector.</span><br>    float3 transmittance = PreEvaluateDirectionalLightTransmission(bsdfData, light, N, NdotL);<br><br>    float3 color; <span class="hljs-type">float</span> attenuation;<br>    EvaluateLight_Directional(lightLoopContext, posInput, light, builtinData, N, L, NdotL,<br>                              color, attenuation);<br><br>    <span class="hljs-comment">// 这里就是根据雾的透视率和阴影计算光的颜色。</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> transmittance contributes to attenuation, how can we use it for early-out?</span><br>    <span class="hljs-keyword">if</span> (attenuation &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// We must clamp here, otherwise our disk light hack for smooth surfaces does not work.</span><br>        <span class="hljs-comment">// Explanation: for a perfectly smooth surface, lighting is only reflected if (NdotL = NdotV).</span><br>        <span class="hljs-comment">// This implies that (NdotH = 1).</span><br>        <span class="hljs-comment">// Due to the floating point arithmetic (see math in ComputeSunLightDirection() and</span><br>        <span class="hljs-comment">// GetBSDFAngle()), we will never arrive at this exact number, so no lighting will be reflected.</span><br>        <span class="hljs-comment">// If we increase the roughness somewhat, the trick still works.</span><br>        ClampRoughness(bsdfData, light.minRoughness);<br><br>        float3 diffuseBsdf, specularBsdf;<br>        BSDF(V, L, NdotL, posInput.positionWS, preLightData, bsdfData, diffuseBsdf, specularBsdf);<br><br>        <span class="hljs-comment">// 光的摄入方向。</span><br>        <span class="hljs-keyword">if</span> (surfaceReflection)<br>        &#123;<br>            attenuation    *= ComputeMicroShadowing(bsdfData, NdotL);<br>            <span class="hljs-type">float</span> intensity = attenuation * NdotL;<br><br>            lighting.diffuse  = diffuseBsdf  * (intensity * light.diffuseDimmer);<br>            lighting.specular = specularBsdf * (intensity * light.specularDimmer);<br>        &#125;<br>        <span class="hljs-comment">// 光在反面同时开启了透射。</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (MaterialSupportsTransmission(bsdfData))<br>        &#123;<br>             <span class="hljs-comment">// Apply wrapped lighting to better handle thin objects at grazing angles.</span><br>            <span class="hljs-comment">// 如果是材质支持透视？  则启用边缘光。</span><br>            <span class="hljs-type">float</span> wrapNdotL = ComputeWrappedDiffuseLighting(NdotL, TRANSMISSION_WRAP_LIGHT);<br>            <span class="hljs-type">float</span> intensity = attenuation * wrapNdotL;<br><br>            <span class="hljs-comment">// We use diffuse lighting for accumulation since it is going to be blurred during the SSS pass.</span><br>            <span class="hljs-comment">// Note: Disney&#x27;s LdoV term in &#x27;diffuseBsdf&#x27; does not hold a meaningful value</span><br>            <span class="hljs-comment">// in the context of transmission, but we keep it unaltered for performance reasons.</span><br>            lighting.diffuse  = transmittance * (diffuseBsdf * (intensity * light.diffuseDimmer));<br>            <span class="hljs-comment">// 高光没有透射光。</span><br>            lighting.specular = <span class="hljs-number">0</span>; <span class="hljs-comment">// No spec trans, the compiler should optimize</span><br>        &#125;<br><br>        <span class="hljs-comment">// Save ALU by applying light and cookie colors only once.</span><br>        lighting.diffuse  *= color;<br>        lighting.specular *= color;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> lighting;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="EvaluateLight-Directional"><a href="#EvaluateLight-Directional" class="headerlink" title="EvaluateLight_Directional"></a>EvaluateLight_Directional</h3><p>用来计算光,输入位置 ，光线，纹理和方向信息，输出光的颜色和衰减。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">EvaluateLight_Directional</span><span class="hljs-params">(LightLoopContext lightLoopContext, PositionInputs posInput,</span><br><span class="hljs-params">                               DirectionalLightData light, BuiltinData builtinData,</span><br><span class="hljs-params">                               float3 N, float3 L, <span class="hljs-type">float</span> NdotL,</span><br><span class="hljs-params">                               out float3 color, out <span class="hljs-type">float</span> attenuation)</span><br>&#123;<br>    <span class="hljs-comment">//light 信息是从外部C#设置的</span><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-comment">// 衰减由阴影和雾影响，颜色是Cookie</span><br>    color = attenuation = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// early Out  背面 和 光颜色削减为0  不进行光照。</span><br>    <span class="hljs-keyword">if</span> ((light.lightDimmer &lt;= <span class="hljs-number">0</span>) || (NdotL &lt;= <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 没有阴影开始</span><br>    float3 positionWS = posInput.positionWS;<br>    <span class="hljs-type">float</span>  shadow     = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">float</span>  shadowMask = <span class="hljs-number">1.0</span>;<br><br>    <span class="hljs-comment">// 读取光的信息 ，开始没有衰减</span><br>    color       = light.color;<br>    attenuation = <span class="hljs-number">1.0</span>;<br><br>    <span class="hljs-comment">// Height fog attenuation. 根据高度雾计算光照衰减。</span><br>    &#123;<br>        <span class="hljs-type">float</span> cosZenithAngle = L.y;<br>        <span class="hljs-type">float</span> fragmentHeight = posInput.positionWS.y;<br>        attenuation *= TransmittanceHeightFog(_HeightFogBaseExtinction, _HeightFogBaseHeight,<br>                                              _HeightFogExponents, cosZenithAngle, fragmentHeight);<br>    &#125;<br><br>    <span class="hljs-comment">// cookie 纹理</span><br>    <span class="hljs-keyword">if</span> (light.cookieIndex &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        float3 lightToSample = positionWS - light.positionRWS;<br>        float3 cookie = EvaluateCookie_Directional(lightLoopContext, light, lightToSample);<br><br>        color *= cookie; <span class="hljs-comment">// 用cookie衰减纹理。</span><br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SHADOWS_SHADOWMASK</span><br>    <span class="hljs-comment">// shadowMaskSelector.x is -1 if there is no shadow mask</span><br>    <span class="hljs-comment">// Note that we override shadow value (in case we don&#x27;t have any dynamic shadow)</span><br>    shadow = shadowMask = (light.shadowMaskSelector.x &gt;= <span class="hljs-number">0.0</span>) ? dot(BUILTIN_DATA_SHADOW_MASK, light.shadowMaskSelector) : <span class="hljs-number">1.0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">if</span> ((light.shadowIndex &gt;= <span class="hljs-number">0</span>) &amp;&amp; (light.shadowDimmer &gt; <span class="hljs-number">0</span>))<br>    &#123;<br>        shadow = lightLoopContext.shadowValue;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SHADOWS_SHADOWMASK</span><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Optimize this code! Currently it is a bit like brute force to get the last transistion and fade to shadow mask, but there is</span><br>        <span class="hljs-comment">// certainly more efficient to do</span><br>        <span class="hljs-comment">// We reuse the transition from the cascade system to fade between shadow mask at max distance</span><br>        uint  payloadOffset;<br>        real  fade;<br>        <span class="hljs-type">int</span> cascadeCount;<br>        <span class="hljs-type">int</span> shadowSplitIndex = <span class="hljs-number">0</span>;<br><br>        shadowSplitIndex = EvalShadow_GetSplitIndex(lightLoopContext.shadowContext, light.shadowIndex, positionWS, fade, cascadeCount);<br><br>        <span class="hljs-comment">// we have a fade caclulation for each cascade but we must lerp with shadow mask only for the last one</span><br>        <span class="hljs-comment">// if shadowSplitIndex is -1 it mean we are outside cascade and should return 1.0 to use shadowmask: saturate(-shadowSplitIndex) return 0 for &gt;= 0 and 1 for -1</span><br>        fade = ((shadowSplitIndex + <span class="hljs-number">1</span>) == cascadeCount) ? fade : saturate(-shadowSplitIndex);<br><br>        <span class="hljs-comment">// In the transition code (both dithering and blend) we use shadow = lerp( shadow, 1.0, fade ) for last transition</span><br>        <span class="hljs-comment">// mean if we expend the code we have (shadow * (1 - fade) + fade). Here to make transition with shadow mask</span><br>        <span class="hljs-comment">// we will remove fade and add fade * shadowMask which mean we do a lerp with shadow mask</span><br>        shadow = shadow - fade + fade * shadowMask;<br><br>        <span class="hljs-comment">// See comment in EvaluateBSDF_Punctual</span><br>        shadow = light.nonLightMappedOnly ? min(shadowMask, shadow) : shadow;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        shadow = lerp(shadowMask, shadow, light.shadowDimmer);<br>    &#125;<br><br>    <span class="hljs-comment">// Transparents have no contact shadow information</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _SURFACE_TYPE_TRANSPARENT</span><br>    shadow = min(shadow, GetContactShadow(lightLoopContext, light.contactShadowIndex));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br>    attenuation *= shadow;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Point-和-Spot"><a href="#Point-和-Spot" class="headerlink" title="Point 和 Spot"></a>Point 和 Spot</h2><p>这两种灯光和距离相关，同时需要用到Tiled</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_PUNCTUAL)<br>&#123;<br>    uint lightCount, lightStart;<br>    <span class="hljs-type">bool</span> fastPath = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LIGHTLOOP_DISABLE_TILE_AND_CLUSTER</span><br>    GetCountAndStart(posInput, LIGHTCATEGORY_PUNCTUAL, lightStart, lightCount);<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>    <span class="hljs-comment">// Fast path is when we all pixels in a wave are accessing same tile or cluster.</span><br>    uint lightStartLane0 = WaveReadLaneFirst(lightStart);<br>    fastPath = WaveActiveAllTrue(lightStart == lightStartLane0); <br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span>   <span class="hljs-comment">// LIGHTLOOP_DISABLE_TILE_AND_CLUSTER</span></span><br>    lightCount = _PunctualLightCount;<br>    lightStart = <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>    <span class="hljs-keyword">if</span> (fastPath)<br>    &#123;<br>        lightStart = lightStartLane0;<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// Scalarized loop. All lights that are in a tile/cluster touched by any pixel in the wave are loaded (scalar load), only the one relevant to current thread/pixel are processed.</span><br>    <span class="hljs-comment">// For clarity, the following code will follow the convention: variables starting with s_ are meant to be wave uniform (meant for scalar register),</span><br>    <span class="hljs-comment">// v_ are variables that might have different value for each thread in the wave (meant for vector registers).</span><br>    <span class="hljs-comment">// This will perform more loads than it is supposed to, however, the benefits should offset the downside, especially given that light data accessed should be largely coherent.</span><br>    <span class="hljs-comment">// Note that the above is valid only if wave intriniscs are supported.</span><br>    uint v_lightListOffset = <span class="hljs-number">0</span>;<br>    uint v_lightIdx = lightStart;<br><br>    <span class="hljs-keyword">while</span> (v_lightListOffset &lt; lightCount)<br>    &#123;<br>        v_lightIdx = FetchIndex(lightStart, v_lightListOffset);<br>        uint s_lightIdx = v_lightIdx;<br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> SCALARIZE_LIGHT_LOOP</span><br>        <span class="hljs-keyword">if</span> (!fastPath)<br>        &#123;<br>            <span class="hljs-comment">// If we are not in fast path, v_lightIdx is not scalar, so we need to query the Min value across the wave. </span><br>            s_lightIdx = WaveActiveMin(v_lightIdx);<br>            <span class="hljs-comment">// If WaveActiveMin returns 0xffffffff it means that all lanes are actually dead, so we can safely ignore the loop and move forward.</span><br>            <span class="hljs-comment">// This could happen as an helper lane could reach this point, hence having a valid v_lightIdx, but their values will be ignored by the WaveActiveMin</span><br>            <span class="hljs-keyword">if</span> (s_lightIdx == <span class="hljs-number">-1</span>)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// Note that the WaveReadLaneFirst should not be needed, but the compiler might insist in putting the result in VGPR.</span><br>        <span class="hljs-comment">// However, we are certain at this point that the index is scalar.</span><br>        s_lightIdx = WaveReadLaneFirst(s_lightIdx);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <br>        <span class="hljs-comment">// 上面一部分计算应该是 光源计算的Tiled算法有关。，这里获取到光照信息。</span><br>        LightData s_lightData = FetchLight(s_lightIdx);<br><br>        <span class="hljs-comment">// If current scalar and vector light index match, we process the light. The v_lightListOffset for current thread is increased.</span><br>        <span class="hljs-comment">// Note that the following should really be ==, however, since helper lanes are not considered by WaveActiveMin, such helper lanes could</span><br>        <span class="hljs-comment">// end up with a unique v_lightIdx value that is smaller than s_lightIdx hence being stuck in a loop. All the active lanes will not have this problem.</span><br>        <span class="hljs-keyword">if</span> (s_lightIdx &gt;= v_lightIdx)<br>        &#123;<br>            v_lightListOffset++;<br>            <span class="hljs-keyword">if</span> (IsMatchingLightLayer(s_lightData.lightLayers, builtinData.renderingLayers))<br>            &#123;<br>                DirectLighting lighting = EvaluateBSDF_Punctual(context, V, posInput, preLightData, s_lightData, bsdfData, builtinData);<br>                AccumulateDirectLighting(lighting, aggregateLighting);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="ShadeSurface-Punctual"><a href="#ShadeSurface-Punctual" class="headerlink" title="ShadeSurface_Punctual"></a>ShadeSurface_Punctual</h3><p>这个函数和指向光部分的一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c">DirectLighting <span class="hljs-title function_">ShadeSurface_Punctual</span><span class="hljs-params">(LightLoopContext lightLoopContext,</span><br><span class="hljs-params">                                     PositionInputs posInput, BuiltinData builtinData,</span><br><span class="hljs-params">                                     PreLightData preLightData, LightData light,</span><br><span class="hljs-params">                                     BSDFData bsdfData, float3 N, float3 V)</span><br>&#123;<br>    DirectLighting lighting;<br>    ZERO_INITIALIZE(DirectLighting, lighting);<br><br>    float3 L;<br>    float3 lightToSample;<br>    float4 distances; <span class="hljs-comment">// &#123;d, d^2, 1/d, d_proj&#125;</span><br>    GetPunctualLightVectors(posInput.positionWS, light, L, lightToSample, distances);<br><br>    <span class="hljs-type">float</span> NdotL = dot(N, L); <span class="hljs-comment">// Do not saturate</span><br><br>    <span class="hljs-comment">// Note: We use NdotL here to early out, but in case of clear coat this is not correct. But we are OK with this</span><br>    <span class="hljs-type">bool</span> surfaceReflection = NdotL &gt; <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// Caution: this function modifies N, NdotL, shadowIndex, contactShadowIndex and shadowMaskSelector. </span><br>    <span class="hljs-comment">// 计算光照投射</span><br>    float3 transmittance = PreEvaluatePunctualLightTransmission(lightLoopContext, posInput, bsdfData,<br>                                                                light, distances.x, N, L, NdotL);<br>    float3 color; <span class="hljs-type">float</span> attenuation;<br>    EvaluateLight_Punctual(lightLoopContext, posInput, light, builtinData, N, L, NdotL, lightToSample, distances,<br>                           color, attenuation);<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> transmittance contributes to attenuation, how can we use it for early-out?</span><br>    <span class="hljs-keyword">if</span> (attenuation &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// Simulate a sphere/disk light with this hack</span><br>        <span class="hljs-comment">// Note that it is not correct with our pre-computation of PartLambdaV (mean if we disable the optimization we will not have the</span><br>        <span class="hljs-comment">// same result) but we don&#x27;t care as it is a hack anyway</span><br>        ClampRoughness(bsdfData, light.minRoughness);<br><br>        float3 diffuseBsdf, specularBsdf;<br>        BSDF(V, L, NdotL, posInput.positionWS, preLightData, bsdfData, diffuseBsdf, specularBsdf);<br><br>        <span class="hljs-keyword">if</span> (surfaceReflection)<br>        &#123;<br>            <span class="hljs-type">float</span> intensity = attenuation * NdotL;<br><br>            lighting.diffuse  = diffuseBsdf  * (intensity * light.diffuseDimmer);<br>            lighting.specular = specularBsdf * (intensity * light.specularDimmer);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (MaterialSupportsTransmission(bsdfData))<br>        &#123;<br>             <span class="hljs-comment">// Apply wrapped lighting to better handle thin objects at grazing angles.</span><br>            <span class="hljs-type">float</span> wrapNdotL = ComputeWrappedDiffuseLighting(NdotL, TRANSMISSION_WRAP_LIGHT);<br>            <span class="hljs-type">float</span> intensity = attenuation * wrapNdotL;<br><br>            <span class="hljs-comment">// We use diffuse lighting for accumulation since it is going to be blurred during the SSS pass.</span><br>            <span class="hljs-comment">// Note: Disney&#x27;s LdoV term in &#x27;diffuseBsdf&#x27; does not hold a meaningful value</span><br>            <span class="hljs-comment">// in the context of transmission, but we keep it unaltered for performance reasons.</span><br>            lighting.diffuse  = transmittance * (diffuseBsdf * (intensity * light.diffuseDimmer));<br>            lighting.specular = <span class="hljs-number">0</span>; <span class="hljs-comment">// No spec trans, the compiler should optimize</span><br>        &#125;<br><br>        <span class="hljs-comment">// Save ALU by applying light and cookie colors only once.</span><br>        lighting.diffuse  *= color;<br>        lighting.specular *= color;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> lighting;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="PreEvaluatePunctualLightTransmission"><a href="#PreEvaluatePunctualLightTransmission" class="headerlink" title="PreEvaluatePunctualLightTransmission"></a>PreEvaluatePunctualLightTransmission</h3><p>这个函数用来计算光照的透射度，可能会修改法线。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// This function return transmittance to provide to EvaluateTransmission</span><br>float3 <span class="hljs-title function_">PreEvaluatePunctualLightTransmission</span><span class="hljs-params">(LightLoopContext lightLoopContext,</span><br><span class="hljs-params">                                            PositionInputs posInput, BSDFData bsdfData,</span><br><span class="hljs-params">                                            inout LightData light, <span class="hljs-type">float</span> distFrontFaceToLight,</span><br><span class="hljs-params">                                            inout float3 N, float3 L, inout <span class="hljs-type">float</span> NdotL)</span><br>&#123;<br>    float3 transmittance = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 判断功能是否开启 如果材质没有包含透射 就没有透射</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> MATERIAL_INCLUDE_TRANSMISSION</span><br>    <span class="hljs-comment">// 判断材质是否支持</span><br>    <span class="hljs-keyword">if</span> (MaterialSupportsTransmission(bsdfData))<br>    &#123;<br>        <span class="hljs-comment">// We support some kind of transmission.</span><br>        <span class="hljs-comment">// 背面才会生效。</span><br>        <span class="hljs-keyword">if</span> (NdotL &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">// And since the light is back-facing, it&#x27;s active.</span><br>            <span class="hljs-comment">// Care must be taken to bias in the direction of the light.</span><br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> change the sign of the bias: faster &amp; uses fewer VGPRs.</span><br>            <span class="hljs-comment">//扭转法线！！！！！！！！</span><br>            N = -N;<br><br>            <span class="hljs-comment">// We want to evaluate cookies and light attenuation, so we flip NdotL.</span><br>            <span class="hljs-comment">// 扭转计算结果</span><br>            NdotL = -NdotL;<br><br>            <span class="hljs-comment">// However, we don&#x27;t want baked or contact shadows.</span><br>            <br>            <span class="hljs-comment">// 关闭阴影</span><br>            light.contactShadowIndex   = <span class="hljs-number">-1</span>;<br>            light.shadowMaskSelector.x = <span class="hljs-number">-1</span>;<br><br>            <span class="hljs-comment">// 材质的透视度。</span><br>            transmittance = bsdfData.transmittance;<br><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-keyword">if</span> (!HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_TRANSMISSION_MODE_THIN_THICKNESS) &amp;&amp; (light.shadowIndex &gt;= <span class="hljs-number">0</span>))<br>            &#123;<br>                <span class="hljs-comment">// We can compute thickness from shadow.</span><br>                <span class="hljs-comment">// Compute the distance from the light to the back face of the object along the light direction.</span><br>                <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> SHADOW BIAS.</span><br>                <span class="hljs-type">float</span> distBackFaceToLight = GetPunctualShadowClosestDistance(lightLoopContext.shadowContext, s_linear_clamp_sampler,<br>                                                                             posInput.positionWS, light.shadowIndex, L, light.positionRWS,<br>                                                                             light.lightType == GPULIGHTTYPE_POINT);<br><br>                <span class="hljs-comment">// Our subsurface scattering models use the semi-infinite planar slab assumption.</span><br>                <span class="hljs-comment">// Therefore, we need to find the thickness along the normal.</span><br>                <span class="hljs-comment">// Warning: based on the artist&#x27;s input, dependence on the NdotL has been disabled.</span><br>                <span class="hljs-type">float</span> thicknessInUnits       = (distFrontFaceToLight - distBackFaceToLight) <span class="hljs-comment">/* * -NdotL */</span>;<br>                <span class="hljs-type">float</span> thicknessInMeters      = thicknessInUnits * _WorldScales[bsdfData.diffusionProfile].x;<br>                <span class="hljs-type">float</span> thicknessInMillimeters = thicknessInMeters * MILLIMETERS_PER_METER;<br><br>                <span class="hljs-comment">// We need to make sure it&#x27;s not less than the baked thickness to minimize light leaking.</span><br>                <span class="hljs-type">float</span> thicknessDelta = max(<span class="hljs-number">0</span>, thicknessInMillimeters - bsdfData.thickness);<br><br>                float3 S = _ShapeParams[bsdfData.diffusionProfile].rgb;<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>                float3 expOneThird = <span class="hljs-built_in">exp</span>(((<span class="hljs-number">-1.0</span> / <span class="hljs-number">3.0</span>) * thicknessDelta) * S);<br>            <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>                <span class="hljs-comment">// Help the compiler. S is premultiplied by ((-1.0 / 3.0) * LOG2_E) on the CPU.</span><br>                float3 p = thicknessDelta * S;<br>                float3 expOneThird = exp2(p);<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>                <span class="hljs-comment">// Approximate the decrease of transmittance by e^(-1/3 * dt * S).</span><br>                transmittance *= expOneThird;<br><br>                <span class="hljs-comment">// Avoid double shadowing. <span class="hljs-doctag">TODO:</span> is there a faster option?</span><br>                light.shadowIndex = <span class="hljs-number">-1</span>;<br><br>                <span class="hljs-comment">// Note: we do not modify the distance to the light, or the light angle for the back face.</span><br>                <span class="hljs-comment">// This is a performance-saving optimization which makes sense as long as the thickness is small.</span><br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> transmittance;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区域光部分"><a href="#区域光部分" class="headerlink" title="区域光部分"></a>区域光部分</h2><p>##屏幕空间反射部分</p><h2 id="反射探针部分"><a href="#反射探针部分" class="headerlink" title="反射探针部分"></a>反射探针部分</h2><h2 id="天空球部分"><a href="#天空球部分" class="headerlink" title="天空球部分"></a>天空球部分</h2><h2 id="光照探针、lightmap"><a href="#光照探针、lightmap" class="headerlink" title="光照探针、lightmap"></a>光照探针、lightmap</h2><p>PostEvaluateBSDF计算了间接光</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PostEvaluateBSDF</span><span class="hljs-params">(  LightLoopContext lightLoopContext,</span><br><span class="hljs-params">                        float3 V, PositionInputs posInput,</span><br><span class="hljs-params">                        PreLightData preLightData, BSDFData bsdfData, BuiltinData builtinData, AggregateLighting lighting,</span><br><span class="hljs-params">                        out float3 diffuseLighting, out float3 specularLighting)</span><br>&#123;<br>    AmbientOcclusionFactor aoFactor;<br>    <span class="hljs-comment">// Use GTAOMultiBounce approximation for ambient occlusion (allow to get a tint from the baseColor)</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>    GetScreenSpaceAmbientOcclusion(posInput.positionSS, preLightData.NdotV, bsdfData.perceptualRoughness, bsdfData.ambientOcclusion, bsdfData.specularOcclusion, aoFactor);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    GetScreenSpaceAmbientOcclusionMultibounce(posInput.positionSS, preLightData.NdotV, bsdfData.perceptualRoughness, bsdfData.ambientOcclusion, bsdfData.specularOcclusion, bsdfData.diffuseColor, bsdfData.fresnel0, aoFactor);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">// AmbientOcclusion 技术需要了解一下</span><br>    ApplyAmbientOcclusionFactor(aoFactor, builtinData, lighting);<br><br>    <span class="hljs-comment">// Subsurface scattering mode</span><br>    <span class="hljs-comment">// SSS效果也是在这里应用的</span><br>    float3 modifiedDiffuseColor = GetModifiedDiffuseColorForSSS(bsdfData);<br><br>    <span class="hljs-comment">// Apply the albedo to the direct diffuse lighting (only once). The indirect (baked)</span><br>    <span class="hljs-comment">// diffuse lighting has already multiply the albedo in ModifyBakedDiffuseLighting().</span><br>    <span class="hljs-comment">// Note: In deferred bakeDiffuseLighting also contain emissive and in this case emissiveColor is 0</span><br>    <span class="hljs-comment">// 漫反射光包含了前面计算 经过模糊的SSS光， 烘焙的关照贴图和自发光。</span><br>    diffuseLighting = modifiedDiffuseColor * lighting.direct.diffuse + builtinData.bakeDiffuseLighting + builtinData.emissiveColor;<br><br>    <span class="hljs-comment">// If refraction is enable we use the transmittanceMask to lerp between current diffuse lighting and refraction value</span><br>    <span class="hljs-comment">// Physically speaking, transmittanceMask should be 1, but for artistic reasons, we let the value vary</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Note we also transfer the refracted light (lighting.indirect.specularTransmitted) into diffuseLighting</span><br>    <span class="hljs-comment">// since we know it won&#x27;t be further processed: it is called at the end of the LightLoop(), but doing this</span><br>    <span class="hljs-comment">// enables opacity to affect it (in ApplyBlendMode()) while the rest of specularLighting escapes it.</span><br>    <br>    <span class="hljs-comment">// 如果有折射则还需要和折射进行混合</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> HAS_REFRACTION</span><br>    diffuseLighting = lerp(diffuseLighting, lighting.indirect.specularTransmitted, bsdfData.transmittanceMask * _EnableSSRefraction);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 高光部分，直接高光，反射探针。</span><br>    specularLighting = lighting.direct.specular + lighting.indirect.specularReflected;<br>    <span class="hljs-comment">// Rescale the GGX to account for the multiple scattering.</span><br>    specularLighting *= <span class="hljs-number">1.0</span> + bsdfData.fresnel0 * preLightData.energyCompensation;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="GetPreLightData"><a href="#GetPreLightData" class="headerlink" title="GetPreLightData"></a>GetPreLightData</h2><p>预光照信息，保存了能量守恒等各种系数，一次性计算在后面需要的时候一次性使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>PreLightData <span class="hljs-title function_">GetPreLightData</span><span class="hljs-params">(float3 V, PositionInputs posInput, inout BSDFData bsdfData)</span><br>&#123;<br>    PreLightData preLightData;<br>    ZERO_INITIALIZE(PreLightData, preLightData);<br><br>    float3 N = bsdfData.normalWS;<br>    preLightData.NdotV = dot(N, V);<br>    preLightData.iblPerceptualRoughness = bsdfData.perceptualRoughness;<br><br>    <span class="hljs-type">float</span> NdotV = ClampNdotV(preLightData.NdotV);<br><br>    <span class="hljs-comment">// We modify the bsdfData.fresnel0 here for iridescence</span><br>    <span class="hljs-comment">// 修改frenel0是为了得到彩虹色高光效果。</span><br>    <span class="hljs-keyword">if</span> (HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_LIT_IRIDESCENCE))<br>    &#123;<br>        <span class="hljs-type">float</span> viewAngle = NdotV;<br>        <span class="hljs-type">float</span> topIor = <span class="hljs-number">1.0</span>; <span class="hljs-comment">// Default is air</span><br>        <span class="hljs-keyword">if</span> (HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_LIT_CLEAR_COAT))<br>        &#123;<br>            topIor = lerp(<span class="hljs-number">1.0</span>, CLEAR_COAT_IOR, bsdfData.coatMask);<br>            <span class="hljs-comment">// <span class="hljs-doctag">HACK:</span> Use the reflected direction to specify the Fresnel coefficient for pre-convolved envmaps</span><br>            viewAngle = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> + Sq(<span class="hljs-number">1.0</span> / topIor) * (Sq(dot(bsdfData.normalWS, V)) - <span class="hljs-number">1.0</span>));<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (bsdfData.iridescenceMask &gt; <span class="hljs-number">0.0</span>)<br>        &#123;<br>            bsdfData.fresnel0 = lerp(bsdfData.fresnel0, EvalIridescence(topIor, viewAngle, bsdfData.iridescenceThickness, bsdfData.fresnel0), bsdfData.iridescenceMask);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 修改fresnel0为了clearcoat效果</span><br>    <span class="hljs-comment">// We modify the bsdfData.fresnel0 here for clearCoat</span><br>    <span class="hljs-keyword">if</span> (HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_LIT_CLEAR_COAT))<br>    &#123;<br>        <span class="hljs-comment">// Fresnel0 is deduced from interface between air and material (Assume to be 1.5 in Unity, or a metal).</span><br>        <span class="hljs-comment">// but here we go from clear coat (1.5) to material, we need to update fresnel0</span><br>        <span class="hljs-comment">// Note: Schlick is a poor approximation of Fresnel when ieta is 1 (1.5 / 1.5), schlick target 1.4 to 2.2 IOR.</span><br>        bsdfData.fresnel0 = lerp(bsdfData.fresnel0, ConvertF0ForAirInterfaceToF0ForClearCoat15(bsdfData.fresnel0), bsdfData.coatMask);<br><br>        preLightData.coatPartLambdaV = GetSmithJointGGXPartLambdaV(NdotV, CLEAR_COAT_ROUGHNESS);<br>        preLightData.coatIblR = reflect(-V, N);<br>        preLightData.coatIblF = F_Schlick(CLEAR_COAT_F0, NdotV) * bsdfData.coatMask;<br>    &#125;<br><br>    <span class="hljs-comment">// Handle IBL + area light + multiscattering.</span><br>    <span class="hljs-comment">// Note: use the not modified by anisotropy iblPerceptualRoughness here.</span><br>    <span class="hljs-type">float</span> specularReflectivity;<br>    GetPreIntegratedFGDGGXAndDisneyDiffuse(NdotV, preLightData.iblPerceptualRoughness, bsdfData.fresnel0, preLightData.specularFGD, preLightData.diffuseFGD, specularReflectivity);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_DIFFUSE_LAMBERT_BRDF</span><br>    preLightData.diffuseFGD = <span class="hljs-number">1.0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LIT_USE_GGX_ENERGY_COMPENSATION</span><br>    <span class="hljs-comment">// Ref: Practical multiple scattering compensation for microfacet models.</span><br>    <span class="hljs-comment">// We only apply the formulation for metals.</span><br>    <span class="hljs-comment">// For dielectrics, the change of reflectance is negligible.</span><br>    <span class="hljs-comment">// We deem the intensity difference of a couple of percent for high values of roughness</span><br>    <span class="hljs-comment">// to not be worth the cost of another precomputed table.</span><br>    <span class="hljs-comment">// Note: this formulation bakes the BSDF non-symmetric!</span><br>    preLightData.energyCompensation = <span class="hljs-number">1.0</span> / specularReflectivity - <span class="hljs-number">1.0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    preLightData.energyCompensation = <span class="hljs-number">0.0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// LIT_USE_GGX_ENERGY_COMPENSATION</span></span><br><br>    float3 iblN;<br><br>    <span class="hljs-comment">// We avoid divergent evaluation of the GGX, as that nearly doubles the cost.</span><br>    <span class="hljs-comment">// If the tile has anisotropy, all the pixels within the tile are evaluated as anisotropic.</span><br>    <span class="hljs-keyword">if</span> (HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_LIT_ANISOTROPY))<br>    &#123;<br>        <span class="hljs-type">float</span> TdotV = dot(bsdfData.tangentWS,   V);<br>        <span class="hljs-type">float</span> BdotV = dot(bsdfData.bitangentWS, V);<br><br>        preLightData.partLambdaV = GetSmithJointGGXAnisoPartLambdaV(TdotV, BdotV, NdotV, bsdfData.roughnessT, bsdfData.roughnessB);<br><br>        <span class="hljs-comment">// perceptualRoughness is use as input and output here</span><br>        GetGGXAnisotropicModifiedNormalAndRoughness(bsdfData.bitangentWS, bsdfData.tangentWS, N, V, bsdfData.anisotropy, preLightData.iblPerceptualRoughness, iblN, preLightData.iblPerceptualRoughness);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        preLightData.partLambdaV = GetSmithJointGGXPartLambdaV(NdotV, bsdfData.roughnessT);<br>        iblN = N;<br>    &#125;<br><br>    preLightData.iblR = reflect(-V, iblN);<br><br>    <span class="hljs-comment">// Area light</span><br>    <span class="hljs-comment">// UVs for sampling the LUTs</span><br>    <span class="hljs-type">float</span> theta = FastACosPos(NdotV); <span class="hljs-comment">// For Area light - UVs for sampling the LUTs</span><br>    float2 uv = Remap01ToHalfTexelCoord(float2(bsdfData.perceptualRoughness, theta * INV_HALF_PI), LTC_LUT_SIZE);<br><br>    <span class="hljs-comment">// Note we load the matrix transpose (avoid to have to transpose it in shader)</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_DIFFUSE_LAMBERT_BRDF</span><br>    preLightData.ltcTransformDiffuse = k_identity3x3;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-comment">// Get the inverse LTC matrix for Disney Diffuse</span><br>    preLightData.ltcTransformDiffuse      = <span class="hljs-number">0.0</span>;<br>    preLightData.ltcTransformDiffuse._m22 = <span class="hljs-number">1.0</span>;<br>    preLightData.ltcTransformDiffuse._m00_m02_m11_m20 = SAMPLE_TEXTURE2D_ARRAY_LOD(_LtcData, s_linear_clamp_sampler, uv, LTC_DISNEY_DIFFUSE_MATRIX_INDEX, <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// Get the inverse LTC matrix for GGX</span><br>    <span class="hljs-comment">// Note we load the matrix transpose (avoid to have to transpose it in shader)</span><br>    preLightData.ltcTransformSpecular      = <span class="hljs-number">0.0</span>;<br>    preLightData.ltcTransformSpecular._m22 = <span class="hljs-number">1.0</span>;<br>    preLightData.ltcTransformSpecular._m00_m02_m11_m20 = SAMPLE_TEXTURE2D_ARRAY_LOD(_LtcData, s_linear_clamp_sampler, uv, LTC_GGX_MATRIX_INDEX, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// Construct a right-handed view-dependent orthogonal basis around the normal</span><br>    preLightData.orthoBasisViewNormal = GetOrthoBasisViewNormal(V, N, preLightData.NdotV);<br><br>    preLightData.ltcTransformCoat = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">if</span> (HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_LIT_CLEAR_COAT))<br>    &#123;<br>        float2 uv = LTC_LUT_OFFSET + LTC_LUT_SCALE * float2(CLEAR_COAT_PERCEPTUAL_ROUGHNESS, theta * INV_HALF_PI);<br><br>        <span class="hljs-comment">// Get the inverse LTC matrix for GGX</span><br>        <span class="hljs-comment">// Note we load the matrix transpose (avoid to have to transpose it in shader)</span><br>        preLightData.ltcTransformCoat._m22 = <span class="hljs-number">1.0</span>;<br>        preLightData.ltcTransformCoat._m00_m02_m11_m20 = SAMPLE_TEXTURE2D_ARRAY_LOD(_LtcData, s_linear_clamp_sampler, uv, LTC_GGX_MATRIX_INDEX, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// refraction (forward only)</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> HAS_REFRACTION</span><br>    RefractionModelResult refraction = REFRACTION_MODEL(V, posInput, bsdfData);<br>    preLightData.transparentRefractV = refraction.rayWS;<br>    preLightData.transparentPositionWS = refraction.positionWS;<br>    preLightData.transparentTransmittance = <span class="hljs-built_in">exp</span>(-bsdfData.absorptionCoefficient * refraction.dist);<br>    <span class="hljs-comment">// Empirical remap to try to match a bit the refraction probe blurring for the fallback</span><br>    <span class="hljs-comment">// Use IblPerceptualRoughness so we can handle approx of clear coat.</span><br>    preLightData.transparentSSMipLevel = PositivePow(preLightData.iblPerceptualRoughness, <span class="hljs-number">1.3</span>) * uint(max(_ColorPyramidScale.z - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> preLightData;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HairShader光照模型</title>
      <link href="/2023/06/02/Unity/HDRP%E4%B8%ADHairShader%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%842/"/>
      <url>/2023/06/02/Unity/HDRP%E4%B8%ADHairShader%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%842/</url>
      
        <content type="html"><![CDATA[<h3 id="HairShader光照模型"><a href="#HairShader光照模型" class="headerlink" title="HairShader光照模型"></a>HairShader光照模型</h3><p>创建ShaderGraph:</p><p>定义的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHADERPASS SHADERPASS_FORWARD</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ DEBUG_DISPLAY</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ LIGHTMAP_ON</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ DIRLIGHTMAP_COMBINED</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ DYNAMICLIGHTMAP_ON</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ SHADOWS_SHADOWMASK</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile DECALS_OFF DECALS_3RT DECALS_4RT</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH SHADOW_VERY_HIGH</span><br></code></pre></td></tr></table></figure><p>include文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;</span></span><br>        <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl&quot;</span></span><br>        <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl&quot;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl&quot;</span></span><br><br><span class="hljs-comment">// 这个在前面定义了</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (SHADERPASS == SHADERPASS_FORWARD)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl&quot;</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> HAS_LIGHTLOOP</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl&quot;</span></span><br></code></pre></td></tr></table></figure><p>和头发表面相关的参数，这个函数主要是ShaderGraph的输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">SurfaceDescription <span class="hljs-title function_">SurfaceDescriptionFunction</span><span class="hljs-params">(SurfaceDescriptionInputs IN)</span><br>&#123;<br>    SurfaceDescription surface = (SurfaceDescription)<span class="hljs-number">0</span>;<br>    surface.Albedo = float3(<span class="hljs-number">0.7353569</span>, <span class="hljs-number">0.7353569</span>, <span class="hljs-number">0.7353569</span>);<br>    surface.Normal = IN.TangentSpaceNormal;<br>    surface.BentNormal = IN.TangentSpaceNormal;<br>    surface.HairStrandDirection = float3 (<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>); <span class="hljs-comment">//头发走向</span><br>    surface.Occlusion = <span class="hljs-number">1</span>;<br>    surface.Alpha = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 用于就算高光的内容：高光的颜色，粗糙的，高光的Shift</span><br>    surface.SpecularTint = float3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    surface.Smoothness = <span class="hljs-number">0.5</span>;<br>    surface.SpecularShift = <span class="hljs-number">0.1</span>;<br>    <br>    surface.SecondarySpecularTint =  float3(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>) ;<br>    surface.SecondarySmoothness = <span class="hljs-number">0.5</span>;<br>    surface.SecondarySpecularShift = <span class="hljs-number">-0.1</span>;<br>    <span class="hljs-keyword">return</span> surface;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的的函数在GetSurfaceAndBuiltinData函数当中调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">GetSurfaceAndBuiltinData</span><span class="hljs-params">(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)</span><br>&#123;<br>    ...<br><br>    <span class="hljs-comment">// 双面处理</span><br>    float3 doubleSidedConstants = float3(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br>    ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);<br><br>    <span class="hljs-comment">// 基本的Normal 切线之类的</span><br>    SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);<br>    <br>    <span class="hljs-comment">// 表面信息 高光 粗糙度 从Graph当中读取</span><br>    SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);<br><br>    <span class="hljs-comment">// 将信息写入到 需要计算的两个结构体当中</span><br>    float3 bentNormalWS;<br>    BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);<br><br>    <span class="hljs-comment">// Builtin Data</span><br>    <span class="hljs-comment">// For back lighting we use the oposite vertex normal  背面的光使用相反的法线，主要用来采样GI？</span><br>    InitBuiltinData(surfaceDescription.Alpha, bentNormalWS, -fragInputs.worldToTangent[<span class="hljs-number">2</span>]<span class="hljs-comment">/*这部分内容是反向法线*/</span>, fragInputs.positionRWS, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);<br>        <br><br>    PostInitBuiltinData(V, posInput, surfaceData, builtinData);<br>&#125;<br></code></pre></td></tr></table></figure><p>BuilSurfaceData()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">BuildSurfaceData</span><span class="hljs-params">(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)</span><br>&#123;<br>   <span class="hljs-comment">// 初始化</span><br>    ZERO_INITIALIZE(SurfaceData, surfaceData);<br><br>    <span class="hljs-comment">// copy across graph values, if defined 直接复制ShaderGraph的内容</span><br>    surfaceData.diffuseColor =                  surfaceDescription.Albedo;<br>    surfaceData.ambientOcclusion =              surfaceDescription.Occlusion; <span class="hljs-comment">// AO</span><br><br>    <span class="hljs-comment">// 两组高光相关的内容</span><br>    surfaceData.perceptualSmoothness =          surfaceDescription.Smoothness; <span class="hljs-comment">// 粗糙度 </span><br>    surfaceData.specularTint =                  surfaceDescription.SpecularTint;<br>    surfaceData.specularShift =                 surfaceDescription.SpecularShift;<br><br>    surfaceData.secondaryPerceptualSmoothness = surfaceDescription.SecondarySmoothness;<br>    surfaceData.secondarySpecularTint =         surfaceDescription.SecondarySpecularTint;<br>    surfaceData.secondarySpecularShift =        surfaceDescription.SecondarySpecularShift;<br><br>    <span class="hljs-comment">// These static material feature allow compile time optimization</span><br>    surfaceData.materialFeatures = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 材质特性：头发的透光以及头发的 SSS效果</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _MATERIAL_FEATURE_HAIR_KAJIYA_KAY</span><br>    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _MATERIAL_FEATURE_SUBSURFACE_SCATTERING</span><br>    surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_SUBSURFACE_SCATTERING;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _MATERIAL_FEATURE_TRANSMISSION</span><br>    surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_TRANSMISSION;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br><br>    <span class="hljs-comment">// 法线 切线</span><br>    float3 doubleSidedConstants = float3(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-comment">// tangent-space normal</span><br>    float3 normalTS = float3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br>    normalTS = surfaceDescription.Normal;<br>    <span class="hljs-comment">// compute world space normal</span><br>    GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);<br>    bentNormalWS = surfaceData.normalWS;<br>    surfaceData.geomNormalWS = fragInputs.worldToTangent[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-comment">// For a typical Unity quad, you have tangent vectors pointing to the right (X axis),</span><br>    <span class="hljs-comment">// and bitangent vectors pointing up (Y axis).</span><br>    <span class="hljs-comment">// The current hair setup uses mesh cards (e.g. quads).</span><br>    <span class="hljs-comment">// Hair is usually painted top-down, from the root to the tip.</span><br>    <span class="hljs-comment">// Therefore, DefaultHairStrandTangent = -MeshCardBitangent. // &lt;==这句话关键</span><br>    <span class="hljs-comment">// Both the SurfaceData and the BSDFData store the hair tangent</span><br>    <span class="hljs-comment">// (which represents the hair strand direction, root to tip). // 头发的方向</span><br>    surfaceData.hairStrandDirectionWS = -fragInputs.worldToTangent[<span class="hljs-number">1</span>].xyz;<br>    <span class="hljs-comment">// The hair strand direction texture contains tangent-space vectors.</span><br>    <span class="hljs-comment">// We use the same convention for the texture, which means that</span><br>    <span class="hljs-comment">// to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),</span><br>    <span class="hljs-comment">// the artist has to paint (0, -1, 0).</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> pending artist feedback...</span><br>    <span class="hljs-comment">// The original Kajiya-Kay BRDF model expects an orthonormal TN frame.</span><br>    <span class="hljs-comment">// Since we use the tangent shift hack </span><br>    <br>    <span class="hljs-comment">// 这个文档需要看一下</span><br>    <span class="hljs-comment">// (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),</span><br>    <span class="hljs-comment">// we may as well not bother to orthonormalize anymore.</span><br>    <span class="hljs-comment">// The tangent should still be a unit vector, though.</span><br>    surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);<br><br>    <span class="hljs-comment">// By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.</span><br>    <span class="hljs-comment">// If user provide bent normal then we process a better term</span><br>    surfaceData.specularOcclusion = <span class="hljs-number">1.0</span>;<br><br>    <span class="hljs-comment">// 下面有一部分是计算 specularOcclusion的</span><br>..........<br>        <br>    <span class="hljs-comment">// 下面是计算GAA的，后面需要看一下</span><br><br>    <span class="hljs-comment">// Propagate the geometry normal</span><br>    surfaceData.geomNormalWS = fragInputs.worldToTangent[<span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>其他部分的计算最终都会归结到BSDF函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void BSDF(  float3 V, float3 L, float NdotL, float3 positionWS, PreLightData preLightData, BSDFData bsdfData,<br>            out float3 diffuseLighting,<br>            out float3 specularLighting)<br>&#123;<br>//preLightData当中比较重要的就用到了NdotV<br>    float LdotV, NdotH, LdotH, NdotV, invLenLV;<br>    GetBSDFAngle(V, L, NdotL, preLightData.NdotV, LdotV, NdotH, LdotH, NdotV, invLenLV);<br><br>    if (HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY))<br>    &#123;<br>    // 颜色以高光为主<br>        float3 t1 = ShiftTangent(bsdfData.hairStrandDirectionWS, bsdfData.normalWS, bsdfData.specularShift);<br>        float3 t2 = ShiftTangent(bsdfData.hairStrandDirectionWS, bsdfData.normalWS, bsdfData.secondarySpecularShift);<br><br>        float3 H = (L + V) * invLenLV;<br><br>        float3 hairSpec1 = bsdfData.specularTint * D_KajiyaKay(t1, H, bsdfData.specularExponent);<br>        float3 hairSpec2 = bsdfData.secondarySpecularTint * D_KajiyaKay(t2, H, bsdfData.secondarySpecularExponent);<br><br>        float3 F = F_Schlick(bsdfData.fresnel0, LdotH);<br>        specularLighting = F * (hairSpec1 + hairSpec2);<br><br>        // Diffuse lighting<br>        // #define INV_PI      0.31830988618379067154<br>        float diffuseTerm = Lambert();  // 漫反射项的强度<br>        diffuseLighting = diffuseTerm;<br>    &#125;<br>    else<br>    &#123;<br>        specularLighting = float3(0.0, 0.0, 0.0);<br>        diffuseLighting = float3(0.0, 0.0, 0.0);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>高光</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 <span class="hljs-title function_">D_KajiyaKay</span><span class="hljs-params">(float3 T, float3 H, <span class="hljs-type">float</span> specularExponent)</span><br>&#123;<br>    <span class="hljs-type">float</span> TdotH = dot(T, H);<br>    <span class="hljs-type">float</span> sinTHSq = saturate(<span class="hljs-number">1.0</span> - (TdotH * TdotH));<br><br>    <span class="hljs-type">float</span> dirAttn = saturate(TdotH + <span class="hljs-number">1.0</span>);<br><br>    <span class="hljs-keyword">return</span> dirAttn * PositivePow(sinTHSq, specularExponent);<br>&#125;<br></code></pre></td></tr></table></figure><p>和BSDF相关的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// return usual BSDF angle</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">GetBSDFAngle</span><span class="hljs-params">(float3 V, float3 L, <span class="hljs-type">float</span> NdotL, <span class="hljs-type">float</span> unclampNdotV, out <span class="hljs-type">float</span> LdotV, out <span class="hljs-type">float</span> NdotH, out <span class="hljs-type">float</span> LdotH, out <span class="hljs-type">float</span> clampNdotV, out <span class="hljs-type">float</span> invLenLV)</span><br>&#123;<br>    <span class="hljs-comment">// Optimized math. Ref: PBR Diffuse Lighting for GGX + Smith Microsurfaces (slide 114).</span><br>    LdotV = dot(L, V);<br>    invLenLV = rsqrt(max(<span class="hljs-number">2.0</span> * LdotV + <span class="hljs-number">2.0</span>, FLT_EPS));    <span class="hljs-comment">// invLenLV = rcp(length(L + V)), clamp to avoid rsqrt(0) = inf, inf * 0 = NaN</span><br>    NdotH = saturate((NdotL + unclampNdotV) * invLenLV);        <span class="hljs-comment">// Do not clamp NdotV here</span><br>    LdotH = saturate(invLenLV * LdotV + invLenLV);<br>    clampNdotV = ClampNdotV(unclampNdotV);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 平滑度到粗糙度</span><br>real <span class="hljs-title function_">PerceptualSmoothnessToPerceptualRoughness</span><span class="hljs-params">(real perceptualSmoothness)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">1.0</span> - perceptualSmoothness);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">real <span class="hljs-title function_">PerceptualRoughnessToRoughness</span><span class="hljs-params">(real perceptualRoughness)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> perceptualRoughness * perceptualRoughness;<br>&#125;<br></code></pre></td></tr></table></figure><p>Bsdf数据当中需要的内容“</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>BSDFData <span class="hljs-title function_">ConvertSurfaceDataToBSDFData</span><span class="hljs-params">(uint2 positionSS, SurfaceData surfaceData)</span><br>&#123;<br>    BSDFData bsdfData;<br>    ZERO_INITIALIZE(BSDFData, bsdfData);<br><br>    <span class="hljs-comment">// IMPORTANT: All enable flags are statically know at compile time, so the compiler can do compile time optimization</span><br>    bsdfData.materialFeatures = surfaceData.materialFeatures;<br><br>    bsdfData.ambientOcclusion = surfaceData.ambientOcclusion;<br>    bsdfData.specularOcclusion = surfaceData.specularOcclusion;<br><br>    bsdfData.diffuseColor = surfaceData.diffuseColor;<br><br>    bsdfData.normalWS = surfaceData.normalWS;<br>    bsdfData.geomNormalWS = surfaceData.geomNormalWS;<br>    bsdfData.perceptualRoughness = PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness);<br><br>    <span class="hljs-comment">// This value will be override by the value in diffusion profile</span><br>    bsdfData.fresnel0 = DEFAULT_HAIR_SPECULAR_VALUE;<br><br>    <span class="hljs-comment">// Note: we have ZERO_INITIALIZE the struct so bsdfData.anisotropy == 0.0</span><br>    <span class="hljs-comment">// Note: DIFFUSION_PROFILE_NEUTRAL_ID is 0</span><br>    <br>    bsdfData.diffusionProfileIndex = FindDiffusionProfileIndex(surfaceData.diffusionProfileHash);<br><br>    <span class="hljs-keyword">if</span> (HasFlag(surfaceData.materialFeatures, MATERIALFEATUREFLAGS_HAIR_SUBSURFACE_SCATTERING))<br>    &#123;<br>        <span class="hljs-comment">// Assign profile id and overwrite fresnel0</span><br>        FillMaterialSSS(bsdfData.diffusionProfileIndex, surfaceData.subsurfaceMask, bsdfData);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (HasFlag(surfaceData.materialFeatures, MATERIALFEATUREFLAGS_HAIR_TRANSMISSION))<br>    &#123;<br>        <span class="hljs-comment">// Assign profile id and overwrite fresnel0</span><br>        FillMaterialTransmission(bsdfData.diffusionProfileIndex, surfaceData.thickness, bsdfData);<br>    &#125;<br><br>    <span class="hljs-comment">// This is the hair tangent (which represents the hair strand direction, root to tip).</span><br>    bsdfData.hairStrandDirectionWS = surfaceData.hairStrandDirectionWS;<br><br>    <span class="hljs-comment">// Kajiya kay</span><br>    <span class="hljs-keyword">if</span> (HasFlag(surfaceData.materialFeatures, MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY))<br>    &#123;<br>        bsdfData.secondaryPerceptualRoughness = PerceptualSmoothnessToPerceptualRoughness(surfaceData.secondaryPerceptualSmoothness);        <br>        bsdfData.specularTint = surfaceData.specularTint;<br>        bsdfData.secondarySpecularTint = surfaceData.secondarySpecularTint;<br>        bsdfData.specularShift = surfaceData.specularShift;<br>        bsdfData.secondarySpecularShift = surfaceData.secondarySpecularShift;<br><br>        <span class="hljs-comment">// We can rewrite specExp from exp2(10 * (1.0 - roughness)) in order</span><br>        <span class="hljs-comment">// to remove the need to take the square root of sinTH</span><br>        <span class="hljs-comment">// 这里是通过粗糙度计算曝光信息</span><br>        bsdfData.specularExponent = exp2(<span class="hljs-number">9.0</span> - <span class="hljs-number">10.0</span> * PerceptualRoughnessToRoughness(bsdfData.perceptualRoughness));<br>        bsdfData.secondarySpecularExponent = exp2(<span class="hljs-number">9.0</span> - <span class="hljs-number">10.0</span> * PerceptualRoughnessToRoughness(bsdfData.secondaryPerceptualRoughness));<br><br>        bsdfData.anisotropy = <span class="hljs-number">0.8</span>; <span class="hljs-comment">// For hair we fix the anisotropy</span><br>    &#125;<br><br>    ApplyDebugToBSDFData(bsdfData);<br><br>    <span class="hljs-keyword">return</span> bsdfData;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HDRP中ShaderGraph生成的UnlitTransparent不接受雾</title>
      <link href="/2023/06/02/Unity/HDRP%E4%B8%ADShaderGraph%E7%94%9F%E6%88%90%E7%9A%84UnlitTransparent%E4%B8%8D%E6%8E%A5%E5%8F%97%E9%9B%BE/"/>
      <url>/2023/06/02/Unity/HDRP%E4%B8%ADShaderGraph%E7%94%9F%E6%88%90%E7%9A%84UnlitTransparent%E4%B8%8D%E6%8E%A5%E5%8F%97%E9%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="HDRP中ShaderGraph生成的UnlitTransparent不接受雾"><a href="#HDRP中ShaderGraph生成的UnlitTransparent不接受雾" class="headerlink" title="HDRP中ShaderGraph生成的UnlitTransparent不接受雾"></a>HDRP中ShaderGraph生成的UnlitTransparent不接受雾</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>在开发UV云的过程中，使用了ShaderGraph来创建Shader。</p><p>发现使用Unlit节点的Transparent模式，会出现物体不接收雾的情况（即使打开了Recive Fog）。</p><p>但是Lit节点的Transparent模式是正常的。</p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>通过阅读代码发现：</p><p>雾的计算在文件AtmosphericScattering.hlsl中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">float4 <span class="hljs-title function_">EvaluateAtmosphericScattering</span><span class="hljs-params">(PositionInputs posInput, float3 V)</span><br>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> do not recompute this, but rather pass it directly.</span><br>    <span class="hljs-type">float</span> fragDist = distance(posInput.positionWS, GetCurrentViewPosition());<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里最重要的内容是posInput.positionWS。出错的原因就是posInput.positionWS当中没有值。</p><p>所以导致计算雾深度的时候结果是0。</p><p>ShaderGraph生成的代码当中，在Vertex片段中VertMesh函数（所有的HDRP内置shader都走这个shader函数计算vertex信息）已经计算了世界坐标，但是没有被传递到Fragment当中。因为ShaderGraph当中判断他不需要世界坐标。</p><p>VertMesh函数位于VertMesh.hlsl当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>VaryingsMeshType <span class="hljs-title function_">VertMesh</span><span class="hljs-params">(AttributesMesh input)</span><br>&#123;<br>    VaryingsMeshType output;<br>...<br>    <span class="hljs-comment">// This return the camera relative position (if enable)</span><br>    float3 positionRWS = TransformObjectToWorld(input.positionOS);<br>    ...<br>    <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> TESSELLATION_ON</span><br>    output.positionRWS = positionRWS;<br>...<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> VARYINGS_NEED_POSITION_WS</span><br>    output.positionRWS = positionRWS;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    output.positionCS = TransformWorldToHClip(positionRWS);<br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面是ShaderGraph生成的传递函数和结构体，法线并没有世界坐标：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Generated Type: VaryingsMeshToPS</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VaryingsMeshToPS</span> &#123;</span><br>    float4 positionCS : SV_Position;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_ANY_INSTANCING_ENABLED</span><br>    uint instanceID : CUSTOM_INSTANCE_ID;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// UNITY_ANY_INSTANCING_ENABLED</span></span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PackedVaryingsMeshToPS</span> &#123;</span><br>    float4 positionCS : SV_Position; <span class="hljs-comment">// unpacked</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_ANY_INSTANCING_ENABLED</span><br>    uint instanceID : CUSTOM_INSTANCE_ID; <span class="hljs-comment">// unpacked</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// UNITY_ANY_INSTANCING_ENABLED</span></span><br>&#125;;<br>PackedVaryingsMeshToPS <span class="hljs-title function_">PackVaryingsMeshToPS</span><span class="hljs-params">(VaryingsMeshToPS input)</span><br>&#123;<br>    PackedVaryingsMeshToPS output;<br>    output.positionCS = input.positionCS;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_ANY_INSTANCING_ENABLED</span><br>    output.instanceID = input.instanceID;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// UNITY_ANY_INSTANCING_ENABLED</span></span><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br>VaryingsMeshToPS <span class="hljs-title function_">UnpackVaryingsMeshToPS</span><span class="hljs-params">(PackedVaryingsMeshToPS input)</span><br>&#123;<br>    VaryingsMeshToPS output;<br>    output.positionCS = input.positionCS;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_ANY_INSTANCING_ENABLED</span><br>    output.instanceID = input.instanceID;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// UNITY_ANY_INSTANCING_ENABLED</span></span><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br></code></pre></td></tr></table></figure><p>在ShaderGraph当中使用一次世界坐标：</p><p><img src="/img/201975-114401.jpg" alt="201975-114401"></p><p>然后在观察生成的代码，出现了世界坐标，再看场景雾就正常了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Generated Type: VaryingsMeshToPS</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VaryingsMeshToPS</span> &#123;</span><br>    float4 positionCS : SV_Position;<br>    float3 positionRWS; <span class="hljs-comment">// optional</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_ANY_INSTANCING_ENABLED</span><br>    uint instanceID : CUSTOM_INSTANCE_ID;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// UNITY_ANY_INSTANCING_ENABLED</span></span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PackedVaryingsMeshToPS</span> &#123;</span><br>    float3 interp00 : TEXCOORD0; <span class="hljs-comment">// auto-packed</span><br>    float4 positionCS : SV_Position; <span class="hljs-comment">// unpacked</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_ANY_INSTANCING_ENABLED</span><br>    uint instanceID : CUSTOM_INSTANCE_ID; <span class="hljs-comment">// unpacked</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// UNITY_ANY_INSTANCING_ENABLED</span></span><br>&#125;;<br>PackedVaryingsMeshToPS <span class="hljs-title function_">PackVaryingsMeshToPS</span><span class="hljs-params">(VaryingsMeshToPS input)</span><br>&#123;<br>    PackedVaryingsMeshToPS output;<br>    output.positionCS = input.positionCS;<br>    output.interp00.xyz = input.positionRWS;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_ANY_INSTANCING_ENABLED</span><br>    output.instanceID = input.instanceID;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// UNITY_ANY_INSTANCING_ENABLED</span></span><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br>VaryingsMeshToPS <span class="hljs-title function_">UnpackVaryingsMeshToPS</span><span class="hljs-params">(PackedVaryingsMeshToPS input)</span><br>&#123;<br>    VaryingsMeshToPS output;<br>    output.positionCS = input.positionCS;<br>    output.positionRWS = input.interp00.xyz;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_ANY_INSTANCING_ENABLED</span><br>    output.instanceID = input.instanceID;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// UNITY_ANY_INSTANCING_ENABLED</span></span><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>shader代码hlsl的包含调用关系比较复杂。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UnlitShader使用</title>
      <link href="/2023/06/02/Unity/Hdrp%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD/"/>
      <url>/2023/06/02/Unity/Hdrp%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="1-UnlitShader使用"><a href="#1-UnlitShader使用" class="headerlink" title="1.UnlitShader使用"></a>1.UnlitShader使用</h1><ol><li><p>目前UnlitGraph支持主要的纹理、向量、颜色、顶点色、屏幕空间位置等各种基础参数的计算。</p></li><li><p>通过宏来切换不同效果的部分需要手写谢。</p></li><li><p>同时支持透明和不透明两种模式。</p></li><li><p><strong>扭曲distort，默认的Unlit shader已经可以使用</strong>，但是UnlitGraph没有提供，LitGraph有这个功能，所以未来应该会提供。</p></li></ol><p>使用方式：HDRP创建默认材质，Shader改成Hdrp&#x2F;Unlit，材质选项中Surface Type改成Transparent。此时材质下方出现了新的选项Transprency Input。打开Distortion，给出一张扭曲纹理，然后调节参数就可以看到扭曲效果。</p><p><strong>注意</strong>：扭曲和渲染顺序无关，所有和扭曲材质重叠切没有渲染深度的材质，都会被扭曲。</p><h1 id="2-LitShader"><a href="#2-LitShader" class="headerlink" title="2.LitShader"></a>2.LitShader</h1><ol><li><p>Lit一共有两种扭曲方式：Refraction折射和Distortion变形。LitGraph也可以使用这两个功能</p></li><li><p>支持折射、扭曲，但是会带上光照。</p></li><li><p>Refraction：透明的Lit物体可以用折射功能（Unlit物体只可以选择是否被折射）。Lit物体如果要折射其他物体就不能被其他的物体折射。不透明物体可以选择是否被折射。可以用来实现类似冰冻怪物的效果。</p></li><li><p>Distortion：Unlit和透明的Lit都可以用。有扭曲的Unlit材质会扭曲任何和他重叠的无深度物体。</p></li></ol><h1 id="3-Unlit贴花"><a href="#3-Unlit贴花" class="headerlink" title="3.Unlit贴花"></a>3.Unlit贴花</h1><ol><li><p>默认的功能无法实现Unlit效果。我们需要自己实现Unlit Decal，理论上只要能够正确读取深度就可以渲染，不过需要研究一下渲染输出的buffer、渲染队列、已经新的深度读取方式。</p></li><li><p><strong>内置贴花支持模型贴花</strong>，一个Decal模型可以贴附在另一个模型上，可以有自己的UV。</p></li></ol><h1 id="4-天空球编程"><a href="#4-天空球编程" class="headerlink" title="4.天空球编程"></a>4.天空球编程</h1><p>参考链接：<a href="https://github.com/Unity-Technologies/ScriptableRenderPipeline/wiki/Writing-A-Custom-Sky-Renderer">天空球编程</a>，可以自由实现想要的天空球。</p><p>#5.HDRP 自带天空球混合</p><p>Unity Volume源代码中有实现HDRI插值的计划，见：TODO注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CubemapParameter</span> :</span> VolumeParameter&lt;Cubemap&gt;<br>&#123;<br>     public <span class="hljs-title function_">CubemapParameter</span><span class="hljs-params">(Cubemap value, <span class="hljs-type">bool</span> overrideState = <span class="hljs-literal">false</span>)</span><br>     : <span class="hljs-title function_">base</span><span class="hljs-params">(value, overrideState)</span> &#123;&#125;<br>     <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Cubemap interpolation</span><br>&#125;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoInterpCubemapParameter</span> :</span> VolumeParameter&lt;Cubemap&gt;<br>&#123;<br>    public <span class="hljs-title function_">NoInterpCubemapParameter</span><span class="hljs-params">(Cubemap value, <span class="hljs-type">bool</span> overrideState = <span class="hljs-literal">false</span>)</span><br>    : <span class="hljs-title function_">base</span><span class="hljs-params">(value, overrideState)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Volume当中的不同天空球都可以实现各自的混合效果，不过Hdri目前没有实现完（如果是其他两种类型的天空球，当前版本已经可以实现插值）。cubemap在混合时实时计算插值，有一部分开销需要考虑。在HDRP6.0.0当中也还是没有实现，不知道Unity是出于什么考虑，一直没有给出Cubemap混合的代码。</p><p>目前，<strong>我们实现这部分代码就可以直接使用Volume当中的天空球插值</strong>。</p><p>#6.关于特效和渲染队列</p><p>之前美术手动调节了材质上的渲染队列来实现不同的特效。现在渲染队列的机制有一些改动，在不熟悉之前最好不要手动设置队列（默认材质都是不能调节的，只能修改<strong>渲染优先级Sort Priority</strong>），通过Shader Graph创建的可以手动设置。</p><p>现在，在不透明物体渲染阶段，不会渲染2650以上的物体（看源代码得到的结果，在以前只要有队列，就会按照队列顺序渲染），反之亦然。</p><p>HDRP理论上不建议手动调整材质顺序，因为这个顺序不在单纯的是顺序，还涉及到各种特殊的效果。</p><p>2650-2850用来渲染被折射的透明物体，这个都是通过设置自动配置的，在不熟悉引擎之前不要修改材质队列。</p><p>2900-3100是一把透明物体。</p><p>2850到2900之间会出现奇怪的变化，Unity没有给出这部分渲染的是什么。</p><p>2000到2500是不透明物体。这个队列以外的不透明物体不会渲染。</p><p>2000以下什么都不会渲染（以前都是可以渲染的）。</p><p><strong>现在的状态就是：如果没有把队列和物体类型匹配就会出现不可预知的结果。</strong></p><p>下面是控制渲染队列的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Priority</span></span><br><span class="hljs-class">        &#123;</span><br>            Background = UnityEngine.Rendering.RenderQueue.Background,<br>            Opaque = UnityEngine.Rendering.RenderQueue.Geometry,<br>            OpaqueAlphaTest = UnityEngine.Rendering.RenderQueue.AlphaTest,<br>            <span class="hljs-comment">// Warning: we must not change Geometry last value to stay compatible with occlusion</span><br>            OpaqueLast = UnityEngine.Rendering.RenderQueue.GeometryLast,<br>            <span class="hljs-comment">// For transparent pass we define a range of 200 value to define the priority</span><br>            <span class="hljs-comment">// Warning: Be sure no range are overlapping</span><br>            PreRefractionFirst = <span class="hljs-number">2750</span> - k_TransparentPriorityQueueRange,<br>            PreRefraction = <span class="hljs-number">2750</span>,<br>            PreRefractionLast = <span class="hljs-number">2750</span> + k_TransparentPriorityQueueRange,<br>            TransparentFirst = UnityEngine.Rendering.RenderQueue.Transparent - k_TransparentPriorityQueueRange,<br>            Transparent = UnityEngine.Rendering.RenderQueue.Transparent,<br>            TransparentLast = UnityEngine.Rendering.RenderQueue.Transparent + k_TransparentPriorityQueueRange,<br>            Overlay = UnityEngine.Rendering.RenderQueue.Overlay<br>        &#125;<br><br>RenderQueueRange k_RenderQueue_OpaqueNoAlphaTest = <br>    new RenderQueueRange &#123; min = (<span class="hljs-type">int</span>)Priority.Opaque, <br>                          max = (<span class="hljs-type">int</span>)Priority.OpaqueAlphaTest - <span class="hljs-number">1</span> &#125;;<br><br>RenderQueueRange k_RenderQueue_OpaqueAlphaTest = <br>    new RenderQueueRange &#123; min = (<span class="hljs-type">int</span>)Priority.OpaqueAlphaTest, <br>                          max = (<span class="hljs-type">int</span>)Priority.OpaqueLast &#125;;<br><br>RenderQueueRange k_RenderQueue_AllOpaque = new RenderQueueRange &#123; <br>    min = (<span class="hljs-type">int</span>)Priority.Opaque,<br>    max = (<span class="hljs-type">int</span>)Priority.OpaqueLast &#125;;<br><br>RenderQueueRange k_RenderQueue_PreRefraction = new RenderQueueRange &#123; <br>    min = (<span class="hljs-type">int</span>)Priority.PreRefractionFirst, <br>    max = (<span class="hljs-type">int</span>)Priority.PreRefractionLast &#125;;<br><br>RenderQueueRange k_RenderQueue_Transparent = new RenderQueueRange &#123; <br>    min = (<span class="hljs-type">int</span>)Priority.TransparentFirst, <br>    max = (<span class="hljs-type">int</span>)Priority.TransparentLast &#125;;<br><br>RenderQueueRange k_RenderQueue_AllTransparent = new RenderQueueRange &#123; <br>    min = (<span class="hljs-type">int</span>)Priority.PreRefractionFirst, <br>    max = (<span class="hljs-type">int</span>)Priority.TransparentLast &#125;;<br><br>RenderQueueRange k_RenderQueue_All = new RenderQueueRange &#123; min = <span class="hljs-number">0</span>, max = <span class="hljs-number">5000</span> &#125;;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HDRP深度纹理</title>
      <link href="/2023/06/02/Unity/HDRP%E6%B7%B1%E5%BA%A6%E7%BA%B9%E7%90%86/"/>
      <url>/2023/06/02/Unity/HDRP%E6%B7%B1%E5%BA%A6%E7%BA%B9%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="HDRP深度纹理"><a href="#HDRP深度纹理" class="headerlink" title="HDRP深度纹理"></a>HDRP深度纹理</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">Auther : LZ</span><br><span class="hljs-comment">Date   : 2018</span><br><span class="hljs-comment">Description</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>HDPR在内置纹理采样上使用了新的方式，网上并没有给出正确答案。并HDRP使用了HLSL语法和以往CG不同，所以资料很少。</p><p>这里主要讲解一下HDRP的内置深度纹理采样和相关的HLSL语法。</p><h2 id="DepthPyramid"><a href="#DepthPyramid" class="headerlink" title="DepthPyramid"></a>DepthPyramid</h2><p>HDRP的沿用了Legacy的_CameraDepthTexture之类的内置纹理名字，方便我们进行迁移，但是和原本采样方法产生了很大出入，下面详细解释。</p><p> <strong>为了支持新的渲染效果，HDRP生成了多分辨率版本的深度图（DepthPyramid）</strong> 。即为Depth生成一个DepthPyramid。</p><p>这张DepthPayermid并不是类似mip的多分辨率版本纹理（类似通过lod参数对mip采样,如下<em>代码1</em>），而是<strong>直接扩展了DepthBuffer的像素大小，把多个分辨率版本放在一张图中</strong>。例如：原本Detph是1024 * 533，为了在DepthPayermid当中保存多个分辨率版本，需要把DepthPayermid扩展到 1024 * 1024。下图是完整的DepthPayermid，最下面的绿框就是真正的depthtexture。</p><p><img src="/../../images/img/depthp.bmp"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hlsl">tex2D（tex,float4(texcoord.xy,0,lod）；//代码1 ： 对mip采样<br></code></pre></td></tr></table></figure><p><strong>HDRP的_CameraDepthTexture指的是DepthPyramid而非DepthTexture</strong>  ，这样会需要一个很严重的问题。我们按照Legacy版本计算的 **屏幕纹理坐标[0,1] 对应的是整个DepthPyramid **。如何从DepthPyramid拿出最高层的Depth。</p><p>根据HDRP的Decal源代码和DepthPyramid生成代码可以发现两个地方。</p><ol><li><p>DepthPyramid的最高层（DepthTexture）保存在左下角</p></li><li><p>DepthPyramid中最高层的分辨率和原本DepthTexture是一样的</p><p> 所以我们可以 ** 通过像素位置进行采样 ** 而不是纹理坐标，也就是说：Depth中[12,12]这个像素，刚好在DepthPyramid[12,12]这个位置上。</p><p> HLSL语法为我们提供了这个采样函数，而CG是做不到的（当然也可以想办法计算一个比例）：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">tex.load(texcoord);<span class="hljs-comment">//代码2 ： 对使用像素位置采样</span><br></code></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/t2d-load-float-int-uint-">Load的hlslAPI链接</a></p><p>下面就是计算屏幕的像素位置（而不是纹理坐标），又刚好SV_POSITION语意，就是我们要的。</p><p>所以深度图的采样方式就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">_CameraDepthTexture.Load(sampler2D_CameraDepthTexture,positionSV);<br><span class="hljs-comment">//使用HDRP提供的宏就是：</span><br>LOAD_TEXTURE2D(_CameraDetphTexture, positionSV).x;<br><span class="hljs-comment">//其中positionSV就是的SV_POSITION对呀的值。</span><br></code></pre></td></tr></table></figure><p>注：这种采样方式有个好处就是在Computeshader中可以很方便的和线程ID对应。整数计算效率更高。</p><h2 id="关于HLSL语法"><a href="#关于HLSL语法" class="headerlink" title="关于HLSL语法"></a>关于HLSL语法</h2><p>很多渲染语法是CG不支持的，其中有两点比较重要：</p><ol><li><p>cg语法中sampler和texture无法分离，而一般GPU支持128个texture，只支持16个sampler，如果无法分离就导致我们只能最多用16个纹理。</p></li><li><p>无法用整数采样器，就是上面的DepthPyramid的问题。</p></li></ol><p>最重要的不同就是采样语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//========cg==========</span><br>sampler2D tex1;<br>sampler2D tex2;<br><span class="hljs-comment">// 采样</span><br>tex2D(tex1,coord);<br>tex2D(tex2,coord);<br><span class="hljs-comment">//=========hlsl========</span><br>SamplerState sampler_tex;<br>Texture2D tex；<br>Texture2D tex1；<br><span class="hljs-comment">// 采样</span><br>tex.sample(sampler_tex,coord);<br>tex1.sample(sampler_tex,coord); <span class="hljs-comment">//复用采样器</span><br><span class="hljs-comment">//</span><br>tex1.load(coord); <span class="hljs-comment">// 直接读取像素</span><br><br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于深度金字塔似乎是一种叫做 Interleaved Sampling的技术。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线性空间、GAMMA空间和HDR、纹理</title>
      <link href="/2023/06/02/Unity/Linear%20And%20Gamma/"/>
      <url>/2023/06/02/Unity/Linear%20And%20Gamma/</url>
      
        <content type="html"><![CDATA[<h2 id="线性空间、GAMMA空间和HDR、纹理"><a href="#线性空间、GAMMA空间和HDR、纹理" class="headerlink" title="线性空间、GAMMA空间和HDR、纹理"></a>线性空间、GAMMA空间和HDR、纹理</h2><h3 id="sRGB"><a href="#sRGB" class="headerlink" title="sRGB"></a>sRGB</h3><p>sRGB是一个纹理的标记，也是一种<strong>数据保存格式</strong>。在对纹理采样和写入纹理内容时产生作用。如果开启sRGB，那么在采样时会自动的对采样得到的值进行sRGB解码，写入时会对写入的值进行sRGB编码，然后再写入。</p><p>(When calculating lighting on older hardware restricted to 8 bits per channel for the framebuffer format, using a gamma curve provides more precision in the human-perceivable range. More bits are used in the range where the human eye is the most sensitive.</p><p>Even though monitors today are digital, they still take a gamma-encoded signal as input. Image files and video files are explicitly encoded to be in gamma space (meaning they carry gamma-encoded values, not linear intensities). This is the standard; everything is in gamma space.) 所以视频的录制结果，PS，SP制作内容的保存一般应该都是sRGB格式。</p><p>unity中如果使用<strong>Gamma空间</strong>，sRGB的<strong>设置失效</strong>。</p><p>(When using Gamma color space, no conversions are done of any kind, and this setting is not used.)</p><p>sRGB (Color Texture)设置的意义：Check this box to specify that the Texture is stored in gamma space. This should always be checked for non-HDR color Textures (such as Albedo and Specular Color)（只有UI和Default会有这个选项, 至于HDR color Textures应该是PS输出的浮点格式纹理）. If the Texture stores information that has a specific meaning, and you need the exact values in the Shader (for example, the smoothness or the metalness), uncheck this box. This box is checked by default.</p><h3 id="Gamma矫正"><a href="#Gamma矫正" class="headerlink" title="Gamma矫正"></a>Gamma矫正</h3><p>如果显示设备按照线性亮度显示内容，人眼的感受会觉得很奇怪。</p><p>所以显示设备需要显示进过Gamma矫正的内容，以符合人眼感受习惯（More bits are used in the range where the human eye is the most sensitive.）。录制设置完成录制后保存的也是经过Gamma矫正的内容。</p><p><strong>目前，各种设备的输入、保存、输出格式都是在Gamma空间的。</strong></p><p>目前sRGB格式就是Gamma空间的标准。(The accepted standard for gamma space is called sRGB )</p><p>**This is the standard; everything is in gamma space.**也就是说一般情况（录制、显示、保存）下都不存在Linear空间。</p><p>所以根据纹理内容需要合理的设置纹理的sRGB标记。（如果是法线或者Mask）则Unity 不会进行任何编码解码操作，直接作为数据来处理。针对的只是颜色纹理（Color RenderTexture）.</p><h3 id="线性空间和Gamma空间"><a href="#线性空间和Gamma空间" class="headerlink" title="线性空间和Gamma空间"></a>线性空间和Gamma空间</h3><p>显示、录制、保存都是Gamma空间，但是当纹理颜色参与计算时，为了精确度，需要在线性空间计算。</p><p>Unity提供了线性空间处理选项:在每一个渲染过程中，<strong>输入需要进行sRGB的解码，输出时在进行sRGB编码</strong>。（To overcome this, you can set Unity to use an RGB sampler to cross over from gamma to linear sampling. This ensures a linear workflow with all inputs and outputs of a Shader in the correct color space, resulting in a correct outcome.）</p><p>设置线性空间方法（go to <strong>Edit</strong> &gt; <strong>Project Settings</strong> &gt; <strong>Player</strong> and open <strong>Player Settings</strong>. Go to <strong>Other Settings</strong> &gt; <strong>Rendering</strong> and change the <strong>Color Space</strong> to <strong>Linear</strong> or <strong>Gamma</strong>, depending on your preference.）</p><p><strong>如果不进行上述设置，Unity就不会进行格式的转化，采样到的就是保存值，输出的内容也会直接写入到纹理上。</strong></p><p><em><strong>特例1</strong>:当使用</em><em>HDR<strong>的时候颜色校正的时机（只在linear空间有效），Shader结果输出到帧缓存中时并未进行Gamma矫正，而是在更晚的时候进行（这一帧完全渲染结束进行一次Gamma矫正）。如果</strong>Non-HDR*</em> 输出到帧缓存的结果就是Gamma矫正的结果。（When using HDR, rendering is performed in linear space into floating point buffers. These buffers have enough precision not to require conversion to and from gamma space whenever the buffer is accessed. This means that when rendering in linear mode, the framebuffers you use store the colors in linear space. Therefore, all blending and post process effects are implicitly performed in linear space. When the final backbuffer is written to, gamma correction is applied.）</p><p><em><strong>特例2</strong>:光照贴图，无论颜色空间的设置，光照贴图永远执行的都是</em>*Linear Space的工作流**：The lighting <strong>calculations in the lightmapper are always done in linear space</strong> (see documentation on the <a href="https://docs.unity3d.com/Manual/GlobalIllumination.html">Lighting Window</a> for more information). <strong>The lightmaps are always stored in gamma space</strong>. This means that the lightmap textures are identical no matter whether you’re in gamma or linear color space.</p><p>*<strong>特例3</strong>:HDR中帧缓存的内容和颜色空间的关系. <strong>When linear color space is enabled and HDR is not enabled</strong>, a special framebuffer type is used that supports sRGB read and sRGB write (convert from gamma to linear when reading, convert from linear to gamma when writing). When this framebuffer is used for blending or it is bound as a Texture, the values are converted to linear space before being used. When these buffers are written to, the value that is being written is converted from linear space to gamma space. <strong>If you are rendering in linear mode and non-HDR mode</strong>, all post-process effects have their source and target buffers created with sRGB read and write enabled so that post-processing and post-process blending occur in linear space.</p><p><em><strong>注</strong>：</em>*Gamma工作流**：读入、写出内容时都不进行Gamma矫正：Even though these values are in gamma space, all the Unity Editor’s Shader calculations still treat their inputs as if they were in linear space. To ensure an acceptable final result, the Editor makes an adjustment to deal with the mismatched formats when it writes the Shader outputs to a framebuffer and does not apply gamma correction to the final result.</p><p>*<strong>注：</strong>一旦打开HDR所有的帧缓存就会从ARGB32(255的整型RGBA)变成ARGBHalf(16位的浮点数)。原本没有HDR时每次帧缓存的读写都会经历sRGB的解码编码。打开HDR后帧缓存的读写不再进行sRGB的编解码，而是在这一帧完全处理完成之后，从HDR转回正常颜色空间后在进行sRGB的编解码，ReadPixel也就是从这里读取纹理的。实际上我们可以在渲染过程中读取colorbuffer，例如渲染到RT当中，这个使用可以读取到没有经过编码颜色数据。</p><h3 id="纹理颜色空间-sRGB选项控制"><a href="#纹理颜色空间-sRGB选项控制" class="headerlink" title="纹理颜色空间(sRGB选项控制)"></a>纹理颜色空间(sRGB选项控制)</h3><p>不同颜色空间的工作流只针对Non-Hdr的Color Texture 在Texture的Inspector当中可以看到。sprite和Default有sRGB的选项，其他没有的不会受到颜色空间设置的影响。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Houdini无法导出UV.z通道</title>
      <link href="/2023/06/02/Unity/Houdini%E5%AF%BC%E5%87%BAfbxUVz%E9%80%9A%E9%81%93/"/>
      <url>/2023/06/02/Unity/Houdini%E5%AF%BC%E5%87%BAfbxUVz%E9%80%9A%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Houdini无法导出UV-z通道"><a href="#Houdini无法导出UV-z通道" class="headerlink" title="Houdini无法导出UV.z通道"></a>Houdini无法导出UV.z通道</h1><p>目前希望在Houdini当中写入一些控制参数，在Unity中读取出来进行一些操作。</p><p>法线当在Houdini中给uv的z通道写入数据时，在Unity当中无法读取出来。</p><p>通过检查Houdini的输出FBX文件，发现Houdini的ROP FBXexport导出结点无法导出uv的z通道。</p><p>目前的解决方案就是不适用。</p><p>之后的方案可以考虑使用Houdini的API进行修改导出设置。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>介绍unity遮挡剔除功能</title>
      <link href="/2023/06/02/Unity/Occluded%20Culling/"/>
      <url>/2023/06/02/Unity/Occluded%20Culling/</url>
      
        <content type="html"><![CDATA[<p>#1.Unity build-in插件：Umbra</p><p>##1.1具体原理</p><p><a href="https://blogs.unity3d.com/cn/2013/12/02/occlusion-culling-in-unity-4-3-the-basics/">原文链接</a>：</p><p>​Umbra’s occlusion culling process can be roughly divided into two distinct stages. In the editor, Umbra processes the game scene so that visibility queries can be performed in the game runtime, in the player. So first, Umbra needs to take the game scene as its input and <strong>bake</strong> it into a lightweight data structure. During the bake, Umbra first <strong>voxelizes</strong> the scene, then groups the voxels into cells and combines these cells with <strong>portals</strong>. This data, in addition to a few other important bits is referred to as <strong>occlusion data</strong> in Unity.</p><p>​In the runtime, Umbra then performs <strong>software portal rasterization</strong> into a <strong>depth buffer</strong>, against which <strong>object visibility</strong> can be tested. In practice, Unity gives Umbra a camera position, and Umbra gives back a list of visible objects. The visibility queries are always <strong>conservative</strong>, which means that false negatives are never returned. On the other hand, some objects may be deemed visible by Umbra even though in reality they appear not to be.</p><h2 id="1-1-编辑阶段"><a href="#1-1-编辑阶段" class="headerlink" title="1.1 编辑阶段"></a>1.1 编辑阶段</h2><h3 id="1-1-1-voxelizes-the-scene："><a href="#1-1-1-voxelizes-the-scene：" class="headerlink" title="1.1.1 voxelizes the scene："></a>1.1.1 <strong>voxelizes</strong> the scene：</h3><p>​使用八叉树将整个场景体素化。每一个正方体体素顶点都会对齐到世界坐标。根据场景中所有需要进行剔除的物体（被Culling Area包裹和被设置为Occlude或（和）Occluder的物体）会计算整个八叉树对场景的覆盖范围，然后细分，。</p><h3 id="1-1-2-groups-the-voxels-into-cells："><a href="#1-1-2-groups-the-voxels-into-cells：" class="headerlink" title="1.1.2 groups the voxels into cells："></a>1.1.2 groups the voxels into cells：</h3><p>​将空的体素Cell合并成一个大的空的正方体。</p><h3 id="1-1-3-combines-these-cells-with-portals"><a href="#1-1-3-combines-these-cells-with-portals" class="headerlink" title="1.1.3 combines these cells with portals"></a>1.1.3 combines these cells with <strong>portals</strong></h3><p>​将所有的Cell合并成一portals，根据Occlusion Culling视图可以看出来，portal实际上是包裹各个Cell边界的长方体。只是包裹Cell正方体的一个面的长方体，而不是包裹整个Cells。现在得到的只是一个场景的划分数据。</p><h3 id="1-1-4-摄像机"><a href="#1-1-4-摄像机" class="headerlink" title="1.1.4 摄像机"></a>1.1.4 摄像机</h3><p>​前面完成了场景划分，接下来需要进行摄像机可行区域设置，也就是需要接一下occlusion area把所有的摄像机可行区域覆盖，同时需要标记为is view area。只有这些区域才会得到正确的摄像机剪裁结果，同时只会为这些区域计算遮挡。通过实验可以看到结果：设置一个场景，和唯一一个oa，并且标记为is view Volume随着这个取悦变大生成的数据也会越来越大。</p><p>​其他区域一般情况下也可能进行遮挡剔除。当时查询数据还是不准确的，很可能产生不能确定的结果。</p><h3 id="1-1-5-区域划分：occlusion-portal-和occlusion-area"><a href="#1-1-5-区域划分：occlusion-portal-和occlusion-area" class="headerlink" title="1.1.5 区域划分：occlusion portal 和occlusion area"></a>1.1.5 区域划分：occlusion portal 和occlusion area</h3><p>op有一个用处，就是统一的控制其包裹的所有occlusion static 物体是否显示。不会印象内部的动态物体。</p><p>oa有两个用处：</p><ol><li>勾选了 is view area 用来标记是否是摄像机可行区域。</li><li>没有勾选is view area 用来包裹一个区域内的非occlusion static 物体，如果这个area被完全遮挡，内部的物体也会被隐藏。</li></ol><h3 id="1-1-6-异常情况"><a href="#1-1-6-异常情况" class="headerlink" title="1.1.6 异常情况"></a>1.1.6 异常情况</h3><p>静态物体和摄像机之间 不能隔着 关闭的op 不然会出错。</p><p>编辑阶段就会产生上述内容。</p><h2 id="1-2-运行阶段"><a href="#1-2-运行阶段" class="headerlink" title="1.2 运行阶段"></a>1.2 运行阶段</h2><p>游戏运行阶段就是直接根据portal来计算这个Cell当中有没有内容被遮挡。</p><p>具体方法就是计算渲染所有portal后的深度，和每一个cell的深度。判断cell当中的物体是否需要被去掉。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Scriptable Render Pipeline Overview</title>
      <link href="/2023/06/02/Unity/SPR%E5%AE%98%E6%96%B9%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/06/02/Unity/SPR%E5%AE%98%E6%96%B9%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://blogs.unity3d.com/cn/2018/01/31/srp-overview/">Scriptable Render Pipeline Overview</a></p><h1 id="Scriptable-Render-Pipeline-Overview"><a href="#Scriptable-Render-Pipeline-Overview" class="headerlink" title="Scriptable Render Pipeline Overview"></a>Scriptable Render Pipeline Overview</h1><pre><code>&gt;unity2018当中介绍了可编程的渲染管线（SRP）。SPR可以通过c#来控制unity中渲染的配置和实现。在了解用户可以定制的渲染管线之前，需要先知道我们所谈论的渲染管线是什么。</code></pre><p>##什么是渲染管线</p><p>​渲染管线是一个概括性的术语，用来概括将对象（Object）绘制到屏幕上的一系列的技术。这是一个高度概括的概念，包括了：</p><ul><li><p>剪裁 </p></li><li><p>对象渲染</p></li><li><p>后处理</p><p>​除了这些抽象的概念之外，他们本身的功能还可以根据用户的需求进一步划分。</p><p>​例如渲染对象可以通过以下方式实现：</p></li><li><p>Multi-pass rendering：每个pass渲染一个对象一个光照</p></li><li><p>Single-pass：每个对象使用一个pass</p></li><li><p>Deffered：将表面属性渲染到G-buffer，然后在屏幕空间实现光照</p><p>当我们使用SRP的时候，就需要决定使用哪一种。不同的方式有不同的优缺点。</p></li></ul><h2 id="渲染入口点（Rendering-entry-point）"><a href="#渲染入口点（Rendering-entry-point）" class="headerlink" title="渲染入口点（Rendering entry point）"></a>渲染入口点（Rendering entry point）</h2><p>​使用SRP时，你需要定义一个类用来控制渲染；渲染管线就是通过这个类来创建的。入口点是对”Render”方法的一次调用，每一次渲染都有不同的渲染上下文（Render Context，下文解释）和需要渲染的摄像机。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BasicPipeInstance</span> : <span class="hljs-title">RenderPipeline</span><br>&#123;<br><span class="hljs-comment">//context 渲染上下文 ，cameras 摄像机列表</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Render</span>(<span class="hljs-params">ScriptableRenderContext context, Camera[] cameras</span>)</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="渲染管线上下文（Render-Pipeline-Context）"><a href="#渲染管线上下文（Render-Pipeline-Context）" class="headerlink" title="渲染管线上下文（Render Pipeline Context）"></a>渲染管线上下文（Render Pipeline Context）</h2><p>​SPR（脚本化渲染管线）渲染使用了延迟执行的概念。首先建立一系列的命令，然后统一执行。通过ScriptableRenderContext类来建立这一系列命令。当用一系列操作填充了这个上下文对象之后，可以 通过“submit”方法，来一次性提交所有drawcall。</p><p>​例子：使用CommandBuffer清空渲染目标：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// Create a new command buffer that can be used</span><br><span class="hljs-comment">// to issue commands to the render context</span><br><span class="hljs-keyword">var</span> cmd = <span class="hljs-keyword">new</span> CommandBuffer();<br><br><span class="hljs-comment">// issue a clear render target command</span><br>cmd.ClearRenderTarget(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, Color.green);<br><br><span class="hljs-comment">// queue the command buffer</span><br>context.ExecuteCommandBuffer(cmd);<br></code></pre></td></tr></table></figure><h2 id="剪裁Culling"><a href="#剪裁Culling" class="headerlink" title="剪裁Culling"></a>剪裁Culling</h2><p>剪裁用来确定哪些内容需要渲染的屏幕上。</p><p>Unity中剪裁包含：</p><ul><li>视锥体剪裁：用摄像机的剪裁平面。</li><li>遮挡剪裁：物体遮挡关系</li></ul><p>渲染开始时，需要决定哪些内容需要被渲染。这需要使用摄像机的透视图执行剪裁操作。剪裁结果是一个对象列表和光照列表。这些内容在接下来的渲染管线当中使用。</p><h3 id="在SRP当中执行剪裁"><a href="#在SRP当中执行剪裁" class="headerlink" title="在SRP当中执行剪裁"></a>在SRP当中执行剪裁</h3><p>在SRP当中你通常需要摄像机的透视来完成渲染。unity内置的渲染也是使用同一个摄像机。SRP提供了一系列剪裁API。</p><p>一般的剪裁流程：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// Create an structure to hold the culling paramaters</span><br>ScriptableCullingParameters cullingParams;<br><br><span class="hljs-comment">//Populate the culling paramaters from the camera</span><br><span class="hljs-keyword">if</span> (!CullResults.GetCullingParameters(camera, stereoEnabled, <span class="hljs-keyword">out</span> cullingParams))<br>    <span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">// if you like you can modify the culling paramaters here</span><br>cullingParams.isOrthographic = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// Create a structure to hold the cull results</span><br>CullResults cullResults = <span class="hljs-keyword">new</span> CullResults();<br><br><span class="hljs-comment">// Perform the culling operation</span><br>CullResults.Cull(<span class="hljs-keyword">ref</span> cullingParams, context, <span class="hljs-keyword">ref</span> cullResults);<br></code></pre></td></tr></table></figure><p>之后可以进行下一步渲染。</p><h2 id="Drawing-绘制"><a href="#Drawing-绘制" class="headerlink" title="Drawing 绘制"></a>Drawing 绘制</h2><p>现在的到了剪裁结果，可以进行进一步渲染。</p><p>这里有很多种配置方法，有下面内容决定：</p><ul><li><p>目标平台</p></li><li><p>特殊的效果</p></li><li><p>项目类型</p><p>具体的例子。</p></li><li><p>HDR和LDR</p></li><li><p>Linear和Gamma</p></li><li><p>MSAA和后处理AA</p></li><li><p>PBR材质和一般材质</p></li><li><p>有无光照</p></li><li><p>光照技术</p></li><li><p>阴影基础</p></li></ul><h3 id="过滤：桶和层"><a href="#过滤：桶和层" class="headerlink" title="过滤：桶和层"></a>过滤：桶和层</h3><p>不同的对象有不同的类型，可以是透明不透明等。Unity使用队列的概念来决定对象渲染的时机。这些队列构成了桶，渲染对象将会保存在桶中（类似桶排序）。当我们使用SRP时，我们可以决定哪个范围的桶可以被渲染。</p><p>除了桶之外，标准的分层也可以用于过滤。</p><p>例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// Get the opaque rendering filter settings</span><br><span class="hljs-keyword">var</span> opaqueRange = <span class="hljs-keyword">new</span> FilterRenderersSettings();<br><br><span class="hljs-comment">//Set the range to be the opaque queues</span><br>opaqueRange.renderQueueRange = <span class="hljs-keyword">new</span> RenderQueueRange()<br>&#123;<br>    min = <span class="hljs-number">0</span>,<br>    max = (<span class="hljs-built_in">int</span>)UnityEngine.Rendering.RenderQueue.GeometryLast,<br>&#125;;<br><br><span class="hljs-comment">//Include all layers</span><br>opaqueRange.layerMask = ~<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h3 id="绘制设置：物体如何被绘制"><a href="#绘制设置：物体如何被绘制" class="headerlink" title="绘制设置：物体如何被绘制"></a>绘制设置：物体如何被绘制</h3><p>之前的过滤和剪裁都是决定了哪些内容需要被渲染。接下来决定这些物体如何被渲染。SRP提供了一系列的操作，对通过过滤的物体进行渲染配置。配置这些数据的结构是：DrawRenderSettings。这个结构允许以下内容的配置：</p><ul><li>Sorting - 物体绘制顺序。</li><li>每个渲染标志 - 传递内部参数。</li><li>渲染标志 - 动态合并实例化技术等等算法</li><li>Shander Pass -当前的draw使用哪一个pass</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// Create the draw render settings</span><br><span class="hljs-comment">// note that it takes a shader pass name</span><br><span class="hljs-keyword">var</span> drs = <span class="hljs-keyword">new</span> DrawRendererSettings(Camera.current, <span class="hljs-keyword">new</span> ShaderPassName(<span class="hljs-string">&quot;Opaque&quot;</span>));<br> <br><span class="hljs-comment">// enable instancing for the draw call</span><br>drs.flags = DrawRendererFlags.EnableInstancing;<br> <br><span class="hljs-comment">// pass light probe and lightmap data to each renderer</span><br>drs.rendererConfiguration = RendererConfiguration.PerObjectLightProbe | RendererConfiguration.PerObjectLightmaps;<br> <br><span class="hljs-comment">// sort the objects like normal opaque objects</span><br>drs.sorting.flags = SortFlags.CommonOpaque;<br></code></pre></td></tr></table></figure><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>现在完成了：</p><ul><li>剪裁规则</li><li>过滤规则</li><li>绘制规则</li></ul><p>我们需要执行一个draw call。一个draw call就是对上下文的一次调用。在SRP中通常不渲染独立的网格，除非你需要一次性绘制很多。这减小了开销，同时保证了CPU的快速执行。</p><p>发布draw call</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// draw all of the renderers</span><br>context.DrawRenderers(cullResults.visibleRenderers, <span class="hljs-keyword">ref</span> drs, opaqueRange);<br> <br><span class="hljs-comment">// submit the context, this will execute all of the queued up commands.</span><br>context.Submit();<br></code></pre></td></tr></table></figure><p>这会把对象渲染到当前绑定的渲染目标。你可以使用一个command buffer来切换渲染目标。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在Unity官方文档的介绍中，SetRenderTarget可以设置渲染目标</title>
      <link href="/2023/06/02/Unity/SetRenderTarget/"/>
      <url>/2023/06/02/Unity/SetRenderTarget/</url>
      
        <content type="html"><![CDATA[<h2 id="在Unity官方文档的介绍中，SetRenderTarget可以设置渲染目标。"><a href="#在Unity官方文档的介绍中，SetRenderTarget可以设置渲染目标。" class="headerlink" title="在Unity官方文档的介绍中，SetRenderTarget可以设置渲染目标。"></a>在Unity官方文档的介绍中，SetRenderTarget可以设置渲染目标。</h2><ol><li>屏幕的渲染目标可以通过Graphics.activeColorBuffer和Graphics.activeDepthBuffer获取。</li></ol><p>其中Graphics.activeDepthBuffer当中包括了stencilbuffer和depthbuffer。</p><ol start="2"><li>commandbuffer当中同样可以使用BuiltinRenderTextureType.Color和BuiltinRenderTextureType.depth来访问对应的渲染目标，但是<strong>BuiltinRenderTextureType.depth是不包括stencilbuffer</strong>的。</li><li>如果想要复用包含stencilbuffer的Graphics.activeDepthBuffer，是不能通过SetRenderTarget和自定义的ColorBuffer组合的，会报错。<strong>因为screen的buffer和rendertarget的buffer不能混合使用</strong>。</li><li>如果只需要复用同一张depth，只需要使用BuiltinRenderTextureType.depth和自定义的colorbuffer即可。</li><li>如果需要复用同一张depth&#x2F;stencil，必须要在一开始修改渲染目标为自定义的RenderTarget，例如：SetRenderTarget(selfColorBuffer, selfDepthBuffer) ,同时selfDepthBuffer的深度位数<strong>必须为24或32</strong>.  如果是16 则不支持stencilbuffer。</li></ol><p>关于延迟渲染（deferred）渲染目标（RenderTexture）的问题</p><ol><li>延迟渲染的RenderTarget目前没有找到方法设置。</li><li>延迟渲染的内容可以通过commandbuffer通过BuiltinRenderTextureType.Gbuffer获取出来。</li><li>BuiltinRenderTextureType.Gbuffer3当中保存了整个渲染流程的结果，包括了Forwardpass。</li><li>在渲染结束后，会将BuiltinRenderTextureType.Gbuffer3当中的内容拷贝到最终渲染目标当中。</li><li>SetRenderBuffers()中的多个渲染目标并不是Gbuffer，而是从shader直接输出的内容。</li><li>CameraEvent.beforelighting可以看到Gbuffer3组合了无光照内容和自发光内容和全局光照，还没有环境反射，不过在AfterGbuffer时还没有自发光内容。</li><li>延迟渲染的环境反射是在完成渲染目标切换之后，才进行渲染的，比天空球还晚。（前向渲染是伴随物体光照同时计算的）</li></ol><p>延迟渲染过程中的深度提取</p><ol><li>如果使用BuiltinRenderTextureType.Depth无法获取到stencil纹理，在deferred当中无存在，如果使用会报错：built-in renderTexture type3 not found…</li><li>deferred过程需要使用BuiltinRenderTextureType.ReolvedDepth，不过使用默认深度和自定义 深度大小很容易不匹配</li><li>在ResolvedDepth中存在完整的深度信息。在deferred第一步先计算延迟物体深度（也就是Gbuffer填充阶段），然后计算前向物体深度，当在延迟渲染中设置depthbuffer时，代替的就是ResolvedDepth。</li><li>ResolvedDepth中的Stencil，延迟光照阶段最多会使用高四位，并且进入前向阶段后不会清零。</li><li>在延迟渲染阶段，前向物体深度计算时会在stencilbuffer当中以207为mask写入内容。这表示高两位和第四位是都可以用的。并且Stencil写入和深度写入在同一个阶段。</li></ol><p>*注：当使用commandbuffer绘制一般的物体时，目前的CameraEvent都是不包含光照信息的，所以绘制出来的内容始终是黑色的。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>旋向性</title>
      <link href="/2023/06/02/Unity/Shader%E5%BD%93%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E5%8F%98%E5%8C%96/"/>
      <url>/2023/06/02/Unity/Shader%E5%BD%93%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="1-旋向性"><a href="#1-旋向性" class="headerlink" title="1 旋向性"></a>1 旋向性</h2><p>两个坐标轴有相同的旋向性：可以通过旋转让两个坐标轴重合。</p><p>左右手坐标系有不同的选项性。</p><h2 id="2-左右手坐标系"><a href="#2-左右手坐标系" class="headerlink" title="2 左右手坐标系"></a>2 左右手坐标系</h2><p>拇指、食指、中指分别代表，+x +y +z轴。由此左右手会产生两个不同的坐标系。</p><h2 id="3-左右手法则"><a href="#3-左右手法则" class="headerlink" title="3 左右手法则"></a>3 左右手法则</h2><p>在cross叉乘中，需要通过正旋向来确定结果轴的指向：</p><p><strong>在左右坐标系中，用左手，在右手坐标系中用右手。</strong></p><h2 id="4-unity的坐标系"><a href="#4-unity的坐标系" class="headerlink" title="4 unity的坐标系"></a>4 unity的坐标系</h2><p>模型空间和世界空间是左手坐标系。</p><p>相机空间是右手坐标系。这相机对准了z轴负方向。也就是说z轴坐标的减少意味着场景深度的增加。</p><h2 id="5-矩阵操作："><a href="#5-矩阵操作：" class="headerlink" title="5. 矩阵操作："></a>5. 矩阵操作：</h2><p>UNITY_MATRIX_P 等价于 <a href="http://resetoter.cn/UnityDoc/ScriptReference/GL.html">GL</a>.GetGPUProjectionMatrix</p><p>Camera.worldToCameraMatrix  ：Note that camera space matches OpenGL convention: camera’s forward is the negative Z axis. This is different from Unity’s convention, where forward is the positive Z axis.</p><p>Camera.cameraToWorldMatrix：Note that camera space matches OpenGL convention: camera’s forward is the negative Z axis. This is different from Unity’s convention, where forward is the positive Z axis.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">UNITY_MATRIX_M<br></code></pre></td></tr></table></figure><ul><li>This is identical to <code>unity_ObjectToWorld</code>, also called the Model transform</li></ul><h2 id="6-unity-XX矩阵"><a href="#6-unity-XX矩阵" class="headerlink" title="6. unity_XX矩阵"></a>6. unity_XX矩阵</h2><p>shader当中unity_XX（Camera相关）开头的矩阵不一定是当前摄像机矩阵，在官方文档当中也没有提到。</p><ol><li><p>根据实验unity_WorldToCamera 和 UNITY_MATRIX_V 的区别在于：</p><p>而UNITY_MATRIX_V改变了旋向性，第三行z值取反了。</p><p>也就是说unity_WorldToCamera 没有改变旋向性。</p></li><li><p>这个时候UNITY_MATRIX_P（glstate_matrix_projection）是根据平台特殊处理的矩阵。</p></li></ol><p>而unity_CameraProjcetion是按照正常的流程的的矩阵。</p><p>unity c#的代码中通过 GL.get…接口的到的矩阵等价于UNITY_MATRIX_P（glstate_matrix_projection）：省略旋向性改变。约束y方向、约束z方向。更加复杂。</p><p>通过Camera.projectionMatrix得到的是一般投影矩阵unity_CamearaProjection。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shader打包</title>
      <link href="/2023/06/02/Unity/Shader%E6%89%93%E5%8C%85/"/>
      <url>/2023/06/02/Unity/Shader%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Shader打包"><a href="#Shader打包" class="headerlink" title="Shader打包"></a>Shader打包</h1><p>总结shader打包过程当中遇到的shader重复，编译时间过长的问题。</p><p>和shader相关的<strong>开销</strong>和以下几个方面有关：</p><ul><li>Other&#x2F;ShaderLab的大小：编译大小</li><li>Asset&#x2F;Shader的大小和重复出现情况：资源当中shader数量</li><li>Shader的编译时间：编译时间</li></ul><p>shader 的打包<strong>策略</strong>主要有一下几种：</p><ul><li>Shader单独打包</li><li>Shader不打包，跟随依赖打入对其依赖资源的包：</li><li>放置到Always Include中</li></ul><p>下面描述上面2、3两种打包策略可能会造成的<strong>问题</strong>：</p><p>1.Always Include会造成<strong>大量的Shader编译时间</strong>(在build阶段），会编译所有的shader变体。<strong>ShaderLab很大。</strong></p><p>2.Shader不打包可能会造成，Shader可能会存在多个版本，<strong>Asset&#x2F;Shader</strong>数量变多。但是一个材质也只会启用一两个变体（shader_feature），所以ShaderLab不会太大。</p><p>不同shader打包策略的细节情况：</p><ol><li><p>如果Always include （无论shader是否打包）则在<strong>打AB包时</strong>会编译所有变体。在<strong>build场景时</strong>也会编译所有变体（无论场景是否使用这个shader）。</p><p>1.1 如果这个shader打了AB包，但是没有加载这个AB包。则<strong>Asset&#x2F;Shader</strong>中只有一份，<strong>ShaderLab</strong>包含了所有变体。</p><p>1.2 如果这个shader打了AB包，同时加载了AB包（确实使用了，比如在材质中使用），则<strong>Asset&#x2F;Shader</strong>和<strong>ShaderLab</strong>都会翻一倍。</p><p>1.3 如果没有打包，但是加载了对这个shader有依赖的内容，则有几个依赖会翻几倍（<strong>这个shader的全部变体都会翻倍</strong>）。<strong>结论</strong>：a.AlwayInclude会使shader_feature编程multicompile全部编译，b.同时不管依赖情况如何，所有变体都会编译。</p></li><li><p>如果不用Always Include，如果不对shader打包，则每一个依赖都会生成一份shader的<strong>Asset&#x2F;Shader</strong>，同时根据各自shader_feature的启用情况，生成各自所需要的<strong>ShaderLab</strong>的。</p></li><li><p>如果不用Always Include，如果对shader打包，则只生成一份shader的<strong>Asset&#x2F;Shader</strong>，他所需要的所有生效的shader_feature决定一份总的<strong>ShaderLab</strong>。</p></li></ol><h2 id="关于FallBack依赖"><a href="#关于FallBack依赖" class="headerlink" title="关于FallBack依赖"></a>关于FallBack依赖</h2><ol><li>如果Shader有多份（无论什么原因），FallBack Shader如果不打包，则FallBack Shader必定有多份。</li><li>无论Shader在AB包中存在了多少份（单独打一个包或被依赖资源打入多个包），如果FallBack Shader打包，则AB包中的这个Shader使用的FallBackShader只有一份，但是如果这个Shader出现在场景中，则Shader会多一份，FallBack Shader会多一份。</li></ol><p>在实际打包过程中需要注意的是，我们无法对内置shader进行打包，只能使用AlwaysInclude所以需要。尤其是依赖的Shader版本，是否在工程中。</p><h2 id="关于Dependency依赖"><a href="#关于Dependency依赖" class="headerlink" title="关于Dependency依赖"></a>关于Dependency依赖</h2><p>和FallBack一致</p><p><strong>注：</strong></p><ol><li><p>场景当中DIsable的GameObject对应的Material的材质一样会被编译进入场景。</p></li><li><p><strong>多个独立打包的shader的同一个Fallback会产生多份。</strong>放在工程目录任何位置FallBack都会生效。</p></li></ol><h1 id="地形shdaer的特殊依赖"><a href="#地形shdaer的特殊依赖" class="headerlink" title="地形shdaer的特殊依赖"></a>地形shdaer的特殊依赖</h1><p>1.如果把默认地形Shader放入AB包，不需要进行设置则可以自动使用本地的Shader</p><p>​针对Nature&#x2F;Terrain&#x2F;… shader</p><p>2.如果AlwayInclude也可以达到一样的效果。</p><p>3.一般Shader的FallBack直接放在工程里即可，但是地形Shader的Dependency 的Hidde&#x2F;***无法Alwaysinclude，单独打包也不会被引用。</p><p>4.注意啊 如果Nature已经放入工程，则工程内的地形只会使用这个，在使用AlwayInlcude包括内置的Natureshadr就没有意义了。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UV云或阴影被远近剪裁面Clip的问题</title>
      <link href="/2023/06/02/Unity/UV%E4%BA%91%E8%A2%AB%E8%A3%81%E5%87%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2023/06/02/Unity/UV%E4%BA%91%E8%A2%AB%E8%A3%81%E5%87%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="UV云或阴影被远近剪裁面Clip的问题"><a href="#UV云或阴影被远近剪裁面Clip的问题" class="headerlink" title="UV云或阴影被远近剪裁面Clip的问题"></a>UV云或阴影被远近剪裁面Clip的问题</h1><p>在制作大世界的过程中，美术需要自己设计云的摆放，这样的云实际上就是一个摆放在天上的大透明面片。</p><p>所有物体的渲染都需要经历一个硬件级别的剪裁，也就是ClipSpace的作用。但是考虑到场景中视距只有几百米，所以远剪裁面可能为500。这就导致云被clip掉了。</p><p>硬件对顶点数据进行剪裁的依据也是clipspace坐标：</p><p>在Unity当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">v2f <span class="hljs-title function_">vert</span> <span class="hljs-params">(appdata v)</span><br>&#123;<br>    v2f o;<br>    o.vertex = UnityObjectToClipPos(v.vertex);<br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure><p>clipspace.z 通常用来进行剪裁、进行深度测试、写入深度。同时依赖于clipspace.w.</p><p>clipspace.xy 通常用来用作透视变换、视口变换、光栅化。同时依赖于clipspace.w.</p><p>当渲染透明物体的时候，clipspace.z实际上就只用做了深度测试和剪裁。</p><p>uv云不希望被剪裁掉，所以可以修改clipspace.z，让他在远近剪裁面之间。</p><p>又由于uv云还是需要进行正确的深度测试，不能挡住不透明物体，所以需要放到远剪裁面上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">v2f <span class="hljs-title function_">vert</span> <span class="hljs-params">(appdata v)</span><br>&#123;<br>    v2f o;<br>    o.vertex = UnityObjectToClipPos(v.vertex);<br>    o.vertex.z =  <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure><p>o.vertex.z 的远近剪裁面实际上和具体的图形接口有关，D3D和Opengl的远剪裁面值是不一样的。所以不能简单的设置成1.</p><p>Unity当中就可以通过：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_REVERSED_Z</span><br><span class="hljs-comment">// 远处比较大</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-comment">// 近处深度大</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// 远近剪裁面 API相关设置：</span><br>D3D11<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_REVERSED_Z 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_NEAR_CLIP_VALUE (1.0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_RAW_FAR_CLIP_VALUE (0.0)</span><br><br>GL<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_REVERSED_Z 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_NEAR_CLIP_VALUE (-1.0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_RAW_FAR_CLIP_VALUE (1.0)</span><br><br>PSSL<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_REVERSED_Z 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_NEAR_CLIP_VALUE (1.0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_RAW_FAR_CLIP_VALUE (0.0)</span><br><br><span class="hljs-comment">// 把clip限制在近剪裁面：</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(UNITY_REVERSED_Z)</span><br>    <span class="hljs-type">float</span> clamped = min(clipPos.z, clipPos.w*UNITY_NEAR_CLIP_VALUE);<span class="hljs-comment">// clipPos.z&lt;1</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">float</span> clamped = max(clipPos.z, clipPos.w*UNITY_NEAR_CLIP_VALUE);<span class="hljs-comment">// clipPos.z&gt;-1</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// 把clip限制在远：</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(UNITY_REVERSED_Z)</span><br>    <span class="hljs-type">float</span> clamped = max(clipPos.z, UNITY_RAW_FAR_CLIP_VALUE);<span class="hljs-comment">// clipPos.z&gt;0</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">float</span> clamped = min(clipPos.z, UNITY_RAW_FAR_CLIP_VALUE);<span class="hljs-comment">// clipPos.z&lt;1</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Texture Streaming</title>
      <link href="/2023/06/02/Unity/UnityTextureStreaming/"/>
      <url>/2023/06/02/Unity/UnityTextureStreaming/</url>
      
        <content type="html"><![CDATA[<h1 id="Texture-Streaming"><a href="#Texture-Streaming" class="headerlink" title="Texture Streaming"></a>Texture Streaming</h1><p><a href="https://docs.unity3d.com/Manual/TextureStreaming.html">官方文档</a></p><p>Texture Streaming 主要为了解决：</p><p>​当导入贴图的时候，会生成mipmap。导致贴图和mipmap加起来占用的空间变大。</p><p>例如：大部分物体离得比较远，使用了贴图的LOD4。但是这个时候LOD0-3都会进入内存。</p><p>Texture Streaming的作用就是在使用贴图的时候，只向内存传递需要的mipmap级别的贴图，降低内存占用，不过需要额外的CPU计算。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UnlitShader使用</title>
      <link href="/2023/06/02/Unity/hdrp%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2023/06/02/Unity/hdrp%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-UnlitShader使用"><a href="#1-UnlitShader使用" class="headerlink" title="1.UnlitShader使用"></a>1.UnlitShader使用</h1><ol><li><p>目前UnlitGraph支持主要的纹理、向量、颜色、顶点色、屏幕空间位置等各种基础参数的计算。</p></li><li><p>通过宏来切换不同效果的部分需要手写谢。</p></li><li><p>同时支持透明和不透明两种模式。</p></li><li><p><strong>扭曲distort，默认的Unlit shader已经可以使用</strong>，但是UnlitGraph没有提供，LitGraph有这个功能，所以未来应该会提供。</p></li></ol><p>使用方式：HDRP创建er默认材质，Shader改成Hdrp&#x2F;Unlit，材质选项中Surface Type改成Transparent。此时材质下方出现了新的选项Transprency Input。打开Distortion，给出一张扭曲纹理，然后调节参数就可以看到扭曲效果。</p><p><strong>注意</strong>：扭曲和渲染顺序无关，所有和扭曲材质重叠切没有渲染深度的材质，都会被扭曲。</p><h1 id="2-LitShader"><a href="#2-LitShader" class="headerlink" title="2.LitShader"></a>2.LitShader</h1><ol><li><p>Lit一共有两种扭曲方式：Refraction折射和Distortion变形。LitGraph也可以使用这两个功能</p></li><li><p>支持折射、扭曲，但是会带上光照。</p></li><li><p>Refraction：透明的Lit物体可以用折射功能（Unlit物体只可以选择是否被折射）。Lit物体如果要折射其他物体就不能被其他的物体折射。不透明物体可以选择是否被折射。可以用来实现类似冰冻怪物的效果。</p></li><li><p>Distortion：Unlit和透明的Lit都可以用。有扭曲的Unlit材质会扭曲任何和他重叠的无深度物体。</p></li></ol><h1 id="3-Unlit贴花"><a href="#3-Unlit贴花" class="headerlink" title="3.Unlit贴花"></a>3.Unlit贴花</h1><ol><li><p>默认的功能无法实现Unlit效果。我们需要自己实现Unlit Decal，理论上只要能够正确读取深度就可以渲染，不过需要研究一下渲染输出的buffer、渲染队列、已经新的深度读取方式。</p></li><li><p><strong>内置贴花支持模型贴花</strong>，一个Decal模型可以贴附在另一个模型上，可以有自己的UV。</p></li></ol><h1 id="4-天空球编程"><a href="#4-天空球编程" class="headerlink" title="4.天空球编程"></a>4.天空球编程</h1><p>参考链接：<a href="https://github.com/Unity-Technologies/ScriptableRenderPipeline/wiki/Writing-A-Custom-Sky-Renderer">天空球编程</a>，可以自由实现想要的天空球。</p><p>#5.HDRP 自带天空球混合</p><p>Unity Volume源代码中有实现HDRI插值的计划，见：TODO注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CubemapParameter</span> :</span> VolumeParameter&lt;Cubemap&gt;<br>&#123;<br>     public <span class="hljs-title function_">CubemapParameter</span><span class="hljs-params">(Cubemap value, <span class="hljs-type">bool</span> overrideState = <span class="hljs-literal">false</span>)</span><br>     : <span class="hljs-title function_">base</span><span class="hljs-params">(value, overrideState)</span> &#123;&#125;<br>     <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Cubemap interpolation</span><br>&#125;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoInterpCubemapParameter</span> :</span> VolumeParameter&lt;Cubemap&gt;<br>&#123;<br>    public <span class="hljs-title function_">NoInterpCubemapParameter</span><span class="hljs-params">(Cubemap value, <span class="hljs-type">bool</span> overrideState = <span class="hljs-literal">false</span>)</span><br>    : <span class="hljs-title function_">base</span><span class="hljs-params">(value, overrideState)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Volume当中的不同天空球都可以实现各自的混合效果，不过Hdri目前没有实现完（如果是其他两种类型的天空球，当前版本已经可以实现插值）。cubemap在混合时实时计算插值，有一部分开销需要考虑。在HDRP6.0.0当中也还是没有实现，不知道Unity是出于什么考虑，一直没有给出Cubemap混合的代码。</p><p>目前，<strong>我们实现这部分代码就可以直接使用Volume当中的天空球插值</strong>。</p><p>#6.关于特效和渲染队列</p><p>之前美术手动调节了材质上的渲染队列来实现不同的特效。现在渲染队列的机制有一些改动，在不熟悉之前最好不要手动设置队列（默认材质都是不能调节的，只能修改<strong>渲染优先级Sort Priority</strong>），通过Shader Graph创建的可以手动设置。</p><p>现在，在不透明物体渲染阶段，不会渲染2650以上的物体（看源代码得到的结果，在以前只要有队列，就会按照队列顺序渲染），反之亦然。</p><p>HDRP理论上不建议手动调整材质顺序，因为这个顺序不在单纯的是顺序，还涉及到各种特殊的效果。</p><p>2650-2850用来渲染被折射的透明物体，这个都是通过设置自动配置的，在不熟悉引擎之前不要修改材质队列。</p><p>2900-3100是一把透明物体。</p><p>2850到2900之间会出现奇怪的变化，Unity没有给出这部分渲染的是什么。</p><p>2000到2500是不透明物体。这个队列以外的不透明物体不会渲染。</p><p>2000以下什么都不会渲染（以前都是可以渲染的）。</p><p><strong>现在的状态就是：如果没有把队列和物体类型匹配就会出现不可预知的结果。</strong></p><p>下面是控制渲染队列的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Priority</span></span><br><span class="hljs-class">        &#123;</span><br>            Background = UnityEngine.Rendering.RenderQueue.Background,<br>            Opaque = UnityEngine.Rendering.RenderQueue.Geometry,<br>            OpaqueAlphaTest = UnityEngine.Rendering.RenderQueue.AlphaTest,<br>            <span class="hljs-comment">// Warning: we must not change Geometry last value to stay compatible with occlusion</span><br>            OpaqueLast = UnityEngine.Rendering.RenderQueue.GeometryLast,<br>            <span class="hljs-comment">// For transparent pass we define a range of 200 value to define the priority</span><br>            <span class="hljs-comment">// Warning: Be sure no range are overlapping</span><br>            PreRefractionFirst = <span class="hljs-number">2750</span> - k_TransparentPriorityQueueRange,<br>            PreRefraction = <span class="hljs-number">2750</span>,<br>            PreRefractionLast = <span class="hljs-number">2750</span> + k_TransparentPriorityQueueRange,<br>            TransparentFirst = UnityEngine.Rendering.RenderQueue.Transparent - k_TransparentPriorityQueueRange,<br>            Transparent = UnityEngine.Rendering.RenderQueue.Transparent,<br>            TransparentLast = UnityEngine.Rendering.RenderQueue.Transparent + k_TransparentPriorityQueueRange,<br>            Overlay = UnityEngine.Rendering.RenderQueue.Overlay<br>        &#125;<br><br>RenderQueueRange k_RenderQueue_OpaqueNoAlphaTest = <br>    new RenderQueueRange &#123; min = (<span class="hljs-type">int</span>)Priority.Opaque, <br>                          max = (<span class="hljs-type">int</span>)Priority.OpaqueAlphaTest - <span class="hljs-number">1</span> &#125;;<br><br>RenderQueueRange k_RenderQueue_OpaqueAlphaTest = <br>    new RenderQueueRange &#123; min = (<span class="hljs-type">int</span>)Priority.OpaqueAlphaTest, <br>                          max = (<span class="hljs-type">int</span>)Priority.OpaqueLast &#125;;<br><br>RenderQueueRange k_RenderQueue_AllOpaque = new RenderQueueRange &#123; <br>    min = (<span class="hljs-type">int</span>)Priority.Opaque,<br>    max = (<span class="hljs-type">int</span>)Priority.OpaqueLast &#125;;<br><br>RenderQueueRange k_RenderQueue_PreRefraction = new RenderQueueRange &#123; <br>    min = (<span class="hljs-type">int</span>)Priority.PreRefractionFirst, <br>    max = (<span class="hljs-type">int</span>)Priority.PreRefractionLast &#125;;<br><br>RenderQueueRange k_RenderQueue_Transparent = new RenderQueueRange &#123; <br>    min = (<span class="hljs-type">int</span>)Priority.TransparentFirst, <br>    max = (<span class="hljs-type">int</span>)Priority.TransparentLast &#125;;<br><br>RenderQueueRange k_RenderQueue_AllTransparent = new RenderQueueRange &#123; <br>    min = (<span class="hljs-type">int</span>)Priority.PreRefractionFirst, <br>    max = (<span class="hljs-type">int</span>)Priority.TransparentLast &#125;;<br><br>RenderQueueRange k_RenderQueue_All = new RenderQueueRange &#123; min = <span class="hljs-number">0</span>, max = <span class="hljs-number">5000</span> &#125;;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>fullforwardshadows</title>
      <link href="/2023/06/02/Unity/fullforwardshadows/"/>
      <url>/2023/06/02/Unity/fullforwardshadows/</url>
      
        <content type="html"><![CDATA[<p>在surfaceshader当中涉及到两个和阴影有关的参数：fullforwardshadows和addshadow</p><h2 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h2><ol><li><p>在前向渲染中surface会编译成forwardbase和forwardadd两个pass，</p></li><li><p>原本的forwardbase当中，默认会对阴影贴图（触发forwardbase的主要直线光对应的阴影）进行采样。如果加上noshadow，在forwardbase阶段也不在对阴影贴图进行采样。</p></li><li><p>在使用fragment shader时，forwardadd pass中需要一个 multi_compile_fwdadd_fullshadow宏来开启对阴影的定义，以对阴影贴图进行正确采样。</p></li><li><p>在surfaceshader当中fullforwardshadows和multi_compile_fwdadd_fullshadow一样。加上后shader的变体多了几个和阴影相关的宏，SHADOWS_SOFT,SHADOWS_CUBE,SHADOW_DEPTH,SHADOWS_SCREEN等等，这些是屏幕阴影采样有关。这个宏并不影响forwardbase（surfaceshader的编译结果）。这个宏对阴影采样有关，所有说只影响forwardadd过程阴影的接收。</p></li><li><p>surface shader的宏：addshadow 的作用是产生shadercaster的pass用来投射阴影，会定义两个宏：SHADOWS_DEPTH:用于生成直线光和探照灯阴影，SHADOW_CUBE：用于生成点光源阴影。这个宏会产生一个shadowcaster所以只影响阴影的投射。他和FallBack 已经自己写的shadow caster是冲突的。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度</title>
      <link href="/2023/06/02/Unity/%E6%B7%B1%E5%BA%A6%E4%BF%A1%E6%81%AF/"/>
      <url>/2023/06/02/Unity/%E6%B7%B1%E5%BA%A6%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h1><p>在unity当中所有的不透明物体都需要使用深度(Zbuffer)做深度剔除：ZWtire ZTest</p><p>深度信息保存在一张高精度的纹理当中。</p><p><strong>Note:</strong> On DX11&#x2F;12, PS4, XboxOne and Metal, the <strong>Z buffer</strong> range is 1–0 and UNITY_REVERSED_Z is defined. On other platforms, the range is 0–1.（在一些平台，深度纹理从近到远是从1到0，并且定义了一个宏UNITY_REVERSED_Z ，在其他平台是从0到1）</p><p>当shader打开ZWrite的时候，默认会 向Zbuffer写入内容，会通过特殊的编码，保证近处的精确度更高。范围在[0,1]之间。描述了远近剪裁面之间。</p><p>注：有一个<strong>Linear01Depth</strong>宏，他会把深度从Zbuffer中的非线性[0,1]（或[1,0]）变成线性的[0,1].</p><p><strong>COMPUTE_EYEDEPTH(i)</strong>:宏会计算观察空间的坐标，实际上就是观察空间的z值（原本是负数，输出之前进行了取反操作）输出到i。（只能在顶点程序中使用，内部使用的顶点shader的输入变量v.vertex）。</p><p><strong>COMPUTE_DEPTH_01</strong>: 这个宏的结果就是一个0到1的深度变化，等于上一个宏 * _ProjectionParam.w（1&#x2F; far）。（也就是除了个远剪裁面）</p><p>上面两个宏，针对的是当前顶点的局部坐标（v.vertex）.</p><p><strong>LinearEyeDepth</strong>(i):  将Zbuffer（深度贴图）中的值转换到观察空间。 </p><p>**Linear01Depth(i)**：将深度贴图的值转化到线性01范围。</p><p>上面两个宏对应的是从深度贴图提取出来的值。</p><p>注：_ProjectionParams <code>x</code> is 1.0 (or –1.0 if currently rendering with a <a href="https://docs.unity3d.com/Manual/SL-PlatformDifferences.html">flipped projection matrix</a>), <code>y</code> is the camera’s near plane, <code>z</code> is the camera’s far plane and <code>w</code> is 1&#x2F;FarPlane.</p><h1 id="渲染管线中深度的保存和计算原理"><a href="#渲染管线中深度的保存和计算原理" class="headerlink" title="渲染管线中深度的保存和计算原理"></a>渲染管线中深度的保存和计算原理</h1><p> 渲染管线过程会出现两次坐标系的选项性转换：</p><ol><li>世界空间&#x3D;&gt;观察空间 ： 左手变右手。</li><li>观察空间&#x3D;&gt;剪裁空间：右手变左手。</li></ol><p>进入剪裁空间是为了方便摄像机剪裁而进行的一次对坐标系参数的<em><strong>缩放和偏移</strong></em>。</p><p>进入剪裁空间后每一个点(x,y,z,w)只需要满足:<br>$$-w \le x  \le w$$</p><p>$$-w \le y  \le w$$</p><p>$$-w \le z  \le w (Opengl)$$ </p><p>$$ 0 \le z  \le w(dx11)$$ </p><h3 id="以DX11为例"><a href="#以DX11为例" class="headerlink" title="以DX11为例"></a>以DX11为例</h3><p>unity DX11的CullSpace的z值计算方式:</p><p>$$     z_{cullspace} &#x3D;  \frac  {near} {far - near}  * z_{cameraspace} + \frac{far*near}{far -near}    $$</p><p>unity对于深度缓存的编码方式：</p><p>$$ z_{inzbuffer} &#x3D; ( - \frac 1 z_{cameraspace})(\frac {near* z_{cameraspace}}{far - near}- \frac{far*near}{far - near}) $$</p><p>注：上面的$  z_{cameraspace}  $由于CameraSapce  所以始终是一个负数。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>世界坐标恢复</title>
      <link href="/2023/06/02/Unity/%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E6%81%A2%E5%A4%8D/"/>
      <url>/2023/06/02/Unity/%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="世界坐标恢复"><a href="#世界坐标恢复" class="headerlink" title="世界坐标恢复"></a>世界坐标恢复</h1><p>在unity当中所有的屏幕空间技术都依赖于世界坐标恢复。例如：SSR屏幕空间反射，SSS屏幕空间阴影，ContactShadow细节阴影等。依赖于屏幕空间的Ray trace。</p><p>这里主要是讨论如何从深度图中恢复世界坐标并进行使用。之后有时间会制作一些相关特效。</p><h2 id="世界坐标恢复-1"><a href="#世界坐标恢复-1" class="headerlink" title="世界坐标恢复"></a>世界坐标恢复</h2><p>我们这里分析的是PostProcessing <a href="mailto:&#86;&#50;&#64;&#x32;&#46;&#x31;&#x34;">&#86;&#50;&#64;&#x32;&#46;&#x31;&#x34;</a>版本当中SSR。主要的代码在ScreenSpaceReflections.hlsl当中。</p><p>具体步骤如下：</p><p><strong>第一步</strong>，需要[0,1]区间的纹理坐标。</p><p>这部分可以在顶点着色器当中设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">VaryingsDefault <span class="hljs-title function_">VertDefault</span><span class="hljs-params">(AttributesDefault v)</span><br>&#123;<br>    VaryingsDefault o;<br>    o.vertex = float4(v.vertex.xy, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    o.texcoord = (v.vertex.xy + <span class="hljs-number">1.0</span>) * <span class="hljs-number">0.5</span>;<br><br>    <span class="hljs-comment">// 处理正反y轴</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_UV_STARTS_AT_TOP</span><br>    o.texcoord = o.texcoord * float2(<span class="hljs-number">1.0</span>, <span class="hljs-number">-1.0</span>) + float2(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二步</strong>，需要根据<strong>屏幕uv坐标</strong>和<strong>深度值</strong>组成出标准设备坐标<strong>NDC</strong>，通过NDC和投影矩阵的逆矩阵就可以计算出摄像机坐标，下面是函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 <span class="hljs-title function_">GetViewSpacePosition</span><span class="hljs-params">(float2 uv)</span><br>&#123;<br>    <span class="hljs-comment">// 采样深度纹理，注意这里不是HDRP的采样方式</span><br>    <span class="hljs-type">float</span> depth = _CameraDepthTexture.SampleLevel(sampler_CameraDepthTexture, UnityStereoTransformScreenSpaceTex(uv), <span class="hljs-number">0</span>).r;<br>    <span class="hljs-comment">// 使用[-1 ,1]区间的uv坐标和，深度纹理当中的值，可以得到标准设备坐标NDC。</span><br>    <span class="hljs-comment">// 这里需要注意需要使用_InverseProjectionMatrix 投影矩阵的逆矩阵。</span><br>    float4 result = mul(_InverseProjectionMatrix, float4(<span class="hljs-number">2.0</span> * uv - <span class="hljs-number">1.0</span>, depth, <span class="hljs-number">1.0</span>));<br>    <span class="hljs-keyword">return</span> result.xyz / result.w;<br>&#125;<br></code></pre></td></tr></table></figure><p>按照上面的步骤我们可以得到屏幕空间中，渲染过深度的物体的世界坐标。</p><p>但是，非HDRP的渲染中我们没有内置的_InverseProjectionMatrix矩阵，这个矩阵是后处理代码中设置到shader里的。</p><p>而在HDRP当中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">real4 <span class="hljs-title function_">frag</span> <span class="hljs-params">(v2f i)</span> : SV_Target<br>&#123;<br>    real2 uv = i.uv * _ScreenParams.xy;<br>    <span class="hljs-comment">// 这个是HDRP读取深度图的方式</span><br>    real depthsrc = LOAD_TEXTURE2D(_CameraDepthTexture, uv).r;<br><span class="hljs-comment">// 构造标准设备坐标</span><br>    real4 cullPos = real4((i.uv.xy * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>), depthsrc, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-comment">// y坐标是坐下角转换到右上角</span><br>    cullPos.y =- cullPos.y;<br><br>    real4 viewPos = mul(UNITY_MATRIX_I_P,cullPos);<br>    viewPos = viewPos / viewPos.w;<br>    real4 worldPos = mul(unity_MatrixInvV,viewPos);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到这里使用了UNITY_MATRIX_I_P矩阵，这个矩阵是UnityHDRP中新增加的。</p><p>深度图的采样方式需要注意和原始方式不同。</p><p>HDRP部分的语法用的是hlsl而非cg。</p><h2 id="关于恢复原理的说明"><a href="#关于恢复原理的说明" class="headerlink" title="关于恢复原理的说明"></a>关于恢复原理的说明</h2><p> _InverseProjectionMatrix矩阵的来源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">GL.GetGPUProjectionMatrix(context.camera.projectionMatrix, <span class="hljs-literal">false</span>).inverse;<br></code></pre></td></tr></table></figure><p>UNITY_MATRIX_P 等价于 <a href="http://resetoter.cn/UnityDoc/ScriptReference/GL.html">GL</a>.GetGPUProjectionMatrix，而UNITY_MATRIX_P 是根据平台进行了特殊调整的，目前还没有仔细研究。</p><ol><li><strong>假设投影变换会让坐标由(x,y,z,w)变成(x’,y’,z’,w’)。</strong></li></ol><p>我们知道投影矩阵会让w向量变成当前点所在的z向量（ w’ &#x3D; z ）。而x’，y’，z’需要在[-w’, w’]之间（也就是-z到z）来进行剪裁。</p><p>也就是说投影矩阵会让w&#x3D;1 变成w’ &#x3D; z（当前点深度坐标）.</p><p>所以逆矩阵会让w’&#x3D;1 变成 w &#x3D; 1 &#x2F; z.   x’[-1 1] &#x3D;&gt; x[x&#x2F;w]（正向：x[x]&#x3D;&gt;x[-w , w]）</p><p>在xyz乘逆矩阵之后，我们得到的范围缩小了z所以需要乘上z，也就是除w。</p><p>这样就恢复出了摄像机坐标。</p><ol start="2"><li><strong>第二点，我们从摄像机坐标恢复到世界坐标的时候使用的矩阵是unity_MatrixInvV，而不是UNITY_MATRIX_I_V(_InvViewMatrix)。</strong></li></ol><h2 id="HDRP从深度图到世界坐标源代码"><a href="#HDRP从深度图到世界坐标源代码" class="headerlink" title="HDRP从深度图到世界坐标源代码"></a>HDRP从深度图到世界坐标源代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Unlit/RevertWorldPosition&quot;</span><br>&#123;<br>    SubShader<br>    &#123;<br>        Tags &#123; <span class="hljs-string">&quot;RenderType&quot;</span>=<span class="hljs-string">&quot;ForwardOnly&quot;</span> &#125;<br>        LOD <span class="hljs-number">100</span><br><br>        Pass<br>        &#123;<br>            HLSLPROGRAM<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> target 4.5</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;</span></span><br>            <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl&quot;</span></span><br><br>            <span class="hljs-keyword">struct</span> appdata<br>            &#123;<br>                real4 vertex : POSITION;<br>                real2 uv : TEXCOORD0;<br>            &#125;;<br><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span></span><br><span class="hljs-class">            &#123;</span><br>                real2 uv : TEXCOORD0;<br>                real4 screenposition : TEXCOORD1;<br>                real4 vertex : SV_POSITION;<br>            &#125;;<br><br>            real _DistancePost;<br><br>            v2f <span class="hljs-title function_">vert</span> <span class="hljs-params">(appdata v)</span><br>            &#123;<br>                v2f o;<br>                o.vertex = mul(UNITY_MATRIX_VP,mul(UNITY_MATRIX_M,v.vertex));<br>                o.uv = v.uv;<br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            real4 <span class="hljs-title function_">frag</span> <span class="hljs-params">(v2f i)</span> : SV_Target<br>            &#123;<br>                real2 uv = i.uv * _ScreenParams.xy;<br>                real depthsrc = LOAD_TEXTURE2D(_CameraDepthTexture, uv).r;<br>                real depth = Linear01Depth(LOAD_TEXTURE2D(_CameraDepthTexture, uv), _ZBufferParams);<br><br>                real4 cullPos = real4((i.uv.xy * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>), depthsrc, <span class="hljs-number">1.0</span>);<br>                cullPos.y =- cullPos.y;<br><br>                real4 viewPos = mul(UNITY_MATRIX_I_P,cullPos);<br>                viewPos = viewPos / viewPos.w;<br>                real4 worldPos = mul(unity_MatrixInvV,viewPos);<br>                real4 worldPos1 = mul(_InvViewMatrix,viewPos);<br>                real4 worldPos3 = mul(UNITY_MATRIX_M,viewPos);<br>                real4 worldPos2 = mul(UNITY_MATRIX_M,mul(UNITY_MATRIX_P,mul(UNITY_MATRIX_V,viewPos)));<br><br>                <span class="hljs-keyword">return</span> float4(worldPos.xyz,<span class="hljs-number">1</span>);<br>            &#125;<br>            ENDHLSL<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渲染过程中buffer的变化</title>
      <link href="/2023/06/02/Unity/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%ADbuffer%E7%9A%84%E5%8F%98%E5%8C%96/"/>
      <url>/2023/06/02/Unity/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%ADbuffer%E7%9A%84%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>无论在Deferred还是Forward，在AfterForwardAplha阶段深度就已经清除了</p><p>Resolve Depth 在Gbuffer填充时生效，在Gbuffer结束时，会拷贝的Depth纹理中</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vulkan Translate Chapter 1 Introduction</title>
      <link href="/2023/06/02/VulkanTranslate/Chapter1-Introduction/"/>
      <url>/2023/06/02/VulkanTranslate/Chapter1-Introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1 Introduction"></a>Chapter 1 Introduction</h1><p>这篇文档主要是一份说明文档，用来描述Vulkan API。 Vulkan API是符合 C99标准的控制low-level图形计算功能的API。</p><p>文档的权威版本在官方网站可以查阅：<a href="https://www.khronos.org/registry/vulkan/">官方文档</a></p><p>生成官方文档的工程：[文档工程](<a href="https://github.com/">https://github.com/</a> KhronosGroup&#x2F;Vulkan-Docs)</p><h2 id="1-1-文档约定"><a href="#1-1-文档约定" class="headerlink" title="1.1 文档约定"></a>1.1 文档约定</h2><p>Vulkan说明文档用与给API开发人员和应用开发人员提供API使用参考，为两者提供统一的约定。从上下文通常也能推断出面向的受众，某些部分只针对这部分开发人员。例如 Valid Usage章节只提供给应用开发人员使用。任何的需求、禁止、建议和选择都在Normative terminology中说明。</p><blockquote><p>Note</p><p> extensions 中定义的结构体、枚举类型已经被集成到了Vulkan 1.1的核心库中。这些内容现在和Vulkan1.1的接口等价。和部分影响了Vulkan说明文件、头文件、和XML注册表。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> VulkanTranslate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vulkan-A-Specification中文翻译版</title>
      <link href="/2023/06/02/VulkanTranslate/Vulkan-A-Specification%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91%E7%89%88/"/>
      <url>/2023/06/02/VulkanTranslate/Vulkan-A-Specification%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Vulkan-A-Specification中文翻译版"><a href="#Vulkan-A-Specification中文翻译版" class="headerlink" title="Vulkan-A-Specification中文翻译版"></a>Vulkan-A-Specification中文翻译版</h1><p>翻译了一点点发现已经有了一个相对完整的中文版，但是发现了大量的错别字和语句问题，导致很难理解。</p><p><a href="https://khronos.org/registry/vulkan/specs/1.1/html/chap15.html#textures-texel-filtering">Vulkan Specification英文版</a></p><p><a href="http://spec.vulkan.org.cn/#devsandqueues">Vulkan Specification中文版</a></p><p>我这里就尝试翻译一些重要的部分。</p><p><a href="Chapter1-Introduction.md">Chapter1-Introduction</a></p><p><a href="Chapter2-Fundamentals-%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD">Chapter2-Fundamentals-基础功能</a></p>]]></content>
      
      
      <categories>
          
          <category> VulkanTranslate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vulkan Translate Chapter2 Fundamentals 基础功能</title>
      <link href="/2023/06/02/VulkanTranslate/Chapter2-Fundamentals-%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD/"/>
      <url>/2023/06/02/VulkanTranslate/Chapter2-Fundamentals-%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter2-Fundamentals-基础功能"><a href="#Chapter2-Fundamentals-基础功能" class="headerlink" title="Chapter2 Fundamentals 基础功能"></a>Chapter2 Fundamentals 基础功能</h1><p>​这个章节主要介绍了基础概念：包括Vulkan架构、扩展模型、API语法、管线配置、数字表示方法、状态和状态查询、以及不同类型的对象和Shader。这部分提供了一个框架用于解释说明文档剩下部分中更加具体的命令和表现。</p><h2 id="2-1-主机和设备环境"><a href="#2-1-主机和设备环境" class="headerlink" title="2.1 主机和设备环境"></a>2.1 主机和设备环境</h2><p>Vulkan说明文件假设并且需要：主机设备满足下面的要求以支持Vulkan的实现：</p><ul><li><p>主机必须支持8,16,32,64位的有符号以及无符号整型，并且可以按照字节（byte）寻址。</p></li><li><p>主机必须支持32-和64-位的浮点数类型，并且满足后续章节的范围和精度的要求。</p></li><li><p>这些数据的字节顺序和表示方式必须和物理设备一致。</p></li></ul><blockquote><p>Note</p><p>因为各种类型的数据和结构体主机和物理设备都需要访问，所以两端都需要高效的访问以便保证灵活写入和高性能。</p></blockquote><h2 id="2-2-Execution-Model-执行模式"><a href="#2-2-Execution-Model-执行模式" class="headerlink" title="2.2 Execution Model 执行模式"></a>2.2 Execution Model 执行模式</h2><p>这一节说明了Vulkan系统的执行模式。</p><p>​Vulkan会暴露出一个或者多个device，每个device会暴露出一个或多个能够异步工作的queue。同一个device支持的各个队列会划分到不同的family。每一个family支持一种或多种功能，并且应该包含一个或多个有相同特性的queue。同一个family当中queue可以认为是互相兼容的。为某个queue所生产的任务，可以在其所属family中的任何一个queue上执行。本说明文档定义了queue可能具备的四个类型的功能：Graphic，Compute，Transfer 和Sparse memory management。</p><blockquote><p>Note</p><p>一个device可能报告出多个相似queue的family，而不是报告出这些fafmily的一个或多个的多个成员。这表明，虽然这些family的queue具有类似的能力，但他们之间并不直接相容。（没有很明白。）</p></blockquote><p>设备内存是通过应用程序明确的管理的。每一个设备都可以声明一个或者多个堆用于区分不同区域的内存。内存堆要么是设备的本地内存要么是主机的本地内存，但是对于设备总是可见的。进一步的内存堆的细节是通过在堆上的可用内存类型暴露出来的。例如可用的内存类型有：</p><ul><li>device local：和device直接物理连接的设备内存。</li><li>device local, host visible: 设备的local内存对于主机可见。</li><li>host local ,host  visible : 是在主机的内存对设备和主机都可见。</li></ul><p>在其它的架构上，可能有一种堆满足各种用处。</p><p>一个Vulkan 应用程序通过提交command buffer来控制所有设备，command buffer能够通过Vulkan库函数的调用记录设备命令。Command buffer的内容依赖与具体的实现和应用程序无关。一旦构造了Comman buffer，就可以进行提交一次或者多次到队列中来执行。多个Command buffer能够通过多线程并行的构建。</p><p>Command buffer 提交到不同的队列能够并行的执行，执行顺序彼此没有关联。Command buffer提交到同一个队列表示了一个提交顺序。Command buffer在设备中执行的结果也是异步返回到主机的。一旦Command buffer提交到一个队列，控制流会立即返回到应用程序。应用程序需要关注同步设备和主机、同步各个队列。</p><h3 id="2-2-1-队列操作-Queue-Operation"><a href="#2-2-1-队列操作-Queue-Operation" class="headerlink" title="2.2.1 队列操作 Queue Operation"></a>2.2.1 队列操作 Queue Operation</h3><p>Vulkan队列提供了一个执行设备引擎的接口。引擎执行的命令在运行之前记录到Command Buffer当中。这些命令伴随queue submission命令提交到一个队列中，进行批量(batches)执行。一旦命令提交到队列，这些命令将会开始并在脱离程序控制的状态下完整的执行，执行的顺序依赖于一些隐式和显式的排序约束。</p><p>任务一般会通过队列提交命令提交到队列，这些命令一般形如<code>vkQueue*</code>(例如：<code>vkQueueSubmit</code>, <code>vkQueueBindSparse</code>)，并且可以接受一组等待信号量（信号被激活时才会开始执行）和一组激发的信号量（人物完成或会激活对应的信号）。信号量的处理和任务本身都属于队列操作。</p><p>在不同队列上的队列操作并没有隐式的顺序限制，可能以任何顺序执行。不同队列间同步可以通过semaphores（通常用于GPU-GPU指令同步）和fences（通常用语CPU-GPU同步）控制。</p><p>提交到一个队列中的Command buffer的执行顺序遵循提交顺序和隐式顺序的约束，其他情况则可能同时执行或者乱序执行。针对单个队列的其他类型的批处理和队列提交（例如：稀疏内存绑定），彼此之间没有隐式顺序约束。附加的批处理和队列提交显式顺序约束可以通过信号量semaphores（通常用于GPU-GPU指令同步）和fences（通常用语CPU-GPU同步）控制。</p><p>在semaphores或fences被激发之前，可以确定的是：之前被提交的队列操作已经完成了，且随后的队列操作可以继续进行内存的写入。等待一个被激活的semaphore或 fence可以保证之前的写入的内容是可用的，并且是对之后的命令可见（也就是说等待的semaphore或 fence完成后，接下来就能获取之前写入的内容。）</p><p>对于Command Buffer是没有顺序约束的，包括相同或者不同类型的Primary Command Buffer的batches或者submissions，以及Primary Command Buffer和Second Command Buffer之间。也就是说，在任何的 semaphore或者fence操作之间，提交一系列的Command Buffer（包括Second Command Buffer） 和在一个单独的Primary Command Buffer中记录这些命令然后提交是一样的（除非当前的状态被重置了）。想要显示的控制这些顺序，可以通过显示信号量。</p><p>在同一个Command Buffer当中的命令遵循一些隐式的顺序约束，但是只约束了一部分操作。</p><blockquote><p>​Note</p><p>提交到一个队列当中的任务有很大的自由度进行重叠执行。这是由于Vulkan本身的管线和并行策略决定的。</p></blockquote><p>记录在Command Buffer当中的命令包括：执行操作（例如：draw，dispatch，clear，copy，query&#x2F;timestamp， begin&#x2F;end subpass，）状态设置操作（例如：bind pipeline，descriptor sets, buffer, set dynamic state,push constants, set render pass），同步操作（例如：set&#x2F;wait events, pipeline barrier, render pass&#x2F;subpass dependencies）一些命令执行多次。状态设置会更新CommandBuffer当前的状态。一些命令的执行基于当前的状态。</p><p>设备端的队列执行和主机端队列提交是异步执行的。当命令缓冲区被提交到队列后控制流马上就退回到应用程序了。 应用程序必须按需求在主机端和设备端进行同步操作。</p><h2 id="2-3-对象模型-Object-Model"><a href="#2-3-对象模型-Object-Model" class="headerlink" title="2.3 对象模型 Object Model"></a>2.3 对象模型 Object Model</h2><p>devices，queue和其他的实例都是通过Vulkan object表示的。在API级别，所有的对象都通过handle来引用。有两种类型的handle：可分发的与不可分发的。<em>可分发的</em> handle是不可见类型数据的指针。这个指针可被layers使用，被当作拦截API命令的一部分， 每一个API命令都接受一个可分发类型的handle作为第一参数。 每一个不可分发类型的对象必须在其生命周期内有唯一一个handle值。</p><p>_不可分发的_handle类型是64位整型类型，其含义是Vulkan实现决定的，他可能会把对象信息直接包含到handle里，而非通过指向一个数据结构。不可分发类型的对象，对于不同的类型或者同一个类型可能没有唯一的handle值（handle可能重复）。 如果handle值不唯一，那么销毁任何一个handle时：要保证不能造成其他类型的、相同handle值的对象变得无效，也要保证如果用同一个handle创建了多个对象，并且创建次数多余销毁次数，也不能让这个销毁操作导致有相同handle值的对象失效。</p><p>所有通过<code>VkDevice</code> （用 <code>VkDevice</code>作为第一个参数 )的命令创建的对象都是该设备私有的，必须不能被其他设备使用。</p><h3 id="2-3-1-对象的生命周期Object-Lifetime"><a href="#2-3-1-对象的生命周期Object-Lifetime" class="headerlink" title="2.3.1 对象的生命周期Object Lifetime"></a>2.3.1 对象的生命周期Object Lifetime</h3><p>对象都是通过形如<code>vkCreate*</code> and <code>vkAllocate*</code> 的命令创建或者分配的。 一旦一个对象被创建或者分配，它的结构就被认为是不变的，即使对象的内容可以自由改动。 对象通过形如<code>vkDestroy*</code> 和 <code>vkFree</code>* 的命令来销毁或释放。</p><p>被分配（而不是创建）的对象从一个已存在的池子对象或者内存堆中获取资源，当被释放时会把资源归还给该池子或者堆。对象的创建和销毁在运行时通常是低频操作， 对象的分配或者释放可能是高频的。对象池帮助调节分配和释放的性能提升。</p><p>应用程序有责任跟踪Vulkan对象的生命周期，并且不能销毁正在被使用的对象。</p><p>属于应用程序端的内存在提交给Vulkan命令的时候会即刻被接管。在Vulkan命令执行结束之后一定会返还给应用程序。应用程序可以在需要占用这些内存的命令返回之后，再修改和释放这些内存。</p><p>下面的对象会在传递给Vulkan命令之后被消耗掉，并且不能再被由它创建的对象访问。这种对象在任何用到他们的API命令执行期间不能被销毁。</p><p>• VkShaderModule<br>• VkPipelineCache</p>]]></content>
      
      
      <categories>
          
          <category> VulkanTranslate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/Unity/Unity%E8%B4%B4%E5%9B%BE%E5%8E%8B%E7%BC%A9/"/>
      <url>/2022/09/19/Unity/Unity%E8%B4%B4%E5%9B%BE%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<p>贴图大小涉及到硬盘空间、内存空间。</p><p>目前可选泽的压缩格式包括：ETC1, ETC2, DXT1,, DXT3, DXT5，还有对于法线的</p><p>参考内容:<a href="https://www.unity3dtips.com/unity-texture-compression-android-ios/">参考链接</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/UE4RenderingSource/%5BUE%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%5D%E5%88%9D%E6%8E%A2UE4%E4%BB%A3%E7%A0%81%E5%B1%82/"/>
      <url>/2022/09/19/UE4RenderingSource/%5BUE%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%5D%E5%88%9D%E6%8E%A2UE4%E4%BB%A3%E7%A0%81%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="初入UE4代码层"><a href="#初入UE4代码层" class="headerlink" title="初入UE4代码层"></a>初入UE4代码层</h1><h2 id="阅读入口"><a href="#阅读入口" class="headerlink" title="阅读入口"></a>阅读入口</h2><p>本篇笔记主要记录了从零开始如何进入UE4的代码层，开始编码和Shader阅读。</p><p>首先需要对Shader和渲染过程有一定了解。</p><p>最开始需要了解的是两个关键的文件：</p><p><strong>BasePassPixelShader.usf</strong>：基础的Deferred渲染的Shader文件。</p><p><strong>DeferredShadingRenderer.cpp</strong>：控制渲染流程的代码。</p><p>当然我们都知道UE4有两套渲染管线：Deferred和针对手机的Mobile，所以对应的文件：</p><p><strong>MobileBasePassPixelShader.usf</strong></p><p><strong>MobileShadingRenderer.cpp</strong></p><p>上边两组文件的命名和编码有足够的自解释性，可以作为阅读的起始点（<strong>Deferred那一组</strong>）。通过阅读可以了解到</p><ol><li>UE4基础的渲染过程.</li><li>UE4Shader的语法、编码方式、组织方式（Shader文件的包含关系、文件结构等）</li></ol><p>推荐反复的推敲阅读，虽然暂时无法开始编码工作，但这两个文件可以对应到Unity或者是其他图形渲染引擎的相应部分。</p><p><strong>我也是以这两个文件为基础不断的进行延展的代码阅读。</strong></p><p>下面对这两部分进行导读：<a href="UE4Shader%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2.md">UE4Shader代码入门导读</a>和<a href="UE4%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2.md">UE4渲染流程代码入门导读</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/UE4RenderingSource/%5BUE%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%5DUE4%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2/"/>
      <url>/2022/09/19/UE4RenderingSource/%5BUE%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%5DUE4%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4渲染管线代码初探"><a href="#UE4渲染管线代码初探" class="headerlink" title="UE4渲染管线代码初探"></a>UE4渲染管线代码初探</h1><p>本篇笔记主要会以<strong>DeferredShadingRenderer.cpp</strong>文件的**Render()**方法为入口，探索UE4场景的渲染过程。</p><p>由于UE4的场景渲染过程复杂，这里主要专注于梳理流程，对于各个调用不会挖掘太深。不过会在之后去详细研究每一个模块。目前的建议是：对于各个模块（场景管理、灯光管理、阴影策略等）会以算法的角度去学习，而不是通过阅读代码。</p><p>对于每一个内容会直接截取原始代码进行注释说明。</p><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>我们现在研究的是UE4渲染场景的流程，包含在下面的方法 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">FDeferredShadingSceneRenderer::Render</span><span class="hljs-params">(FRHICommandListImmediate&amp; RHICmdList)</span><br></code></pre></td></tr></table></figure><p>该方法只有600行左右的核心代码，都会尝试做梳理，而不梳理的部分会引出其他章节或给出相关算法。</p><p>下面是相当简单概略的介绍。如需了解详情，请通读相关代码或输出的“profilegpu”日志。</p><h3 id="硬件渲染接口RHI"><a href="#硬件渲染接口RHI" class="headerlink" title="硬件渲染接口RHI"></a>硬件渲染接口RHI</h3><p>RHI 是平台特定的图形 API 之上的一个薄层。UE4 中的 RHI 抽象层尽可能低，这样大多数功能都能以与平台无关的代码写成，从而能够在支持所需功能层级的任何平台上运行。</p><p>而我们代码中的资源最终会归结到RHI类型的资源，可以再<a href="https://docs.unrealengine.com/en-US/API/Runtime/RHI/index.html">官方RHI索引页面</a>搜索到。</p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>在 UE4 中，渲染器所见的场景由基本组件和 FScene 中存储的多种其他结构的列表定义。将维护一个基元的八叉树，用于加速空间查询。</p><h3 id="总体渲染顺序"><a href="#总体渲染顺序" class="headerlink" title="总体渲染顺序"></a>总体渲染顺序</h3><p>这部分内容以<a href="https://docs.unrealengine.com/zh-CN/Programming/Rendering/Overview/index.html">官方文档</a>中的总体渲染顺序为框架进行对照代码的细化、解释说明。</p><h3 id="渲染状态默认值"><a href="#渲染状态默认值" class="headerlink" title="渲染状态默认值"></a>渲染状态默认值</h3><p>由于渲染状态数量众多，要在每次绘制之前对它们全部设置一遍是不现实的。为此，UE4 具有隐性设置的一组状态，它们被认为是设置为了默认值（因此在变更后必须恢复为默认值），另外还有一组少得多的状态需要显性设置。没有隐性默认值的状态有：</p><ul><li>RHISetRenderTargets</li><li>RHISetBoundShaderState</li><li>RHISetDepthState</li><li>RHISetBlendState</li><li>RHISetRasterizerState</li><li>由 RHISetBoundShaderState 设置的着色器的任何依赖性</li></ul><h2 id="SceneContext资源申请"><a href="#SceneContext资源申请" class="headerlink" title="SceneContext资源申请"></a>SceneContext资源申请</h2><p>按需要重新分配全局场景渲染目标，使其对当前视图足够大。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//可以看到需要从RHICmdList中申请我们需要的RenderTarget,这里是创建一个渲染目标对象</span><br>FSceneRenderTargets&amp; SceneContext = FSceneRenderTargets::Get(RHICmdList); <br><span class="hljs-comment">// 转化成可写</span><br>GRenderTargetPool.TransitionTargetsWritable(RHICmdList);<br><span class="hljs-comment">// 情况RenderTarget内容，确认buffer格式正确</span><br>SceneContext.ReleaseSceneColor();<br><span class="hljs-comment">// 进行相关资源、线程状态的检查</span><br>...<br><span class="hljs-comment">// SCOPED_DRAW_EVENT用于标注GPU的渲染代码块，用于调试和分辨渲染阶段。</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">官方说明：</span><br><span class="hljs-comment">It is also useful to do a &#x27;profilegpu&#x27; command and look through the draw events. You can then do a Find in Files in Visual Studio on the draw event name to find the corresponding C++ implementation.</span><br><span class="hljs-comment">*/</span><br>SCOPED_DRAW_EVENT(RHICmdList, Scene);<br><span class="hljs-comment">// 可以用引用这些统计数据名称的SCOPED_GPU_STAT宏检测渲染线程上的代码块</span><br>SCOPED_GPU_STAT(RHICmdList, Stat_GPU_Unaccounted);<br><span class="hljs-comment">// 继续资源申请</span><br>&#123;<br>    SCOPE_CYCLE_COUNTER(STAT_FDeferredShadingSceneRenderer_Render_Init);<br>    <span class="hljs-comment">// Initialize global system textures (pass-through if already initialized).</span><br>    GSystemTextures.InitializeTextures(RHICmdList, FeatureLevel);<br>    <span class="hljs-comment">// Allocate the maximum scene render target space for the current view family.</span><br>    SceneContext.Allocate(RHICmdList, ViewFamily);<br>&#125;<br>SceneContext.AllocDummyGBufferTargets(RHICmdList);<br></code></pre></td></tr></table></figure><h2 id="InitViews可见物体筛选"><a href="#InitViews可见物体筛选" class="headerlink" title="InitViews可见物体筛选"></a>InitViews可见物体筛选</h2><p>通过多种剔除方法为视图初始化基元可见性，设立此帧可见的动态阴影、按需要交叉阴影视锥与世界场景（对整个场景的阴影或预阴影）。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Find the visible primitives.</span><br><span class="hljs-type">bool</span> bDoInitViewAftersPrepass = InitViews(RHICmdList, ILCTaskData, SortEvents);<br></code></pre></td></tr></table></figure><p>这部分过程包括了遮挡剔除、透明物体排序等CPU端的处理，准备各种资源。</p><p>下面探索InitView代码内部：</p><h3 id="PreVisibilityFrameSetup"><a href="#PreVisibilityFrameSetup" class="headerlink" title="PreVisibilityFrameSetup"></a>PreVisibilityFrameSetup</h3><h3 id="ComputeViewVisibility"><a href="#ComputeViewVisibility" class="headerlink" title="ComputeViewVisibility"></a>ComputeViewVisibility</h3><h3 id="CreateIndirectCapsuleShadows"><a href="#CreateIndirectCapsuleShadows" class="headerlink" title="CreateIndirectCapsuleShadows"></a>CreateIndirectCapsuleShadows</h3><h3 id="PostVisibilityFrameSetup"><a href="#PostVisibilityFrameSetup" class="headerlink" title="PostVisibilityFrameSetup"></a>PostVisibilityFrameSetup</h3><h2 id="PrePass-x2F-Depth-only-pass"><a href="#PrePass-x2F-Depth-only-pass" class="headerlink" title="PrePass &#x2F; Depth only pass"></a>PrePass &#x2F; Depth only pass</h2><p>RenderPrePass &#x2F; FDepthDrawingPolicy。渲染遮挡物，对景深缓冲区仅输出景深。该通道可以在多种模式下工作：禁用、仅遮蔽，或完全景深，具体取决于活动状态的功能的需要。该通道通常的用途是初始化 Hierarchical Z 以降低 Base 通道的着色消耗（Base 通道的像素着色器消耗非常大）。</p><h2 id="Base-pass"><a href="#Base-pass" class="headerlink" title="Base pass"></a>Base pass</h2><p>RenderBasePass &#x2F; TBasePassDrawingPolicy。渲染不透明和遮盖的材质，向 GBuffer 输出材质属性。光照图贡献和天空光照也会在此计算并加入场景颜色。</p><h2 id="Issue-Occlusion-Queries-x2F-BeginOcclusionTests"><a href="#Issue-Occlusion-Queries-x2F-BeginOcclusionTests" class="headerlink" title="Issue Occlusion Queries &#x2F; BeginOcclusionTests"></a>Issue Occlusion Queries &#x2F; BeginOcclusionTests</h2><p>提出将用于下一帧的 InitViews 的延迟遮蔽查询。这会通过渲染所查询物体周围的相邻的框、有时还会将相邻的框组合在一起以减少绘制调用来完成。</p><h2 id="Lighting"><a href="#Lighting" class="headerlink" title="Lighting"></a>Lighting</h2><p>阴影图将对各个光照渲染，光照贡献会累加到场景颜色，并使用标准延迟和平铺延迟着色。光照也会在透明光照体积中累加。</p><h2 id="Fog"><a href="#Fog" class="headerlink" title="Fog"></a>Fog</h2><p>雾和大气在延迟通道中对不透明表面进行逐个像素计算。</p><h2 id="Translucency"><a href="#Translucency" class="headerlink" title="Translucency"></a>Translucency</h2><p>透明度累加到屏外渲染目标，在其中它应用了逐个顶点的雾化，因而可以整合到场景中。光照透明度在一个通道中计算最终光照以正确融合。</p><h2 id="Post-Processing"><a href="#Post-Processing" class="headerlink" title="Post Processing"></a>Post Processing</h2><p>多种后期处理效果均通过 GBuffers 应用。透明度将合成到场景中。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/UE4RenderingSource/%5BUE%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%5DUE4Shader%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2/"/>
      <url>/2022/09/19/UE4RenderingSource/%5BUE%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%5DUE4Shader%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4Shader代码初探"><a href="#UE4Shader代码初探" class="headerlink" title="UE4Shader代码初探"></a>UE4Shader代码初探</h1><h2 id="BasePassPixelShader-usf"><a href="#BasePassPixelShader-usf" class="headerlink" title="BasePassPixelShader.usf"></a>BasePassPixelShader.usf</h2><p><strong>BasePassPixelShader.usf</strong>是理解Unreal Shader最好的切入点。</p><p>下面是Unreal官方文档<a href="https://docs.unrealengine.com/zh-CN/Programming/Rendering/ShaderDevelopment/index.html">shader开发</a>给出的简单说明：</p><blockquote><p>典型的材质像素着色器类型将先通过调用 <strong>GetMaterialPixelParameters</strong> 顶点工厂函数来创建 <strong>FMaterialPixelParameters</strong> 构造。GetMaterialPixelParameters 将特定于顶点工厂的输入转换为任何过程可能想访问的属性，例如 WorldPosition 和 TangentNormal 等等。然后，材质着色器将调用 <strong>CalcMaterialParameters</strong>，后者将写出 <code>FMaterialPixelParameters</code> 的其余成员，之后 <code>FMaterialPixelParameters</code> 完全初始化。然后，材质着色器将通过 MaterialTemplate.usf 中的函数来访问该材质的某些输入（例如，通过 <strong>GetMaterialEmissive</strong> 访问材质的自发光输入），执行一些明暗处理，然后输出该过程的最终颜色。</p></blockquote><p>上文中出现的函数和结构体均可以在<strong>BasePassPixelShader.usf</strong>文件当中找到对应的位置。而提到的<strong>MaterialTemplate.usf</strong> 文件则可以查看各种函数的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">GetMaterialPixelParameters<br>FMaterialPixelParameters<br>CalcMaterialParameters<br>GetMaterialEmissive<br></code></pre></td></tr></table></figure><p>首先观察函数<strong>FPixelShaderInOut_MainPS</strong></p><p>这里主要是在对Gbuffer(FPixelShaderOut)进行填充。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// is called in MainPS() from PixelShaderOutputCommon.usf</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FPixelShaderInOut_MainPS</span><span class="hljs-params">(FVertexFactoryInterpolantsVSToPS Interpolants,</span><br><span class="hljs-params">FBasePassInterpolantsVSToPS BasePassInterpolants,</span><br><span class="hljs-params">in FPixelShaderIn In, </span><br><span class="hljs-params">inout FPixelShaderOut Out)</span><br>&#123;<br><span class="hljs-comment">//像素着色器的主要计算过程</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="PixelShaderOutputCommon-ush"><a href="#PixelShaderOutputCommon-ush" class="headerlink" title="PixelShaderOutputCommon.ush"></a>PixelShaderOutputCommon.ush</h2><p>根据上一段代码的注释可以延展到这个文件：PixelShaderOutputCommon.ush</p><p>文件的内容很少，就是一个通用的Shader文件，当中包括了所有Pixel的公用入口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MainPS</span><br><span class="hljs-params">(...)</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>里面大量的宏控制了输入的输出的结构体类型</strong>。</p><h2 id="MaterialTemplate-usf"><a href="#MaterialTemplate-usf" class="headerlink" title="MaterialTemplate.usf"></a>MaterialTemplate.usf</h2><p>从这个文件名字可以看出这是定义材质模板的头文件。</p><p>包括了VS-PS结构体的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FMaterialPixelParameters</span></span><br><span class="hljs-class">&#123;</span><br>    ...<br><span class="hljs-comment">/** Interpolated vertex color, in linear color space. */</span><br>half4 VertexColor;<br><br><span class="hljs-comment">/** Normalized world space normal. */</span><br>half3 WorldNormal;<br>... ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>定义了重要的空间转换函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 <span class="hljs-title function_">GetTranslatedWorldPosition_NoMaterialOffsets</span><span class="hljs-params">(FMaterialPixelParameters Parameters)</span><br>float4 <span class="hljs-title function_">GetScreenPosition</span><span class="hljs-params">(FMaterialVertexParameters Parameters)</span><br>float4 <span class="hljs-title function_">GetScreenPosition</span><span class="hljs-params">(FMaterialPixelParameters Parameters)</span><br>float2 <span class="hljs-title function_">GetSceneTextureUV</span><span class="hljs-params">(FMaterialVertexParameters Parameters)</span><br><br></code></pre></td></tr></table></figure><p>各种材质函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">MaterialFloat2 <span class="hljs-title function_">GetLightmapUVs</span><span class="hljs-params">(FMaterialPixelParameters Parameters)</span><br>half3 <span class="hljs-title function_">GetMaterialNormal</span><span class="hljs-params">(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs)</span><br>half3 <span class="hljs-title function_">GetMaterialEmissive</span><span class="hljs-params">(FPixelMaterialInputs PixelMaterialInputs)</span><br>half <span class="hljs-title function_">GetMaterialMetallic</span><span class="hljs-params">(FPixelMaterialInputs PixelMaterialInputs)</span><br></code></pre></td></tr></table></figure><p>从函数和变量名可以看到代码很好理解。</p><h2 id="TiledDeferredLightShaders-usf"><a href="#TiledDeferredLightShaders-usf" class="headerlink" title="TiledDeferredLightShaders.usf"></a>TiledDeferredLightShaders.usf</h2><p>Unreal默认时使用Deferred渲染，上面的三个文件都是Geometry阶段的代码。而这个文件就是LIght阶段的代码。</p><p>Unreal使用TiledDeferredLight策略，和Unity HDRP的光照策略接近。 </p><p>入口函数，可以看到这个和Unity的HDRP一样使用了ComputeShader来计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, <span class="hljs-number">1</span>)]<br><span class="hljs-type">void</span> <span class="hljs-title function_">TiledDeferredLightingMain</span><span class="hljs-params">(</span><br><span class="hljs-params">uint3 GroupId : SV_GroupID,</span><br><span class="hljs-params">uint3 DispatchThreadId : SV_DispatchThreadID,</span><br><span class="hljs-params">    uint3 GroupThreadId : SV_GroupThreadID)</span> <br>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>除了线程同步之外的操作，关键的就是TIle的灯光列表的获取，<strong>通过边界剪裁获取影响每一个tile的灯光列表</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Compute per-tile lists of affecting lights through bounds culling</span><br><span class="hljs-comment">// Each thread now operates on a sample instead of a pixel</span><br><span class="hljs-comment">// 计算影响tile的灯光列表，这里的计算以Tile为单位而非pixel</span><br>LOOP<br><span class="hljs-title function_">for</span> <span class="hljs-params">(uint LightIndex = ThreadIndex; LightIndex &lt; NumLights &amp;&amp; LightIndex &lt; MAX_LIGHTS; LightIndex += THREADGROUP_TOTALSIZE)</span><br>&#123;<br>       ... <br>&#125;<br><span class="hljs-comment">//GPU线程同步</span><br>GroupMemoryBarrierWithGroupSync();<br></code></pre></td></tr></table></figure><p>在灯光列表计算完成之后，就是再次遍历这个灯光列表，进行光照计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>BRANCH<br><span class="hljs-title function_">if</span> <span class="hljs-params">(InGBufferData.ShadingModelID != SHADINGMODELID_UNLIT)</span><br>&#123;<br>        <span class="hljs-comment">// 遍历每一个灯光，读取灯光信息，填充LightData，这里和Unity出奇的相似。</span><br>LOOP<br><span class="hljs-title function_">for</span> <span class="hljs-params">(uint TileLightIndex = <span class="hljs-number">0</span>; TileLightIndex &lt; NumLightsAffectingTile; TileLightIndex++)</span> <br>&#123;<br>uint LightIndex = TileLightIndices[TileLightIndex];<br>FDeferredLightData LightData = (FDeferredLightData)<span class="hljs-number">0</span>;<br>...<br><span class="hljs-comment">// Lights requiring light attenuation are not supported tiled for now</span><br>CompositedLighting += GetDynamicLighting(WorldPosition, CameraVector, ScreenSpaceData.GBuffer, ScreenSpaceData.AmbientOcclusion, InGBufferData.ShadingModelID, LightData, float4(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-number">0.5</span>, uint2(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>&#125;<br><br><span class="hljs-comment">// 遍历每一个灯光，读取灯光信息，填充LightData，这里和Unity出奇的相似。和上面区别是灯光类型不同光照复杂程度不同</span><br>LOOP<br><span class="hljs-title function_">for</span> <span class="hljs-params">(uint TileLightIndex = <span class="hljs-number">0</span>; TileLightIndex &lt; NumSimpleLightsAffectingTile; TileLightIndex++)</span> <br>&#123;<br>uint LightIndex = TileSimpleLightIndices[TileLightIndex];<br><br>FSimpleDeferredLightData LightData = (FSimpleDeferredLightData)<span class="hljs-number">0</span>;<br>           ...<br><span class="hljs-comment">// todo: doesn&#x27;t support ScreenSpaceSubsurfaceScattering yet (not using alpha)</span><br>CompositedLighting.rgb += GetSimpleDynamicLighting(...);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终写出光照结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">BRANCH<br>   <span class="hljs-title function_">if</span> <span class="hljs-params">(all(DispatchThreadId.xy &lt; ViewDimensions.zw))</span> <br>&#123;<br><span class="hljs-comment">// One some hardware we can read and write from the same UAV with a 32 bit format. We don&#x27;t do that yet.</span><br>RWOutTexture[PixelPos.xy] = InTexture[PixelPos.xy] + CompositedLighting;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="DeferredLightingCommon-ush"><a href="#DeferredLightingCommon-ush" class="headerlink" title="DeferredLightingCommon.ush"></a>DeferredLightingCommon.ush</h2><p>这个文件延展自上一小节，TiledDeferredLightShaders.usf文件中的<strong>光照计算代码GetDynamicLighting和GetSimpleDynamicLighting</strong>就是来自这个文件。</p><p>GetDynamicLighting函数简要代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** Calculates lighting for a given position, normal, etc with a fully featured lighting model designed for quality. */</span><br>float4 <span class="hljs-title function_">GetDynamicLighting</span><span class="hljs-params">(float3 WorldPosition, float3 CameraVector, FGBufferData GBuffer, <span class="hljs-type">float</span> AmbientOcclusion, uint ShadingModelID, FDeferredLightData LightData, float4 LightAttenuation, <span class="hljs-type">float</span> Dither, uint2 Random)</span><br>&#123;<br>FLightAccumulator LightAccumulator = (FLightAccumulator)<span class="hljs-number">0</span>;<br>float3 V = ...;<br>float3 N = ...;<br>float3 L = ...;<span class="hljs-comment">// Already normalized</span><br>float3 ToLight = ...;<br><span class="hljs-type">float</span> NoL = ...;<br><span class="hljs-type">float</span> DistanceAttenuation = <span class="hljs-number">1</span>;<br><span class="hljs-type">float</span> LightRadiusMask = <span class="hljs-number">1</span>;<br><span class="hljs-type">float</span> SpotFalloff = <span class="hljs-number">1</span>;<br><br>...<br>BRANCH<br><span class="hljs-title function_">if</span> <span class="hljs-params">(LightRadiusMask &gt; <span class="hljs-number">0</span> &amp;&amp; SpotFalloff &gt; <span class="hljs-number">0</span>)</span><br>&#123;<br><span class="hljs-type">float</span> SurfaceShadow = <span class="hljs-number">1</span>;<br><span class="hljs-type">float</span> SubsurfaceShadow = <span class="hljs-number">1</span>;<br>BRANCH<br><span class="hljs-title function_">if</span> <span class="hljs-params">(LightData.ShadowedBits)</span><br><span class="hljs-title function_">GetShadowTerms</span><span class="hljs-params">(...)</span>;<br><span class="hljs-keyword">else</span><br>SurfaceShadow = AmbientOcclusion;<br>...<br><span class="hljs-keyword">if</span>( LightData.ShadowedBits &lt; <span class="hljs-number">2</span> &amp;&amp; GBuffer.ShadingModelID == SHADINGMODELID_HAIR )<br>&#123;<br>SubsurfaceShadow = ShadowRayCast(...);<br>&#125;<br><br>...<br>float3 LobeEnergy = AreaLightSpecular(LightData, LobeRoughness, ToLight, L, V, N);<br>float3 SurfaceLighting = SurfaceShading(GBuffer, LobeRoughness, LobeEnergy, L, V, N, Random);<br>float3 SubsurfaceLighting = SubsurfaceShading(GBuffer, L, V, N, SubsurfaceShadow, Random);<br>...<br>&#125;<br><br><span class="hljs-keyword">return</span> LightAccumulator_GetResult(LightAccumulator);<br>&#125;<br></code></pre></td></tr></table></figure><p>​从化简后的代码可以清楚的看出他的代码结构，而<strong>AreaLightSpecular</strong>、<strong>SurfaceShading</strong>和<strong>SubsurfaceShading</strong>就是光照计算的关键，我们的讨论到此为止，而接下来的内容涉及到光照函数、阴影算法、光照策略之后再讨论。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/UE4RenderingSource/UE4%E6%B8%B2%E6%9F%93%E6%BA%90%E7%A0%81%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84/"/>
      <url>/2022/09/19/UE4RenderingSource/UE4%E6%B8%B2%E6%9F%93%E6%BA%90%E7%A0%81%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4-Rendering-SourceCode"><a href="#UE4-Rendering-SourceCode" class="headerlink" title="UE4 Rendering SourceCode"></a>UE4 Rendering SourceCode</h1><p>开始阅读UE4 渲染相关的引擎源码。</p><p>源代码目录：</p><p>\Source\Runtime\Renderer\</p><p><strong>这部分主要记录一些基本的数据类型的代码。</strong></p><h2 id="FSceneView"><a href="#FSceneView" class="headerlink" title="FSceneView"></a>FSceneView</h2><ul><li>A projection from scene space into a 2D screen region.</li></ul><p>将场景空间转换到屏幕空间的类，<strong>直接对应了一个View（一个Camera）</strong>。</p><p>内部保存了ViewMatrix 和ProjectionMatrix。</p><p>一个屏幕上可以用有多个View。</p><p>和Camera相关的参数设置等，这里应该就是对应一个Camera。</p><p>一些参数，都适合具体摄像机相关的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** Actual field of view and that desired by the camera originally */</span><br><span class="hljs-type">float</span> FOV;<br>FLinearColor BackgroundColor;<br>FLinearColor OverlayColor;<br><span class="hljs-comment">/** Color scale multiplier used during post processing */</span><br>FLinearColor ColorScale;<br><br><span class="hljs-comment">/** Maximum number of shadow cascades to render with. */</span><br>int32 MaxShadowCascades;<br><br>FViewMatrices ViewMatrices;<br><br><span class="hljs-comment">/** Variables used to determine the view matrix */</span><br>FVectorViewLocation;<br>FRotatorViewRotation;<br>FQuatBaseHmdOrientation;<br>FVectorBaseHmdLocation;<br><span class="hljs-type">float</span>WorldToMetersScale;<br><br><span class="hljs-comment">// normally the same as ViewMatrices unless &quot;r.Shadow.FreezeCamera&quot; is activated</span><br>FViewMatrices ShadowViewMatrices;<br></code></pre></td></tr></table></figure><h2 id="FViewMatrices"><a href="#FViewMatrices" class="headerlink" title="FViewMatrices"></a>FViewMatrices</h2><p><strong>和摄像机相关的矩阵</strong>：</p><p>ViewMatrix和ProjectionMatrix以及相关的数据和操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//构造函数</span><br>FViewMatrices()<br>&#123;<br>ProjectionMatrix.SetIdentity();<br>ViewMatrix.SetIdentity();<br>HMDViewMatrixNoRoll.SetIdentity();<br>TranslatedViewMatrix.SetIdentity();<br>TranslatedViewProjectionMatrix.SetIdentity();<br>InvTranslatedViewProjectionMatrix.SetIdentity();<br>PreViewTranslation = FVector::ZeroVector;<br>ViewOrigin = FVector::ZeroVector;<br>ProjectionScale = FVector2D::ZeroVector;<br>TemporalAAProjectionJitter = FVector2D::ZeroVector;<br>ScreenScale = <span class="hljs-number">1.f</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="FSceneViewFamily"><a href="#FSceneViewFamily" class="headerlink" title="FSceneViewFamily"></a>FSceneViewFamily</h2><ul><li>A set of views into a scene which only have different view transforms and owner actors.</li></ul><p><strong>保存所有的FSceneView，对应一个RenderTarget</strong>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">TArray&lt;<span class="hljs-type">const</span> FSceneView*&gt; Views;<br></code></pre></td></tr></table></figure><p>一个FSceneViewFamily当中的物体会渲染到同一个RenderTarget上，类似Unity的多个View。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** The render target which the views are being rendered to. */</span><br><span class="hljs-type">const</span> FRenderTarget* RenderTarget;<br></code></pre></td></tr></table></figure><p>要绘制的内容保存在FSceneInterface当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** The scene being viewed. */</span><br>FSceneInterface* Scene;<br></code></pre></td></tr></table></figure><p>其他和一个视口相关的内容：自动曝光。Gamma矫正、截屏内容等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** Gamma correction used when rendering this family. Default is 1.0 */</span><br><span class="hljs-type">float</span> GammaCorrection;<br><br><span class="hljs-comment">/** Editor setting to allow designers to override the automatic expose. 0:Automatic, following indices: -4 .. +4 */</span><br>FExposureSettings ExposureSettings;<br><span class="hljs-comment">/** </span><br><span class="hljs-comment">* Which component of the scene rendering should be output to the final render target.</span><br><span class="hljs-comment">* If SCS_FinalColorLDR this indicates do nothing.</span><br><span class="hljs-comment">*/</span><br>ESceneCaptureSource SceneCaptureSource;<br><br><span class="hljs-comment">/** When enabled, the scene capture will composite into the render target instead of overwriting its contents. */</span><br>ESceneCaptureCompositeMode SceneCaptureCompositeMode;<br></code></pre></td></tr></table></figure><h2 id="FSceneInterface"><a href="#FSceneInterface" class="headerlink" title="FSceneInterface"></a>FSceneInterface</h2><ul><li>An interface to the private scene manager implementation of a scene.  Use GetRendererModule().AllocateScene to create.</li><li>The scene</li></ul><p><strong>场景和场景管理的接口，这部分没有实现代码只有接口。</strong></p><p>把UPrimitiveComponent加入FSceneInterface，这里应该是maintread和renderthread的一个交互位置。</p><p>UPrimitiveComponent的增删改查，UPrimitiveComponent应该就是场景当中的渲染对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>virtual <span class="hljs-type">void</span> <span class="hljs-title function_">AddPrimitive</span><span class="hljs-params">(UPrimitiveComponent* Primitive)</span> = <span class="hljs-number">0</span>;<br><br>virtual <span class="hljs-type">void</span> <span class="hljs-title function_">RemovePrimitive</span><span class="hljs-params">(UPrimitiveComponent* Primitive)</span> = <span class="hljs-number">0</span>;<br><br>virtual <span class="hljs-type">void</span> <span class="hljs-title function_">ReleasePrimitive</span><span class="hljs-params">(UPrimitiveComponent* Primitive)</span> = <span class="hljs-number">0</span>;<br><br>virtual <span class="hljs-type">bool</span> <span class="hljs-title function_">GetPreviousLocalToWorld</span><span class="hljs-params">(<span class="hljs-type">const</span> FPrimitiveSceneInfo* PrimitiveSceneInfo, FMatrix&amp; OutPreviousLocalToWorld)</span> <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br><br></code></pre></td></tr></table></figure><p>灯光相关的管理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">virtual <span class="hljs-type">void</span> <span class="hljs-title function_">AddLight</span><span class="hljs-params">(ULightComponent* Light)</span> = <span class="hljs-number">0</span>;<br><br>virtual <span class="hljs-type">void</span> <span class="hljs-title function_">RemoveLight</span><span class="hljs-params">(ULightComponent* Light)</span> = <span class="hljs-number">0</span>;<br><br>virtual <span class="hljs-type">void</span> <span class="hljs-title function_">AddInvisibleLight</span><span class="hljs-params">(ULightComponent* Light)</span> = <span class="hljs-number">0</span>;<br>virtual <span class="hljs-type">void</span> <span class="hljs-title function_">SetSkyLight</span><span class="hljs-params">(FSkyLightSceneProxy* Light)</span> = <span class="hljs-number">0</span>;<br>virtual <span class="hljs-type">void</span> <span class="hljs-title function_">DisableSkyLight</span><span class="hljs-params">(FSkyLightSceneProxy* Light)</span> = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>Decal、反射探针、雾、风场、SpeedTree、特效等的管理。</p><p>从开头声明的类可以看出他管理的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 渲染相关内容</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AWorldSettings</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FAtmosphericFogSceneInfo</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FMaterial</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FMaterialShaderMap</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FPrimitiveSceneInfo</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FRenderResource</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FRenderTarget</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSkyLightSceneProxy</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FTexture</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FVertexFactory</span>;</span><br><span class="hljs-comment">// 场景资源</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UDecalComponent</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ULightComponent</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UPlanarReflectionComponent</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UPrimitiveComponent</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UReflectionCaptureComponent</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">USkyLightComponent</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UStaticMeshComponent</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UTextureCube</span>;</span><br></code></pre></td></tr></table></figure><h2 id="UPrimitiveComponent-略"><a href="#UPrimitiveComponent-略" class="headerlink" title="UPrimitiveComponent 略"></a>UPrimitiveComponent 略</h2><ul><li>PrimitiveComponents are SceneComponents that contain or generate some sort of geometry, generally to be rendered or used as collision data.</li><li>There are several subclasses for the various types of geometry, but the most common by far are the ShapeComponents (Capsule, Sphere, Box), StaticMeshComponent, and SkeletalMeshComponent.</li><li>ShapeComponents generate geometry that is used for collision detection but are not rendered, while StaticMeshComponents and SkeletalMeshComponents contain pre-built geometry that is rendered, but can also be used for collision detection.</li></ul><p>描述用于渲染或者碰撞计算的组件，描述多种几何体类型：ShapeComponents 、StaticMeshComponent、SkeletalMeshComponent。</p><p>ShapeComponents 主要用于碰撞但是不渲染。</p><p>StaticMeshComponents and SkeletalMeshComponents 既可以用于碰撞也可以用于渲染。</p><h2 id="FRenderResource"><a href="#FRenderResource" class="headerlink" title="FRenderResource"></a>FRenderResource</h2><ul><li>A rendering resource which is owned by the rendering thread.</li></ul><p>渲染线程拥有的资源。</p><p>和RHI有关的初始化等内容。</p><p>具体的实现包括：</p><h3 id="FTexture"><a href="#FTexture" class="headerlink" title="FTexture"></a>FTexture</h3><ul><li>A textures resource.</li></ul><h3 id="FTextureReference"><a href="#FTextureReference" class="headerlink" title="FTextureReference"></a>FTextureReference</h3><ul><li>A texture reference resource.</li></ul><h3 id="FVertexBuffer"><a href="#FVertexBuffer" class="headerlink" title="FVertexBuffer"></a>FVertexBuffer</h3><ul><li>A vertex buffer resource</li></ul><h3 id="FNullColorVertexBuffer"><a href="#FNullColorVertexBuffer" class="headerlink" title="FNullColorVertexBuffer"></a>FNullColorVertexBuffer</h3><ul><li>A vertex buffer with a single color component.  This is used on meshes that don’t have a color component to keep from needing a separate vertex factory to handle this case.</li></ul><h3 id="FIndexBuffer"><a href="#FIndexBuffer" class="headerlink" title="FIndexBuffer"></a>FIndexBuffer</h3><ul><li>An index buffer resource.</li></ul><h3 id="和FrenderResource无关的"><a href="#和FrenderResource无关的" class="headerlink" title="和FrenderResource无关的"></a>和FrenderResource无关的</h3><p>FGlobalDynamicVertexBuffer</p><p>FGlobalDynamicIndexBuffer</p><h3 id="FVertexFactory"><a href="#FVertexFactory" class="headerlink" title="FVertexFactory"></a>FVertexFactory</h3><ul><li>Encapsulates a vertex data source which can be linked into a vertex shader.</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/UE4RenderingSource/UE4%E6%B8%B2%E6%9F%93%E6%BA%90%E7%A0%81%E5%9F%BA%E7%A1%80Pipeline/"/>
      <url>/2022/09/19/UE4RenderingSource/UE4%E6%B8%B2%E6%9F%93%E6%BA%90%E7%A0%81%E5%9F%BA%E7%A1%80Pipeline/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4基础源码Pipeline部分"><a href="#UE4基础源码Pipeline部分" class="headerlink" title="UE4基础源码Pipeline部分"></a>UE4基础源码Pipeline部分</h1><p>这部分主要记录源代码中和Pipeline相关的部分。</p><h1 id="FSceneRenderer"><a href="#FSceneRenderer" class="headerlink" title="FSceneRenderer"></a>FSceneRenderer</h1><ul><li>Used as the scope for scene rendering functions.</li><li>It is initialized in the game thread by FSceneViewFamily::BeginRender, and then passed to the rendering thread.</li><li>The rendering thread calls Render(), and deletes the scene renderer when it returns.</li></ul><p>有两个主要的继承类：FMobileSceneRenderer和FDeferredShadingSceneRenderer。手机不支持Deferred（MRT），所以都是forward渲染。</p><p>保存了要渲染的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//要渲染的场景。</span><br><span class="hljs-comment">/** The scene being rendered. */</span><br>FScene* Scene;<br><span class="hljs-comment">// 一个渲染目标RenderTarget，这个可以有多个渲染View。</span><br><span class="hljs-comment">/** The view family being rendered.  This references the Views array. */</span><br>FSceneViewFamily ViewFamily;<br><br><span class="hljs-comment">// 所有Mesh？</span><br>FMeshElementCollector MeshCollector;<br><br><span class="hljs-comment">// 光</span><br><span class="hljs-comment">/** Information about the visible lights. */</span><br>TArray&lt;FVisibleLightInfo,SceneRenderingAllocator&gt; VisibleLightInfos;<br><br><span class="hljs-comment">// 和阴影相关的内容</span><br><span class="hljs-comment">/** Array of dispatched parallel shadow depth passes. */</span><br>TArray&lt;FParallelMeshDrawCommandPass*, SceneRenderingAllocator&gt; DispatchedShadowDepthPasses;<br><br>FSortedShadowMaps SortedShadowsForShadowDepthPass;<br></code></pre></td></tr></table></figure><p>渲染相关的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// FSceneRenderer interface</span><br>virtual <span class="hljs-type">void</span> <span class="hljs-title function_">Render</span><span class="hljs-params">(FRHICommandListImmediate&amp; RHICmdList)</span> = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h1 id="FMobileSceneRenderer"><a href="#FMobileSceneRenderer" class="headerlink" title="FMobileSceneRenderer"></a>FMobileSceneRenderer</h1><ul><li>Renderer that implements simple forward shading and associated features.</li></ul><p>主要包含了各种渲染方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">void</span> <span class="hljs-title function_">RenderMobileBasePass</span><span class="hljs-params">(FRHICommandListImmediate&amp; RHICmdList, <span class="hljs-type">const</span> TArrayView&lt;<span class="hljs-type">const</span> FViewInfo*&gt; PassViews)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">RenderMobileEditorPrimitives</span><span class="hljs-params">(FRHICommandList&amp; RHICmdList, <span class="hljs-type">const</span> FViewInfo&amp; View, <span class="hljs-type">const</span> FMeshPassProcessorRenderState&amp; DrawRenderState)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">RenderModulatedShadowProjections</span><span class="hljs-params">(FRHICommandListImmediate&amp; RHICmdList)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">RenderOcclusion</span><span class="hljs-params">(FRHICommandListImmediate&amp; RHICmdList)</span>;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">RequiresTranslucencyPass</span><span class="hljs-params">(FRHICommandListImmediate&amp; RHICmdList, <span class="hljs-type">const</span> FViewInfo&amp; View)</span> <span class="hljs-type">const</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">RenderDecals</span><span class="hljs-params">(FRHICommandListImmediate&amp; RHICmdList)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">RenderTranslucency</span><span class="hljs-params">(FRHICommandListImmediate&amp; RHICmdList, <span class="hljs-type">const</span> TArrayView&lt;<span class="hljs-type">const</span> FViewInfo*&gt; PassViews, <span class="hljs-type">bool</span> bRenderToSceneColor)</span>;<br><br><br></code></pre></td></tr></table></figure><p>具体的实现在源文件MobileShadingRenderer.cpp当中。</p><h2 id="MobileShadingRenderer的Renderer过程"><a href="#MobileShadingRenderer的Renderer过程" class="headerlink" title="MobileShadingRenderer的Renderer过程"></a>MobileShadingRenderer的Renderer过程</h2><p>这里详细标注下面方法的渲染过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">FMobileSceneRenderer::Render</span><span class="hljs-params">(FRHICommandListImmediate&amp; RHICmdList)</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">RHICmdList.SetCurrentStat(GET_STATID(STAT_CLMM_SceneStart));<br><span class="hljs-comment">// 计算各个视口大小和位置。</span><br>PrepareViewRectsForRendering();<br><br><span class="hljs-comment">// 遮挡剔除？</span><br>WaitOcclusionTests(RHICmdList);<br>FRHICommandListExecutor::GetImmediateCommandList().PollOcclusionQueries();<br>RHICmdList.ImmediateFlush(EImmediateFlushType::DispatchToRHIThread);<br><br><span class="hljs-comment">// FeatureLevel ：ES  SM4 SM5</span><br><span class="hljs-type">const</span> ERHIFeatureLevel::Type ViewFeatureLevel = ViewFamily.GetFeatureLevel();<br><br><span class="hljs-comment">// 初始化渲染目标</span><br><span class="hljs-comment">// Allocate the maximum scene render target space for the current view family.</span><br>SceneContext.Allocate(RHICmdList, this);<br><br><br></code></pre></td></tr></table></figure><h3 id="PrepareViewRectsForRendering"><a href="#PrepareViewRectsForRendering" class="headerlink" title="PrepareViewRectsForRendering();"></a>PrepareViewRectsForRendering();</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">FSceneRenderer::PrepareViewRectsForRendering</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 判断是否在渲染线程</span><br>    check(IsInRenderingThread());<br>    ...<br>        <br>    <span class="hljs-comment">// 主要就是计算FamilySize</span><br>    ComputeFamilySize();<br>    <br>    <br>    <span class="hljs-comment">// Find the visible primitives.</span><br>InitViews(RHICmdList);<br>    <br>    <br>    <span class="hljs-comment">// 开始渲染</span><br>    RHICmdList.BeginRenderPass(SceneColorRenderPassInfo, TEXT(<span class="hljs-string">&quot;SceneColorRendering&quot;</span>));<br><br>    <span class="hljs-comment">// 渲染BasePass （Opaque Forward）</span><br>    <span class="hljs-comment">// Opaque and masked</span><br>RHICmdList.SetCurrentStat(GET_STATID(STAT_CLMM_Opaque));<br>RenderMobileBasePass(RHICmdList, ViewList);<br>RHICmdList.ImmediateFlush(EImmediateFlushType::DispatchToRHIThread);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FSceneRenderTargets"><a href="#FSceneRenderTargets" class="headerlink" title="FSceneRenderTargets"></a>FSceneRenderTargets</h3><p>渲染目标的构造</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Encapsulates the render targets used for scene rendering.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RENDERER_API</span> <span class="hljs-title">FSceneRenderTargets</span> :</span> public FRenderResource<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FRHICommandListImmediate"><a href="#FRHICommandListImmediate" class="headerlink" title="FRHICommandListImmediate"></a>FRHICommandListImmediate</h3><h3 id="RenderMobileBasePass"><a href="#RenderMobileBasePass" class="headerlink" title="RenderMobileBasePass"></a>RenderMobileBasePass</h3><p>方法内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// 这个循环主要遍历所有的View</span><br><span class="hljs-keyword">for</span> (int32 ViewIndex = <span class="hljs-number">0</span>; ViewIndex &lt; PassViews.Num(); ViewIndex++)<br>&#123;<br><span class="hljs-comment">// 获取View的信息</span><br>    <span class="hljs-type">const</span> FViewInfo&amp; View = *PassViews[ViewIndex];<br>    <span class="hljs-keyword">if</span> (!View.ShouldRenderView())<br>    &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 更新Buffer</span><br>    <span class="hljs-keyword">if</span> (Scene-&gt;UniformBuffers.UpdateViewUniformBuffer(View))<br>    &#123;<br>        UpdateOpaqueBasePassUniformBuffer(RHICmdList, View);<br>        UpdateDirectionalLightUniformBuffers(RHICmdList, View);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置视口</span><br>    RHICmdList.SetViewport(View.ViewRect.Min.X, View.ViewRect.Min.Y, <span class="hljs-number">0</span>, View.ViewRect.Max.X, View.ViewRect.Max.Y, <span class="hljs-number">1</span>);<br>   View.ParallelMeshDrawCommandPasses[EMeshPass::BasePass].DispatchDraw(nullptr, RHICmdList);<br><br>    <span class="hljs-comment">// editor primitives</span><br>    &#123;<br>        FMeshPassProcessorRenderState <span class="hljs-title function_">DrawRenderState</span><span class="hljs-params">(View, Scene-&gt;UniformBuffers.MobileOpaqueBasePassUniformBuffer)</span>;<br>        DrawRenderState.SetBlendState(TStaticBlendStateWriteMask&lt;CW_RGBA&gt;::GetRHI());<br>        DrawRenderState.SetDepthStencilAccess(Scene-&gt;DefaultBasePassDepthStencilAccess);<br>        DrawRenderState.SetDepthStencilState(TStaticDepthStencilState&lt;<span class="hljs-literal">true</span>, CF_DepthNearOrEqual&gt;::GetRHI());<br>        RenderMobileEditorPrimitives(RHICmdList, View, DrawRenderState);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="FDeferredShadingSceneRenderer"><a href="#FDeferredShadingSceneRenderer" class="headerlink" title="FDeferredShadingSceneRenderer"></a>FDeferredShadingSceneRenderer</h1><ul><li>Scene renderer that implements a deferred shading pipeline and associated features.</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/UE4/%5BUE%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%5D%E5%88%9D%E6%8E%A2UE4%E4%BB%A3%E7%A0%81%E5%B1%82/"/>
      <url>/2022/09/19/UE4/%5BUE%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%5D%E5%88%9D%E6%8E%A2UE4%E4%BB%A3%E7%A0%81%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="初入UE4代码层"><a href="#初入UE4代码层" class="headerlink" title="初入UE4代码层"></a>初入UE4代码层</h1><h2 id="阅读入口"><a href="#阅读入口" class="headerlink" title="阅读入口"></a>阅读入口</h2><p>本篇笔记主要记录了从零开始如何进入UE4的代码层，开始编码和Shader阅读。</p><p>首先需要对Shader和渲染过程有一定了解。</p><p>最开始需要了解的是两个关键的文件：</p><p><strong>BasePassPixelShader.usf</strong>：基础的Deferred渲染的Shader文件。</p><p><strong>DeferredShadingRenderer.cpp</strong>：控制渲染流程的代码。</p><p>当然我们都知道UE4有两套渲染管线：Deferred和针对手机的Mobile，所以对应的文件：</p><p><strong>MobileBasePassPixelShader.usf</strong></p><p><strong>MobileShadingRenderer.cpp</strong></p><p>上边两组文件的命名和编码有足够的自解释性，可以作为阅读的起始点（<strong>Deferred那一组</strong>）。通过阅读可以了解到</p><ol><li>UE4基础的渲染过程.</li><li>UE4Shader的语法、编码方式、组织方式（Shader文件的包含关系、文件结构等）</li></ol><p>推荐反复的推敲阅读，虽然暂时无法开始编码工作，但这两个文件可以对应到Unity或者是其他图形渲染引擎的相应部分。</p><p><strong>我也是以这两个文件为基础不断的进行延展的代码阅读。</strong></p><p>下面对这两部分进行导读：<a href="UE4Shader%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2.md">UE4Shader代码入门导读</a>和<a href="UE4%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2.md">UE4渲染流程代码入门导读</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/UE4/%5BUE%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%5DUE4%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2/"/>
      <url>/2022/09/19/UE4/%5BUE%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%5DUE4%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4渲染管线代码初探"><a href="#UE4渲染管线代码初探" class="headerlink" title="UE4渲染管线代码初探"></a>UE4渲染管线代码初探</h1><p>本篇笔记主要会以<strong>DeferredShadingRenderer.cpp</strong>文件的**Render()**方法为入口，探索UE4场景的渲染过程。</p><p>由于UE4的场景渲染过程复杂，这里主要专注于梳理流程，对于各个调用不会挖掘太深。不过会在之后去详细研究每一个模块。目前的建议是：对于各个模块（场景管理、灯光管理、阴影策略等）会以算法的角度去学习，而不是通过阅读代码。</p><p>对于每一个内容会直接截取原始代码进行注释说明。</p><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>我们现在研究的是UE4渲染场景的流程，包含在下面的方法 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">FDeferredShadingSceneRenderer::Render</span><span class="hljs-params">(FRHICommandListImmediate&amp; RHICmdList)</span><br></code></pre></td></tr></table></figure><p>该方法只有600行左右的核心代码，都会尝试做梳理，而不梳理的部分会引出其他章节或给出相关算法。</p><p>下面是相当简单概略的介绍。如需了解详情，请通读相关代码或输出的“profilegpu”日志。</p><h3 id="硬件渲染接口RHI"><a href="#硬件渲染接口RHI" class="headerlink" title="硬件渲染接口RHI"></a>硬件渲染接口RHI</h3><p>RHI 是平台特定的图形 API 之上的一个薄层。UE4 中的 RHI 抽象层尽可能低，这样大多数功能都能以与平台无关的代码写成，从而能够在支持所需功能层级的任何平台上运行。</p><p>而我们代码中的资源最终会归结到RHI类型的资源，可以再<a href="https://docs.unrealengine.com/en-US/API/Runtime/RHI/index.html">官方RHI索引页面</a>搜索到。</p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>在 UE4 中，渲染器所见的场景由基本组件和 FScene 中存储的多种其他结构的列表定义。将维护一个基元的八叉树，用于加速空间查询。</p><h3 id="总体渲染顺序"><a href="#总体渲染顺序" class="headerlink" title="总体渲染顺序"></a>总体渲染顺序</h3><p>这部分内容以<a href="https://docs.unrealengine.com/zh-CN/Programming/Rendering/Overview/index.html">官方文档</a>中的总体渲染顺序为框架进行对照代码的细化、解释说明。</p><h3 id="渲染状态默认值"><a href="#渲染状态默认值" class="headerlink" title="渲染状态默认值"></a>渲染状态默认值</h3><p>由于渲染状态数量众多，要在每次绘制之前对它们全部设置一遍是不现实的。为此，UE4 具有隐性设置的一组状态，它们被认为是设置为了默认值（因此在变更后必须恢复为默认值），另外还有一组少得多的状态需要显性设置。没有隐性默认值的状态有：</p><ul><li>RHISetRenderTargets</li><li>RHISetBoundShaderState</li><li>RHISetDepthState</li><li>RHISetBlendState</li><li>RHISetRasterizerState</li><li>由 RHISetBoundShaderState 设置的着色器的任何依赖性</li></ul><h2 id="SceneContext资源申请"><a href="#SceneContext资源申请" class="headerlink" title="SceneContext资源申请"></a>SceneContext资源申请</h2><p>按需要重新分配全局场景渲染目标，使其对当前视图足够大。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//可以看到需要从RHICmdList中申请我们需要的RenderTarget,这里是创建一个渲染目标对象</span><br>FSceneRenderTargets&amp; SceneContext = FSceneRenderTargets::Get(RHICmdList); <br><span class="hljs-comment">// 转化成可写</span><br>GRenderTargetPool.TransitionTargetsWritable(RHICmdList);<br><span class="hljs-comment">// 情况RenderTarget内容，确认buffer格式正确</span><br>SceneContext.ReleaseSceneColor();<br><span class="hljs-comment">// 进行相关资源、线程状态的检查</span><br>...<br><span class="hljs-comment">// SCOPED_DRAW_EVENT用于标注GPU的渲染代码块，用于调试和分辨渲染阶段。</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">官方说明：</span><br><span class="hljs-comment">It is also useful to do a &#x27;profilegpu&#x27; command and look through the draw events. You can then do a Find in Files in Visual Studio on the draw event name to find the corresponding C++ implementation.</span><br><span class="hljs-comment">*/</span><br>SCOPED_DRAW_EVENT(RHICmdList, Scene);<br><span class="hljs-comment">// 可以用引用这些统计数据名称的SCOPED_GPU_STAT宏检测渲染线程上的代码块</span><br>SCOPED_GPU_STAT(RHICmdList, Stat_GPU_Unaccounted);<br><span class="hljs-comment">// 继续资源申请</span><br>&#123;<br>    SCOPE_CYCLE_COUNTER(STAT_FDeferredShadingSceneRenderer_Render_Init);<br>    <span class="hljs-comment">// Initialize global system textures (pass-through if already initialized).</span><br>    GSystemTextures.InitializeTextures(RHICmdList, FeatureLevel);<br>    <span class="hljs-comment">// Allocate the maximum scene render target space for the current view family.</span><br>    SceneContext.Allocate(RHICmdList, ViewFamily);<br>&#125;<br>SceneContext.AllocDummyGBufferTargets(RHICmdList);<br></code></pre></td></tr></table></figure><h2 id="InitViews可见物体筛选"><a href="#InitViews可见物体筛选" class="headerlink" title="InitViews可见物体筛选"></a>InitViews可见物体筛选</h2><p>通过多种剔除方法为视图初始化基元可见性，设立此帧可见的动态阴影、按需要交叉阴影视锥与世界场景（对整个场景的阴影或预阴影）。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Find the visible primitives.</span><br><span class="hljs-type">bool</span> bDoInitViewAftersPrepass = InitViews(RHICmdList, ILCTaskData, SortEvents);<br></code></pre></td></tr></table></figure><p>这部分过程包括了遮挡剔除、透明物体排序等CPU端的处理，准备各种资源。</p><p>下面探索InitView代码内部：</p><h3 id="PreVisibilityFrameSetup"><a href="#PreVisibilityFrameSetup" class="headerlink" title="PreVisibilityFrameSetup"></a>PreVisibilityFrameSetup</h3><h3 id="ComputeViewVisibility"><a href="#ComputeViewVisibility" class="headerlink" title="ComputeViewVisibility"></a>ComputeViewVisibility</h3><h3 id="CreateIndirectCapsuleShadows"><a href="#CreateIndirectCapsuleShadows" class="headerlink" title="CreateIndirectCapsuleShadows"></a>CreateIndirectCapsuleShadows</h3><h3 id="PostVisibilityFrameSetup"><a href="#PostVisibilityFrameSetup" class="headerlink" title="PostVisibilityFrameSetup"></a>PostVisibilityFrameSetup</h3><h2 id="PrePass-x2F-Depth-only-pass"><a href="#PrePass-x2F-Depth-only-pass" class="headerlink" title="PrePass &#x2F; Depth only pass"></a>PrePass &#x2F; Depth only pass</h2><p>RenderPrePass &#x2F; FDepthDrawingPolicy。渲染遮挡物，对景深缓冲区仅输出景深。该通道可以在多种模式下工作：禁用、仅遮蔽，或完全景深，具体取决于活动状态的功能的需要。该通道通常的用途是初始化 Hierarchical Z 以降低 Base 通道的着色消耗（Base 通道的像素着色器消耗非常大）。</p><h2 id="Base-pass"><a href="#Base-pass" class="headerlink" title="Base pass"></a>Base pass</h2><p>RenderBasePass &#x2F; TBasePassDrawingPolicy。渲染不透明和遮盖的材质，向 GBuffer 输出材质属性。光照图贡献和天空光照也会在此计算并加入场景颜色。</p><h2 id="Issue-Occlusion-Queries-x2F-BeginOcclusionTests"><a href="#Issue-Occlusion-Queries-x2F-BeginOcclusionTests" class="headerlink" title="Issue Occlusion Queries &#x2F; BeginOcclusionTests"></a>Issue Occlusion Queries &#x2F; BeginOcclusionTests</h2><p>提出将用于下一帧的 InitViews 的延迟遮蔽查询。这会通过渲染所查询物体周围的相邻的框、有时还会将相邻的框组合在一起以减少绘制调用来完成。</p><h2 id="Lighting"><a href="#Lighting" class="headerlink" title="Lighting"></a>Lighting</h2><p>阴影图将对各个光照渲染，光照贡献会累加到场景颜色，并使用标准延迟和平铺延迟着色。光照也会在透明光照体积中累加。</p><h2 id="Fog"><a href="#Fog" class="headerlink" title="Fog"></a>Fog</h2><p>雾和大气在延迟通道中对不透明表面进行逐个像素计算。</p><h2 id="Translucency"><a href="#Translucency" class="headerlink" title="Translucency"></a>Translucency</h2><p>透明度累加到屏外渲染目标，在其中它应用了逐个顶点的雾化，因而可以整合到场景中。光照透明度在一个通道中计算最终光照以正确融合。</p><h2 id="Post-Processing"><a href="#Post-Processing" class="headerlink" title="Post Processing"></a>Post Processing</h2><p>多种后期处理效果均通过 GBuffers 应用。透明度将合成到场景中。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/UE4/%5BUE%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%5DUE4Shader%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2/"/>
      <url>/2022/09/19/UE4/%5BUE%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%5DUE4Shader%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4Shader代码初探"><a href="#UE4Shader代码初探" class="headerlink" title="UE4Shader代码初探"></a>UE4Shader代码初探</h1><h2 id="BasePassPixelShader-usf"><a href="#BasePassPixelShader-usf" class="headerlink" title="BasePassPixelShader.usf"></a>BasePassPixelShader.usf</h2><p><strong>BasePassPixelShader.usf</strong>是理解Unreal Shader最好的切入点。</p><p>下面是Unreal官方文档<a href="https://docs.unrealengine.com/zh-CN/Programming/Rendering/ShaderDevelopment/index.html">shader开发</a>给出的简单说明：</p><blockquote><p>典型的材质像素着色器类型将先通过调用 <strong>GetMaterialPixelParameters</strong> 顶点工厂函数来创建 <strong>FMaterialPixelParameters</strong> 构造。GetMaterialPixelParameters 将特定于顶点工厂的输入转换为任何过程可能想访问的属性，例如 WorldPosition 和 TangentNormal 等等。然后，材质着色器将调用 <strong>CalcMaterialParameters</strong>，后者将写出 <code>FMaterialPixelParameters</code> 的其余成员，之后 <code>FMaterialPixelParameters</code> 完全初始化。然后，材质着色器将通过 MaterialTemplate.usf 中的函数来访问该材质的某些输入（例如，通过 <strong>GetMaterialEmissive</strong> 访问材质的自发光输入），执行一些明暗处理，然后输出该过程的最终颜色。</p></blockquote><p>上文中出现的函数和结构体均可以在<strong>BasePassPixelShader.usf</strong>文件当中找到对应的位置。而提到的<strong>MaterialTemplate.usf</strong> 文件则可以查看各种函数的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">GetMaterialPixelParameters<br>FMaterialPixelParameters<br>CalcMaterialParameters<br>GetMaterialEmissive<br></code></pre></td></tr></table></figure><p>首先观察函数<strong>FPixelShaderInOut_MainPS</strong></p><p>这里主要是在对Gbuffer(FPixelShaderOut)进行填充。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// is called in MainPS() from PixelShaderOutputCommon.usf</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FPixelShaderInOut_MainPS</span><span class="hljs-params">(FVertexFactoryInterpolantsVSToPS Interpolants,</span><br><span class="hljs-params">FBasePassInterpolantsVSToPS BasePassInterpolants,</span><br><span class="hljs-params">in FPixelShaderIn In, </span><br><span class="hljs-params">inout FPixelShaderOut Out)</span><br>&#123;<br><span class="hljs-comment">//像素着色器的主要计算过程</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="PixelShaderOutputCommon-ush"><a href="#PixelShaderOutputCommon-ush" class="headerlink" title="PixelShaderOutputCommon.ush"></a>PixelShaderOutputCommon.ush</h2><p>根据上一段代码的注释可以延展到这个文件：PixelShaderOutputCommon.ush</p><p>文件的内容很少，就是一个通用的Shader文件，当中包括了所有Pixel的公用入口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MainPS</span><br><span class="hljs-params">(...)</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>里面大量的宏控制了输入的输出的结构体类型</strong>。</p><h2 id="MaterialTemplate-usf"><a href="#MaterialTemplate-usf" class="headerlink" title="MaterialTemplate.usf"></a>MaterialTemplate.usf</h2><p>从这个文件名字可以看出这是定义材质模板的头文件。</p><p>包括了VS-PS结构体的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FMaterialPixelParameters</span></span><br><span class="hljs-class">&#123;</span><br>    ...<br><span class="hljs-comment">/** Interpolated vertex color, in linear color space. */</span><br>half4 VertexColor;<br><br><span class="hljs-comment">/** Normalized world space normal. */</span><br>half3 WorldNormal;<br>... ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>定义了重要的空间转换函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 <span class="hljs-title function_">GetTranslatedWorldPosition_NoMaterialOffsets</span><span class="hljs-params">(FMaterialPixelParameters Parameters)</span><br>float4 <span class="hljs-title function_">GetScreenPosition</span><span class="hljs-params">(FMaterialVertexParameters Parameters)</span><br>float4 <span class="hljs-title function_">GetScreenPosition</span><span class="hljs-params">(FMaterialPixelParameters Parameters)</span><br>float2 <span class="hljs-title function_">GetSceneTextureUV</span><span class="hljs-params">(FMaterialVertexParameters Parameters)</span><br><br></code></pre></td></tr></table></figure><p>各种材质函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">MaterialFloat2 <span class="hljs-title function_">GetLightmapUVs</span><span class="hljs-params">(FMaterialPixelParameters Parameters)</span><br>half3 <span class="hljs-title function_">GetMaterialNormal</span><span class="hljs-params">(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs)</span><br>half3 <span class="hljs-title function_">GetMaterialEmissive</span><span class="hljs-params">(FPixelMaterialInputs PixelMaterialInputs)</span><br>half <span class="hljs-title function_">GetMaterialMetallic</span><span class="hljs-params">(FPixelMaterialInputs PixelMaterialInputs)</span><br></code></pre></td></tr></table></figure><p>从函数和变量名可以看到代码很好理解。</p><h2 id="TiledDeferredLightShaders-usf"><a href="#TiledDeferredLightShaders-usf" class="headerlink" title="TiledDeferredLightShaders.usf"></a>TiledDeferredLightShaders.usf</h2><p>Unreal默认时使用Deferred渲染，上面的三个文件都是Geometry阶段的代码。而这个文件就是LIght阶段的代码。</p><p>Unreal使用TiledDeferredLight策略，和Unity HDRP的光照策略接近。 </p><p>入口函数，可以看到这个和Unity的HDRP一样使用了ComputeShader来计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, <span class="hljs-number">1</span>)]<br><span class="hljs-type">void</span> <span class="hljs-title function_">TiledDeferredLightingMain</span><span class="hljs-params">(</span><br><span class="hljs-params">uint3 GroupId : SV_GroupID,</span><br><span class="hljs-params">uint3 DispatchThreadId : SV_DispatchThreadID,</span><br><span class="hljs-params">    uint3 GroupThreadId : SV_GroupThreadID)</span> <br>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>除了线程同步之外的操作，关键的就是TIle的灯光列表的获取，<strong>通过边界剪裁获取影响每一个tile的灯光列表</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Compute per-tile lists of affecting lights through bounds culling</span><br><span class="hljs-comment">// Each thread now operates on a sample instead of a pixel</span><br><span class="hljs-comment">// 计算影响tile的灯光列表，这里的计算以Tile为单位而非pixel</span><br>LOOP<br><span class="hljs-title function_">for</span> <span class="hljs-params">(uint LightIndex = ThreadIndex; LightIndex &lt; NumLights &amp;&amp; LightIndex &lt; MAX_LIGHTS; LightIndex += THREADGROUP_TOTALSIZE)</span><br>&#123;<br>       ... <br>&#125;<br><span class="hljs-comment">//GPU线程同步</span><br>GroupMemoryBarrierWithGroupSync();<br></code></pre></td></tr></table></figure><p>在灯光列表计算完成之后，就是再次遍历这个灯光列表，进行光照计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>BRANCH<br><span class="hljs-title function_">if</span> <span class="hljs-params">(InGBufferData.ShadingModelID != SHADINGMODELID_UNLIT)</span><br>&#123;<br>        <span class="hljs-comment">// 遍历每一个灯光，读取灯光信息，填充LightData，这里和Unity出奇的相似。</span><br>LOOP<br><span class="hljs-title function_">for</span> <span class="hljs-params">(uint TileLightIndex = <span class="hljs-number">0</span>; TileLightIndex &lt; NumLightsAffectingTile; TileLightIndex++)</span> <br>&#123;<br>uint LightIndex = TileLightIndices[TileLightIndex];<br>FDeferredLightData LightData = (FDeferredLightData)<span class="hljs-number">0</span>;<br>...<br><span class="hljs-comment">// Lights requiring light attenuation are not supported tiled for now</span><br>CompositedLighting += GetDynamicLighting(WorldPosition, CameraVector, ScreenSpaceData.GBuffer, ScreenSpaceData.AmbientOcclusion, InGBufferData.ShadingModelID, LightData, float4(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-number">0.5</span>, uint2(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>&#125;<br><br><span class="hljs-comment">// 遍历每一个灯光，读取灯光信息，填充LightData，这里和Unity出奇的相似。和上面区别是灯光类型不同光照复杂程度不同</span><br>LOOP<br><span class="hljs-title function_">for</span> <span class="hljs-params">(uint TileLightIndex = <span class="hljs-number">0</span>; TileLightIndex &lt; NumSimpleLightsAffectingTile; TileLightIndex++)</span> <br>&#123;<br>uint LightIndex = TileSimpleLightIndices[TileLightIndex];<br><br>FSimpleDeferredLightData LightData = (FSimpleDeferredLightData)<span class="hljs-number">0</span>;<br>           ...<br><span class="hljs-comment">// todo: doesn&#x27;t support ScreenSpaceSubsurfaceScattering yet (not using alpha)</span><br>CompositedLighting.rgb += GetSimpleDynamicLighting(...);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终写出光照结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">BRANCH<br>   <span class="hljs-title function_">if</span> <span class="hljs-params">(all(DispatchThreadId.xy &lt; ViewDimensions.zw))</span> <br>&#123;<br><span class="hljs-comment">// One some hardware we can read and write from the same UAV with a 32 bit format. We don&#x27;t do that yet.</span><br>RWOutTexture[PixelPos.xy] = InTexture[PixelPos.xy] + CompositedLighting;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="DeferredLightingCommon-ush"><a href="#DeferredLightingCommon-ush" class="headerlink" title="DeferredLightingCommon.ush"></a>DeferredLightingCommon.ush</h2><p>这个文件延展自上一小节，TiledDeferredLightShaders.usf文件中的<strong>光照计算代码GetDynamicLighting和GetSimpleDynamicLighting</strong>就是来自这个文件。</p><p>GetDynamicLighting函数简要代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** Calculates lighting for a given position, normal, etc with a fully featured lighting model designed for quality. */</span><br>float4 <span class="hljs-title function_">GetDynamicLighting</span><span class="hljs-params">(float3 WorldPosition, float3 CameraVector, FGBufferData GBuffer, <span class="hljs-type">float</span> AmbientOcclusion, uint ShadingModelID, FDeferredLightData LightData, float4 LightAttenuation, <span class="hljs-type">float</span> Dither, uint2 Random)</span><br>&#123;<br>FLightAccumulator LightAccumulator = (FLightAccumulator)<span class="hljs-number">0</span>;<br>float3 V = ...;<br>float3 N = ...;<br>float3 L = ...;<span class="hljs-comment">// Already normalized</span><br>float3 ToLight = ...;<br><span class="hljs-type">float</span> NoL = ...;<br><span class="hljs-type">float</span> DistanceAttenuation = <span class="hljs-number">1</span>;<br><span class="hljs-type">float</span> LightRadiusMask = <span class="hljs-number">1</span>;<br><span class="hljs-type">float</span> SpotFalloff = <span class="hljs-number">1</span>;<br><br>...<br>BRANCH<br><span class="hljs-title function_">if</span> <span class="hljs-params">(LightRadiusMask &gt; <span class="hljs-number">0</span> &amp;&amp; SpotFalloff &gt; <span class="hljs-number">0</span>)</span><br>&#123;<br><span class="hljs-type">float</span> SurfaceShadow = <span class="hljs-number">1</span>;<br><span class="hljs-type">float</span> SubsurfaceShadow = <span class="hljs-number">1</span>;<br>BRANCH<br><span class="hljs-title function_">if</span> <span class="hljs-params">(LightData.ShadowedBits)</span><br><span class="hljs-title function_">GetShadowTerms</span><span class="hljs-params">(...)</span>;<br><span class="hljs-keyword">else</span><br>SurfaceShadow = AmbientOcclusion;<br>...<br><span class="hljs-keyword">if</span>( LightData.ShadowedBits &lt; <span class="hljs-number">2</span> &amp;&amp; GBuffer.ShadingModelID == SHADINGMODELID_HAIR )<br>&#123;<br>SubsurfaceShadow = ShadowRayCast(...);<br>&#125;<br><br>...<br>float3 LobeEnergy = AreaLightSpecular(LightData, LobeRoughness, ToLight, L, V, N);<br>float3 SurfaceLighting = SurfaceShading(GBuffer, LobeRoughness, LobeEnergy, L, V, N, Random);<br>float3 SubsurfaceLighting = SubsurfaceShading(GBuffer, L, V, N, SubsurfaceShadow, Random);<br>...<br>&#125;<br><br><span class="hljs-keyword">return</span> LightAccumulator_GetResult(LightAccumulator);<br>&#125;<br></code></pre></td></tr></table></figure><p>​从化简后的代码可以清楚的看出他的代码结构，而<strong>AreaLightSpecular</strong>、<strong>SurfaceShading</strong>和<strong>SubsurfaceShading</strong>就是光照计算的关键，我们的讨论到此为止，而接下来的内容涉及到光照函数、阴影算法、光照策略之后再讨论。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/UE4/UnrealLightmap%E7%BB%93%E6%9E%84%E5%92%8C%E7%BC%96%E7%A0%81/"/>
      <url>/2022/09/19/UE4/UnrealLightmap%E7%BB%93%E6%9E%84%E5%92%8C%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="UnrealLightmap结构和编码"><a href="#UnrealLightmap结构和编码" class="headerlink" title="UnrealLightmap结构和编码"></a>UnrealLightmap结构和编码</h1><h2 id="光度图编码方式"><a href="#光度图编码方式" class="headerlink" title="光度图编码方式"></a>光度图编码方式</h2><p>​由于光照亮度的生成时其亮度范围远大于1的浮点数区间，故其最好的存储方式应当是浮点纹理，比如通用的exr格式。exr的缺点是更大的存储、内存和渲染时的带宽占用，同时有多平台兼容性问题，故目前主流的商业引擎或各大厂的自研引擎，其在移动端的光照图也大都使用RGB8或RGBA8图进行存储。</p><p>​把亮度数据从浮点数压缩到0~256的整数时需要进行编码进行存储(UE4中编码这一部分也叫做量化)，通过此编码映射把无限范围的浮点数域映射到有限的[0,255]的整数域中，其压缩方式是有损的，在压缩过程中的信息损失会造成光照图的质量的下降和不可逆失真。</p><p>​UE4中光照亮度编码映射没有采用传统的RGBM,RGBD,LOGLUV方式编码，而是使用自己开发的编码方式，分别对LQ和HQ光照的亮度信息进行压缩。</p><h3 id="LQ编码"><a href="#LQ编码" class="headerlink" title="LQ编码"></a>LQ编码</h3><p><strong>这部分代码在LightmapData.cpp源文件当中查看：</strong></p><p>会对亮度信息进行编码，预乘之后，写入lightmap编码：</p><p>$$ (0.5 + \frac{1}{16} log_2(x+0.0390625)) $$</p><p><strong>值域偏移0.5是为了把亮度x∈[0,1]之间的y的值域从[-0.5,0]平移到[0,0.5]之间，不丢失暗部信息</strong>?</p><p>log结果除以16，有两个好处，一是可以把更多的原始亮度信息编码到值域中。原本按照 y∈[0,1]的约束，log(x+0.00390625)的中x取值范围约为x∈[0,1.41],而在除了16之后,x的取值范围大约在x∈[0,255]之间。二是因为需要预乘颜色和亮度值，较小的亮度值乘以颜色可以很大程度规避掉数值上的上溢出。<strong>这部分来自网络，需要重新计算</strong></p><p>$$ (0.5 + \frac{1}{SimpleLogScale} log_2(x+SimpleLogBlackPoint )) $$</p><p>使用y的最大和最小值对归一化参数进行变换，其变换公式为</p><p><strong>N_mul &#x3D; 1 &#x2F;(max-min)</strong></p><p><strong>N_add &#x3D; -min&#x2F;(max-min)</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/UE4/ue4%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/09/19/UE4/ue4%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4光照模型"><a href="#UE4光照模型" class="headerlink" title="UE4光照模型"></a>UE4光照模型</h1><h2 id="引文"><a href="#引文" class="headerlink" title="引文"></a>引文</h2><p>主要参考文章《Real Shading in Unreal Engine 4》by Brian Karis, Epic Games.</p><p>详细介绍了UE4的PBR模型，这里对其中主要的细节总结。</p><p>UE4的PBR灵感来自于Disney：</p><p>Burley, Brent, “Physically-Based Shading at Disney”, part of “Practical Physically Based Shading<br>in Film and Game Production”, SIGGRAPH 2012 Course Notes. <a href="http://blog.selfshadow.com/">http://blog.selfshadow.com/</a><br>publications&#x2F;s2012-shading-course&#x2F;</p><p>使用PBR的目的如下,原文：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">Real-Time Performance<br>    • First and foremost, it needs to be efficient to use with many lights visible at a time.<br>    Reduced Complexity<br>    • There should be as few parameters as possible. A large <span class="hljs-built_in">array</span> of parameters either results in<br>    decision paralysis, trial and error, or interconnected properties that require many values to be<br>    changed <span class="hljs-keyword">for</span> a single intended effect.<br>    • We need to be able to use image-based lighting and analytic light sources interchangeably, so<br>    parameters must behave consistently across all light types.<br><br>Intuitive Interface<br>    • We prefer simple-to-understand values, as opposed to physical ones such as index of refraction.<br>    Perceptually Linear<br>    • We wish to support layering through masks, but we can only afford to shade once per pixel. This<br>    means that parameter-blended shading must match blending of the shaded results as closely as<br>    possible.<br>    <br>Easy to Master<br>    • We would like to avoid the need <span class="hljs-keyword">for</span> technical understanding of dielectrics and conductors, as well<br>    as minimize the effort required to create basic physically plausible materials.<br>    Robust<br>    • It should be difficult to mistakenly create physically implausible materials.<br>    • All combinations of parameters should be as robust and plausible as possible.<br>    Expressive<br>    • Deferred shading limits the number of shading models we can have, so our base shading model<br>    needs to be descriptive enough to cover <span class="hljs-number">99</span>% of the materials that occur in the real world.<br>    • All layerable materials need to share the same <span class="hljs-built_in">set</span> of parameters in order to blend between them.<br>    Flexible<br>    • Other projects and licensees may not share the same goal of photorealism, so it needs to be<br>    flexible enough to enable non-photorealistic rendering<br></code></pre></td></tr></table></figure><h2 id="光照模型"><a href="#光照模型" class="headerlink" title="光照模型"></a>光照模型</h2><p>UE4的漫反射模型使用Lambertian：</p><p>$$ f(l,v) &#x3D; \frac{c_{diff}}{\pi} $$</p><p>$ c_{diff} $是表面的albedo。</p><p>UE4的高光同样使用微表面模型：</p><p>$$ f(l,v) &#x3D; \frac{D(h)G(l,v,h)F(v,h)}{4(nl)(nv)} $$</p><h3 id="D项-：GGX-Trowbridge-Reitz"><a href="#D项-：GGX-Trowbridge-Reitz" class="headerlink" title="D项 ：GGX (Trowbridge-Reitz)"></a>D项 ：GGX (Trowbridge-Reitz)</h3><p>$$ \alpha &#x3D; roughness^2 $$</p><p>$$ D_{GGX}(h)&#x3D;\frac{\alpha^2}{\pi((nh)^2(\alpha^2-1)+1)^2} $$</p><h3 id="G项：Schlick"><a href="#G项：Schlick" class="headerlink" title="G项：Schlick"></a>G项：Schlick</h3><p>UE4使用的Schlick-GGX（用在IBL上）</p><p>$$k &#x3D;\frac{\alpha} {2}$$  </p><p>$$ \alpha &#x3D; roughness^2 $$</p><p>UE4又根据Disney文章对其做了修改（这个修改只用在解析光源上，IBL在glancing angles会太暗）：</p><p>$$k &#x3D;\frac{(roughness + 1)^2} {8}$$  </p><p>$$ G_{GGX}(v) &#x3D; \frac{nv}{(nv)(1-k)+k} $$</p><h3 id="F项：Schlick’s-approximation"><a href="#F项：Schlick’s-approximation" class="headerlink" title="F项：Schlick’s approximation"></a>F项：Schlick’s approximation</h3><p>$$ F(v,h)&#x3D;F_0 + (1 - F_0) 2^{-5.55473(vh)-6.98316)(vh)} $$</p><h2 id="IBL"><a href="#IBL" class="headerlink" title="IBL"></a>IBL</h2><p>首先需要解决的是辐射度积分，通常使用重要度采样：</p><p>$$ \int_H L_i(l)f(l,v)cos(\theta_l)dl  &#x3D; \frac{1}{N}\sum^{N}_{k&#x3D;1}\frac{L_i(l_k)f(l_k,v)cos theta _{l_k} }{p(l_k,v)} $$</p><p>表示采样半球上的所有光线.k表示反射探针上的一个点，采样多个点，p表示概率。</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 <span class="hljs-title function_">ImportanceSampleGGX</span><span class="hljs-params">( float2 Xi, <span class="hljs-type">float</span> Roughness , float3 N )</span><br>&#123;<br>    <span class="hljs-type">float</span> a = Roughness * Roughness;<br>    <span class="hljs-type">float</span> Phi = <span class="hljs-number">2</span> * PI * Xi.x;<br>    <span class="hljs-type">float</span> CosTheta = <span class="hljs-built_in">sqrt</span>( (<span class="hljs-number">1</span> - Xi.y) / ( <span class="hljs-number">1</span> + (a*a - <span class="hljs-number">1</span>) * Xi.y ) );<br>    <span class="hljs-type">float</span> SinTheta = <span class="hljs-built_in">sqrt</span>( <span class="hljs-number">1</span> - CosTheta * CosTheta );<br>    float3 H;<br>    H.x = SinTheta * <span class="hljs-built_in">cos</span>( Phi );<br>    H.y = SinTheta * <span class="hljs-built_in">sin</span>( Phi );<br>    H.z = CosTheta;<br>    float3 UpVector = <span class="hljs-built_in">abs</span>(N.z) &lt; <span class="hljs-number">0.999</span> ? float3(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) : float3(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    float3 TangentX = normalize( cross( UpVector , N ) );<br>    float3 TangentY = cross( N, TangentX );<br>    <span class="hljs-comment">// Tangent to world space</span><br>    <span class="hljs-keyword">return</span> TangentX * H.x + TangentY * H.y + N * H.z;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="重要度采样的推导"><a href="#重要度采样的推导" class="headerlink" title="重要度采样的推导"></a>重要度采样的推导</h3><p>这部分内容主要解释什么是重要度采样以及如何推导。</p><p>从PDF（概率密度函数：积分为1）到重要度采样函数的过程。</p><p>目的：通过求和模拟复杂函数积分，代表就是蒙特卡洛积分。</p><p>蒙特卡洛积分是等分采样，重要度采样能够修正蒙特卡洛积分的权重来提升准确度。</p><p>重要度采样：引入分布p(x)。</p><p>蒙特卡洛计算积分：</p><p>$$ \int_a^b f(x) dx &#x3D; \frac{b-a}{N}\sum_{i&#x3D;1}^{N}f(x_i)$$</p><p>重要度采样积分：</p><p>$$ \int_a^b f(x) dx &#x3D; \int_a^b p(x)\frac{\pi(x)}{p(x)}f(x) dx$$</p><p>我们可以将上面的函数当做$ \frac{\pi(x)}{p(x)}f(x)  $在概率p(x)上的期望，则：</p><p>可以在$ p(x) $上采样估计期望: </p><p>$$ E|f| &#x3D; \frac{1}{N}\sum_{i&#x3D;1}^{N}\frac{\pi(x_i)}{p(x_i)}f(x_i) $$</p><p>则$ \frac{\pi(x_i)}{p(x_i)} $为重要度权重。</p><p>所以重要度采样就需要有一个新的分布和分布对应的概率。</p><h4 id="Importance-Sampling-techniques-for-GGX"><a href="#Importance-Sampling-techniques-for-GGX" class="headerlink" title="Importance Sampling techniques for GGX"></a>Importance Sampling techniques for GGX</h4><p>针对IBL和ray tracing 没有L方向所以需要这个方法计算。</p><p>光照函数：</p><p>$$  L_o &#x3D; L_e + \int L_i f(w_i,w_o) (w_i.w_n) dw_i$$</p><p>对于一条光线：</p><p>$$ f(l,v) &#x3D; \frac{D(h)G(l,v,h)F(v,h)}{4(nl)(nv)} $$</p><p>我们现在探讨GGX的重要度采样，应为NDF对于整个BRDF有重要的影响，在Ray Tracing当中也是重要的讨论部分。</p><p>$$ D_{GGX}(h)&#x3D;\frac{\alpha^2}{\pi((nh)^2(\alpha^2-1)+1)^2} $$</p><p>为了进行重要度采样，我们需要在求D(h)的边缘分布函数（CDF）的倒数。来生成一个微表面法线(因为光线追踪和IBL当中可能没有光线方向，所以需要特殊的方法计算这个h)。</p><h4 id="概率论预备知识"><a href="#概率论预备知识" class="headerlink" title="概率论预备知识"></a>概率论预备知识</h4><p>概率密度函数：“PDF”（<strong>P</strong>robability <strong>D</strong>ensity <strong>F</strong>unction）</p><p>联合概率：P(A,B)</p><p>条件概率：P(A|B) &#x3D; P(A,B) &#x2F; P(A)</p><p>边缘概率：P(A)</p><p>事件独立：P(A|B) &#x3D; P(A,B) &#x2F; P(B) &#x3D; P(A)</p><h4 id="Phong-BRDF"><a href="#Phong-BRDF" class="headerlink" title="Phong BRDF"></a>Phong BRDF</h4><p>Phong模型的PDF：</p><p>$$ p(\theta,\phi)&#x3D; \frac{n + 1}{2\pi}cos^n(\theta)sin(\theta) $$</p><p>首先对$ \phi $积分，得到了$ \theta $的边缘密度函数。：</p><p>$$ p(\theta)&#x3D; \int_0^{2\pi}p(\theta,\phi)  d\phi&#x3D;(n + 1)cos^n(\theta)sin(\theta) $$</p><p>然后推导出$ \phi $的条件概率，各项同性的$ p(\phi || \theta)  $结果永远都是这样。刚好是一个单位圆的周长，他们是独立的：</p><p>$$ p(\phi | \theta) &#x3D; \frac{p(\theta,\phi)}{p(\theta)} &#x3D; \frac{1}{2\pi} &#x3D; p(\phi )$$</p><p>现在我们得到了两个条件概率，分别积分就可以得到具体的概率值。</p><p>设 $ P(S_\phi)  $为$ \phi $的概率，则对条件概率积分：</p><p>$$ P(S_\phi) &#x3D; \int_0^{S_\phi} p(\phi) d \phi  &#x3D; \int_0^{S_\phi} \frac{1}{2\pi}d \phi &#x3D; \frac{S_\phi}{2\pi}$$</p><p>假设 $ P(S_\phi)  $是一个随机变量：</p><p> $$ P(S_\phi)  &#x3D;\frac{ s_\phi}{2\pi} &#x3D;\xi_\phi  $$</p><p>$$   s_\phi  &#x3D; 2\pi\xi_\phi $$</p><p>设 $ P(S_\theta)  $为$ \theta $的概率，则对条件概率积分：</p><p>$$ P(S_\theta)&#x3D;\int_0^{S_\theta} p(\theta)d\theta &#x3D;\int_0^{S_\theta} (n + 1)cos^n(\theta)sin(\theta) d\theta &#x3D; 1 - cos^{1 + n}s_{\theta}$$</p><p>$$   s_\theta  &#x3D; cos^{-1}((1-\xi_\theta)^{\frac{1}{1+n}}) $$</p><p>$ \xi  $是一个随机变量。重要度采样的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">vec2 <span class="hljs-title function_">importance_sample_phong</span><span class="hljs-params">(vec2 xi)</span><br>&#123;<br>  <span class="hljs-type">float</span> phi = <span class="hljs-number">2.0f</span> * PI * xi.x;<br>  <span class="hljs-type">float</span> theta = <span class="hljs-built_in">acos</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">1.0f</span> - xi.y, <span class="hljs-number">1.0f</span>/(n+<span class="hljs-number">1.0f</span>)));<br>  <span class="hljs-keyword">return</span> vec2(phi, theta);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IBL计算"><a href="#IBL计算" class="headerlink" title="IBL计算"></a>IBL计算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 <span class="hljs-title function_">SpecularIBL</span><span class="hljs-params">( float3 SpecularColor , <span class="hljs-type">float</span> Roughness , float3 N, float3 V )</span><br>&#123;<br>    float3 SpecularLighting = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> uint NumSamples = <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">for</span>( uint i = <span class="hljs-number">0</span>; i &lt; NumSamples; i++ )<br>    &#123;<br>    float2 Xi = Hammersley( i, NumSamples );<br>        <span class="hljs-comment">// 使用xi分布进行采样。</span><br>        float3 H = ImportanceSampleGGX( Xi, Roughness , N );<br>        float3 L = <span class="hljs-number">2</span> * dot( V, H ) * H - V;<br>        <span class="hljs-type">float</span> NoV = saturate( dot( N, V ) );<br>        <span class="hljs-type">float</span> NoL = saturate( dot( N, L ) );<br>        <span class="hljs-type">float</span> NoH = saturate( dot( N, H ) );<br>        <span class="hljs-type">float</span> VoH = saturate( dot( V, H ) );<br>        <span class="hljs-keyword">if</span>( NoL &gt; <span class="hljs-number">0</span> )<br>        &#123;<br>            float3 SampleColor = EnvMap.SampleLevel( EnvMapSampler , L, <span class="hljs-number">0</span> ).rgb;<br>            <span class="hljs-type">float</span> G = G_Smith( Roughness , NoV, NoL );<br>            <span class="hljs-type">float</span> Fc = <span class="hljs-built_in">pow</span>( <span class="hljs-number">1</span> - VoH, <span class="hljs-number">5</span> );<br>            float3 F = (<span class="hljs-number">1</span> - Fc) * SpecularColor + Fc;<br>            <span class="hljs-comment">// Incident light = SampleColor * NoL</span><br>            <span class="hljs-comment">// Microfacet specular = D*G*F / (4*NoL*NoV)</span><br>            <span class="hljs-comment">// pdf = D * NoH / (4 * VoH) xi对应的概率</span><br>            <span class="hljs-comment">// SpecularLighting =  D*G*F / (4*NoL*NoV) /  (pdf)</span><br>            <span class="hljs-comment">// SpecularLighting = NoL* D*G*F / (4*NoL*NoV) * (4 * VoH)  / D * NoH</span><br>            <span class="hljs-comment">// 这里pdf是1所以公式变为 G*F / (4*NoL*NoV)，约分之后得到下面的公式</span><br>            <span class="hljs-comment">// 也就是说P等于1</span><br>            SpecularLighting += SampleColor * F * G * VoH / (NoH * NoV);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 取平均值</span><br>    <span class="hljs-keyword">return</span> SpecularLighting / NumSamples;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/UE4/UE4_Performance_Bottlenecks/"/>
      <url>/2022/09/19/UE4/UE4_Performance_Bottlenecks/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4-GPU-profile"><a href="#UE4-GPU-profile" class="headerlink" title="UE4 GPU profile"></a>UE4 GPU profile</h1><p>This post describe  Pipeline and Render Bottlenecks of UE4.</p><h2 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h2><p>To display a frame both calculations on the GPU and CPU need to be finished.</p><p>After, All the game code finished and all the pixel shaded, we can dispatch a frame to the screen.</p><p>The time of cost is the bigger number between GPU and CPU.</p><h3 id="GPU-cost"><a href="#GPU-cost" class="headerlink" title="GPU cost"></a>GPU cost</h3><p>On the GPU, we have parallelism and a pipeline.</p><p>Parallel - many core work at same time.  Core are best utilized when working on same task.</p><p>Pipeline- frame divided into steps.  Pixel Shader can’t continue before it’s fed with data from Vertex Shader.</p><p>Vertex Shader -&gt; Tesselation -&gt; Geometry -&gt; Pixel Shader.</p><h3 id="Draw-call"><a href="#Draw-call" class="headerlink" title="Draw call"></a>Draw call</h3><p>CPU sends commands - “draw calls “  to control the GPU.</p><p>more mesh. more materials &#x3D;&#x3D;  More draw calls.</p><p>If you want to draw a triangle set with a different material, you have to dispatch a GPU command from CPU to the GPU first, and goes through the driver , and then is translated, and only the transmitted to the GPU.</p><h3 id="Pixel-bound-sources-of-trouble"><a href="#Pixel-bound-sources-of-trouble" class="headerlink" title="Pixel- bound sources of trouble"></a>Pixel- bound sources of trouble</h3><h3 id="Resolution-of-screen"><a href="#Resolution-of-screen" class="headerlink" title="Resolution of screen."></a>Resolution of screen.</h3><p>Pixel most slowest part of the pipeline.</p><p>Depend resolution of screen.</p><p>Heavy shader, post processing, translucency</p><h3 id="Quad-overDraw"><a href="#Quad-overDraw" class="headerlink" title="Quad overDraw"></a>Quad overDraw</h3><p>Quad means a block of 4 pixel(2*2)</p><p>Many operations on the GPU are done on full quads or even bigger tiles-not single pixels</p><p>Small polygon waste GPU time. More small or more thin then triangle the bigger the problem.</p><p>Triangle cunt is rarly a problem.</p><p>Avoiding small and thin triangle :  Use Lods. Keep polygons bigger and even.</p><h3 id="Triangle-Count"><a href="#Triangle-Count" class="headerlink" title="Triangle Count"></a>Triangle Count</h3><p>explode after tessllation.</p><p>shadow casting need copy a mesh for drawing shadow mask.</p><h3 id="Hard-edges-UV-splits-Smooth-group"><a href="#Hard-edges-UV-splits-Smooth-group" class="headerlink" title="Hard edges ,UV splits,Smooth group"></a>Hard edges ,UV splits,Smooth group</h3><p>add vertex count.</p><h3 id="Memory-related-sources"><a href="#Memory-related-sources" class="headerlink" title="Memory-related sources"></a>Memory-related sources</h3><h3 id="Texture-Sample"><a href="#Texture-Sample" class="headerlink" title="Texture Sample"></a>Texture Sample</h3><p>Too many texture sampler use up the bandwidth.</p><p>Texture packing and Compression.</p><h3 id="Texture-Cache"><a href="#Texture-Cache" class="headerlink" title="Texture Cache"></a>Texture Cache</h3><p>fetch data from nearby cache.  Need UV continue.</p><p>UV  noise is bad for cache.</p><h3 id="Streaming-cache"><a href="#Streaming-cache" class="headerlink" title="Streaming cache"></a>Streaming cache</h3><p>Good for memory. It’s not related to the GPU cache.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/UE4/Building_Better_3D_Meshes_and_Textures/"/>
      <url>/2022/09/19/UE4/Building_Better_3D_Meshes_and_Textures/</url>
      
        <content type="html"><![CDATA[<h1 id="Building-Better-3D-Meshes-and-Textures"><a href="#Building-Better-3D-Meshes-and-Textures" class="headerlink" title="Building Better 3D Meshes and Textures"></a>Building Better 3D Meshes and Textures</h1><p>Meshes And Textures  are basic assets. It’s important to control the asset detail to get better game performance.</p><h2 id="Naming-Conventions"><a href="#Naming-Conventions" class="headerlink" title="Naming Conventions"></a>Naming Conventions</h2><p>First of all, I want to discuss  is Naming Conventions . It’s Great you can know what they are when you read the asset list by reading their name.</p><p>There are examples. We can prefix with a couple of letters to  help us  quickly identify what type of the data is.</p><p>SM_Rock_00 - <strong>S</strong>tatic <strong>M</strong>esh for a <strong>Rock</strong> variation <strong>00</strong></p><p>T_Rock_00_BC - <strong>B</strong>ase <strong>C</strong>olor <strong>T</strong>exture for a <strong>Rock</strong> variation <strong>00</strong></p><p>SKM_RockBun_00 - <strong>Sk</strong>eletal <strong>M</strong>esh</p><h2 id="Texture-Creation"><a href="#Texture-Creation" class="headerlink" title="Texture Creation"></a>Texture Creation</h2><p>We prefer to: (GPU like it)</p><p>Textures should always be a power of 2.</p><p>Textures do not have to be square, just use a power of 2. </p><p>If you go with power of two texture the advantage is that Engine will generate <strong>mip map chain</strong> for you that will really help in terms of performance and quality.</p><p>We cant bring a non power of 2 texture but  Engine will do some like padding internally so that like square, so you end up with wasting space  </p><p><strong>UI</strong> stuff non power of 2 is not so bad, because those are alway at full resolution.</p><p>We have a very flexible in the type of texture like:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">PNG- Embed Alpha Support<br>PSD- Embed Alpha Support<br>TGA- Embed Alpha Support<br>BMP<br>FLOAT<br>PCX<br>IPG<br>EXR<br>DDS - Cubemap <span class="hljs-title function_">Texture</span> <span class="hljs-params">(<span class="hljs-number">32</span> Bit / Channels <span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>. ARGB <span class="hljs-number">32</span> bppm <span class="hljs-type">unsigned</span>)</span><br>HDR - Cubemap <span class="hljs-title function_">Texture</span> <span class="hljs-params">(LongLat Unwrap)</span><br></code></pre></td></tr></table></figure><p>JPEG is compressed ,So you will let go some quality. because Engine will recompress over JPEG.</p><h2 id="Texture-Import"><a href="#Texture-Import" class="headerlink" title="Texture Import"></a>Texture Import</h2><p>Drag into editor Or Use import Panel.</p><h2 id="Alpha-Import"><a href="#Alpha-Import" class="headerlink" title="Alpha Import"></a>Alpha Import</h2><p>  In terms of storage, splitting the alpha from the texture make that we can use different size of alpha. if we have limited space.</p><p>There are something need be known</p><p>LOD bias.</p><p>Channel Packing.</p><p>Srgb.</p><h2 id="Mip-Mapping"><a href="#Mip-Mapping" class="headerlink" title="Mip Mapping"></a>Mip Mapping</h2><p>Base Version is full resolution, other are smaller.</p><p>Mip Gen Setting:  Filtering.</p><p>LOD bias.</p><p>Texture Group: Pre-configure texture based on their usage.</p><h2 id="Texture-Compression"><a href="#Texture-Compression" class="headerlink" title="Texture Compression"></a>Texture Compression</h2><p>Main modes are：</p><p>DXT1 -  No Alpha</p><p>DXT5 -  Alpha</p><p>these are tile-based compression.</p><p>There ara some special mode for HDR texture.</p><p>bc7 -  compression time is longer but you have higher quality over the DXT1 and DXT5.</p><h2 id="System-Unit"><a href="#System-Unit" class="headerlink" title="System Unit"></a>System Unit</h2><p>UE4 use Centimeters for unity of measurement.</p><p>Make sure set DCC unit to centimeters</p><h2 id="Triangle-Counts"><a href="#Triangle-Counts" class="headerlink" title="Triangle Counts"></a>Triangle Counts</h2><p>Do not model small detials.</p><p>You should constantly check the triangle count.</p><p>Engine can deal with a lot of polygon ,but we should prepare scene  properly for that.</p><h2 id="Material-ID"><a href="#Material-ID" class="headerlink" title="Material ID"></a>Material ID</h2><p>As you model your object , you can specify which polygons use which material in your mesh.   Engine treat material id as separate objects. GPU rendering this robot is equivalent to rendering two objects.</p><p>Material ID in unity is corresponding to  submeshes.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/tech/vc6_debug_err/"/>
      <url>/2022/09/19/tech/vc6_debug_err/</url>
      
        <content type="html"><![CDATA[<p>用VC6在64位Windows7下调试的时候，如果中断(Shift+F5)调试，程序无法退出。</p><p><strong>问题描述：</strong><br>当点击F5开始一个项目的调试时，程序在设置的断点处停止，这时按下Shift+F5后，vc6可以退出调试状态，但是WINDOWS系统的任务栏上会留下前面调试时产生的进程图标。该进程不能被结束，即使使用任务管理器，也不可以。这时如果再次按下F5调试，并按下Shift+F5后，任务栏上会留下两个这样的图标，这两个进程都可以在任务管理器上看到，不占CPU资源，但占用一定的内存。结束该进程的唯一的办法是（在任务栏上去掉该图标）：关闭VC6,并重新开启.</p><p><strong>一般的解决方法：</strong><br>不使用”结束调试”这个功能,让程序正常结束(就是放个可以退出的菜单或者按钮, 而不是使用Shift+F5的退出)。</p><p><strong>终极解决方法：</strong><br>替换DM.dll和TLLOC.DLL为正确的版本。首先下载正确版本：VC6.zip（里面包含这两个dll），然后将下载的版本替换到程序安装目录“Common&#x2F;MSDev98&#x2F;Bin&#x2F;TLLOC.dll”和“Common&#x2F;MSDev98&#x2F;Bin&#x2F;DM.dll”，这样VC6在windows 7 64位的系统调试时，就可以任意退出了。</p><p><a href="../../index.md">back</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/tech/use_c_in_python/"/>
      <url>/2022/09/19/tech/use_c_in_python/</url>
      
        <content type="html"><![CDATA[<h1 id="在python中使用c-x2F-c-模块"><a href="#在python中使用c-x2F-c-模块" class="headerlink" title="在python中使用c&#x2F;c++模块"></a>在python中使用c&#x2F;c++模块</h1><p>在python当中使用c++的方式有很多主要可以使用</p><p>主要可以参考下面两个链接：</p><p>该方法是在源代码级别进行调用，需要重新调用源代码，生成的c模块也可以被所有的python代码调用</p><p><a href="https://docs.python.org/2/extending/extending.html">官方扩展说明</a></p><p>该链接包含了众多的方法，可以选择一个进行使用</p><p><a href="http://intermediate-and-advanced-software-carpentry.readthedocs.io/en/latest/c++-wrapping.html#manual-wrapping">多个python调用c&#x2F;c++的方法</a></p><p>下面我将要介绍的是第二个链接中，手动配置模块的过程，不使用外部的库。并且完成的模块可以被所有python随时调用。</p><ol><li>首先需要写一个c语言的文件</li><li>这个文件的名字是<strong>spammodule.c</strong>就是我们需要的源文件。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;python2.7/Python.h&gt;</span><span class="hljs-comment">//头文件时固定的</span></span><br><span class="hljs-comment">//该方法的参数是固定的，方法名并非python中要调用的方法名</span><br><span class="hljs-type">static</span> PyObject*<br><span class="hljs-title function_">spam_system</span><span class="hljs-params">(PyObject* self, PyObject *args)</span> &#123;<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *command;<br>      <span class="hljs-type">int</span> sts;<br>      <span class="hljs-comment">// 检查类型并进行能类型转换,如果非0则表示转换称重结果保存在出入的地址当&gt;  </span><br>      <span class="hljs-comment">// 中。否则返回0。返回的指针时不可以修改的所以声明成了const</span><br>      <span class="hljs-keyword">if</span>(!PyArg_ParseTuple(args,<span class="hljs-string">&quot;s&quot;</span>,&amp;command))<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>     <span class="hljs-comment">//系统调用</span><br>     sts = system(command);<br>     <span class="hljs-comment">//简历一个python的返回类型</span><br>     <span class="hljs-keyword">return</span> Py_BuildValue(<span class="hljs-string">&quot;i&quot;</span>,sts);<br>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">      * 如果是空返回值：</span><br><span class="hljs-comment">      * Py_INCREF(Py_None);</span><br><span class="hljs-comment">      * return Py_None;</span><br><span class="hljs-comment">     */</span><br>&#125;<br><br><span class="hljs-type">static</span> PyMethodDef SpamMethods[] = &#123;<br>    <span class="hljs-comment">// 这里第一个表示python中的方法名，第二个表示对应c的方法，后面固定</span><br>    &#123;<span class="hljs-string">&quot;system&quot;</span>,  spam_system, METH_VARARGS, <span class="hljs-string">&quot;Execute a shell command.&quot;</span>&#125;,<br>    &#123;<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>&#125;        <span class="hljs-comment">/* Sentinel */</span><br>&#125;;<br> <br>DL_EXPORT(<span class="hljs-type">void</span>) initspam(<span class="hljs-type">void</span>)<br>&#123;<br>    <span class="hljs-comment">// 这里表示把模块spam中加入SpamMethods当中所有的方法</span><br>   <span class="hljs-comment">// 之后在python中就可以使用import spam  调用spam.system</span><br>      (<span class="hljs-type">void</span>)Py_InitModule(<span class="hljs-string">&quot;spam&quot;</span>, SpamMethods);<br>&#125;<br></code></pre></td></tr></table></figure><p>源文件每个方法的含义可以参考链接当中的说明,下面需要将这个源文件安装到python中，和链接一中编译源文件不同，这个方法是将模块直接安装到python中，下面时安装代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> distutils.core <span class="hljs-keyword">import</span> setup, Extension<br><span class="hljs-comment">#表示安装的模块名和源文件名</span><br>extension_mod = Extension(<span class="hljs-string">&quot;spam&quot;</span>,[<span class="hljs-string">&quot;spammodule.c&quot;</span>])<br><span class="hljs-comment">#表示进行安装</span><br>setup(name=<span class="hljs-string">&quot;spam&quot;</span>,ext_modules=[extension_mod])<br></code></pre></td></tr></table></figure><p>下面是在python中调用我们安装好的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br>__author__ = <span class="hljs-string">&#x27;liangz14&#x27;</span><br><br><span class="hljs-keyword">import</span> spam<br>status = spam.system(<span class="hljs-string">&quot;ls -l&quot;</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-built_in">print</span> status<br></code></pre></td></tr></table></figure><p><a href="../../index.md">back to list</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/tech/tech_index/"/>
      <url>/2022/09/19/tech/tech_index/</url>
      
        <content type="html"><![CDATA[<p><a href="use_c_in_python.md">在python当中使用</a></p><p><a href="qt_qa_1.md">在重写QWidget类过程中遇到的问题</a></p><p><a href="learn_makefile.md">MakeFiles基本使用指南</a></p><p><a href="learn_mongodb.md">mongodb安装</a></p><p><a href="some_c_tips.md">c语言tips</a></p><p><a href="hadoop_headfirst.md">hadoop基本使用</a></p><p><a href="docker_headfirst.md">docker基本使用</a></p><p><a href="vc6_debug_err.md">vc6.0在win7 64bit下无法关闭调试</a></p><p><a href="../../index.md">back</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/tech/some_c_tips/"/>
      <url>/2022/09/19/tech/some_c_tips/</url>
      
        <content type="html"><![CDATA[<ol><li><p>对size()进行加减操作产生的问题   size()返回的类型时 无符号类型  在默认转换的过程中数据的范围和大小会发生变化。（由于数据类型发生了变化）</p></li><li><p>(1&lt;&#x3D; A,B &lt;&#x3D; 10^9) 注意公倍数的范围</p></li><li><p>sizeof (*)指针全部都是 地址长度  32位就是4  64位就是8<br>sizeof (int\boole) 数据类型 表示这个类型所用的位数<br>sizeof ([])数组就是指数组长度</p></li><li><p>char *d&#x3D;”0123456789”存放在常量区，是无法修的。char d[]而数组是存放在栈中，是可以修改的。两者区别如下：<br>  4.1 ”读“ ”写“ 能力</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *a = <span class="hljs-string">&quot;abcd&quot;</span>;  <span class="hljs-comment">//此时&quot;abcd&quot;存放在常量区。通过指针只可以访问字符串常量，而不可以改变它。</span><br><span class="hljs-type">char</span> a[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;abcd&quot;</span>； <span class="hljs-comment">//此时 &quot;abcd&quot;存放在栈。可以通过指针去访问和修改数组内容。</span><br></code></pre></td></tr></table></figure><p> 4.2. 赋值时刻</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *a = <span class="hljs-string">&quot;abcd&quot;</span>; <span class="hljs-comment">//是在编译时就确定了（因为为常量）。</span><br><span class="hljs-type">char</span> a[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;abcd&quot;</span>； <span class="hljs-comment">//在运行时确定</span><br></code></pre></td></tr></table></figure><pre><code>4.3. 存取效率</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *a = <span class="hljs-string">&quot;abcd&quot;</span>; <span class="hljs-comment">//存于静态存储区。在栈上的数组比指针所指向字符串快。因此慢，如果修改会出现：“Segment Default&quot;</span><br><span class="hljs-type">char</span> a[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;abcd&quot;</span>； <span class="hljs-comment">//存于栈上。快</span><br></code></pre></td></tr></table></figure><pre><code>另外注意：</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a[] = <span class="hljs-string">&quot;01234&quot;</span> <span class="hljs-comment">//虽然没有指明字符串的长度，但是此时系统已经开好了，就是大小为6：&#x27;0&#x27; &#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27; &#x27;4&#x27; &#x27;5&#x27; &#x27;\0&#x27;，</span><br></code></pre></td></tr></table></figure><pre><code>(注意strlen(a)是不计‘\0’ 而sizeof(a)是计算 &#39;\0&#39;的)</code></pre><ol start="5"><li><p>const 不能修饰后面的*  也是时不存在const * ，所以char const * cp中 const 只能修饰char。而 char * const cp中，const修饰了cp。</p></li><li><p>下面程序的输出是 4 6 4 6 （g++编译器）</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">char</span>*s)</span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(s)&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 指针的大小</span><br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">strlen</span>(s)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> *s1=<span class="hljs-string">&quot;123456&quot;</span>;<br>    <span class="hljs-type">char</span> s2[] = <span class="hljs-string">&quot;123456&quot;</span>;<br>    test(s1);<br>    test(s2);<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>  <a href="../../index.md">back</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/tech/qt_qa_1/"/>
      <url>/2022/09/19/tech/qt_qa_1/</url>
      
        <content type="html"><![CDATA[<p>在软件开发的过程中需要对QT界面进行调整，主要使用了QSS的样式表，同时为了实现一些特别的功能需要对某些类进行重写。<br>在对样式进行改进的过程中遇到了两个问题：</p><ol><li>signals明明已经声明了，但是提示：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">error LNK2019: 无法解析的外部符号 &quot;public: void __cdecl QMyWidget::mouseMoveSignal()<br></code></pre></td></tr></table></figure><p>QMyWidget是我自己重写的QWidget，主要为了实现一些特别的功能，mouseMoveSignal是我写的信号。<br>在执行emit mouseMoveSignal()时，发生了错误，这个错误主要是由于，在手动书写代码的时候漏掉了Q_OBJECT的声明。</p><p>代码片段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QMyWidget</span></span><br><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">QWidget</span></span><br><span class="hljs-class">&#123;</span><br>    Q_OBJECT <span class="hljs-comment">//丢失了这一句会造成上面的错误。</span><br>public:<br>    QMyWidget(<span class="hljs-type">void</span>);<br>    QMyWidget(QWidget *);<br>    ~QMyWidget(<span class="hljs-type">void</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>在我完成重写了QMyWidget之后，发现我对界面的QSS设置全部失效了。<br>此时需要重写新类的paintEvent方法。代码如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">QMyWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *e)</span>&#123;<br>    QStyleOption opt;<br>    opt.init(this);<br>    QPainter <span class="hljs-title function_">p</span><span class="hljs-params">(this)</span>;<br>    style()-&gt;drawPrimitive(QStyle::PE_Widget, &amp;opt, &amp;p, this);<br>    QWidget::paintEvent(e);<br>&#125;<br></code></pre></td></tr></table></figure><p>直接使用这一段代码进行复制即可使用，将QMyWidget改成你对应的类名，并且包含对应的类，就可以解决这一问题。</p><p><a href="../../index.md">back to list</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/tech/learn_mongodb/"/>
      <url>/2022/09/19/tech/learn_mongodb/</url>
      
        <content type="html"><![CDATA[<ol><li>进入<a href="https://www.mongodb.org/?_ga=1.6778743.416898270.1442579015">官网下载</a>：</li></ol><p>下载32bit版本（只能使用最多2G空间）;</p><ol start="2"><li><p>安装，将bin目录加入环境变量</p></li><li><p>建立数据库，同时也会开启这个数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mongod --dbpath D:\develop_kit\MongoDB\data<br></code></pre></td></tr></table></figure></li><li><p>在网站下载测试使用的数据集resturant</p></li><li><p>导入测试数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mongoimport --db test --collection restaurants --drop --file primer-dataset.json<br></code></pre></td></tr></table></figure></li><li><p>使用python进行测试：</p></li></ol><p><a href="https://docs.mongodb.org/getting-started/python/import-data/">测试数据所在网页</a></p><p><a href="https://docs.mongodb.org/getting-started/python/client/">需要安装pymongo</a></p><ol start="7"><li><a href="https://docs.mongodb.org/getting-started/python/client/">具体命令参考</a></li></ol><p><a href="../../index.md">back</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/tech/learn_makefile/"/>
      <url>/2022/09/19/tech/learn_makefile/</url>
      
        <content type="html"><![CDATA[<p>“这篇博客的内容来自我原来开源中国的博客这里修正了一下<del>因为原来直接拷贝的ipython的格式代码是有问题的</del>”</p><p>下面的内容是直接从我的ipython notebook中摘录出来的所以可能不是很清楚，如果想查看完整版本以及例子，可以访问：</p><p><a href="git@github.com:liangz0707/WTF-makefile.git">git地址</a></p><p><a href="https://github.com/liangz0707/WTF-makefile/archive/master.zip">下载地址</a></p><p>如果不能查看ipython notebook 可以直接打开其中的lession.html 结果是一样的</p><h2 id="首先讲解编译器等内容"><a href="#首先讲解编译器等内容" class="headerlink" title="首先讲解编译器等内容"></a>首先讲解编译器等内容</h2><p>What is Compiler？</p><p>Compiler&#x3D;编译器，就是将某种代码编译成机器语言，或者说编译成能够由处理器直接执行的“代码”。一个程序员会以一种语言在编辑器当中编写语句。例如：c、Lisp。编写完成后生成的文件就是源代码。然后程序员运行具体的编译器，把上述文件名作为参数进行编译。</p><p>执行过程中，编译器会依照语法顺序，逐一对语句进行解析。最终生成输出代码。一般的编译器的输出结果叫做object code或者object module（这里的object和面向对象中的object不同）。这里的object code是机器语言。</p><p>在传统的操作系统当中，在编译之后往往还需要额外的步骤，因为当有多于一个Object Code时 他们的指令、和数据之间存在关系，所以需要进行链接，得到的结果是。 load module。</p><h2 id="下面使用具体的编译器GCC来讲解"><a href="#下面使用具体的编译器GCC来讲解" class="headerlink" title="下面使用具体的编译器GCC来讲解"></a>下面使用具体的编译器GCC来讲解</h2><p>GCC是c语言的编译器之一：</p><p>gcc is the “GNU” C Compiler, and g++ is the “GNU C++ compiler</p><p>我们编写一个hello.c文件（见目录）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream.h&quot;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">cout</span> &amp;lt;&amp;lt; <span class="hljs-string">&quot;Hello\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行如下命令，输出的结果就是可执行的机器码（.exe可执行程序），默认文件名是a.exe</p><p>主要g++编译的源文件中头文件的引用一般为#include,并且要注意使用命名空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ hello.c -o hello<br></code></pre></td></tr></table></figure><h2 id="Makefiles的使用"><a href="#Makefiles的使用" class="headerlink" title="Makefiles的使用"></a>Makefiles的使用</h2><p>在实际的编译过程中，逐个的编译源代码过于冗杂，尤其是当你需要包含很多源文件时，你不得不每一次都要打字输入。</p><p>而是用Makefile就是为了简化很多源文件的编译过程。 例如我们有很多c问见需要编译:</p><ul>    <li>main.cpp</li>    <li>hello.cpp</li>    <li>factorial.cpp</li>    <li>functions.h 以上的文件都是通过头文件串联起来的</li></ul>如果需要手动的编译，如下非常麻烦<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ main.cpp hello.cpp factorial.cpp -o hello<br></code></pre></td></tr></table></figure><p>执行上面得到的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hello<br></code></pre></td></tr></table></figure><p>###编译的过程包含了：</p><ul>    <li>把source code转换成object files</li>    <li>将不同的object files连接成可执行的机器码（.exe) 下面使用最简单的Makefile 来进行编译，代替手工过程</li></ul>基本的Makefile组成如下：<p><code><span style="color: #ff0000; font-family: Consolas;">target: dependencies</span></code></p><p><code><span style="color: #ff0000; font-family: Consolas;">[tab]system command</span></code></p><p>‘target’可以理解为要编译的目标或任务（分号后的内容），dependencies表示要完成这个目标所需要的前提。编写成我们需要的格式如下：</p><p><code><span style="color: #ff0000; font-family: Consolas;">all:     </span></code></p><p><code><span style="color: #ff0000; font-family: Consolas;">    g++ main.cpp hello.cpp factorial.cpp -o hello</span></code></p><p>从makefile文件中可以看出我们的目的是‘all’，这是makefiles默认的目标。make工具在没有特殊声明的时候会有限执行‘all’，我们看到all是没有依赖的，所以可以安全的执行。</p><h3>那么如何使用依赖关系呢？</h3>有时候我们会使用不同的‘target’。因为当我们修改了一个文件的时候，不希望把所有的文件都进行重新编译。<p>例如以下的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefiles">all: hello<br>hello: main.o factorial.o hello.o     <br>    g++ main.o factorial.o hello.o -o hello<br>main.o: main.cpp     <br>    g++ -c main.cpp<br>factorial.o: factorial.cpp     <br>    g++ -c factorial.cpp<br>hello.o: hello.cpp     <br>    g++ -c hello.cpp<br>clean:     <br>    del *o hello.exe<br></code></pre></td></tr></table></figure><p>相当于把编译的过程（上述的两部，编译、连接）拆分开。</p><p>我们看到all只有一个依赖，而没有命令，这是为了让make能够正确的执行。all必须执行才能完成。</p><p>对于每一个可用的目标所有的依赖都会被搜索，如果找到则执行。</p><p>我们还看到了一个clean的目标,他可以快速的清除所有的object和可执行程序。</p><h3 id="在makefiles中使用变量和注释"><a href="#在makefiles中使用变量和注释" class="headerlink" title="在makefiles中使用变量和注释"></a>在makefiles中使用变量和注释</h3><p>例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs makefiles"># I am a comment, and I want to say that the variable CC will be<br><br># the compiler to use. CC=g++<br><br># Hey!, I am comment number 2. I want to say that CFLAGS will be the<br><br># options I&#x27;ll pass to the compiler.<br><br>CFLAGS=-c -Wall<br><br>all: hello<br><br>hello: main.o factorial.o hello.o    <br><br>    $(CC) main.o factorial.o hello.o -o hello<br><br>main.o: main.cpp     <br><br>    $(CC) $(CFLAGS) main.cpp<br><br>factorial.o: factorial.cpp     <br><br>    $(CC) $(CFLAGS) factorial.cpp<br><br>hello.o: hello.cpp     <br><br>    $(CC) $(CFLAGS) hello.cpp<br><br>clean:     <br><br>    del *o hello.exe<br></code></pre></td></tr></table></figure><p>如上所示，使用$(VAR)就可以轻松的访问变量。</p><p><a href="../../index.md">back</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/tech/hadoop_headfirst/"/>
      <url>/2022/09/19/tech/hadoop_headfirst/</url>
      
        <content type="html"><![CDATA[<h2 id="Hadoop安装（Ubuntu14-04）"><a href="#Hadoop安装（Ubuntu14-04）" class="headerlink" title="Hadoop安装（Ubuntu14.04）"></a>Hadoop安装（Ubuntu14.04）</h2><ol><li>安装java</li><li>配置JAVA_HOME</li><li>下载hadoop2.7解压即可使用</li></ol><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p>在下面的配置文件中配置HDFS:</p><p>etc&#x2F;hadoop&#x2F;core-site.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.defaultFS<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://localhost:9000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>etc&#x2F;hadoop&#x2F;hdfs-site.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.replication<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>完成以上两个配置文件尝试进行ssh链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh localhost</span><br></code></pre></td></tr></table></figure><p>使用下面的命令进行无密码ssh链接:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh-keygen -t dsa -P <span class="hljs-string">&#x27;&#x27;</span> -f ~/.ssh/id_dsa</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 0600 ~/.ssh/authorized_keys</span><br></code></pre></td></tr></table></figure><ol><li>Format the filesystem:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">bin/hdfs namenode -format</span><br></code></pre></td></tr></table></figure><ol start="2"><li>Start NameNode daemon and DataNode daemon:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sbin/start-dfs.sh</span><br></code></pre></td></tr></table></figure><ol start="3"><li><p>在浏览器中查看NameNode<br>NameNode - <a href="http://localhost:50070/">http://localhost:50070/</a></p></li><li><p>创建目录</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">bin/hdfs dfs -<span class="hljs-built_in">mkdir</span> /user</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">bin/hdfs dfs -<span class="hljs-built_in">mkdir</span> /user/&lt;username&gt;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>将文件拷贝到HDFS文件系统:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">bin/hdfs dfs -put etc/hadoop input</span><br></code></pre></td></tr></table></figure><ol start="6"><li>Run some of the examples provided:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar grep input output <span class="hljs-string">&#x27;dfs[a-z.]+&#x27;</span></span><br></code></pre></td></tr></table></figure><ol start="7"><li>Examine the output files: Copy the output files from the distributed filesystem to the local filesystem and examine them:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">bin/hdfs dfs -get output output</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> output/*</span><br></code></pre></td></tr></table></figure><ol start="8"><li>When you’re done, stop the daemons with:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sbin/stop-dfs.sh</span><br></code></pre></td></tr></table></figure><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>编写map reduce文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.StringTokenizer;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.IntWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Text;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Job;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Mapper;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Reducer;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WordCount</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TokenizerMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mapper</span>&lt;Object, Text, Text, IntWritable&gt;&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">IntWritable</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntWritable</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Text</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(Object key, Text value, Context context )</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>      <span class="hljs-type">StringTokenizer</span> <span class="hljs-variable">itr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringTokenizer</span>(value.toString());<br>      <span class="hljs-keyword">while</span> (itr.hasMoreTokens()) &#123;<br>        word.set(itr.nextToken());<br>        context.write(word, one);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntSumReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;Text,IntWritable,Text,IntWritable&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">IntWritable</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntWritable</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(Text key, Iterable&lt;IntWritable&gt; values,Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (IntWritable val : values) &#123;<br>        sum += val.get();<br>      &#125;<br>      result.set(sum);<br>      context.write(key, result);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Configuration</span> <span class="hljs-variable">conf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br>    <span class="hljs-type">Job</span> <span class="hljs-variable">job</span> <span class="hljs-operator">=</span> Job.getInstance(conf, <span class="hljs-string">&quot;word count&quot;</span>);<br>    job.setJarByClass(WordCount.class);<br>    job.setMapperClass(TokenizerMapper.class);<br>    job.setCombinerClass(IntSumReducer.class);<br>    job.setReducerClass(IntSumReducer.class);<br>    job.setOutputKeyClass(Text.class);<br>    job.setOutputValueClass(IntWritable.class);<br>    FileInputFormat.addInputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(args[<span class="hljs-number">0</span>]));<br>    FileOutputFormat.setOutputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(args[<span class="hljs-number">1</span>]));<br>    System.exit(job.waitForCompletion(<span class="hljs-literal">true</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>制作成jar包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">bin/hadoop com.sun.tools.javac.Main WordCount.java</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">jar cf wc.jar WordCount*.class</span><br></code></pre></td></tr></table></figure><p>启动hdfs并将文件提交到hdfs中:参考HDFS</p><p>执行程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/hadoop jar wc.jar WordCount /user/liangz14/input /user/liangz14/output<br></code></pre></td></tr></table></figure><p>查看结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/hadoop fs -cat /user/joe/wordcount/output/part-r-00000`<br></code></pre></td></tr></table></figure><p>-libjars, -files and -archives: 参数的使用  分别用来制定jar包，指定文件，和未解压文件 通过#也可以致命具体解压后的文件名<br>，不同参数之间用‘’，‘分割</p><h3 id="mr的一般过程"><a href="#mr的一般过程" class="headerlink" title="mr的一般过程"></a>mr的一般过程</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">(input) &lt;k1, v1&gt; -&gt; map -&gt; &lt;k2, v2&gt; -&gt; combine -&gt; &lt;k2, v2&gt; -&gt; reduce -&gt; &lt;k3, v3&gt; (output)<br>combine和reducer的作用一样 设置的方法：  job.setCombinerClass(IntSumReducer.class);<br></code></pre></td></tr></table></figure><h3 id="MAIN方法中的设置"><a href="#MAIN方法中的设置" class="headerlink" title="MAIN方法中的设置"></a>MAIN方法中的设置</h3><h4 id="Mapper-："><a href="#Mapper-：" class="headerlink" title="Mapper ："></a>Mapper ：</h4><p>通过Job.setMapperClass(Class) 设置map </p><p>map的结果通过context.write(WritableComparable, Writable).进行收集</p><p>之后会根据比较器进行分组： Job.setGroupingComparatorClass(Class).</p><p>之后map的结果救回被排序 并被划分给不同的reducer，划分任务的个数和reduce任务的个数一样</p><p>可以制定那个key进入那个Reducer：通过实现客户自定义的划分器</p><p>用户可以选择是有使用一个结合器 Job.setCombinerClass(Class)，来实现中间结果的本地聚合，可以减少数据传输的总量（从Mapper到Reducer）</p><p>中间结果总是会进行排序，根据：key的长度，key，值的长度，值。可以控制是否压缩，如何压缩。</p><h4 id="Maps的数量："><a href="#Maps的数量：" class="headerlink" title="Maps的数量："></a>Maps的数量：</h4><p>有输入数据的总数决定。输入文件的总的块数</p><p>maps的数量最好为每个节点10到100  经过设置到了每个cpu最多300</p><p>Configuration.set(MRJobConfig.NUM_MAPS, int) 可以进行设置</p><h4 id="Mapper细节："><a href="#Mapper细节：" class="headerlink" title="Mapper细节："></a>Mapper细节：</h4><p>Map首先调用setup（context）操作</p><p>然后调用map（object，object，context）操作</p><p>最后调用cleanup（context）操作</p><p>map可以通过RawComparator 控制分组和排序</p><p>通过Partitioner控制那个key进入那个Reducer</p><p>通过setCombinerClass 可以进行本地的组合</p><p>通过 CompressionCodec控制压缩</p><h4 id="Reducer："><a href="#Reducer：" class="headerlink" title="Reducer："></a>Reducer：</h4><p>Reducer将中间结果（有共同的key）装换成一个更小的值的集合</p><p>Job.setNumReduceTasks(int).来设置reduce的数量</p><p>Job.setReducerClass(Class) 来对reduce进行设置</p><p>每一个 &lt;key, (list of values)&gt;都会调用一次</p><p>Reducer有三个主要的阶段shuffle, sort and reduce.</p><h4 id="Shuffle："><a href="#Shuffle：" class="headerlink" title="Shuffle："></a>Shuffle：</h4><p>框架从所有Mapper的排序结果中获取相关的划分</p><p>Sort：框架通过key将Reducer的输入进行分组，因为不同的mapper可能有相同key的输出   </p><p>Job.setSortComparatorClass(Class).可以生命子集的规则，指定如何分组</p><p>Reduce：每一个key都会执行一个reduce，这个结果会通过Context.write写入到文件系统中。</p><p>Reduce的输出结果是没有经过排序的</p><p>Recude的个数 0.95 *  节点数 * 节点最大容器数 - 1.75 * …</p><h4 id="Partitioner"><a href="#Partitioner" class="headerlink" title="Partitioner"></a>Partitioner</h4><p>用来将key空间进行划分，最终划分的总数和reduce任务的总数是一样的<br>HashPartitioner是默认的划分器</p><h4 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h4><p>计数器时统计工具，M R都能用来统计</p><p>Hadoop MapReduce comes bundled with a library of generally useful mappers, reducers, and partitioners.</p><p>Hadoop的MR 是由一系列的 M  R 和P操作库 组成的</p><h4 id="JOB设置"><a href="#JOB设置" class="headerlink" title="JOB设置"></a>JOB设置</h4><p>Mapper, combiner (if any), Partitioner, Reducer, InputFormat, OutputFormat implementations</p><p>其中FileInputFormat设置输入文件的集合路径</p><p>FileOutputFormat设置输出路径</p><h2 id="HDFS常用命令"><a href="#HDFS常用命令" class="headerlink" title="HDFS常用命令"></a>HDFS常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">hadoop fs -ls /<br>hadoop fs -lsr<br>hadoop fs -mkdir /user/hadoop<br>hadoop fs -put a.txt /user/hadoop/<br>hadoop fs -get /user/hadoop/a.txt /<br>hadoop fs -cp src dst<br>hadoop fs -mv src dst<br>hadoop fs -cat /user/hadoop/a.txt<br>hadoop fs -rm /user/hadoop/a.txt<br>hadoop fs -rmr /user/hadoop/a.txt<br>hadoop fs -text /user/hadoop/a.txt<br>hadoop fs -copyFromLocal localsrc dst 与hadoop fs -put功能类似。<br>hadoop fs -moveFromLocal localsrc dst 将本地文件上传到hdfs，同时删除本地文件。<br><br>hadoop dfsadmin -report<br>hadoop dfsadmin -safemode enter | leave | get | wait<br>hadoop dfsadmin -setBalancerBandwidth 1000<br></code></pre></td></tr></table></figure><p><a href="../../index.md">back</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/tech/github_page_ssl_error/"/>
      <url>/2022/09/19/tech/github_page_ssl_error/</url>
      
        <content type="html"><![CDATA[<p>我在建立github-page本地文件的时候出现了错误。</p><ol><li><p>GitHub Metadata开头的警告：<br>在github当中新建一个Personal access tokens，添加到系统环境变量，就可以解决。</p></li><li><p>Liquid Exception: SSL_connect returned&#x3D;1 errno&#x3D;0 state&#x3D;error:..<br> 这个错误主要是由于Google需要验证证书。需要给系统添加一个证书，cacert.pem文件。</p><p> 下载<a href="http://curl.haxx.se/ca/cacert.pem">http://curl.haxx.se/ca/cacert.pem</a><br> 复制到C:\Windows<br> 运行下面命令:<br> export SSL_CERT_FILE&#x3D;c:&#x2F;windows&#x2F;cacert.pem<br> 重新运行jekyll serve</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/tech/docker_headfirst/"/>
      <url>/2022/09/19/tech/docker_headfirst/</url>
      
        <content type="html"><![CDATA[<h1 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h1><p>docker可以构建Build、运输Ship、运行Run</p><p>docker是一个一次建立到处运行的平台</p><h2 id="Containers-vs-VMs"><a href="#Containers-vs-VMs" class="headerlink" title="Containers vs. VMs"></a>Containers vs. VMs</h2><p>docker是容器  openstack是虚拟机</p><p>Docker组成 : Docker Client     &#x2F; Docker Server</p><p>Docker组件：镜像Image（只读）  &#x2F; 容器Container（对照JVM） &#x2F; 仓库Repository（对照GitHub）</p><h2 id="改变工程交付的方式"><a href="#改变工程交付的方式" class="headerlink" title="改变工程交付的方式"></a>改变工程交付的方式</h2><h2 id="Docker-的使用场景："><a href="#Docker-的使用场景：" class="headerlink" title="Docker 的使用场景："></a>Docker 的使用场景：</h2><p>简化配置、提高开发效率、应用隔离、服务器整合、</p><p>Linux安装  Linux内置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install docker.io<br>source  /etc/bash_completion.d/docker.io<br></code></pre></td></tr></table></figure><p>启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -i(表示为容器始终打开标准输入) -t(为容器分布一个伪ttp终端)ubuntu /bin/bash<br></code></pre></td></tr></table></figure><p>容器信息查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps [-a](所有容器) [-l](最新容器)  什么都不加表示正在运行中的容器<br>CONTAINER ID 容器的唯一ID             NAMES是docker守护进程分配的名字<br>docker inspect [容器的名字 或  ID]   显示容器详细的信息<br></code></pre></td></tr></table></figure><p>定义名字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name=[容器名字] -i -t  ubuntu /bin/bash<br></code></pre></td></tr></table></figure><p>重新启动已经停止的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start -i container01<br></code></pre></td></tr></table></figure><p>删除已经停止的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm  container01<br></code></pre></td></tr></table></figure><p>始终运行的容器适用于在后台运行的服务  没有交互式回话</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -i -t ubuntu /bin/bash<br></code></pre></td></tr></table></figure><p>使用 Ctrl-P  Ctrl-Q 的组合 退出交互式容器bash  这样容器会在后台运行</p><p>此时使用ps命令查看  就能看到  运行还在执行</p><p>回到正在执行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker attach [name or ID]<br></code></pre></td></tr></table></figure><p>在运行的容器中使用 exit  完全退出</p><p>使用run命令启动守护时容器，会返回一个ID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name [A name] -d (表示后台的方式启动)  ubuntu(镜像名字) /bin/sh -c &quot;死循环&quot;<br></code></pre></td></tr></table></figure><p>借助 logs 命令查看容器日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs [-f](动态跟踪)  [-t](加上实际) [--tail] 返回后面的n条<br></code></pre></td></tr></table></figure><p>top 可以查看运行中容器内进程的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker  top [name   or  ID]<br></code></pre></td></tr></table></figure><p>使用exec 在已经运行的docker 容器中启动新进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker  exec [-d] [-i] [-t]  容器名 [COMMAND]  [ARG]<br></code></pre></td></tr></table></figure><p>使用stop 或 kill 停止  运行中的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker  stop [name or ID]<br></code></pre></td></tr></table></figure><p>stop 是发送信号 等待容器的停止 ，停止后会返回容器的名字</p><p>kill 是直接杀死容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker  kill [name or ID]<br></code></pre></td></tr></table></figure><p>使用  man 查看详细介绍</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">man  docker-run<br></code></pre></td></tr></table></figure><p><a href="../../index.md">back</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/RayTracingLearning/Install/"/>
      <url>/2022/09/19/RayTracingLearning/Install/</url>
      
        <content type="html"><![CDATA[<h2 id="How-to-Get-Started-with-DirectX-Raytracing"><a href="#How-to-Get-Started-with-DirectX-Raytracing" class="headerlink" title="How to Get Started with DirectX Raytracing?"></a><strong>How to Get Started with DirectX Raytracing?</strong></h2><ul><li>An installation of <a href="https://en.wikipedia.org/wiki/Windows_10_version_history">Windows 10 RS4 (v.1803)</a> or higher</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">DirectX Raytracing is experimental on RS4, so you need to enable Developer Mode.<br>On Windows <span class="hljs-number">10</span> RS5, DXR should be integrated which will simplify use.<br></code></pre></td></tr></table></figure><ul><li>You will need GPU hardware and software drivers that support DXR.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">NVIDIA supports DXR on Volta GPUs with drivers 396.x and above.<br>NVIDIA supports DXR on Turing GPUs with drivers in the 400 series.<br>All DirectX 12 class GPUs can run DXR via Microsoft&#x27;s fallback layer<br>On Windows 10 RS4, this fallback uses a subtly different API, so not all tutorials support both hardware and fallback modes.<br></code></pre></td></tr></table></figure><ul><li>For development on RS4, you need Microsoft’s <a href="http://forums.directxtech.com/index.php?topic=5860.0">DXR installation package</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">Many of the tutorials above come with this package.<br>On RS5, this may be integrated with the standard Windows SDK<br></code></pre></td></tr></table></figure><p><a href="https://en.wikipedia.org/wiki/Windows_10_version_history">Windows版本查看</a>，我们一般看到的是build版本。</p><p>Win+R ，输入cmd在命令行最上方会显示，其中17763就是Build版本，可以看表得到对应的Version：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">Microsoft Windows [版本 <span class="hljs-number">10.0</span><span class="hljs-number">.17763</span><span class="hljs-number">.1577</span>]<br>(c) <span class="hljs-number">2018</span> Microsoft Corporation。保留所有权利。<br><br>C:\Users\User&gt;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">Version</th><th align="center">Codename</th><th align="center">Marketing name</th><th align="center">Build</th><th align="center">Release date</th></tr></thead><tbody><tr><td align="center">HomePro Pro Education Pro for Workstations</td><td align="center">Enterprise Education</td><td align="center">LTSC</td><td align="center">Mobile</td><td align="center"></td></tr><tr><td align="center">1507</td><td align="center"><a href="https://en.wikipedia.org/wiki/Windows_10_version_history_(version_1507)">Threshold 1</a></td><td align="center">N&#x2F;A</td><td align="center">10240</td><td align="center">July 29, 2015</td></tr><tr><td align="center">1511</td><td align="center"><a href="https://en.wikipedia.org/wiki/Windows_10_version_history_(version_1511)">Threshold 2</a></td><td align="center">November Update</td><td align="center">10586</td><td align="center">November 10, 2015</td></tr><tr><td align="center">1607</td><td align="center"><a href="https://en.wikipedia.org/wiki/Windows_10_version_history_(version_1607)">Redstone 1</a></td><td align="center">Anniversary Update</td><td align="center">14393</td><td align="center">August 2, 2016</td></tr><tr><td align="center">1703</td><td align="center"><a href="https://en.wikipedia.org/wiki/Windows_10_version_history_(version_1703)">Redstone 2</a></td><td align="center">Creators Update</td><td align="center">15063</td><td align="center">April 5, 2017</td></tr><tr><td align="center">1709</td><td align="center"><a href="https://en.wikipedia.org/wiki/Windows_10_version_history_(version_1709)">Redstone 3</a></td><td align="center">Fall Creators Update</td><td align="center">16299</td><td align="center">October 17, 2017</td></tr><tr><td align="center">1803</td><td align="center"><a href="https://en.wikipedia.org/wiki/Windows_10_version_history_(version_1803)">Redstone 4</a></td><td align="center">April 2018 Update</td><td align="center">17134</td><td align="center">April 30, 2018</td></tr><tr><td align="center">1809</td><td align="center"><a href="https://en.wikipedia.org/wiki/Windows_10_version_history_(version_1809)">Redstone 5</a></td><td align="center">October 2018 Update</td><td align="center">17763</td><td align="center">November 13, 2018</td></tr><tr><td align="center">1903</td><td align="center"><a href="https://en.wikipedia.org/wiki/Windows_10_version_history_(version_1903)">19H1</a></td><td align="center">May 2019 Update</td><td align="center">18362</td><td align="center">May 21, 2019</td></tr><tr><td align="center">1909</td><td align="center"><a href="https://en.wikipedia.org/wiki/Windows_10_version_history_(version_1909)">19H2</a></td><td align="center">November 2019 Update</td><td align="center">18363</td><td align="center">November 12, 2019</td></tr><tr><td align="center">2004</td><td align="center"><a href="https://en.wikipedia.org/wiki/Windows_10_version_history_(version_2004)">20H1</a></td><td align="center">May 2020 Update</td><td align="center">19041</td><td align="center">May 27, 2020</td></tr><tr><td align="center">20H2</td><td align="center"><a href="https://en.wikipedia.org/wiki/Windows_10_version_history#Version_20H2_(October_2020_Update)">20H2</a></td><td align="center">October 2020 Update</td><td align="center">19042</td><td align="center">October 20, 2020</td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Windows_10_version_history#Dev_Channel">Dev Channel</a></td><td align="center">20270</td><td align="center">N&#x2F;A</td><td align="center">Rolling Builds in Development</td><td align="center"></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/language/lua/fast_learn_lua/"/>
      <url>/2022/09/19/language/lua/fast_learn_lua/</url>
      
        <content type="html"><![CDATA[<h1 id="Lua-语言-15-分钟快速入门"><a href="#Lua-语言-15-分钟快速入门" class="headerlink" title="Lua 语言 15 分钟快速入门"></a>Lua 语言 15 分钟快速入门</h1><p>本文来自<a href="http://www.linuxidc.com/Linux/2013-06/86582.htm">oschina.net </a></p><p><a href="../../../index.md">back</a></p><p><a href="../lang_index.md">back to language</a></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 两个横线开始单行的注释</span><br><span class="hljs-comment">--[[</span><br><span class="hljs-comment">    加上两个[和]表示</span><br><span class="hljs-comment">      多行的注释。</span><br><span class="hljs-comment"> --]]</span><br></code></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua">num = <span class="hljs-number">42</span>  <span class="hljs-comment">-- 所有的数字都是double。 </span><br><span class="hljs-comment">-- 别担心，double的64位中有52位用于 </span><br><span class="hljs-comment">-- 保存精确的int值; 对于需要52位以内的int值， </span><br><span class="hljs-comment">-- 机器的精度不是问题。</span><br><br>s = <span class="hljs-string">&#x27;walternate&#x27;</span>  <span class="hljs-comment">-- 像Python那样的不可变的字符串。 </span><br>t = <span class="hljs-string">&quot;双引号也可以&quot;</span> <br>u = <span class="hljs-string">[[ 两个方括号 </span><br><span class="hljs-string">      用于 </span><br><span class="hljs-string">      多行的字符串。]]</span> <br>t = <span class="hljs-literal">nil</span>  <span class="hljs-comment">-- 未定义的t; Lua 支持垃圾收集。</span><br></code></pre></td></tr></table></figure><h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- do/end之类的关键字标示出程序块： </span><br><span class="hljs-keyword">while</span> num &lt; <span class="hljs-number">50</span> <span class="hljs-keyword">do</span> <br>  num = num + <span class="hljs-number">1</span>  <span class="hljs-comment">-- 没有 ++ or += 运算符。 </span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- If语句： </span><br><span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">40</span> <span class="hljs-keyword">then</span> <br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;over 40&#x27;</span>) <br><span class="hljs-keyword">elseif</span> s ~= <span class="hljs-string">&#x27;walternate&#x27;</span> <span class="hljs-keyword">then</span>  <span class="hljs-comment">-- ~= 表示不等于。 </span><br>  <span class="hljs-comment">-- 像Python一样，== 表示等于；适用于字符串。 </span><br>  <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>(<span class="hljs-string">&#x27;not over 40\n&#x27;</span>)  <span class="hljs-comment">-- 默认输出到stdout。 </span><br><span class="hljs-keyword">else</span> <br>  <span class="hljs-comment">-- 默认变量都是全局的。 </span><br>  thisIsGlobal = <span class="hljs-number">5</span>  <span class="hljs-comment">-- 通常用驼峰式定义变量名。</span><br><br>  <span class="hljs-comment">-- 如何定义局部变量： </span><br>  <span class="hljs-keyword">local</span> line = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()  <span class="hljs-comment">-- 读取stdin的下一行。</span><br><br>  <span class="hljs-comment">-- ..操作符用于连接字符串： </span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Winter is coming, &#x27;</span> .. line) <br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 未定义的变量返回nil。 </span><br><span class="hljs-comment">-- 这不会出错： </span><br>foo = anUnknownVariable  <span class="hljs-comment">-- 现在 foo = nil.</span><br><br>aBoolValue = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">--只有nil和false是fals; 0和 &#x27;&#x27;都是true！ </span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> aBoolValue <span class="hljs-keyword">then</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;twas false&#x27;</span>) <span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- &#x27;or&#x27;和 &#x27;and&#x27;都是可短路的（译者注：如果已足够进行条件判断则不计算后面的条件表达式）。 </span><br><span class="hljs-comment">-- 类似于C/js里的 a?b:c 操作符： </span><br>ans = aBoolValue <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;yes&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;no&#x27;</span>  <span class="hljs-comment">--&gt; &#x27;no&#x27;</span><br><br>karlSum = <span class="hljs-number">0</span> <br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">100</span> <span class="hljs-keyword">do</span>  <span class="hljs-comment">-- 范围包括两端 </span><br>  karlSum = karlSum + i <br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 使用 &quot;100, 1, -1&quot; 表示递减的范围： </span><br>fredSum = <span class="hljs-number">0</span> <br><span class="hljs-keyword">for</span> j = <span class="hljs-number">100</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span> <span class="hljs-keyword">do</span> fredSum = fredSum + j <span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 通常，范围表达式为begin, end[, step].</span><br><br><span class="hljs-comment">-- 另一种循环表达方式： </span><br><span class="hljs-keyword">repeat</span> <br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;the way of the future&#x27;</span>) <br>  num = num - <span class="hljs-number">1</span> <br><span class="hljs-keyword">until</span> num == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span><span class="hljs-params">(n)</span></span> <br>  <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">end</span> <br>  <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">2</span>) + fib(n - <span class="hljs-number">1</span>) <br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 支持闭包及匿名函数： </span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adder</span><span class="hljs-params">(x)</span></span> <br>  <span class="hljs-comment">-- 调用adder时，会创建用于返回的函数，并且能记住变量x的值： </span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(y)</span></span> <span class="hljs-keyword">return</span> x + y <span class="hljs-keyword">end</span> <br><span class="hljs-keyword">end</span> <br>a1 = adder(<span class="hljs-number">9</span>) <br>a2 = adder(<span class="hljs-number">36</span>) <br><span class="hljs-built_in">print</span>(a1(<span class="hljs-number">16</span>))  <span class="hljs-comment">--&gt; 25 </span><br><span class="hljs-built_in">print</span>(a2(<span class="hljs-number">64</span>))  <span class="hljs-comment">--&gt; 100</span><br><br><span class="hljs-comment">-- 返回值、函数调用和赋值都可以使用长度不匹配的list。 </span><br><span class="hljs-comment">-- 不匹配的接收方会被赋为nil； </span><br><span class="hljs-comment">-- 不匹配的发送方会被忽略。</span><br><br>x, y, z = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> <br><span class="hljs-comment">-- 现在x = 1, y = 2, z = 3, 而 4 会被丢弃。</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span><span class="hljs-params">(a, b, c)</span></span> <br>  <span class="hljs-built_in">print</span>(a, b, c) <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">23</span>, <span class="hljs-number">42</span> <br><span class="hljs-keyword">end</span><br><br>x, y = bar(<span class="hljs-string">&#x27;zaphod&#x27;</span>)  <span class="hljs-comment">--&gt; prints &quot;zaphod  nil nil&quot; </span><br><span class="hljs-comment">-- 现在 x = 4, y = 8, 而值15..42被丢弃。</span><br><br><span class="hljs-comment">-- 函数是一等公民，可以是局部或者全局的。 </span><br><span class="hljs-comment">-- 下面是等价的： </span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span></span> <span class="hljs-keyword">return</span> x * x <span class="hljs-keyword">end</span> <br>f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x)</span></span> <span class="hljs-keyword">return</span> x * x <span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 这些也是等价的： </span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span><span class="hljs-params">(x)</span></span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>(x) <span class="hljs-keyword">end</span> <br><span class="hljs-keyword">local</span> g; g  = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x)</span></span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>(x) <span class="hljs-keyword">end</span> <br><span class="hljs-comment">-- &#x27;local g&#x27;可以支持g自引用。</span><br><br><span class="hljs-comment">-- 顺便提一下，三角函数是以弧度为单位的。</span><br><br><span class="hljs-comment">-- 用一个字符串参数调用函数，不需要括号： </span><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;hello&#x27;</span>  <span class="hljs-comment">--可以工作。</span><br></code></pre></td></tr></table></figure><h3 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- Table = Lua唯一的数据结构; </span><br><span class="hljs-comment">--        它们是关联数组。 </span><br><span class="hljs-comment">-- 类似于PHP的数组或者js的对象， </span><br><span class="hljs-comment">-- 它们是哈希查找表（dict），也可以按list去使用。</span><br><br><span class="hljs-comment">-- 按字典/map的方式使用Table：</span><br><br><span class="hljs-comment">-- Dict的迭代默认使用string类型的key： </span><br>t = &#123;key1 = <span class="hljs-string">&#x27;value1&#x27;</span>, key2 = <span class="hljs-literal">false</span>&#125;<br><br><span class="hljs-comment">-- String的key可以像js那样用点去引用： </span><br><span class="hljs-built_in">print</span>(t.key1)  <span class="hljs-comment">-- 打印 &#x27;value1&#x27;. </span><br>t.newKey = &#123;&#125;  <span class="hljs-comment">-- 添加新的 key/value 对。 </span><br>t.key2 = <span class="hljs-literal">nil</span>  <span class="hljs-comment">-- 从table删除 key2。</span><br><br><span class="hljs-comment">-- 使用任何非nil的值作为key： </span><br>u = &#123;[<span class="hljs-string">&#x27;@!#&#x27;</span>] = <span class="hljs-string">&#x27;qbert&#x27;</span>, [&#123;&#125;] = <span class="hljs-number">1729</span>, [<span class="hljs-number">6.28</span>] = <span class="hljs-string">&#x27;tau&#x27;</span>&#125; <br><span class="hljs-built_in">print</span>(u[<span class="hljs-number">6.28</span>])  <span class="hljs-comment">-- 打印 &quot;tau&quot;</span><br><br><span class="hljs-comment">-- 对于数字和字符串的key是按照值来匹配的，但是对于table则是按照id来匹配。 </span><br>a = u[<span class="hljs-string">&#x27;@!#&#x27;</span>]  <span class="hljs-comment">-- 现在 a = &#x27;qbert&#x27;. </span><br>b = u[&#123;&#125;]    <span class="hljs-comment">-- 我们期待的是 1729,  但是得到的是nil: </span><br><span class="hljs-comment">-- b = nil ，因为没有找到。 </span><br><span class="hljs-comment">-- 之所以没找到，是因为我们用的key与保存数据时用的不是同一个对象。 </span><br><span class="hljs-comment">-- 所以字符串和数字是可用性更好的key。</span><br><br><span class="hljs-comment">-- 只需要一个table参数的函数调用不需要括号： </span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">h</span><span class="hljs-params">(x)</span></span> <span class="hljs-built_in">print</span>(x.key1) <span class="hljs-keyword">end</span> <br>h&#123;key1 = <span class="hljs-string">&#x27;Sonmi~451&#x27;</span>&#125;  <span class="hljs-comment">-- 打印&#x27;Sonmi~451&#x27;.</span><br><br><span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(u) <span class="hljs-keyword">do</span>  <span class="hljs-comment">-- Table 的遍历. </span><br>  <span class="hljs-built_in">print</span>(key, val) <br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- _G 是一个特殊的table，用于保存所有的全局变量 </span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">_G</span>[<span class="hljs-string">&#x27;_G&#x27;</span>] == <span class="hljs-built_in">_G</span>)  <span class="hljs-comment">-- 打印&#x27;true&#x27;.</span><br><br><span class="hljs-comment">-- 按list/array的方式使用：</span><br><br><span class="hljs-comment">-- List 的迭代方式隐含会添加int的key： </span><br>v = &#123;<span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>, <span class="hljs-number">1.21</span>, <span class="hljs-string">&#x27;gigawatts&#x27;</span>&#125; <br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, #v <span class="hljs-keyword">do</span>  <span class="hljs-comment">-- #v 是list的size </span><br>  <span class="hljs-built_in">print</span>(v[i])  <span class="hljs-comment">-- 索引从 1 开始!! 太疯狂了！ </span><br><span class="hljs-keyword">end</span> <br><span class="hljs-comment">-- &#x27;list&#x27;并非真正的类型，v 还是一个table， </span><br><span class="hljs-comment">-- 只不过它有连续的整数作为key，可以像list那样去使用。</span><br></code></pre></td></tr></table></figure><h3 id="元表-metatable"><a href="#元表-metatable" class="headerlink" title="元表(metatable)"></a>元表(metatable)</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- table的元表提供了一种机制，可以重定义table的一些操作。 </span><br><span class="hljs-comment">-- 之后我们会看到元表是如何支持类似js的prototype行为。</span><br><br>f1 = &#123;a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>&#125;  <span class="hljs-comment">-- 表示一个分数 a/b. </span><br>f2 = &#123;a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>&#125;<br><br><span class="hljs-comment">-- 这个是错误的： </span><br><span class="hljs-comment">-- s = f1 + f2</span><br><br>metafraction = &#123;&#125; <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">metafraction.__add</span><span class="hljs-params">(f1, f2)</span></span> <br>  sum = &#123;&#125; <br>  sum.b = f1.b * f2.b <br>  sum.a = f1.a * f2.b + f2.a * f1.b <br>  <span class="hljs-keyword">return</span> sum <br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">setmetatable</span>(f1, metafraction) <br><span class="hljs-built_in">setmetatable</span>(f2, metafraction)<br><br>s = f1 + f2  <span class="hljs-comment">-- 调用在f1的元表上的__add(f1, f2) 方法</span><br><br><span class="hljs-comment">-- f1, f2 没有能访问它们元表的key，这与prototype不一样， </span><br><span class="hljs-comment">-- 所以你必须用getmetatable(f1)去获得元表。元表是一个普通的table， </span><br><span class="hljs-comment">-- Lua可以通过通常的方式去访问它的key，例如__add。</span><br><br><span class="hljs-comment">-- 不过下面的代码是错误的，因为s没有元表： </span><br><span class="hljs-comment">-- t = s + s </span><br><span class="hljs-comment">-- 下面的类形式的模式可以解决这个问题：</span><br><br><span class="hljs-comment">-- 元表的__index 可以重载点运算符的查找： </span><br>defaultFavs = &#123;animal = <span class="hljs-string">&#x27;gru&#x27;</span>, food = <span class="hljs-string">&#x27;donuts&#x27;</span>&#125; <br>myFavs = &#123;food = <span class="hljs-string">&#x27;pizza&#x27;</span>&#125; <br><span class="hljs-built_in">setmetatable</span>(myFavs, &#123;<span class="hljs-built_in">__index</span> = defaultFavs&#125;) <br>eatenBy = myFavs.animal  <span class="hljs-comment">-- 可以工作！这要感谢元表的支持</span><br><br><span class="hljs-comment">-- 如果在table中直接查找key失败，会使用元表的__index 继续查找，并且是递归的查找</span><br><br><span class="hljs-comment">-- __index的值也可以是函数function(tbl, key) ，这样可以支持更多的自定义的查找。</span><br><br><span class="hljs-comment">-- __index、__add等等，被称为元方法。 </span><br><span class="hljs-comment">-- 这里是table的元方法的全部清单：</span><br><br><span class="hljs-comment">-- __add(a, b)                    for a + b </span><br><span class="hljs-comment">-- __sub(a, b)                    for a - b </span><br><span class="hljs-comment">-- __mul(a, b)                    for a * b </span><br><span class="hljs-comment">-- __div(a, b)                    for a / b </span><br><span class="hljs-comment">-- __mod(a, b)                    for a % b </span><br><span class="hljs-comment">-- __pow(a, b)                    for a ^ b </span><br><span class="hljs-comment">-- __unm(a)                        for -a </span><br><span class="hljs-comment">-- __concat(a, b)                  for a .. b </span><br><span class="hljs-comment">-- __len(a)                        for #a </span><br><span class="hljs-comment">-- __eq(a, b)                      for a == b </span><br><span class="hljs-comment">-- __lt(a, b)                      for a &lt; b </span><br><span class="hljs-comment">-- __le(a, b)                      for a &lt;= b </span><br><span class="hljs-comment">-- __index(a, b)  &lt;fn or a table&gt;  for a.b </span><br><span class="hljs-comment">-- __newindex(a, b, c)            for a.b = c </span><br><span class="hljs-comment">-- __call(a, ...)                  for a(...)</span><br></code></pre></td></tr></table></figure><h3 id="类风格的table"><a href="#类风格的table" class="headerlink" title="类风格的table"></a>类风格的table</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 类并不是内置的；有不同的方法通过表和元表来实现。</span><br><br><span class="hljs-comment">-- 下面是一个例子，后面是对例子的解释</span><br><br>Dog = &#123;&#125;                                  <span class="hljs-comment">-- 1.</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog:new</span><span class="hljs-params">()</span></span>                        <span class="hljs-comment">-- 2. </span><br>  newObj = &#123;sound = <span class="hljs-string">&#x27;woof&#x27;</span>&#125;                <span class="hljs-comment">-- 3. </span><br>  <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">self</span>                      <span class="hljs-comment">-- 4. </span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">setmetatable</span>(newObj, <span class="hljs-built_in">self</span>)        <span class="hljs-comment">-- 5. </span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog:makeSound</span><span class="hljs-params">()</span></span>                  <span class="hljs-comment">-- 6. </span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;I say &#x27;</span> .. <span class="hljs-built_in">self</span>.sound) <br><span class="hljs-keyword">end</span><br><br>mrDog = Dog:new()                          <span class="hljs-comment">-- 7. </span><br>mrDog:makeSound()  <span class="hljs-comment">-- &#x27;I say woof&#x27;        -- 8.</span><br><br><span class="hljs-comment">-- 1. Dog看上去像一个类；其实它完全是一个table。 </span><br><span class="hljs-comment">-- 2. 函数tablename:fn(...) 与函数tablename.fn(self, ...) 是一样的 </span><br><span class="hljs-comment">--    冒号（:）只是添加了self作为第一个参数。 </span><br><span class="hljs-comment">--    下面的第7和第8条说明了self变量是如何得到其值的。 </span><br><span class="hljs-comment">-- 3. newObj是类Dog的一个实例。 </span><br><span class="hljs-comment">-- 4. self为初始化的类实例。通常self = Dog，不过继承关系可以改变这个。 </span><br><span class="hljs-comment">--    如果把newObj的元表和__index都设为self， </span><br><span class="hljs-comment">--    newObj就可以得到self的函数。 </span><br><span class="hljs-comment">-- 5. 记住：setmetatable返回其第一个参数。 </span><br><span class="hljs-comment">-- 6. 冒号（：）在第2条是工作的，不过这里我们期望 </span><br><span class="hljs-comment">--    self是一个实例，而不是类 </span><br><span class="hljs-comment">-- 7. 与Dog.new(Dog)类似，所以 self = Dog in new()。 </span><br><span class="hljs-comment">-- 8. 与mrDog.makeSound(mrDog)一样; self = mrDog。</span><br><br></code></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs lua">LoudDog = Dog:new()                          <span class="hljs-comment">-- 1.</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LoudDog:makeSound</span><span class="hljs-params">()</span></span> <br>  s = <span class="hljs-built_in">self</span>.sound .. <span class="hljs-string">&#x27; &#x27;</span>                      <span class="hljs-comment">-- 2. </span><br>  <span class="hljs-built_in">print</span>(s .. s .. s) <br><span class="hljs-keyword">end</span><br><br>seymour = LoudDog:new()                      <span class="hljs-comment">-- 3. </span><br>seymour:makeSound()  <span class="hljs-comment">-- &#x27;woof woof woof&#x27;      -- 4.</span><br><br><span class="hljs-comment">-- 1. LoudDog获得Dog的方法和变量列表。 </span><br><span class="hljs-comment">-- 2. 通过new()，self有一个&#x27;sound&#x27;的key from new()，参见第3条。 </span><br><span class="hljs-comment">-- 3. 与LoudDog.new(LoudDog)一样，并且被转换成 </span><br><span class="hljs-comment">--    Dog.new(LoudDog)，因为LoudDog没有&#x27;new&#x27; 的key， </span><br><span class="hljs-comment">--    不过在它的元表可以看到 __index = Dog。 </span><br><span class="hljs-comment">--    结果: seymour的元表是LoudDog，并且 </span><br><span class="hljs-comment">--    LoudDog.__index = LoudDog。所以有seymour.key </span><br><span class="hljs-comment">--    = seymour.key, LoudDog.key, Dog.key, 要看 </span><br><span class="hljs-comment">--    针对给定的key哪一个table排在前面。 </span><br><span class="hljs-comment">-- 4. 在LoudDog可以找到&#x27;makeSound&#x27;的key；这与 </span><br><span class="hljs-comment">--    LoudDog.makeSound(seymour)一样。</span><br><br><span class="hljs-comment">-- 如果需要，子类也可以有new()，与基类的类似： </span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LoudDog:new</span><span class="hljs-params">()</span></span> <br>  newObj = &#123;&#125; <br>  <span class="hljs-comment">-- 初始化newObj </span><br>  <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">self</span> <br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">setmetatable</span>(newObj, <span class="hljs-built_in">self</span>) <br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--[[ 我把这部分给注释了，这样脚本剩下的部分就可以运行了</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">-- 假设文件mod.lua的内容是： </span><br><span class="hljs-comment">local M = &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">local function sayMyName() </span><br><span class="hljs-comment">  print(&#x27;Hrunkner&#x27;) </span><br><span class="hljs-comment">end</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">function M.sayHello() </span><br><span class="hljs-comment">  print(&#x27;Why hello there&#x27;) </span><br><span class="hljs-comment">  sayMyName() </span><br><span class="hljs-comment">end</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">return M</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">-- 另一个文件也可以使用mod.lua的函数： </span><br><span class="hljs-comment">local mod = require(&#x27;mod&#x27;)  -- 运行文件mod.lua.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">-- require是包含模块的标准做法。 </span><br><span class="hljs-comment">-- require等价于:    (针对没有被缓存的情况；参加后面的内容) </span><br><span class="hljs-comment">local mod = (function () </span><br><span class="hljs-comment">  &lt;contents of mod.lua&gt; </span><br><span class="hljs-comment">end)() </span><br><span class="hljs-comment">-- mod.lua就好像一个函数体，所以mod.lua的局部变量对外是不可见的。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">-- 下面的代码是工作的，因为在mod.lua中mod = M： </span><br><span class="hljs-comment">mod.sayHello()  -- Says hello to Hrunkner.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">-- 这是错误的；sayMyName只在mod.lua中存在： </span><br><span class="hljs-comment">mod.sayMyName()  -- 错误</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">-- require返回的值会被缓存，所以一个文件只会被运行一次， </span><br><span class="hljs-comment">-- 即使它被require了多次。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">-- 假设mod2.lua包含代码&quot;print(&#x27;Hi!&#x27;)&quot;。 </span><br><span class="hljs-comment">local a = require(&#x27;mod2&#x27;)  -- 打印Hi! </span><br><span class="hljs-comment">local b = require(&#x27;mod2&#x27;)  -- 不再打印; a=b.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">-- dofile与require类似，只是不做缓存： </span><br><span class="hljs-comment">dofile(&#x27;mod2&#x27;)  --&gt; Hi! </span><br><span class="hljs-comment">dofile(&#x27;mod2&#x27;)  --&gt; Hi! (再次运行，与require不同)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">-- loadfile加载一个lua文件，但是并不允许它。 </span><br><span class="hljs-comment">f = loadfile(&#x27;mod2&#x27;)  -- Calling f() runs mod2.lua.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">-- loadstring是loadfile的字符串版本。 </span><br><span class="hljs-comment">g = loadstring(&#x27;print(343)&#x27;)  --返回一个函数。 </span><br><span class="hljs-comment">g()  -- 打印343; 在此之前什么也不打印。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">--]]</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/language/c++/unlock_queue/"/>
      <url>/2022/09/19/language/c++/unlock_queue/</url>
      
        <content type="html"><![CDATA[<h1 id="无锁队列的实现"><a href="#无锁队列的实现" class="headerlink" title="无锁队列的实现"></a>无锁队列的实现</h1><p>本文修改自<a href="https://coolshell.cn/articles/8239.html">无锁队列的实现</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/language/c++/thread/"/>
      <url>/2022/09/19/language/c++/thread/</url>
      
        <content type="html"><![CDATA[<p>##临界区</p><p>在多线程当中进行互斥同步的锁。</p><p>可是使用windase.h当中的临时区锁进行控制：</p><p>**InitializeCriticalSection  此函数初始化一个临界区对象 **</p><p>void InitializeCriticalSection(  LPCRITICAL_SECTION <em>lpCriticalSection</em>);</p><p>参数：lpCriticalSection指向临界区对象的指针</p><p>这个进程负责分配一个临界区对象使用的内存，它可以通过声明类型的CRITICAL_SECTION的变量使用的内存。一旦一个临界区对象已被初始化，该进程的线程可以在EnterCriticalSection或LeaveCriticalSection函数指定对象，提供对共享资源的相互独占式访问。对于不同进程之间的类似线程同步，使用互斥对象。</p><p>一个临界区对象不能移动或复制。这一进程也绝不能修改该对象，但必须把它作为逻辑不透明来处理。只能使用由与Microsoft Win32 ® API提供的临界区功能，用来管理临界区对象。</p><p>在低内存的情况下，InitializeCriticalSection可能提出STATUS_NO_MEMORY异常。</p><p><strong>DeleteCriticalSection 删除关键节对象释放由该对象使用的所有系统资源。</strong></p><p>void WINAPI DeleteCriticalSection(<em>Inout</em> LPCRITICAL_SECTION lpCriticalSection);</p><p>参数：<em>lpCriticalSection，</em>对关键节对象的指针。先前必须已将该对象初始化于InitializeCriticalSection对象中。</p><p><strong>线程锁的概念函数EnterCriticalSection和LeaveCriticalSection的用法</strong></p><p>使用结构CRITICAL_SECTION 需加入头文件#include “afxmt.h”</p><p>定义一个全局的锁 CRITICAL_SECTION的实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">CRITICAL_SECTION cs;<br>InitializeCriticalSection(&amp;cs);<br><br><span class="hljs-comment">//第一个线程</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;      <br>  EnterCriticalSection(&amp;cs);<span class="hljs-comment">//加锁</span><br><span class="hljs-comment">// TODO：逻辑</span><br>  LeaveCriticalSection(&amp;cs);<span class="hljs-comment">//解锁</span><br>&#125;<br><br><span class="hljs-comment">//第二线程</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;      <br>  EnterCriticalSection(&amp;cs);<span class="hljs-comment">//加锁</span><br><span class="hljs-comment">// TODO：逻辑</span><br>  LeaveCriticalSection(&amp;cs);<span class="hljs-comment">//解锁</span><br>&#125;<br><br><span class="hljs-comment">//使用完成</span><br>DeleteCriticalSection(&amp;cs);<br></code></pre></td></tr></table></figure><h2 id="互斥锁和阻塞信号"><a href="#互斥锁和阻塞信号" class="headerlink" title="互斥锁和阻塞信号"></a>互斥锁和阻塞信号</h2><p>SuspendThread 如果暂停了获取锁的进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">EnterCriticalSection(&amp;cs);<span class="hljs-comment">//加锁</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>A</span><br>LeaveCriticalSection(&amp;cs);<span class="hljs-comment">//解锁</span><br></code></pre></td></tr></table></figure><p>如果在A处暂停则可能造成死锁。</p><p>WaitForSingleObject是等待一个特定的对象编程发出信号的状态或者过时。</p><p>说明<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx">WaitForSingleObject</a></p><p>例子<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686915(v=vs.85).aspx">WaitForSingleObject</a></p><h2 id="多线程编程之Windows同步方式"><a href="#多线程编程之Windows同步方式" class="headerlink" title="多线程编程之Windows同步方式"></a>多线程编程之Windows同步方式</h2><p>　本文来自<a href="http://www.cnblogs.com/kuliuheng/p/4062211.html">cnblogs.</a></p><p>​在Windows环境下针对多线程同步与互斥操作的支持，主要包括四种方式：临界区（CriticalSection）、互斥对象（Mutex）、信号量（Semaphore）、事件对象（Event）。下面分别针对这四种方式作说明：</p><p><strong>（1）临界区（CriticalSection）</strong></p><p>　　每个进程中访问临界资源的那段代码称为临界区（临界资源是一次仅允许一个进程使用的共享资源）。每次只准许一个进程进入临界区，进入后不允许其他进程进入。不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问。Windows环境下临界区的基本操作有以下几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">CRITICAL_SECTION CriticalSection;<br>InitializeCriticalSection(&amp;CriticalSection);<br>EnterCriticalSection(&amp;CriticalSection);<br>LeaveCriticalSection(&amp;CriticalSection);<br>DeleteCriticalSection(&amp;CriticalSection);<br></code></pre></td></tr></table></figure><p><strong>（2）互斥对象（Mutex）</strong></p><p>　　在编程中，引入了对象互斥对象（也叫互斥锁）的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。互斥对象的操作接口有以下几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">CreateMutex<br>OpenMutex<br>ReleaseMutex<br></code></pre></td></tr></table></figure><p> 　　在使用互斥对象的时候借助WaitforSingleObject，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">WaitForSingleObject(<span class="hljs-comment">/*...*/</span>);<br>    do_something();<br>ReleaseMutex(<span class="hljs-comment">/*...*/</span>);<br></code></pre></td></tr></table></figure><p> **（3）信号量（Semaphore）　　**</p><p>　　信号量有时被称为信号灯，是在多线程环境下使用的一种设施，它负责协调各个线程，以保证它们能够正确、合理的使用公共资源。也是操作系统中用于控制<strong>进程同步互斥</strong>的量。信号量分为单值和多值两种，前者只能被一个线程获得，后者可以被若干个线程获得。与互斥对象相比，信号量就好比是可以容纳N多个人的房子允许多个人同时进入（数量有限制而已），而互斥对象就只能容纳一个人的小房子，同一时刻只能一个人使用。</p><p>　　Windows环境下的信号量操作接口包括：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">CreateSemaphore<br>OpenSemaphore<br>ReleaseSemaphore<br></code></pre></td></tr></table></figure><p> 　　信号量的使用方式与互斥对象差不多，只不过在初始化的时候需要指定信号的个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">WaitForSingleObject(<span class="hljs-comment">/*...*/</span>);<br>    do_something();<br>ReleaseSemaphore(<span class="hljs-comment">/*...*/</span>);<br></code></pre></td></tr></table></figure><p> <strong>（4）事件对象（Event）</strong></p><p>　　 Event对象是Windows下面很有趣的一种锁结果。从某种意义上说，它和互斥锁很相近，但是又不一样。因为在线程获得锁的使用权之前，常常需要某一个线程（可能是主线程也可能是其他线程）调用SetEvent设置一下才行。关键是，在线程结束之前，我们也不清楚当前线程获得Event之后执行到哪了。所以使用起来，要特别小心。常用的Event对象操作有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">CreateEvent<br>OpenEvent<br>PulseEvent<br>ResetEvent<br>SetEvent<br></code></pre></td></tr></table></figure><p> 　　主线程一般可以这样做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">CreateEvent(<span class="hljs-comment">/*...*/</span>);    <span class="hljs-comment">// 创建事件对象</span><br>SetEvent(<span class="hljs-comment">/*...*/</span>);       <span class="hljs-comment">// 设置信号</span><br>WaitForMultiObjects(hThread, <span class="hljs-comment">/*...*/</span>);    <span class="hljs-comment">// 等待线程结束</span><br>CloseHandle(<span class="hljs-comment">/*...*/</span>);    <span class="hljs-comment">// 关闭线程句柄</span><br></code></pre></td></tr></table></figure><p> 　　而被启动的线程一般要等待某个事件再进行动作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    WaitForSingleObject(<span class="hljs-comment">/*...*/</span>);    <span class="hljs-comment">// 等待事件</span><br>    <span class="hljs-comment">/*...*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong><br>（1）关于<a href="http://msdn.microsoft.com/en-us/library/ms686908(v=VS.85).aspx">临界区</a>、<a href="http://msdn.microsoft.com/en-us/library/ms686927(v=VS.85).aspx">互斥区</a>、<a href="http://msdn.microsoft.com/en-us/library/ms686946(v=VS.85).aspx">信号量</a>、<a href="http://msdn.microsoft.com/en-us/library/ms686915(v=VS.85).aspx">E</a><a href="http://msdn.microsoft.com/en-us/library/ms686915(v=VS.85).aspx">vent</a>在msdn上均有示例代码；</p><p>（2）一般来说，使用频率上<strong>信号量 &gt; 互斥对象 &gt; 临界区 &gt; 事件对象</strong></p><p>（3）信号量可以实现其他三种锁的功能，学习上应有所侧重</p><p>（4）纸上得来终觉浅，多实践才能掌握它们之间的区别 *    *</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/language/c++/network/"/>
      <url>/2022/09/19/language/c++/network/</url>
      
        <content type="html"><![CDATA[<p>winsock2.h</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/19/language/lang_index/"/>
      <url>/2022/09/19/language/lang_index/</url>
      
        <content type="html"><![CDATA[<h1 id="语言学习"><a href="#语言学习" class="headerlink" title="语言学习"></a>语言学习</h1><p>包含了基本的语言基础和相关技巧</p><p>Lua</p><p><a href="lua/fast_learn_lua.md">十五分钟快速学会lua</a></p><p>C++</p><p><a href="c++/network.md">windows网络编程</a></p><p><a href="c++/thread.md">多线程</a></p><p><a href="unlock_queue.md">无锁队列</a></p><p><a href="../../index.md">back</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在unity的IL2CPP中接入FASTBuild</title>
      <link href="/2022/08/03/Unity/il2cpp_fastbuild/"/>
      <url>/2022/08/03/Unity/il2cpp_fastbuild/</url>
      
        <content type="html"><![CDATA[<h1 id="在unity的IL2CPP中接入FASTBuild"><a href="#在unity的IL2CPP中接入FASTBuild" class="headerlink" title="在unity的IL2CPP中接入FASTBuild"></a>在unity的IL2CPP中接入FASTBuild</h1><h2 id="如何编译IL2CPP-exe"><a href="#如何编译IL2CPP-exe" class="headerlink" title="如何编译IL2CPP.exe"></a>如何编译IL2CPP.exe</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">jam WinEditor<br></code></pre></td></tr></table></figure><h2 id="如何调试IL2CPP-exe"><a href="#如何调试IL2CPP-exe" class="headerlink" title="如何调试IL2CPP.exe"></a>如何调试IL2CPP.exe</h2><p>用vs2017我研究了一天没有成功，改用rider进行附加调试。第一步加入一个ReadKey的指令，等待附加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public static int Main(string[] args)<br>&#123;<br>    // 这里是等待附加的代码<br>    ConsoleKey key = Console.ReadKey().Key;<br>    int exitCode;<br>    try<br>    &#123;<br>        exitCode = Run(args, true);<br>    &#125;<br>    catch (PathTooLongException e)<br>    &#123;<br>        Console.WriteLine(&quot;IL2CPP error: The specified output path is too long to write generated files. Please choose a location with a shorter path.&quot;);<br>        Console.WriteLine(e);<br>        throw;<br>    &#125;<br>    catch (Exception e)<br>    &#123;<br>        Console.WriteLine(&quot;il2cpp.exe didn&#x27;t catch exception: &quot; + e.StackTrace);<br>        throw;<br>    &#125;<br><br>    return exitCode;<br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><p>jam 编译的il2cpp.exe断点上好像有一些BUG，我直接用rider的debug编译了il2cpp.exe然后copy到对应文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">WindowsEditor\Data\il2cpp\build\deploy\net471<br></code></pre></td></tr></table></figure><p>il2cpp.exe主要负责生成和编译代码，fastbuild只负责编译，所以可以修改编译部分的代码，例如在指令上加入一个开关，指定是否使用fastbuild</p><p>目前思路：</p><p>IL2CPP 编译cache</p><p>编译代码之前会生成一个编译列表sourceFilesToCompile,这个决定了哪些文件需要编译成 .obj以及使用哪些编译器以及链接器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">using (MiniProfiler.Section(&quot;FindFilesToCompile&quot;))<br>&#123;<br>    sourceFilesToCompile = _programBuildDescription.CppCompileInstructions.Concat(toolChainContext.ExtraCompileInstructions).ToArray();<br><br>    foreach (var sourceFile in sourceFilesToCompile)<br>    &#123;<br>        sourceFile.Defines = sourceFile.Defines.Concat(_cppToolChain.ToolChainDefines());<br>        sourceFile.IncludePaths = sourceFile.IncludePaths.Concat(_cppToolChain.ToolChainIncludePaths()).Concat(toolChainContext.ExtraIncludeDirectories);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后调用BuildAllCppFiles进行obj编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">using (MiniProfiler.Section(&quot;BuildAllCppFiles&quot;))<br>    objectFiles = BuildAllCppFiles(sourceFilesToCompile, buildStatistics);<br></code></pre></td></tr></table></figure><p>BuildAllCppFiles主要是先生成cached以及needsCompiled两个列表，对needsCompiled会开对应多的线程进行并行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">if (needsCompiled.Count &gt; 0)<br>&#123;<br>    var compiledObjectResults = ParallelFor.RunWithResult(needsCompiled.ToArray(), ProvideObjectFile).ToList();<br>&#125;<br></code></pre></td></tr></table></figure><p>加入fastbuild选项，可以利用sourceFilesToCompile这个列表，生成fbuild.bff文件，然后拉起对应平台的fastbuild即可实现IL2CPP的联合编译。</p>]]></content>
      
      
      <categories>
          
          <category> FASTBUILD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IL2CPP </tag>
            
            <tag> FASTBUILD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>snp Profiler</title>
      <link href="/2022/07/18/Unity/profiler/"/>
      <url>/2022/07/18/Unity/profiler/</url>
      
        <content type="html"><![CDATA[<p><img src="/../../images/2022-07-19-18-03-57.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> snp </tag>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>textmesh-pro 压缩通道</title>
      <link href="/2022/07/18/Unity/textmeshpro/"/>
      <url>/2022/07/18/Unity/textmeshpro/</url>
      
        <content type="html"><![CDATA[<h2 id="把Alpha-8改为4通道的RGBA"><a href="#把Alpha-8改为4通道的RGBA" class="headerlink" title="把Alpha 8改为4通道的RGBA"></a>把Alpha 8改为4通道的RGBA</h2><p><img src="/../../images/2022-07-21-17-44-41.png"></p><h2 id="修改shader根据uv采样不同的通道"><a href="#修改shader根据uv采样不同的通道" class="headerlink" title="修改shader根据uv采样不同的通道"></a>修改shader根据uv采样不同的通道</h2><p><img src="/../../images/2022-07-21-17-45-35.png"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li><p>优化图集算法，不能让中间线切割字符，使一个字符分布到多个通道中</p></li><li><p>修改采样的shader</p></li><li><p>稳定化debug</p></li><li><p>不如把图片直接改为2048x2048 alpha8</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> textmesh-pro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDVS shader variants</title>
      <link href="/2022/07/13/ARM/IDVS-shader-variants/"/>
      <url>/2022/07/13/ARM/IDVS-shader-variants/</url>
      
        <content type="html"><![CDATA[<h1 id="IDVS-shader-variants"><a href="#IDVS-shader-variants" class="headerlink" title="IDVS shader variants"></a>IDVS shader variants</h1><p>On Mali GPUs in the Bifrost and Valhall families, vertex shaders are executed using an optimized shading flow called Index-Driven Vertex Shading (IDVS).</p><p>In the IDVS pipeline, vertex shaders are compiled into two binaries:</p><ul><li>A position shader, which computes only position.</li><li>A varying shader, which computes the remaining non-position vertex attribute outputs.</li></ul><h2 id="Figure-2-1-IDVS-pipeline"><a href="#Figure-2-1-IDVS-pipeline" class="headerlink" title="Figure 2-1 IDVS pipeline"></a>Figure 2-1 IDVS pipeline</h2><p><img src="/../../images/2022-07-13-14-47-58.png"></p>]]></content>
      
      
      <categories>
          
          <category> mali gpu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mali </tag>
            
            <tag> IDVS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mali Bifrost Family Performance Counters</title>
      <link href="/2022/07/11/ARM/mali-bifrost-family-performance-counters/"/>
      <url>/2022/07/11/ARM/mali-bifrost-family-performance-counters/</url>
      
        <content type="html"><![CDATA[<h1 id="Mali-Bifrost-Family-Performance-Counters"><a href="#Mali-Bifrost-Family-Performance-Counters" class="headerlink" title="Mali Bifrost Family Performance Counters"></a>Mali Bifrost Family Performance Counters</h1><p>Analysis and optimization of graphics and compute content running on a GPU is an important task when trying to build a top quality system integration, or a compelling high performance application. For developers working with the public APIs, such as OpenGL ES and OpenCL, the GPU is a black box which is very difficult to analyze based solely on the API visible behaviors. Frame pipelining and asynchronous processing of submitted work effectively decouple the application’s visible performance from the API calls which define the workload being executed, making analysis of performance an activity based on expert knowledge and intuition rather than direct measurement.</p><p>Tools such as ARM DS-5 Streamline provide developers access to the GPU hardware performance counters, the principle means to determine the behavior inside the black box beneath the API and identify any problem areas which need optimization. This work guide assumes that DS-5 Streamline is the tool being used for performance analysis, and follows the DS-5 naming conventions for the counters.</p><h2 id="1-Performance-Counter-Infrastructure"><a href="#1-Performance-Counter-Infrastructure" class="headerlink" title="1 Performance Counter Infrastructure"></a>1 Performance Counter Infrastructure</h2><p>The Bifrost GPU family supports many performance counters which can all be captured simultaneously. Performance counters are provided for each functional block in the design:</p><p>Job Manager<br>Tiler<br>Shader core(s)<br>L2 cache(s)<br>See my earlier blog series for an introduction to the Bifrost GPU architecture - it introduces some of the fundamental concepts which are important to understand, and which place the more detailed information in this document in context.</p><p>The Mali GPU: An Abstract Machine, Part 1 - Frame Pipelining<br>The Mali GPU: An Abstract Machine, Part 2 - Tile-based Rendering<br>The Mali GPU: An Abstract Machine, Part 4 - The Bifrost Shader Core</p><h3 id="1-1-Supported-Counters"><a href="#1-1-Supported-Counters" class="headerlink" title="1.1 Supported Counters"></a>1.1 Supported Counters</h3><p>The GPUs in the Bifrost family implement a large number of performance counters natively in the hardware, and it is also generally useful to generate some derived counters by combining one or more of the raw hardware counters in useful and interesting ways. This document will describe all of the counters exported from DS-5 Streamline, and some of the useful derived counters which can be derived from them. DS-5 Streamline allows custom performance counter graphs to be created using equations, so all of these performance counters can be directly visualized in the GUI.</p><h3 id="1-2-Counter-Implementation-Caveats"><a href="#1-2-Counter-Implementation-Caveats" class="headerlink" title="1.2 Counter Implementation Caveats"></a>1.2 Counter Implementation Caveats</h3><p>The hardware counter implementation in the GPU is designed to be low cost, such that it has minimal impact on performance and power. Many of the counters are close approximations of the behavior described in this document in order to minimize the amount of additional hardware logic required to generate the counter signals, so some small deviations from what you may expect may be encountered.</p><span id="more"></span><h2 id="2-Job-Manager-Counters"><a href="#2-Job-Manager-Counters" class="headerlink" title="2 Job Manager Counters"></a>2 Job Manager Counters</h2><p>This section describes the counters implemented by the Mali Job Manager component.</p><h3 id="2-1-Top-Level-Activity"><a href="#2-1-Top-Level-Activity" class="headerlink" title="2.1 Top Level Activity"></a>2.1 Top Level Activity</h3><p>These counters provide information about the overall number of cycles that the GPU was processing a workload, or waiting for software to handle workload completion interrupts.</p><h4 id="2-1-1-JM-GPU-ACTIVE"><a href="#2-1-1-JM-GPU-ACTIVE" class="headerlink" title="2.1.1 JM.GPU_ACTIVE"></a>2.1.1 JM.GPU_ACTIVE</h4><p>Availability: All</p><p>This counter increments every cycle that the GPU either has any workload queued in a Job slot. Note that this counter will increment any cycle a workload is present even if the GPU is totally stalled waiting for external memory to return data; that is still counted as active time even though no forward progress was made.</p><h4 id="2-1-2-JM-GPU-UTILIZATION-Derived"><a href="#2-1-2-JM-GPU-UTILIZATION-Derived" class="headerlink" title="2.1.2 JM.GPU_UTILIZATION (Derived)"></a>2.1.2 JM.GPU_UTILIZATION (Derived)</h4><p>Availability: All</p><p>If the GPU operating frequency is known then overall GPU utilization can be calculated as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">JM.GPU_UTILIZATION = JM.GPU_ACTIVE / GPU_MHZ<br></code></pre></td></tr></table></figure><p>Well pipelined applications which are not running at vsync and keeping the GPU busy should achieve a utilization of around 98%. Lower utilization than this typically indicates one of the following scenarios:</p><p>  Content running at vsync.<br>  In this scenario the GPU goes idle as it has no need to run until next vsync signal.<br>  Content which is bottlenecked by the CPU.<br>  In this scenario the application or driver is causing high CPU load, and cannot build new workloads for the GPU quickly enough to keep it busy.<br>  Content which is oscillating between CPU and the GPU activity.<br>  In this scenario the application is using APIs which break the frame-level pipeline needed to keep the GPU busy. The most common causes are calls to glReadPixels() or glFinish(), as these explicitly drain the pipeline, but other API calls can cause stalls if used in a blocking manner before their result is ready. These include calls such as glClientWaitSync(), glWaitSync(), or glGetQueryObjectuiv().<br>Collecting GPU activity and CPU activity as part of the same DS-5 Streamline data capture can help disambiguate between the cases above. This type of analysis is explored in more detail in my blog on Mali performance.</p><p>It is important to note that most modern devices support Dynamic Voltage and Frequency Scaling (DVFS) to optimize energy usage, which means that the GPU frequency is often not constant while running a piece of content. It is recommended that platform DVFS is disabled, locking the CPU, GPU and memory bus at a fixed frequency, if possible as it makes performance analysis much easier, and results more reproducible. The method for doing this is device specific, and many not be possible at all on production devices; please refer to your platform’s documentation for details.</p><h4 id="2-1-3-JM-JS0-ACTIVE"><a href="#2-1-3-JM-JS0-ACTIVE" class="headerlink" title="2.1.3 JM.JS0_ACTIVE"></a>2.1.3 JM.JS0_ACTIVE</h4><p>Availability: All</p><p>This counter increments every cycle that the GPU has a Job chain running in Job slot 0. This Job slot is used solely for the processing of fragment Jobs, so this corresponds directly to fragment shading workloads.</p><p>For most graphics content there are orders of magnitude more fragments than vertices, so this Job slot will usually be the dominant Job slot which has the highest processing load. In content which is not hitting vsync and the GPU is the performance bottleneck, it is normal for JS0_ACTIVE to be approximately equal to GPU_ACTIVE. In this scenario vertex processing can run in parallel to the fragment processing, allowing fragment processing to run all of the time.</p><h4 id="2-1-4-JM-JS0-UTILIZATION-Derived"><a href="#2-1-4-JM-JS0-UTILIZATION-Derived" class="headerlink" title="2.1.4 JM.JS0_UTILIZATION (Derived)"></a>2.1.4 JM.JS0_UTILIZATION (Derived)</h4><p>Availability: All</p><p>The percentage JS0 utilization can be calculated as:</p><p>JM.JS0_UTILIZATION &#x3D; JM.JS0_ACTIVE &#x2F; JM.GPU_ACTIVE<br>In content which is not hitting vsync and the GPU is the performance bottleneck it is normal for this utilization metric to be close to 1.0 (100%). Fragment processing is normally the dominant workload, and a utilization of close to 100% shows that vertex processing is running in parallel to the fragment processing, allowing maximum utilization of the functional units in the hardware.</p><h4 id="2-1-5-JM-JS1-ACTIVE"><a href="#2-1-5-JM-JS1-ACTIVE" class="headerlink" title="2.1.5 JM.JS1_ACTIVE"></a>2.1.5 JM.JS1_ACTIVE</h4><p>Availability: All</p><p>This counter increments every cycle the GPU has a Job chain running in Job slot 1. This Job slot can be used for compute shaders, vertex shaders, and tiling workloads. This counter cannot disambiguate between these workloads.</p><h4 id="2-1-6-JM-JS1-UTILIZATION-Derived"><a href="#2-1-6-JM-JS1-UTILIZATION-Derived" class="headerlink" title="2.1.6 JM.JS1_UTILIZATION (Derived)"></a>2.1.6 JM.JS1_UTILIZATION (Derived)</h4><p>Availability: All</p><p>The percentage JS1 utilization can be calculated as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">JM.JS1_UTILIZATION = JM.JS1_ACTIVE / JM.GPU_ACTIVE<br></code></pre></td></tr></table></figure><h4 id="2-1-7-JM-IRQ-ACTIVE"><a href="#2-1-7-JM-IRQ-ACTIVE" class="headerlink" title="2.1.7 JM.IRQ_ACTIVE"></a>2.1.7 JM.IRQ_ACTIVE</h4><p>Availability: All</p><p>This counter increments every cycle the GPU has an interrupt pending, awaiting handling by the driver running on the CPU. Note that this does not necessarily indicate lost performance because the GPU can still process Job chains from other Job slots, as well as process the next work item in the interrupt generating Job slot, while an interrupt is pending.</p><p>If a high JM.IRQ_ACTIVE cycle count is observed alongside other counters which make it look like the GPU is starving for work, such as a low SC.COMPUTE_ACTIVE and SC.FRAG_ACTIVE, this may indicate a system performance issue. Possible causes include:</p><p>A system where the CPU is fully utilized, causing a delay in scheduling IRQ handlers.<br>A system where a device driver, which may not be the Mali device driver, has IRQs masked for a long period of time, stopping the CPU receiving new interrupt notifications.<br>Processing a very high number of small framebuffers or small compute workloads, resulting in a high frequency of job completion interrupts to the CPU.</p><h3 id="2-2-Task-Dispatch"><a href="#2-2-Task-Dispatch" class="headerlink" title="2.2 Task Dispatch"></a>2.2 Task Dispatch</h3><p>This section looks at the counters related to how the Job Manager issues work to shader cores.</p><h4 id="2-2-1-JM-JS0-TASKS"><a href="#2-2-1-JM-JS0-TASKS" class="headerlink" title="2.2.1 JM.JS0_TASKS"></a>2.2.1 JM.JS0_TASKS</h4><p>Availability: All</p><p>This counter increments every time the Job Manager issues a task to a shader core. For JS0 these tasks correspond to a single 32x32 pixel screen region, although not all of these pixels may be rendered due to viewport or scissor settings.</p><h4 id="2-2-2-JM-PIXEL-COUNT-Derived"><a href="#2-2-2-JM-PIXEL-COUNT-Derived" class="headerlink" title="2.2.2 JM.PIXEL_COUNT (Derived)"></a>2.2.2 JM.PIXEL_COUNT (Derived)</h4><p>Availability: All</p><p>A approximation of the total scene pixel count can be computed as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">JM.PIXEL_COUNT = JM.JS0_TASKS * 32 * 32<br></code></pre></td></tr></table></figure><h2 id="3-Shader-Core-Counters"><a href="#3-Shader-Core-Counters" class="headerlink" title="3 Shader Core Counters"></a>3 Shader Core Counters</h2><p>This section describes the counters implemented by the Mali Shader Core. For the purposes of clarity this section talks about either fragment workloads or compute workloads. Vertex, Geometry, and Tessellation workloads are treated as a one dimensional compute problem by the shader core, so are counted as a compute workload from the point of view of the counters in this section.</p><p>The GPU hardware records separate counters per shader core in the system. DS-5 Streamline shows the average of all of the shader core counters.</p><h3 id="3-1-Shader-Core-Activity"><a href="#3-1-Shader-Core-Activity" class="headerlink" title="3.1 Shader Core Activity"></a>3.1 Shader Core Activity</h3><p>These counters show the total activity level of the shader core.</p><h4 id="3-1-1-SC-COMPUTE-ACTIVE"><a href="#3-1-1-SC-COMPUTE-ACTIVE" class="headerlink" title="3.1.1 SC.COMPUTE_ACTIVE"></a>3.1.1 SC.COMPUTE_ACTIVE</h4><p>Availability: All</p><p>This counter increments every cycle at least one compute task is active anywhere inside the shader core, including the fixed-function compute frontend, or the programmable execution core.</p><h4 id="3-1-2-SC-FRAG-ACTIVE"><a href="#3-1-2-SC-FRAG-ACTIVE" class="headerlink" title="3.1.2 SC.FRAG_ACTIVE"></a>3.1.2 SC.FRAG_ACTIVE</h4><p>Availability: All</p><p>This counter increments every cycle at least one fragment task is active anywhere inside the shader core, including the fixed-function fragment frontend, the programmable execution core, or the fixed-function fragment backend.</p><h4 id="3-1-3-SC-EXEC-CORE-ACTIVE"><a href="#3-1-3-SC-EXEC-CORE-ACTIVE" class="headerlink" title="3.1.3 SC.EXEC_CORE_ACTIVE"></a>3.1.3 SC.EXEC_CORE_ACTIVE</h4><p>Availability: All</p><p>This counter increments every cycle at least one quad is active inside the programmable execution core. Note that this counter does not give any idea of total utilization of the shader core resources, but simply gives an indication that something was running.</p><h4 id="3-1-4-SC-EXEC-CORE-UTILIZATION-Derived"><a href="#3-1-4-SC-EXEC-CORE-UTILIZATION-Derived" class="headerlink" title="3.1.4 SC.EXEC_CORE_UTILIZATION (Derived)"></a>3.1.4 SC.EXEC_CORE_UTILIZATION (Derived)</h4><p>Availability: All</p><p>An approximation of the overall utilization of the execution core can be determined using the following equation:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.EXEC_CORE_UTILIZATION = SC.EXEC_CORE_ACTIVE / JM.GPU_ACTIVE<br></code></pre></td></tr></table></figure><p>A low utilization of the execution core indicates possible lost performance, as there are spare shader core cycles which could be used if they could be accessed. There are multiple possible root causes of low utilization. The most common cause is content with a significant number tiles which do not require any fragment shader program to be executed. This may occur because:</p><p>Screen regions are simply a clear color and contain no drawn geometry.<br>Screen regions contain significant amount of geometry which only does a depth&#x2F;stencil update and this update can be entirely resolved at the point of early-zs, prior to fragment shading.<br>Other causes include:</p><p>Screen regions containing a high level of front-to-back geometry, resulting in one layer being drawn and multiple redundant layers being killed by early-zs. If the cost of loading the redundant geometry exceeds the cost of shading the visible layer then some idle time will be observed.<br>Screen regions containing a high level of opaque back-to-front geometry, resulting in one layer being drawn and multiple redundant layers being killed by Forward Pixel Kill (FPK); see Killing Pixels - A New Optimization for Shading on ARM Mali GPUs.</p><h3 id="3-2-Compute-Frontend-Events"><a href="#3-2-Compute-Frontend-Events" class="headerlink" title="3.2 Compute Frontend Events"></a>3.2 Compute Frontend Events</h3><p>These counters show the task and thread issue behavior of the shader core’s fixed function compute frontend which issues work into the programmable core.</p><h4 id="3-2-1-SC-COMPUTE-QUADS"><a href="#3-2-1-SC-COMPUTE-QUADS" class="headerlink" title="3.2.1 SC.COMPUTE_QUADS"></a>3.2.1 SC.COMPUTE_QUADS</h4><p>Availability: All</p><p>This counter increments for every compute quad spawned by the shader core. One compute quad is spawned for every four work items (compute shaders), vertices (vertex and tessellation evaluation shaders), primitives (geometry shaders), or control points (tessellation control shaders). To ensure full utilization of the four thread capacity of a quad any compute workgroups should be a multiple of four in size.</p><h4 id="3-2-2-SC-COMPUTE-QUAD-CYCLES-Derived"><a href="#3-2-2-SC-COMPUTE-QUAD-CYCLES-Derived" class="headerlink" title="3.2.2 SC.COMPUTE_QUAD_CYCLES (Derived)"></a>3.2.2 SC.COMPUTE_QUAD_CYCLES (Derived)</h4><p>Availability: All</p><p>This counter calculates an average compute cycles per compute quad, giving some measure of the per-quad processing load.</p><p>SC.COMPUTE_QUAD_CYCLES &#x3D; SC.COMPUTE_ACTIVE &#x2F; SC.COMPUTE_QUADS<br>Note that in most cases the dominant cost here is the programmable code running on the execution core, and so there will be some cross-talk caused by compute and fragment workloads running concurrently on the same hardware. This counter is therefore indicative of cost, but does not reflect precise costing.</p><h3 id="3-3-Fragment-Frontend-Events"><a href="#3-3-Fragment-Frontend-Events" class="headerlink" title="3.3 Fragment Frontend Events"></a>3.3 Fragment Frontend Events</h3><p>These counters show the task and thread issue behavior of the shader core’s fixed-function fragment frontend. This unit is significantly more complicated than the compute frontend, so there are a large number of counters available.</p><h4 id="3-3-1-SC-FRAG-PRIMITIVES-RAST"><a href="#3-3-1-SC-FRAG-PRIMITIVES-RAST" class="headerlink" title="3.3.1 SC.FRAG_PRIMITIVES_RAST"></a>3.3.1 SC.FRAG_PRIMITIVES_RAST</h4><p>Availability: All</p><p>This counter increments for every primitive entering the frontend fixed-function rasterization stage; these primitives are guaranteed to be inside the current tile being rendered.</p><p>Note that this counter will increment once per primitive per tile in which that primitive is located. If you wish to know the total number of primitives in the scene without factoring in tiling effects see the Tiler block’s primitive counters.</p><h4 id="3-3-2-SC-FRAG-QUADS-RAST"><a href="#3-3-2-SC-FRAG-QUADS-RAST" class="headerlink" title="3.3.2 SC.FRAG_QUADS_RAST"></a>3.3.2 SC.FRAG_QUADS_RAST</h4><p>Availability: All</p><p>This counter increments for every 2x2 pixel quad which is rasterized by the rasterization unit. The quads generated have at least some coverage based on the current sample pattern, but may subsequently be killed by early depth and stencil testing and as such never issued to the programmable core.</p><h4 id="3-3-3-SC-FRAG-QUADS-EZS-TEST"><a href="#3-3-3-SC-FRAG-QUADS-EZS-TEST" class="headerlink" title="3.3.3 SC.FRAG_QUADS_EZS_TEST"></a>3.3.3 SC.FRAG_QUADS_EZS_TEST</h4><p>Availability: All</p><p>This counter increments for every 2x2 pixel quad which is subjected to ZS testing. We want as many quads as possible to be subject to early ZS testing as it is significantly more efficient than late ZS testing, which will only kill threads after they have been fragment shaded.</p><h4 id="3-3-4-SC-FRAG-QUADS-EZS-UPDATE"><a href="#3-3-4-SC-FRAG-QUADS-EZS-UPDATE" class="headerlink" title="3.3.4 SC.FRAG_QUADS_EZS_UPDATE"></a>3.3.4 SC.FRAG_QUADS_EZS_UPDATE</h4><p>Availability: All</p><p>This counter increments for every 2x2 pixel quad which has completed an early ZS update operation. Quads which have a depth value which depends on shader execution, or which have indeterminate coverage due to use of discard statements in the shader or the use of alpha-to-coverage, may be early ZS tested but cannot do an early ZS update.</p><h4 id="3-3-5-SC-FRAG-QUADS-EZS-KILLED"><a href="#3-3-5-SC-FRAG-QUADS-EZS-KILLED" class="headerlink" title="3.3.5 SC.FRAG_QUADS_EZS_KILLED"></a>3.3.5 SC.FRAG_QUADS_EZS_KILLED</h4><p>Availability: All</p><p>This counter increments for every 2x2 pixel quad which is completely killed by early ZS testing. These killed quads will not generate any further processing in the shader core.</p><h4 id="3-3-6-SC-FRAG-QUADS-KILLED-BY-OVERDRAW-Derived"><a href="#3-3-6-SC-FRAG-QUADS-KILLED-BY-OVERDRAW-Derived" class="headerlink" title="3.3.6 SC.FRAG_QUADS_KILLED_BY_OVERDRAW (Derived)"></a>3.3.6 SC.FRAG_QUADS_KILLED_BY_OVERDRAW (Derived)</h4><p>Availability: All</p><p>This derived counter increments for every 2x2 pixel quad which survives early-zs testing but that is overdrawn by an opaque quad before spawning as fragment shading threads in the programmable core.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.FRAG_QUADS_KILLED_BY_OVERDRAW = SC.FRAG_QUADS_RAST - SC.FRAG_QUADS_EZS_KILL - SC.FRAG_QUADS<br></code></pre></td></tr></table></figure><p>If a significant percentage of the total rasterized quads are overdrawn, this is indicative that the application is rendering in a back-to-front order which means that the early-zs test is unable to kill the redundant workload. Schemes such as Forward Pixel Kill can minimize the cost, but it is recommended that the application renders opaque geometry front-to-back as early-zs testing provides stronger guarantees of efficiency.</p><h4 id="3-3-7-SC-FRAG-QUADS-OPAQUE"><a href="#3-3-7-SC-FRAG-QUADS-OPAQUE" class="headerlink" title="3.3.7 SC.FRAG_QUADS_OPAQUE"></a>3.3.7 SC.FRAG_QUADS_OPAQUE</h4><p>Availability: All</p><p>This counter increments for every 2x2 pixel quad which is architecturally opaque – i.e. not using blending, shader discard, or alpha-to-coverage – that survives early-zs testing. Opaque fragments are normally more efficient for the GPU to handle, as only the top opaque layer needs to be drawn, so we recommend ensuring opacity of draw calls whenever possible.</p><h4 id="3-3-8-SC-FRAG-QUADS-TRANSPARENT-Derived"><a href="#3-3-8-SC-FRAG-QUADS-TRANSPARENT-Derived" class="headerlink" title="3.3.8 SC.FRAG_QUADS_TRANSPARENT (Derived)"></a>3.3.8 SC.FRAG_QUADS_TRANSPARENT (Derived)</h4><p>Availability: All</p><p>This counter increments for every 2x2 pixel quad which is architecturally transparent – i.e. using blending, shader discard, or alpha-to-coverage – that survives early-zs testing. Note that transparent in this context implies either alpha transparency, or a shader-dependent coverage mask.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.FRAG_QUADS_TRANSPARENT = SC.FRAG_QUADS_RAST - SC.FRAG_QUADS_EZS_KILL - SC.FRAG_QUADS_OPAQUE<br></code></pre></td></tr></table></figure><h4 id="3-3-9-SC-FRAG-QUAD-BUFFER-NOT-EMPTY"><a href="#3-3-9-SC-FRAG-QUAD-BUFFER-NOT-EMPTY" class="headerlink" title="3.3.9 SC.FRAG_QUAD_BUFFER_NOT_EMPTY"></a>3.3.9 SC.FRAG_QUAD_BUFFER_NOT_EMPTY</h4><p>Availability: All</p><p>This counter increments every cycle the fragment unit is active, and the pre-pipe buffer contains at least one 2x2 pixel quad waiting to be executed in the execution core. If this buffer drains the frontend will be unable to spawn a new quad if an execution core quad slot becomes free.</p><p>If this counter is low relative to SC.FRAG_ACTIVE then the shader core may be running out of rasterized quads to turn in to fragment quads, which can in turn cause low utilization of the functional units in the execution core if the total number of quads active in the execution core drops too far. Possible causes for this include:</p><p>Tiles which contain no geometry.<br>Tiles which contain a lot of geometry which can be dropped at early-zs, either because it is redundant and it is killed, or because it is a simple depth and stencil update which can be resolved without fragment shader execution.<br>Tiles which contain triangles from a large number of different drawing operations, causing state loading to become a bottleneck. It is recommended that industry best practice, such as draw batching, is used to minimize the number of unique drawing operations present in a frame.</p><h4 id="3-3-10-SC-FRAG-QUADS"><a href="#3-3-10-SC-FRAG-QUADS" class="headerlink" title="3.3.10 SC.FRAG_QUADS"></a>3.3.10 SC.FRAG_QUADS</h4><p>Availability: All</p><p>This counter increments for every fragment quad created by the GPU.</p><p>In most situations a single quad contains threads for four fragments spanning a 2×2 pixel region of the screen. If an application is rendering to a multi-sampled render target with GL_SAMPLE_SHADING enabled then shader evaluation is per-sample rather than per pixel and one fragment thread will be generated for example sample point covered. For example, an 8xMSAA render target using sample rate shading will generate two fragment quads per screen pixel covered by the primitive.</p><h4 id="3-3-11-SC-FRAG-PARTIAL-QUADS"><a href="#3-3-11-SC-FRAG-PARTIAL-QUADS" class="headerlink" title="3.3.11 SC.FRAG_PARTIAL_QUADS"></a>3.3.11 SC.FRAG_PARTIAL_QUADS</h4><p>Availability: All</p><p>This counter increments for every fragment quad which contains at least one thread slot which has no sample coverage, and is therefore indicative of lost performance. Partial coverage in a 2×2 fragment quad will occur if its sample points span the edge of a triangle, or if one or more sample points fail an early-zs test.</p><h4 id="3-3-12-SC-FRAG-PARTIAL-QUAD-PERCENTAGE-Derived"><a href="#3-3-12-SC-FRAG-PARTIAL-QUAD-PERCENTAGE-Derived" class="headerlink" title="3.3.12 SC.FRAG_PARTIAL_QUAD_PERCENTAGE (Derived)"></a>3.3.12 SC.FRAG_PARTIAL_QUAD_PERCENTAGE (Derived)</h4><p>Availability: All</p><p>This counter calculates an percentage of spawned quads that have partial coverage.</p><p>SC.FRAG_PARTIAL_QUAD_PERCENTAGE &#x3D; SC.FRAG_PARTIAL_QUADS &#x2F; SC.FRAG_QUADS<br>A high percentage of partial quads indicates possible problems with meshes containing high numbers of small triangles; the ratio of the total edge length of a primitive to the screen area of a primitive increases as primitives shrink, so quads which span primitive edges become more common.</p><p>Partial coverage issues can be reduced by using object meshes which contain larger triangles. One common optimization technique which helps reduce the frequency of microtriangles is the use of dynamic model level of detail selection. In these schemes, each object mesh is generated at multiple detail levels during content generation, and an appropriate mesh is chosen per draw call based on the distance between the object and the camera. The further the object is from the camera, the lower the selected mesh complexity needs to be.</p><h4 id="3-3-13-SC-FRAG-QUAD-CYCLES-Derived"><a href="#3-3-13-SC-FRAG-QUAD-CYCLES-Derived" class="headerlink" title="3.3.13 SC.FRAG_QUAD_CYCLES (Derived)"></a>3.3.13 SC.FRAG_QUAD_CYCLES (Derived)</h4><p>Availability: All</p><p>This counter calculates an average fragment cycles per fragment quad, giving some measure of the per-quad processing cost.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.FRAG_QUAD_CYCLES = SC.FRAG_ACTIVE / SC.FRAG_QUADS<br></code></pre></td></tr></table></figure><p>Note that in most cases the dominant cost here is the programmable code running on the execution core, so there will be some cross-talk caused by compute and fragment workloads running concurrently on the same hardware. This counter is therefore indicative of cost, but does not reflect precise costing.</p><h3 id="3-4-Fragment-Backend-Events"><a href="#3-4-Fragment-Backend-Events" class="headerlink" title="3.4 Fragment Backend Events"></a>3.4 Fragment Backend Events</h3><p>These counters record the fragment backend behavior.</p><h4 id="3-4-1-SC-FRAG-THREADS-LZS-TEST"><a href="#3-4-1-SC-FRAG-THREADS-LZS-TEST" class="headerlink" title="3.4.1 SC.FRAG_THREADS_LZS_TEST"></a>3.4.1 SC.FRAG_THREADS_LZS_TEST</h4><p>Availability: All</p><p>This counter increments for every thread triggering late depth and stencil (ZS) testing.</p><h4 id="3-4-2-SC-FRAG-THREADS-LZS-KILLED"><a href="#3-4-2-SC-FRAG-THREADS-LZS-KILLED" class="headerlink" title="3.4.2 SC.FRAG_THREADS_LZS_KILLED"></a>3.4.2 SC.FRAG_THREADS_LZS_KILLED</h4><p>Availability: All</p><p>This counter increments for every thread killed by late ZS testing. These threads are killed after their fragment program has executed, so a significant number of threads being killed at late ZS implies a significant amount of lost performance and&#x2F;or wasted energy performing rendering which has no useful visual output.</p><p>The main causes of threads using late-zs are:</p><p>Fragment shader programs using explicit discard statements<br>Fragment shader programs using implicit discard (alpha-to-coverage).<br>Fragment shader programs with side-effects on shared resources, such as shader storage buffer objects, images, or atomics.</p><h4 id="3-4-3-SC-FRAG-NUM-TILES"><a href="#3-4-3-SC-FRAG-NUM-TILES" class="headerlink" title="3.4.3 SC.FRAG_NUM_TILES"></a>3.4.3 SC.FRAG_NUM_TILES</h4><p>Availability: All</p><p>This counter increments for every tile rendered. The size of a physical tile can vary from 16×16 pixels (largest) downwards. The size of physical tile actually used depends on the number of bytes of memory needed to store the working set for each pixel; the largest tile size allows up to 128-bits per pixel of color storage – enough for a single 32-bit per pixel render target using 4xMSAA, or  4x32-bit per pixel surfaces using multiple-render targets (MRT). Requiring more than that will result in proportionally smaller tile sizes.</p><p>The total storage required per pixel depends on the use of:</p><p>Multi-sample anti-aliasing (MSAA)<br>Multiple render targets (MRT)<br>The size of the attached per-pixel color data format(s)<br>The use of pixel local storage (PLS); see Pixel Local Storage.<br>In general the larger tile sizes are more efficient than smaller tile sizes, especially for content with high geometry complexity. This counter cannot be used to directly determine the physical tile sizes used.</p><h4 id="3-4-4-SC-FRAG-TILES-CRC-CULLED"><a href="#3-4-4-SC-FRAG-TILES-CRC-CULLED" class="headerlink" title="3.4.4 SC.FRAG_TILES_CRC_CULLED"></a>3.4.4 SC.FRAG_TILES_CRC_CULLED</h4><p>Availability: All</p><p>This counter increments for every physical rendered tile which has its writeback cancelled due to a matching transaction elimination CRC hash. If a high percentage of the tile writes are being eliminated this implies that you are re-rendering the entire screen when not much has changed, so consider using scissor rectangles to minimize the amount of area which is redrawn. This isn’t always easy, especially for window surfaces which are pipelines using multiple buffers, but EGL extensions such as these may be supported on your platform which can help manage the partial frame updates:</p><p><a href="https://www.khronos.org/registry/egl/extensions/KHR/EGL_KHR_partial_update.txt">https://www.khronos.org/registry/egl/extensions/KHR/EGL_KHR_partial_update.txt</a><br><a href="https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_swap_buffers_with_damage.txt">https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_swap_buffers_with_damage.txt</a></p><h3 id="3-5-Execution-Engine-Events"><a href="#3-5-Execution-Engine-Events" class="headerlink" title="3.5 Execution Engine Events"></a>3.5 Execution Engine Events</h3><p>These counters look at the behavior of the arithmetic execution engine.</p><h4 id="3-5-1-SC-EE-INSTRS"><a href="#3-5-1-SC-EE-INSTRS" class="headerlink" title="3.5.1 SC.EE_INSTRS"></a>3.5.1 SC.EE_INSTRS</h4><p>Availability: All</p><p>This counter increments for every arithmetic instruction architecturally executed for a quad in an execution engine. This counter is normalized based on the number of execution engines implemented in the design, so gives the per engine performance, rather than the total executed application workload.</p><h4 id="3-5-2-SC-EE-UTILIZATION-Derived"><a href="#3-5-2-SC-EE-UTILIZATION-Derived" class="headerlink" title="3.5.2. SC.EE_UTILIZATION (Derived)"></a>3.5.2. SC.EE_UTILIZATION (Derived)</h4><p>Availability: All</p><p>The peak performance is one arithmetic instruction per engine per cycle, so the effective utilization of the arithmetic hardware can be computed as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.EE_UTILIZATION = SC.EE_INSTRS / SC.EXEC_CORE_ACTIVE<br></code></pre></td></tr></table></figure><h4 id="3-5-3-SC-EE-INSTRS-DIVERGED"><a href="#3-5-3-SC-EE-INSTRS-DIVERGED" class="headerlink" title="3.5.3 SC.EE_INSTRS_DIVERGED"></a>3.5.3 SC.EE_INSTRS_DIVERGED</h4><p>Availability: All</p><p>This counter increments for every arithmetic instruction architecturally executed where there is control flow divergence in the quad resulting in at least one lane of computation being masked out. Control flow divergence erodes arithmetic execution efficiency because it implies some arithmetic lanes are idle, so should be minimized when designing shader effects.</p><h3 id="3-6-Load-x2F-Store-Cache-Events"><a href="#3-6-Load-x2F-Store-Cache-Events" class="headerlink" title="3.6 Load&#x2F;Store Cache Events"></a>3.6 Load&#x2F;Store Cache Events</h3><p>These counters look at the behavior of the load&#x2F;store pipe.</p><h4 id="3-6-1-SC-LSC-READS-FULL"><a href="#3-6-1-SC-LSC-READS-FULL" class="headerlink" title="3.6.1 SC.LSC_READS_FULL"></a>3.6.1 SC.LSC_READS_FULL</h4><p>Availability: All</p><p>This counter increments for every LS cache access executed which returns 128-bits of data.</p><h4 id="3-6-2-SC-LSC-READS-SHORT"><a href="#3-6-2-SC-LSC-READS-SHORT" class="headerlink" title="3.6.2 SC.LSC_READS_SHORT"></a>3.6.2 SC.LSC_READS_SHORT</h4><p>Availability: All</p><p>This counter increments for every LS cache access executed which returns less than 128-bits of data.</p><p>Full width data loads make best use of the cache, so where possible efficiency can be improved by merging short loads together.</p><p>Maximize data locality in attributes, varyings, and uniform buffers within a thread, for example packing data into adjacent vector elements and structure fields.<br>Minimize the amount of unused data in vector data types, uniform buffer control structures, and interleaved vertex attribute buffers.<br>Write compute shaders so adjacent threads sharing a quad access adjacent addresses in memory, allowing multiple loads to return data from the same cache line.</p><h4 id="3-6-3-SC-LSC-WRITES-FULL"><a href="#3-6-3-SC-LSC-WRITES-FULL" class="headerlink" title="3.6.3 SC.LSC_WRITES_FULL"></a>3.6.3 SC.LSC_WRITES_FULL</h4><p>Availability: All</p><p>This counter increments for every LS cache access executed which writes 128-bits of data.</p><h4 id="3-6-4-SC-LSC-WRITES-SHORT"><a href="#3-6-4-SC-LSC-WRITES-SHORT" class="headerlink" title="3.6.4 SC.LSC_WRITES_SHORT"></a>3.6.4 SC.LSC_WRITES_SHORT</h4><p>Availability: All</p><p>This counter increments for every LS cache access executed which writes less than 128-bits of data.</p><p>Full width data writes make best use of the cache, so where possible efficiency can be improved by merging short writes together. See LS_READ_SHORT section for advice on how this can be achieved.</p><h4 id="3-6-5-SC-LSC-ATOMICS"><a href="#3-6-5-SC-LSC-ATOMICS" class="headerlink" title="3.6.5 SC.LSC_ATOMICS"></a>3.6.5 SC.LSC_ATOMICS</h4><p>Availability: All</p><p>This counter increments for atomic operation issued to the LS cache.</p><h4 id="3-6-6-SC-LSC-ISSUES-Derived"><a href="#3-6-6-SC-LSC-ISSUES-Derived" class="headerlink" title="3.6.6 SC.LSC_ISSUES (Derived)"></a>3.6.6 SC.LSC_ISSUES (Derived)</h4><p>Availability: All</p><p>This counter counts the total number of load&#x2F;store cache access operations issued. Each operation is executed with single cycle throughput, but latency of response depends on cache hit rate and external memory system performance.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.LSC_ISSUES = SC.LSC_READS_FULL + SC.LSC_READS_SHORT + <br>                SC.LSC_WRITES_FULL + SC.LSC_WRITES_SHORT +<br>                SC.LSC_ATOMICS<br></code></pre></td></tr></table></figure><h4 id="3-6-7-SC-LSC-UTILIZATION-Derived"><a href="#3-6-7-SC-LSC-UTILIZATION-Derived" class="headerlink" title="3.6.7 SC.LSC_UTILIZATION (Derived)"></a>3.6.7 SC.LSC_UTILIZATION (Derived)</h4><p>Availability: All</p><p>The utilization of the load&#x2F;store cache can be determined as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.LSC_UTILIZATION = SC.LSC_ISSUES / SC.EXEC_CORE_ACTIVE<br></code></pre></td></tr></table></figure><h4 id="3-6-8-SC-LSC-READ-BEATS"><a href="#3-6-8-SC-LSC-READ-BEATS" class="headerlink" title="3.6.8 SC.LSC_READ_BEATS"></a>3.6.8 SC.LSC_READ_BEATS</h4><p>Availability: All</p><p>This counter increments for every 16 bytes of data fetched from the L2 memory system.</p><h4 id="3-6-9-SC-LSC-L2-BYTES-PER-ISSUE-Derived"><a href="#3-6-9-SC-LSC-L2-BYTES-PER-ISSUE-Derived" class="headerlink" title="3.6.9 SC.LSC_L2_BYTES_PER_ISSUE (Derived)"></a>3.6.9 SC.LSC_L2_BYTES_PER_ISSUE (Derived)</h4><p>Availability: All</p><p>The average number of bytes read from the L2 cache per load&#x2F;store L1 cache access can be given as.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.LSC_L2_BYTES_PER_ISSUE = (SC.LSC_READ_BEATS * 16) / SC.LSC_ISSUES<br></code></pre></td></tr></table></figure><p>This gives some idea of level one cache efficiency, although does require some knowledge of how the application is using non-texture data to interpret. For example some use cases expect to have good cache hit rates and reuse the same data many times from different threads, whereas other use cases are data streaming use cases are use each data item exactly once.</p><h4 id="3-6-10-SC-LSC-READ-BEATS-EXTERNAL"><a href="#3-6-10-SC-LSC-READ-BEATS-EXTERNAL" class="headerlink" title="3.6.10 SC.LSC_READ_BEATS_EXTERNAL"></a>3.6.10 SC.LSC_READ_BEATS_EXTERNAL</h4><p>Availability: All</p><p>This counter increments for every 16 bytes of data fetched from the L2 memory system which missed in the L2 cache and required a fetch from external memory.</p><h4 id="3-6-11-SC-LSC-EXTERNAL-BYTES-PER-ISSUE-Derived"><a href="#3-6-11-SC-LSC-EXTERNAL-BYTES-PER-ISSUE-Derived" class="headerlink" title="3.6.11 SC.LSC_EXTERNAL_BYTES_PER_ISSUE (Derived)"></a>3.6.11 SC.LSC_EXTERNAL_BYTES_PER_ISSUE (Derived)</h4><p>Availability: All</p><p>The average number of bytes read from the external memory interface per load&#x2F;store L1 cache access can be given as.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.LSC_EXTERNAL_BYTES_PER_ISSUE = (SC.LSC_READ_BEATS_EXTERNAL * 16) / SC.<br></code></pre></td></tr></table></figure><p>LSC_ISSUES<br>This gives some idea of level two cache efficiency, although does require some knowledge of how the application is using non-texture data to interpret. For example some use cases expect to have good cache hit rates and reuse the same data many times from different threads, whereas other use cases are data streaming use cases are use each data item exactly once.</p><h4 id="3-6-12-SC-LSC-WRITE-BEATS"><a href="#3-6-12-SC-LSC-WRITE-BEATS" class="headerlink" title="3.6.12 SC.LSC_WRITE_BEATS"></a>3.6.12 SC.LSC_WRITE_BEATS</h4><p>Availability: All</p><p>This counter increments for every 16 bytes of data written to the L2 memory system.</p><h3 id="3-7-Texture-Pipe-Events"><a href="#3-7-Texture-Pipe-Events" class="headerlink" title="3.7 Texture Pipe Events"></a>3.7 Texture Pipe Events</h3><p>This counter set looks at the texture pipe behavior.</p><p>Note: The texture pipe event counters increment per thread (fragment), not per quad.</p><h4 id="3-7-1-SC-TEX-INSTRS"><a href="#3-7-1-SC-TEX-INSTRS" class="headerlink" title="3.7.1 SC.TEX_INSTRS"></a>3.7.1 SC.TEX_INSTRS</h4><p>Availability: All</p><p>This counter increments for every architecturally executed texture instruction.</p><h4 id="3-7-2-SC-TEX-ISSUES"><a href="#3-7-2-SC-TEX-ISSUES" class="headerlink" title="3.7.2 SC.TEX_ISSUES"></a>3.7.2 SC.TEX_ISSUES</h4><p>Availability: All</p><p>This counter increments for every texture issue cycle used. Some instructions take more than one cycle due to multi-cycle data access and filtering operations:</p><p>2D bilinear filtering takes one cycle.<br>2D trilinear filtering takes two cycles.<br>3D bilinear filtering takes two cycles.<br>3D trilinear filtering takes four cycles.<br>Sampling from multi-plane YUV may take multiple cycles on some implementations.<br>Sampling from wide (&gt;&#x3D; 16-bit per channel)  textures may take multiple cycles.<br>Note: sampling from a depth texture only requires a single channel to be returned and so only takes a single cycle, even though it would otherwise qualify as a wide data format.</p><h4 id="3-7-3-SC-TEX-UTILIZATION-Derived"><a href="#3-7-3-SC-TEX-UTILIZATION-Derived" class="headerlink" title="3.7.3 SC.TEX_UTILIZATION (Derived)"></a>3.7.3 SC.TEX_UTILIZATION (Derived)</h4><p>Availability: All</p><p>The texture unit utilization is computed as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.TEX_UTILIZATION = SC.TEX_ISSUES / SC.EXEC_CORE_ACTIVE<br></code></pre></td></tr></table></figure><h4 id="3-7-4-SC-TEX-CPI-Derived"><a href="#3-7-4-SC-TEX-CPI-Derived" class="headerlink" title="3.7.4 SC.TEX_CPI (Derived)"></a>3.7.4 SC.TEX_CPI (Derived)</h4><p>Availability: All</p><p>The average cycle usage of the texture unit per instruction can be computed as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.TEX_CPI = SC.TEX_ISSUES / SC.TEX_INSTRS<br></code></pre></td></tr></table></figure><p>The best case CPI is 1.0; CPI above 1.0 implies the use of multi-cycle texture instructions. The following counters give a direct view of two of the sources of multi-cycle texture operations:</p><p>SC.TEX_INSTR_3D (see )<br>SC.TEX_INSTR_TRILINEAR (see section)<br>If both of these counter sources are zero then the third source of multi-cycle operations (for which a direct counter does not exist) is accesses to wide channel texture formats such as the OpenGL ES 3.x 16-bit and 32-bit per channel integer and floating point formats, or multi-plane YUV formats.</p><h4 id="3-7-5-SC-TEX-INSTR-3D"><a href="#3-7-5-SC-TEX-INSTR-3D" class="headerlink" title="3.7.5 SC.TEX_INSTR_3D"></a>3.7.5 SC.TEX_INSTR_3D</h4><p>Availability: All</p><p>This counter increments for every architecturally executed texture instruction which is accessing a 3D texture. These will take at least two cycles to process, and may take four cycles if trilinear filtering is used.</p><h4 id="3-7-6-SC-TEX-INSTR-TRILINEAR"><a href="#3-7-6-SC-TEX-INSTR-TRILINEAR" class="headerlink" title="3.7.6 SC.TEX_INSTR_TRILINEAR"></a>3.7.6 SC.TEX_INSTR_TRILINEAR</h4><p>Availability: All</p><p>This counter increments for every architecturally executed texture instruction which is using a trilinear (GL_LINEAR_MIPMAP_LINEAR) minification filter. These will take at least two cycles to process, and may take four cycles if a 3D texture is being sampled from.</p><p>In content which is texture filtering throughput limited, switching from trilinear filtering to bilinear filtering (GL_LINEAR_MIPMAP_NEAREST) may improve performance.</p><h4 id="3-7-7-SC-TEX-INSTR-MIPMAP"><a href="#3-7-7-SC-TEX-INSTR-MIPMAP" class="headerlink" title="3.7.7 SC.TEX_INSTR_MIPMAP"></a>3.7.7 SC.TEX_INSTR_MIPMAP</h4><p>Availability: All</p><p>This counter increments for every architecturally executed texture instruction which is accessing a texture which has mipmaps enabled. Mipmapping provides improved 3D texturing quality, as it provides some pre-filtering for minified texture samples, and also improves performance as it reduces pressure on texture caches. It is highly recommended that mipmapping is used for all 3D texturing operations reading from static input textures.</p><h4 id="3-7-8-SC-TEX-INSTR-COMPRESSED"><a href="#3-7-8-SC-TEX-INSTR-COMPRESSED" class="headerlink" title="3.7.8 SC.TEX_INSTR_COMPRESSED"></a>3.7.8 SC.TEX_INSTR_COMPRESSED</h4><p>Availability: All</p><p>This counter increments for every architecturally executed texture instruction which is accessing a texture which is compressed, including both application-level texture compression such as ETC and ASTC, as well as internal texture compression such as AFBC framebuffer compression. Texture compression can significantly improve performance due to reduced pressure on the texture data caches and external memory system. It is recommended that all input assets from the application use compression whenever it is possible to do so.</p><h4 id="3-7-9-SC-TEX-READ-BEATS"><a href="#3-7-9-SC-TEX-READ-BEATS" class="headerlink" title="3.7.9 SC.TEX_READ_BEATS"></a>3.7.9 SC.TEX_READ_BEATS</h4><p>Availability: All</p><p>This counter increments for every 16 bytes of texture data fetched from the L2 memory system.</p><h4 id="3-7-10-SC-TEX-L2-BYTES-PER-ISSUE-Derived"><a href="#3-7-10-SC-TEX-L2-BYTES-PER-ISSUE-Derived" class="headerlink" title="3.7.10 SC.TEX_L2_BYTES_PER_ISSUE (Derived)"></a>3.7.10 SC.TEX_L2_BYTES_PER_ISSUE (Derived)</h4><p>Availability: All</p><p>The average number of bytes read from the L2 cache per texture L1 cache access can be given as.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.TEX_L2_BYTES_PER_ISSUE = (SC.TEX_READ_BEATS * 16) / SC.TEX_ISSUES<br></code></pre></td></tr></table></figure><p>This gives some idea of level one cache efficiency, although does require some knowledge of how the application is using texture data to interpret. For example some use cases expect to have good cache hit rates and reuse the same data many times from different threads, whereas other use cases are data streaming use cases are use each data item exactly once.</p><h4 id="3-7-11-SC-TEX-READ-BEATS-EXTERNAL"><a href="#3-7-11-SC-TEX-READ-BEATS-EXTERNAL" class="headerlink" title="3.7.11 SC.TEX_READ_BEATS_EXTERNAL"></a>3.7.11 SC.TEX_READ_BEATS_EXTERNAL</h4><p>Availability: All</p><p>This counter increments for every 16 bytes of texture data fetched from the L2 memory system which missed in the L2 cache and required a fetch from external memory.</p><h4 id="3-7-12-SC-TEX-EXTERNAL-BYTES-PER-ISSUE-Derived"><a href="#3-7-12-SC-TEX-EXTERNAL-BYTES-PER-ISSUE-Derived" class="headerlink" title="3.7.12 SC.TEX_EXTERNAL_BYTES_PER_ISSUE (Derived)"></a>3.7.12 SC.TEX_EXTERNAL_BYTES_PER_ISSUE (Derived)</h4><p>Availability: All</p><p>The average number of bytes read from the external memory interface per texture operation can be given as.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.TEX_EXTERNAL_BYTES_PER_ISSUE = (SC.TEX_READ_BEATS_EXTERNAL * 16) / SC.TEX_ISSUES<br></code></pre></td></tr></table></figure><p>This gives some idea of level two cache efficiency, although does require some knowledge of how the application is using texture data to interpret. For example some use cases expect to have good cache hit rates and reuse the same data many times from different threads, whereas other use cases are data streaming use cases are use each data item exactly once.</p><h3 id="3-8-Varying-Unit-Events"><a href="#3-8-Varying-Unit-Events" class="headerlink" title="3.8 Varying Unit Events"></a>3.8 Varying Unit Events</h3><p>This counter set looks at the varying unit behavior:</p><h4 id="3-8-1-SC-VARY-INSTR"><a href="#3-8-1-SC-VARY-INSTR" class="headerlink" title="3.8.1 SC.VARY_INSTR"></a>3.8.1 SC.VARY_INSTR</h4><p>Availability: All</p><p>This counter increments for every architecturally executed varying unit instruction for a fragment quad.</p><h4 id="3-8-2-SC-VARY-ISSUES-16"><a href="#3-8-2-SC-VARY-ISSUES-16" class="headerlink" title="3.8.2 SC.VARY_ISSUES_16"></a>3.8.2 SC.VARY_ISSUES_16</h4><p>Availability: All</p><p>This counter increments for every architecturally executed cycle of “mediump” 16-bit varying interpolation.</p><p>Interpolating mediump fp16 values is twice as fast as interpolating highp fp32 values, so should be used whenever it is suitable. Most use cases which contribute to computing an 8-bit unorm color value can safely use fp16 precision</p><h4 id="3-8-3-SC-VARY-ISSUES-32"><a href="#3-8-3-SC-VARY-ISSUES-32" class="headerlink" title="3.8.3 SC.VARY_ISSUES_32"></a>3.8.3 SC.VARY_ISSUES_32</h4><p>Availability: All</p><p>This counter increments for every architecturally executed cycle of “highp” 32-bit varying interpolation.</p><p>Interpolating highp fp32 values is half the performance and twice the bandwidth of interpolating medium fp16 values, so should only be used for cases where the additional floating point precision is necessary. The most common use cases requiring high-precision varyings are texture sampling coordinates, and anything related to accurately computing 3D position in the scene.</p><h4 id="3-8-4-SC-VARY-UTILIZATION-Derived"><a href="#3-8-4-SC-VARY-UTILIZATION-Derived" class="headerlink" title="3.8.4 SC.VARY_UTILIZATION (Derived)"></a>3.8.4 SC.VARY_UTILIZATION (Derived)</h4><p>Availability: All</p><p>The utilization of the varying unit can be determined as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.VARY_UTILIZATION = (SC.VARY_ISSUES_16 + SC.VARY_ISSUES_32) / SC.EXEC_CORE_ACTIVE<br></code></pre></td></tr></table></figure><h2 id="4-Tiler-Counters"><a href="#4-Tiler-Counters" class="headerlink" title="4 Tiler Counters"></a>4 Tiler Counters</h2><p>The tiler counters provide details of the workload of the fixed function tiling unit, which places primitives into the tile lists which are subsequently read by the fragment frontend during fragment shading.</p><h3 id="4-1-Tiler-Activity"><a href="#4-1-Tiler-Activity" class="headerlink" title="4.1 Tiler Activity"></a>4.1 Tiler Activity</h3><p>These counters show the overall activity of the tiling unit.</p><h4 id="4-1-1-TI-ACTIVE"><a href="#4-1-1-TI-ACTIVE" class="headerlink" title="4.1.1 TI.ACTIVE"></a>4.1.1 TI.ACTIVE</h4><p>Availability: All</p><p>This counter increments every cycle the tiler is processing a task. The tiler can run in parallel to vertex shading and fragment shading so a high cycle count here does not necessarily imply a bottleneck, unless the SC.COMPUTE_ACTIVE counter in the shader cores are very low relative to this.</p><h4 id="4-2-Tiler-Primitive-Occurrence"><a href="#4-2-Tiler-Primitive-Occurrence" class="headerlink" title="4.2 Tiler Primitive Occurrence"></a>4.2 Tiler Primitive Occurrence</h4><p>These counters give a functional breakdown of the tiling workload given to the GPU by the application.</p><h4 id="4-2-1-TI-PRIMITIVE-POINTS"><a href="#4-2-1-TI-PRIMITIVE-POINTS" class="headerlink" title="4.2.1 TI.PRIMITIVE_POINTS"></a>4.2.1 TI.PRIMITIVE_POINTS</h4><p>Availability: All</p><p>This counter increments for every point primitive processed by the tiler. This counter is incremented before any clipping or culling, so reflects the raw workload from the application.</p><h4 id="4-2-2-TI-PRIMITIVE-LINES"><a href="#4-2-2-TI-PRIMITIVE-LINES" class="headerlink" title="4.2.2 TI.PRIMITIVE_LINES"></a>4.2.2 TI.PRIMITIVE_LINES</h4><p>Availability: All</p><p>This counter increments for every line segment primitive processed by the tiler. This counter is incremented before any clipping or culling, so reflects the raw workload from the application.</p><h4 id="4-2-3-TI-PRIMITIVE-TRIANGLES"><a href="#4-2-3-TI-PRIMITIVE-TRIANGLES" class="headerlink" title="4.2.3 TI.PRIMITIVE_TRIANGLES"></a>4.2.3 TI.PRIMITIVE_TRIANGLES</h4><p>Availability: All</p><p>This counter increments for every triangle primitive processed by the tiler. This counter is incremented before any clipping or culling, so reflects the raw workload from the application.</p><h4 id="4-2-4-TI-INPUT-PRIMITIVES-Derived"><a href="#4-2-4-TI-INPUT-PRIMITIVES-Derived" class="headerlink" title="4.2.4 TI.INPUT_PRIMITIVES (Derived)"></a>4.2.4 TI.INPUT_PRIMITIVES (Derived)</h4><p>Availability: All</p><p>This derived counter contains the total number of primitives entering primitive assembly.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">TI.INPUT_PRIMITIVES = TI.PRIMITIVE_POINTS + TI.PRIMITIVE_LINES + TI.PRIMITIVE_TRIANGLES<br></code></pre></td></tr></table></figure><h3 id="4-3-Tiler-Visibility-and-Culling-Occurrence"><a href="#4-3-Tiler-Visibility-and-Culling-Occurrence" class="headerlink" title="4.3 Tiler Visibility and Culling Occurrence"></a>4.3 Tiler Visibility and Culling Occurrence</h3><p>These counters give a breakdown of how the workload has been affected by clipping and culling. The culling schemes are applied in the order shown below:</p><p>Culling diagram</p><p>This order impacts the interpretation of the counters in terms of comparing the culling rates against the total number of primitives entering and leaving each stage.</p><h4 id="4-3-1-TI-CULLED-FACING"><a href="#4-3-1-TI-CULLED-FACING" class="headerlink" title="4.3.1 TI.CULLED_FACING"></a>4.3.1 TI.CULLED_FACING</h4><p>Availability: All</p><p>This counter is incremented for every primitive which is culled due to the application of front-face or back-face culling rules. For most meshes approximately half of the triangles are back facing so this counter should typically be similar to the visible primitives, although lower is always better.</p><h4 id="4-3-2-TI-CULLED-FRUSTUM"><a href="#4-3-2-TI-CULLED-FRUSTUM" class="headerlink" title="4.3.2 TI.CULLED_FRUSTUM"></a>4.3.2 TI.CULLED_FRUSTUM</h4><p>Availability: All</p><p>This counter is incremented for every primitive which is culled due to being totally outside of the clip-space volume. Application-side culling should be used to minimize the amount of out-of-shot geometry being sent to the GPU as it is expensive in terms of bandwidth and power. One of my blogs looks at application side culling in more detail</p><h4 id="4-3-3-TI-CULLED-COVERAGE"><a href="#4-3-3-TI-CULLED-COVERAGE" class="headerlink" title="4.3.3 TI.CULLED_COVERAGE"></a>4.3.3 TI.CULLED_COVERAGE</h4><p>Availability: All</p><p>This counter is incremented for every microtriangle primitive which is culled due to lack of any coverage of active sample points.</p><h4 id="4-3-4-TI-PRIMITIVE-VISIBLE"><a href="#4-3-4-TI-PRIMITIVE-VISIBLE" class="headerlink" title="4.3.4 TI.PRIMITIVE_VISIBLE"></a>4.3.4 TI.PRIMITIVE_VISIBLE</h4><p>Availability: All</p><p>This counter is incremented for every primitive which is visible, surviving all types of culling which are applied.</p><p>Note: Visible in this context simply means that a primitive is inside the viewing frustum, facing in the correct direction, and has at least some sample coverage. Primitives which are visible at this stage still may generate no rendered fragments; for example ZS testing during fragment processing may determine that a primitive is entirely occluded by other primitives.</p><h4 id="4-3-5-TI-CULLED-FACING-PERCENT-Derived"><a href="#4-3-5-TI-CULLED-FACING-PERCENT-Derived" class="headerlink" title="4.3.5 TI.CULLED_FACING_PERCENT (Derived)"></a>4.3.5 TI.CULLED_FACING_PERCENT (Derived)</h4><p>Availability: All</p><p>This counter determines the percentage of primitive inputs into the facing test which are culled by it.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">TI.CULLED_FACING_PERCENT = TI.CULLED_FACING / TI_INPUT_PRIMITIVES<br></code></pre></td></tr></table></figure><p>In typical 3D content it is expected that approximately half of the input primitives will be culled by the facing tests, as the side of a model which is facing away from the camera is not visible and can be dropped without fragment shading. If a low percentage of primitives are culled by the facing tests in a 3D application this implies that the application may not be enabling the back-face test for everything which could benefit from it; check the application draw calls for opaque objects are enabling GL_CULL_FACE correctly.</p><h4 id="4-3-6-TI-CULLED-FRUSTUM-PERCENT-Derived"><a href="#4-3-6-TI-CULLED-FRUSTUM-PERCENT-Derived" class="headerlink" title="4.3.6 TI.CULLED_FRUSTUM_PERCENT (Derived)"></a>4.3.6 TI.CULLED_FRUSTUM_PERCENT (Derived)</h4><p>Availability: All</p><p>This counter determines the percentage of primitive inputs into the frustum test which are culled by it.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">TI.CULLED_FRUSTUM_PERCENT = TI.CULLED_FRUSTUM / (TI.INPUT_PRIMITIVES - TL.CULLED_FACING)<br></code></pre></td></tr></table></figure><p>One of the most important optimizations an application can perform is efficiently culling objects which are outside of the visible frustum, as these optimizations can be applied quickly by exploiting scene knowledge such as object bounding volume checks (see Mali Performance 5: An Application’s Performance Responsibilities for more information on application culling techniques). It is expected that some triangles will be outside of the frustum – CPU culling is normally approximate, and some objects may be span frustum boundary – but this should be minimized as it indicates that redundant vertex processing is occurring.</p><h4 id="4-3-7-TI-CULLED-COVERAGE-PERCENT-Derived"><a href="#4-3-7-TI-CULLED-COVERAGE-PERCENT-Derived" class="headerlink" title="4.3.7 TI.CULLED_COVERAGE_PERCENT (Derived)"></a>4.3.7 TI.CULLED_COVERAGE_PERCENT (Derived)</h4><p>Availability: All</p><p>This counter determines the percentage of primitive inputs into the coverage test which are culled by it.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">TI.CULLED_COVERAGE_PERCENT = TI.CULLED_FRUSTUM / (TI.INPUT_PRIMITIVES - TL.CULLED_FACING - TI.CULLED_FRUSTUM)<br></code></pre></td></tr></table></figure><p>A significant number of triangles being culled due to the coverage test indicates that the application is using very dense models which are producing small microtriangles; even if the triangles which produce no coverage are killed it is expected that there will also be a number of visible triangles which cover a small number of sample points, which are still disproportionately expensive to process relative to their screen coverage.</p><p>Microtriangles are expensive to process for a number of reasons.</p><p>On mobile devices they are most expensive due to the bandwidth cost they incur. The vertex shader has to read the vertex attributes and write the varyings, and the fragment shader has to read and interpolate the varyings, which are typically bulky floating point vector data types. For example, the simplest vertex consisting of only a vec4 fp32 position attribute requires two 128-bit reads and one 128-bit write, a total of 24 bytes of memory bandwidth used. The cost of the vertex bandwidth is amortized over the number of fragments that a triangle generates. A triangle covering 50 pixels will effectively cost 0.5 bytes per pixel in terms of vertex bandwidth, which is equivalent of the cost of a single ETC2 compressed texture fetch. A microtriangle covering a two pixels will cost 12 bytes per pixel, and is therefore likely to generate stalls on the memory system.</p><p>Note: This example is for the “best case” microtriangle consisting of only of a position; most real applications will also have additional per-vertex attributes, such as vertex normals and texture coordinates. Applications loading between 50 and 100 bytes of input data per vertex are common.</p><p>Fragment workloads are always spawned as 2×2 pixel quads; quads which span the edges of a triangle may contain partial sample coverage, in which one or more of the fragments in the quad does not contribute to the final render, but which costs some performance to process. Microtriangles cause an increase in partial quads, as there are more edges per unit area shaded. The shader core counter SC.FRAG_PARTIAL_QUADS (see section 3.3.11) may provide additional evidence of the existence of microtriangles.</p><h4 id="4-3-8-TI-FRONT-FACING"><a href="#4-3-8-TI-FRONT-FACING" class="headerlink" title="4.3.8 TI.FRONT_FACING"></a>4.3.8 TI.FRONT_FACING</h4><p>Availability: All</p><p>This counter is incremented for every triangle which is front-facing. This counter is incremented after culling, so only counts visible primitives which are actually emitted into the tile list.</p><p>This counter is not directly useful for performance profiling as there is no rendering performance difference between front-facing and back-facing triangles, but is useful used for debugging culling related logic problems, and stencil test logic problems as stencil testing can do different things for front-facing and back-facing triangles.</p><h4 id="4-3-9-TI-BACK-FACING"><a href="#4-3-9-TI-BACK-FACING" class="headerlink" title="4.3.9 TI.BACK_FACING"></a>4.3.9 TI.BACK_FACING</h4><p>Availability: All</p><p>This counter is incremented for every triangle which is back-facing. This counter is incremented after culling, so only counts visible primitives which are actually emitted into the tile list.</p><p>If you are not using back-facing triangles for some special algorithmic purpose, such as Refraction Based on Local Cubemaps, then a high value here relative to the total number of triangles may indicate that the application has forgotten to turn on back-face culling. For most opaque geometry no back facing triangles should be expected.</p><p>This counter is not directly useful for performance profiling as there is no rendering performance difference between front-facing and back-facing triangles, but is useful used for debugging culling related logic problems, and stencil test logic problems as stencil testing can do different things for front-facing and back-facing triangles.</p><h3 id="4-4-Shading-Requests"><a href="#4-4-Shading-Requests" class="headerlink" title="4.4 Shading Requests"></a>4.4 Shading Requests</h3><p>These counters track the workload requests for the Index-Driver Vertex Shading pipeline, one of the new features introduced in the Bifrost GPU architecture.</p><h4 id="4-4-1-TI-IDVS-POSITION-SHADING-REQUEST"><a href="#4-4-1-TI-IDVS-POSITION-SHADING-REQUEST" class="headerlink" title="4.4.1 TI.IDVS_POSITION_SHADING_REQUEST"></a>4.4.1 TI.IDVS_POSITION_SHADING_REQUEST</h4><p>Availability: All</p><p>This counter is incremented for every batch of triangles which have been position shaded. Each batch consists of 4 vertices from sequential index ranges.</p><h4 id="4-4-2-TI-IDVS-VARYING-SHADING-REQUEST"><a href="#4-4-2-TI-IDVS-VARYING-SHADING-REQUEST" class="headerlink" title="4.4.2 TI.IDVS_VARYING_SHADING_REQUEST"></a>4.4.2 TI.IDVS_VARYING_SHADING_REQUEST</h4><p>Availability: All</p><p>This counter is incremented for every batch of triangles which have been varying shaded. Each batch consists of 4 vertices from sequential index ranges.</p><h2 id="5-L2-Cache-Counters"><a href="#5-L2-Cache-Counters" class="headerlink" title="5 L2 Cache Counters"></a>5 L2 Cache Counters</h2><p>This section documents the behavior of the L2 memory system counters.</p><p>In systems which implement multiple L2 caches or bus interfaces the counters presented in DS-5 Streamline are the sum of the counters from all of the L2 counter blocks present, as this gives the aggregate memory system usage.</p><p>All derivations in this document are computations per slice, so it may be necessary to divide these by the number of cache slices present in your design when using user-level equations in DS-5 Streamline.</p><h3 id="5-1-Internal-Cache-Usage"><a href="#5-1-Internal-Cache-Usage" class="headerlink" title="5.1 Internal Cache Usage"></a>5.1 Internal Cache Usage</h3><p>These counters profile the internal use of the L2 cache versus the available cycle capacity.</p><h3 id="5-1-1-L2-ANY-LOOKUP"><a href="#5-1-1-L2-ANY-LOOKUP" class="headerlink" title="5.1.1 L2.ANY_LOOKUP"></a>5.1.1 L2.ANY_LOOKUP</h3><p>Availability: All</p><p>The counter increments for any L2 read or write request from an internal master, or snoop request from an internal or external master.</p><h3 id="5-1-2-L2-INTERNAL-UTILIZATION-Derived"><a href="#5-1-2-L2-INTERNAL-UTILIZATION-Derived" class="headerlink" title="5.1.2 L2.INTERNAL_UTILIZATION (Derived)"></a>5.1.2 L2.INTERNAL_UTILIZATION (Derived)</h3><p>Availability: All</p><p>Each L2 cache slice can process a single read, write, or snoop operation per clock cycle. The internal utilization of the L2 cache by the processing masters in the system can be determined via the equation:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">LS.INTERNAL_UTILIZATION = L2.ANY_LOOKUP / JM.GPU_ACTIVE<br></code></pre></td></tr></table></figure><h3 id="5-2-Internal-Traffic-Profile"><a href="#5-2-Internal-Traffic-Profile" class="headerlink" title="5.2 Internal Traffic Profile"></a>5.2 Internal Traffic Profile</h3><p>These counters profile the internal read traffic into the L2 cache from the various internal masters.</p><h3 id="5-2-1-L2-READ-REQUEST"><a href="#5-2-1-L2-READ-REQUEST" class="headerlink" title="5.2.1 L2.READ_REQUEST"></a>5.2.1 L2.READ_REQUEST</h3><p>Availability: All</p><p>The counter increments for every read transaction received by the L2 cache.</p><h3 id="5-2-2-L2-EXTERNAL-READ-REQUEST"><a href="#5-2-2-L2-EXTERNAL-READ-REQUEST" class="headerlink" title="5.2.2 L2.EXTERNAL_READ_REQUEST"></a>5.2.2 L2.EXTERNAL_READ_REQUEST</h3><p>Availability: All</p><p>The counter increments for every read transaction sent by the L2 cache to external memory.</p><h3 id="5-2-3-L2-READ-MISS-RATE-Derived"><a href="#5-2-3-L2-READ-MISS-RATE-Derived" class="headerlink" title="5.2.3 L2.READ_MISS_RATE (Derived)"></a>5.2.3 L2.READ_MISS_RATE (Derived)</h3><p>Availability: All</p><p>The counter gives an indication of the number of reads which are missing and being sent on the L2 external interface to main memory.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">L2.READ_MISS_RATE = L2.EXTERNAL_READ_REQUEST / L2.READ_REQUEST<br></code></pre></td></tr></table></figure><h4 id="5-2-4-L2-WRITE-REQUEST"><a href="#5-2-4-L2-WRITE-REQUEST" class="headerlink" title="5.2.4 L2.WRITE_REQUEST"></a>5.2.4 L2.WRITE_REQUEST</h4><p>Availability: All</p><p>The counter increments for every write transaction received by the L2 cache.</p><h4 id="5-2-5-L2-EXTERNAL-WRITE-REQUEST"><a href="#5-2-5-L2-EXTERNAL-WRITE-REQUEST" class="headerlink" title="5.2.5 L2.EXTERNAL_WRITE_REQUEST"></a>5.2.5 L2.EXTERNAL_WRITE_REQUEST</h4><p>Availability: All</p><p>The counter increments for every write transaction sent by the L2 cache to external memory.</p><h4 id="5-2-6-L2-WRITE-MISS-RATE-Derived"><a href="#5-2-6-L2-WRITE-MISS-RATE-Derived" class="headerlink" title="5.2.6 L2.WRITE_MISS_RATE (Derived)"></a>5.2.6 L2.WRITE_MISS_RATE (Derived)</h4><p>Availability: All</p><p>The counter gives an indication of the number of writes which are missing and being sent on the L2 external interface to main memory.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">L2.WRITE_MISS_RATE = L2.EXTERNAL_WRITE_REQUEST / L2.WRITE_REQUEST<br></code></pre></td></tr></table></figure><p>Note: In most cases writes to main memory are necessary and not a bad thing, for example writing vertex data to intermediate storage for later use during fragment shading, or when writing back the final color contents of a tile at the end of a frame. A high write miss rate is therefore not necessarily indicative of a performance problem if those writes were always intended to be sent to main memory. </p><h3 id="5-3-External-Read-Traffic-Events"><a href="#5-3-External-Read-Traffic-Events" class="headerlink" title="5.3 External Read Traffic Events"></a>5.3 External Read Traffic Events</h3><p>These counters profile the external read memory interface behavior. Note that this includes traffic from the entire GPU L2 memory subsystem, not just traffic from the L2 cache, as some types of access will bypass the L2 cache.</p><h4 id="5-3-1-L2-EXTERNAL-READ-BEATS"><a href="#5-3-1-L2-EXTERNAL-READ-BEATS" class="headerlink" title="5.3.1 L2.EXTERNAL_READ_BEATS"></a>5.3.1 L2.EXTERNAL_READ_BEATS</h4><p>Availability: All</p><p>This counter increments on every clock cycle a read beat is read off the external AXI bus.</p><h4 id="5-3-2-L2-EXTERNAL-READ-BYTES-Derived"><a href="#5-3-2-L2-EXTERNAL-READ-BYTES-Derived" class="headerlink" title="5.3.2 L2.EXTERNAL_READ_BYTES (Derived)"></a>5.3.2 L2.EXTERNAL_READ_BYTES (Derived)</h4><p>Availability: All</p><p>With knowledge of the bus width used in the GPU the beat counter can be converted into a raw bandwidth counter.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">L2.EXTERNAL_READ_BYTES = SUM(L2.EXTERNAL_READ_BEATS * L2.AXI_WIDTH_BYTES)<br></code></pre></td></tr></table></figure><p>Note: Most implementations of a Bifrost GPU use a 128-bit (16 byte) AXI interface, but a 64-bit (8 byte) interface is also possible to reduce the area used by a design. This information can be obtained from your chipset manufacturer.</p><h4 id="5-3-3-L2-EXTERNAL-READ-UTILIZATION-Derived"><a href="#5-3-3-L2-EXTERNAL-READ-UTILIZATION-Derived" class="headerlink" title="5.3.3 L2.EXTERNAL_READ_UTILIZATION (Derived)"></a>5.3.3 L2.EXTERNAL_READ_UTILIZATION (Derived)</h4><p>Availability: All</p><p>The GPU can issue one read beat per clock per implemented cache slice. The total utilization of the AXI read interface can be determined per cache slice using:</p><p>L2.EXTERNAL_READ_UTILIZATION &#x3D; L2.EXTERNAL_READ_BEATS &#x2F; SC.GPU_ACTIVE<br>Note: This utilization metric ignores any frequency changes which may occur downstream of the GPU. If you have, for example, a 600MHz GPU connected to a 300MHz AXI bus of the same data width then it will be impossible for the GPU to achieve more than 50% utilization of its native interface because the AXI bus is unable to provide the data as quickly as the GPU can consume it.</p><h4 id="5-3-4-L2-EXTERNAL-READ-STALL"><a href="#5-3-4-L2-EXTERNAL-READ-STALL" class="headerlink" title="5.3.4 L2.EXTERNAL_READ_STALL"></a>5.3.4 L2.EXTERNAL_READ_STALL</h4><p>Availability: All</p><p>This counter increments every cycle that the GPU is unable to issue a new read transaction to AXI, because AXI is unable to accept the request. If this number is high it may indicate that the AXI bus is suffering from high contention due to accesses from other sources, or that the GPU is clocked faster than the AXI bus it is connected to.</p><h4 id="5-3-5-L2-Read-Latency-Histogram"><a href="#5-3-5-L2-Read-Latency-Histogram" class="headerlink" title="5.3.5 L2 Read Latency Histogram"></a>5.3.5 L2 Read Latency Histogram</h4><p>Availability: All</p><p>The L2 interface implements a six entry histogram which tracks the response latency for the external reads. The counter for the sixth level is synthesized from multiple raw counter values.</p><p>Histogram Range</p><p>Counter Equation</p><p>0-127 Cycles</p><p>L2.EXT_RRESP_0_127</p><p>128-191 Cycles</p><p>L2.EXT_RRESP_128_191</p><p>192-255 Cycles</p><p>L2.EXT_RRESP_192_255</p><p>256-319 Cycles</p><p>L2.EXT_RRESP_256_319</p><p>320-383 Cycles</p><p>L2.EXT_RRESP_320_383</p><blockquote><p>383 Cycles</p></blockquote><p>L2.EXTERNAL_READ_BEATS - L2.EXT_RRESP_0_127 -<br>L2.EXT_RRESP_128_191 - L2.EXT_RRESP_192_255 -<br>L2.EXT_RRESP_256_319 - L2.EXT_RRESP_320_383</p><p>Mali shader cores are designed to tolerate an external read response latency of 170 GPU cycles; systems reporting significantly higher latency than this for a high percentage of transactions will observe some reduction in performance, as the shader core will stall more often waiting for main memory to provide data.</p><h4 id="5-3-6-L2-Read-Outstanding-Transaction-Histogram"><a href="#5-3-6-L2-Read-Outstanding-Transaction-Histogram" class="headerlink" title="5.3.6 L2 Read Outstanding Transaction Histogram"></a>5.3.6 L2 Read Outstanding Transaction Histogram</h4><p>Availability: All</p><p>The L2 interface implements a four entry histogram which tracks the outstanding transaction levels for the external reads. The counter for the fourth level is synthesized from multiple raw counter values.</p><p>Histogram Range</p><p>Counter Equation</p><p>0-25%</p><p>L2.EXT_READ_CNT_Q1</p><p>25-50%</p><p>L2.EXT_READ_CNT_Q2</p><p>50-75%</p><p>L2.EXT_READ_CNT_Q3</p><p>75%-100%</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">L2.EXTERNAL_READ - L2.EXT_READ_CNT_Q1 - L2.EXT_READ_CNT_Q2 - L2.EXT_READ_CNT_Q3<br></code></pre></td></tr></table></figure><p>The number of currently outstanding transactions gives some idea of how many concurrent memory requests the shader core has queued on the AXI bus. This will not directly cost performance unless we completely run out of transactions; content with a high percentage of transactions in the 75-100% range may be losing performance because it is unable to construct new requests to be sent onto the AXI interface.</p><p>Note: The maximum number of outstanding transactions available is a synthesis time option when implementing the GPU. The total number of outstanding transaction count should be selected to ensure that the GPU can keep data requests queued on the external DDR controller. In a system with 170 cycles of read response latency, and a typical transaction size of 4 data beats, at least 170&#x2F;4 (42) outstanding transactions are required.</p><h3 id="5-4-External-Write-Traffic-Events"><a href="#5-4-External-Write-Traffic-Events" class="headerlink" title="5.4 External Write Traffic Events"></a>5.4 External Write Traffic Events</h3><p>These counters profile the external write memory interface behavior. Note that this includes traffic from the entire GPU L2 memory subsystem, not just traffic from the L2 cache, as some types of access will bypass the L2 cache.</p><h4 id="5-4-1-L2-EXTERNAL-WRITE-BEATS"><a href="#5-4-1-L2-EXTERNAL-WRITE-BEATS" class="headerlink" title="5.4.1 L2.EXTERNAL_WRITE_BEATS"></a>5.4.1 L2.EXTERNAL_WRITE_BEATS</h4><p>Availability: All</p><p>This counter increments on every clock cycle a write beat is read off the external AXI bus.</p><h4 id="5-4-2-L2-EXTERNAL-WRITE-BYTES-Derived"><a href="#5-4-2-L2-EXTERNAL-WRITE-BYTES-Derived" class="headerlink" title="5.4.2 L2.EXTERNAL_WRITE_BYTES (Derived)"></a>5.4.2 L2.EXTERNAL_WRITE_BYTES (Derived)</h4><p>Availability: All</p><p>With knowledge of the bus width used in the GPU the beat counter can be converted into a raw bandwidth counter.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">L2.EXTERNAL_WRITE_BYTES = SUM(L2.EXTERNAL_WRITE_BEATS * L2.AXI_WIDTH_BYTES)<br></code></pre></td></tr></table></figure><p>Note: Most implementations of a Bifrost GPU use a 128-bit (16 byte) AXI interface, but a 64-bit (8 byte) interface is also possible to reduce the area used by a design. This information can be obtained from your chipset manufacturer.</p><h4 id="5-4-3-L2-EXTERNAL-WRITE-UTILIZATION-Derived"><a href="#5-4-3-L2-EXTERNAL-WRITE-UTILIZATION-Derived" class="headerlink" title="5.4.3 L2.EXTERNAL_WRITE_UTILIZATION (Derived)"></a>5.4.3 L2.EXTERNAL_WRITE_UTILIZATION (Derived)</h4><p>Availability: All</p><p>The GPU can issue one read beat per clock per implemented cache slice. The total utilization of the AXI write interface can be determined per cache slice using:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">L2.EXTERNAL_WRITE_UTILIZATION = L2.EXTERNAL_WRITE_BEATS / SC.GPU_ACTIVE<br></code></pre></td></tr></table></figure><p>Note: This utilization metric ignores any frequency changes which may occur downstream of the GPU. If you have, for example, a 600MHz GPU connected to a 300MHz AXI bus of the same data width then it will be impossible for the GPU to achieve more than 50% utilization of its native interface because the AXI bus is unable to provide the data as quickly as the GPU can consume it.</p><h4 id="5-4-4-L2-EXTERNAL-WRITE-STALL"><a href="#5-4-4-L2-EXTERNAL-WRITE-STALL" class="headerlink" title="5.4.4 L2.EXTERNAL_WRITE_STALL"></a>5.4.4 L2.EXTERNAL_WRITE_STALL</h4><p>Availability: All</p><p>This counter increments every cycle that the GPU is unable to issue a new write transaction to AXI, because AXI is unable to accept the request. If this number is high it may indicate that the AXI bus is suffering from high contention due to accesses from other sources, or that the GPU is clocked faster than the AXI bus it is connected to.</p><h4 id="5-4-5-L2-Write-Outstanding-Transaction-Histogram"><a href="#5-4-5-L2-Write-Outstanding-Transaction-Histogram" class="headerlink" title="5.4.5 L2 Write Outstanding Transaction Histogram"></a>5.4.5 L2 Write Outstanding Transaction Histogram</h4><p>Availability: All</p><p>The L2 interface implements a four entry histogram which tracks the outstanding transaction levels for the external writes. The counter for the fourth level is synthesized from multiple raw counter values.</p><p>Histogram Range</p><p>Counter Equation</p><p>0-25%</p><p>L2.EXT_WRITE_CNT_Q1</p><p>25-50%</p><p>L2.EXT_WRITE_CNT_Q2</p><p>50-75%</p><p>L2.EXT_WRITE_CNT_Q3</p><p>75%-100%</p><p>L2.EXTERNAL_WRITE - L2.EXT_WRITE_CNT_Q1 -<br>L2.EXT_WRITE_CNT_Q2 - L2.EXT_WRITE_CNT_Q3</p><p>The number of currently outstanding transactions gives some idea of how many concurrent memory requests the shader core has queued on the AXI bus. This will not directly cost performance unless we completely run out of transactions; content with a high percentage of transactions in the 75-100% range may be losing performance because it is unable to construct new requests to be sent onto the AXI interface.</p><p>Note: The maximum number of outstanding transactions available is a synthesis time option when implementing the GPU. The total number of outstanding transaction count should be selected to ensure that the GPU can keep data requests queued on the external DDR controller. In a system with 90 cycles of write response latency, and a typical transaction size of 4 data beats, at least 90&#x2F;4 (23) outstanding transactions are required.</p><h2 id="6-Conclusions"><a href="#6-Conclusions" class="headerlink" title="6 Conclusions"></a>6 Conclusions</h2><p>This document has defined all of the Mali Bifrost family performance counters available via DS-5 Streamline, as well as some derived-counters which can be derived from them. Hopefully this provides a useful starting point for your application optimization activity when using Mali GPUs.</p><p>We also publish a Mali Application Optimization Guide. You can visit this by clicking on the link below:</p>]]></content>
      
      
      <categories>
          
          <category> mali gpu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mali </tag>
            
            <tag> Gpu Counters </tag>
            
            <tag> Bifrost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDR硬件层Framebuffer格式标准与渲染阶段的关系</title>
      <link href="/2022/07/09/GPUAartch/HDR%E7%A1%AC%E4%BB%B6%E5%B1%82Framebuffer%E6%A0%BC%E5%BC%8F%E6%A0%87%E5%87%86%E4%B8%8E%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2022/07/09/GPUAartch/HDR%E7%A1%AC%E4%BB%B6%E5%B1%82Framebuffer%E6%A0%BC%E5%BC%8F%E6%A0%87%E5%87%86%E4%B8%8E%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="HDR硬件层Framebuffer格式标准与渲染阶段的关系"><a href="#HDR硬件层Framebuffer格式标准与渲染阶段的关系" class="headerlink" title="HDR硬件层Framebuffer格式标准与渲染阶段的关系"></a>HDR硬件层Framebuffer格式标准与渲染阶段的关系</h1><p>这里主要探讨的是<strong>SwapChain的格式</strong>、<strong>写入其中的数据</strong>以及<strong>屏幕实际亮度</strong>之间的关系。</p><h2 id="SDR格式"><a href="#SDR格式" class="headerlink" title="SDR格式"></a>SDR格式</h2><p>对于SDR屏幕 Buffer主要有：</p><p>R8G8B8A8_UNORM：首先屏幕的eotf曲线是始终存在的，这种格式输入的颜色，图像接口不会进行任何处理，需要我们自己在shader中进行sRGB编码。</p><p>R8G8B8A8_SNORM：这种格式输入的颜色在显示之前会自动编码到SRGB空间（自动Gamma矫正），所以我们不需要进行处理，也就是说shader当中直接写出线性颜色即可。A通道是线性的。</p><blockquote><p>  Vulkan的解释：</p><p>  specifies a four-component, 32-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit R component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3.</p><p>  On the other hand, <strong>non-*_SRGB formats</strong> will be very likely exposed in pair with a <strong>SRGB color space.</strong> <strong>This means, the hardware will not apply any transfer function when reading from or writing to such images, yet they will still be presented on a device with sRGB display characteristics</strong>。（即使使用非SRGB的format，仍然可以使用 SRGB的colorSpace），这意味着硬件不会帮助进行自动的空间转换（在读写buffer时），但是仍然使用srgb的eotf的显示特性。</p></blockquote><p>SRGB的进一步说明：</p><p><a href="https://docs.rs/vulkano/0.7.2/vulkano/swapchain/enum.ColorSpace.html">https://docs.rs/vulkano/0.7.2/vulkano/swapchain/enum.ColorSpace.html</a></p><p><img src="/../../images/HDR%E7%A1%AC%E4%BB%B6%E5%B1%82Framebuffer%E6%A0%BC%E5%BC%8F%E6%A0%87%E5%87%86%E4%B8%8E%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5%E7%9A%84%E5%85%B3%E7%B3%BB/1590989148165.png" alt="1590989148165"></p><span id="more"></span><h2 id="HDR格式"><a href="#HDR格式" class="headerlink" title="HDR格式"></a>HDR格式</h2><p>R16G16B16_Float:这种格式输出的是线性浮点数颜色，数据可以超过1，1对应的是80nits。使用的是scRGB。</p><p>DX的参考：</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range">https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range</a></p><p>R10G10B10A2_UNORM：这种格式不会进行任何处理，直接结合EOFT曲线进行显示， 所以需要我们自己在Shader中进行PQ编码。（在我的显示器上Vulkan不支持，暂时没有测试过，但是GL和DX是支持这个格式的）</p><p>VK_COLOR_SPACE_HDR10_ST2084_EXT：说明colorSpace，表示使用BT2020颜色空间，使用ST2048的EOTF。</p><blockquote><p>   Note:</p><p>  对于Vulkan来说所有的ColorSpace都需要在Shader当中进行函数编码，除了SRGB。（对于SRGB的ColorSpace，通过指定带有SRGB的Format就能自动转换）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> GPUAartch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Graphics Core Next</title>
      <link href="/2022/07/09/GPUAartch/GCN%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/"/>
      <url>/2022/07/09/GPUAartch/GCN%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Graphics-Core-Next"><a href="#Graphics-Core-Next" class="headerlink" title="Graphics Core Next"></a>Graphics Core Next</h1><p>GCN是2012年之后的GPU架构。</p><p>使用了精简指令集合。</p><p>GCN架构同时用到了PS4和XboxOne APU的图形部分。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://en.wikipedia.org/wiki/Graphics_Core_Next#cite_note-24">Wiki Graphics_Core_Next</a></p>]]></content>
      
      
      <categories>
          
          <category> GPUAartch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GPU分支语句性能</title>
      <link href="/2022/07/09/GPUAartch/GPU%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E6%80%A7%E8%83%BD/"/>
      <url>/2022/07/09/GPUAartch/GPU%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="GPU分支语句性能"><a href="#GPU分支语句性能" class="headerlink" title="GPU分支语句性能"></a>GPU分支语句性能</h1><p>下面就是一组线程同时执行，*表示空跑，&#x3D;表示执行。可以看到他们是同时完成的。一个计算单元的所有线程结束以后，可以开始下一组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========<span class="hljs-keyword">if</span>==============<span class="hljs-keyword">else</span>**********endif===========<br>线程B:  =========<span class="hljs-keyword">if</span>**************<span class="hljs-keyword">else</span>==========endif===========<br></code></pre></td></tr></table></figure><p>就可以理解为判断只会产生一个遮罩，这个遮罩会决定我这段代码是不是空跑。GPU的计算资源十分紧俏，空跑越多就是我们说的开销大。例如32个线程，每一个都跑不通的分支，那么就相当于性能下降到了1&#x2F;32。这里的开销是利用率降低而不是时间变长。</p><p>关于跑完会等待的。。。GPU一般不会阻塞等待别的线程的（有例外），假如w表示等待。下面的状态是不对的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========<span class="hljs-keyword">if</span>==============<span class="hljs-keyword">else</span> endif===========<br><br>线程B:  =========<span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span>=======endif===========wwwwwww<br></code></pre></td></tr></table></figure><span id="more"></span><p>也就是说不存在按照时间最长的分支算开销。</p><p>什么情况下会发生优化？那就是下面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========<span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span>======endif===========<br><br>线程B:  =========<span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span>======endif===========<br></code></pre></td></tr></table></figure><p>下面的状态不会发生：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========<span class="hljs-keyword">if</span> **********************<span class="hljs-keyword">else</span>======endif===========<br><br>线程B:  =========<span class="hljs-keyword">if</span> **********************<span class="hljs-keyword">else</span>======endif===========<br></code></pre></td></tr></table></figure><p>另外if本身是有开销的。就是下面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========ifififif **********************elseelse======endif===========<br><br>线程B:  =========ifififif **********************elseelse======endif===========<br></code></pre></td></tr></table></figure><p>如果我们用了if去切换了很短的语句就是浪费，想下面这种if就没有存在的必要，改成别的方式比较好。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========ifififif elseelse=endif===========<br><br>线程B:  =========ifififif elseelse=endif===========<br></code></pre></td></tr></table></figure><p>重头戏来了，什么时候if很有用？超高的计算是一种，例如：光追，因为光追的特性可以保证线程成批的走同一个分支，平型光。这个没有研究过就是个大概。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========ifififif 光追左边一点的位置-》》》》》》》》elseelse  ******** endif===========<br><br>线程B:  =========ifififif 光追右边一点的位置-》》》》》》》》elseelse  ******** endif===========<br></code></pre></td></tr></table></figure><p>另一个就是显存访问。这样走相同的分支，效率更高。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========ifififif  读取纹理 ~~~~~~~~~~~~~~~~ elseelse  endif===========<br><br>线程B:  =========ifififif  读取纹理 ~~~~~~~~~~~~~~~~ elseelse  endif===========<br></code></pre></td></tr></table></figure><p>可能会存在.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========ifififif  读取纹理 A~~~~~~~~~elseelse  ********************endif==========<br><br>线程B:  =========ifififif  *********************elseelse读取纹理 B~~~~~~~~~endif===========<br></code></pre></td></tr></table></figure><p>但是GPU有很多个CU，如果大量的CU可以节省一个分支只有少部分会两部分都跑那么这个分支就是有意义的。剩下的时间可以处理别的任务。</p><p>上面不是很准确，只是用比较好理解的方式解释一下。不同的GPU架构，都是有自己的特性的。</p>]]></content>
      
      
      <categories>
          
          <category> GPUAartch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GPU架构整合</title>
      <link href="/2022/07/09/GPUAartch/GPU%E6%9E%B6%E6%9E%84%E7%B1%BB%E5%9E%8B%E6%95%B4%E5%90%88/"/>
      <url>/2022/07/09/GPUAartch/GPU%E6%9E%B6%E6%9E%84%E7%B1%BB%E5%9E%8B%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="GPU架构整合"><a href="#GPU架构整合" class="headerlink" title="GPU架构整合"></a>GPU架构整合</h1><p>AMD公司GPU芯片架构:</p><table><thead><tr><th align="center">Microarchitecture</th><th align="center">GPUs</th><th align="center">Graphic cards &#x2F; SoCs</th></tr></thead><tbody><tr><td align="center">GCN 5th</td><td align="center">Vega 10</td><td align="center">Radeon Rx Vega series</td></tr><tr><td align="center">GCN 4th</td><td align="center">Polaris 10, Polaris 11, Polaris 12</td><td align="center">Radeon Rx 400 series Radeon_500_series</td></tr><tr><td align="center">GCN 3rd</td><td align="center">Tonga, Fiji, Carrizo</td><td align="center">Radeon R9 Series</td></tr><tr><td align="center">GCN 2nd</td><td align="center">Bonaire, Hawaii, Kaveri, Kabini, Temash, Mullins, Beema, Carrizo-L</td><td align="center">Radeon HD 7790, <strong>PlayStation 4</strong>, Xbox One</td></tr><tr><td align="center">GCN 1st</td><td align="center">Oland, Cape Verde, Pitcairn, Tahiti</td><td align="center">Radeon HD 77xx–7900 Series</td></tr><tr><td align="center">TeraScale 3</td><td align="center">Cayman, Trinity&#x2F;Richland</td><td align="center">Radeon HD 69xx Series, Radeon HD 7xxx–76xx Series</td></tr><tr><td align="center">TeraScale 2</td><td align="center">Cedar, Cypress, Juniper, Redwood, Palm, Sumo</td><td align="center">Radeon HD 5000 Series, Radeon HD 6350, Radeon HD 64xx–68xx Series</td></tr><tr><td align="center">TeraScale 1</td><td align="center">R600, RV630, RV610, RV790, RV770, …</td><td align="center">Radeon HD 2000 Series, HD 3000, HD 4000</td></tr></tbody></table><span id="more"></span><p>Nvidia公司GPU芯片架构:</p><table><thead><tr><th>Microarchitecture</th><th>GPUs</th><th>Graphic cards &#x2F; SoCs</th></tr></thead><tbody><tr><td>Turing</td><td>TU10x, TU11x</td><td>GeForce 20 series, GeForce 16 series</td></tr><tr><td>Volta</td><td>GV10x</td><td>Nvidia Titan V</td></tr><tr><td>Pascal</td><td>GP10x</td><td>GeForce 10 series, Tegra X2</td></tr><tr><td>Maxwell</td><td>GM10x, GM20x</td><td>GeForce GTX 750 Ti, GTX 750, GTX 860M, GeForce 900 series, Tegra X1</td></tr><tr><td>Kepler</td><td>GK10x, GK110, GK208</td><td>GeForce 600 series, GeForce 700 series, Tegra K1</td></tr><tr><td>Fermi</td><td>GF10x, GF11x</td><td>GeForce 400 series, GeForce 500 series</td></tr><tr><td>Tesla</td><td>G8x, G9x, GT20x, GT21x</td><td>GeForce 8 series, GeForce 9 series, GeForce 100 series, GeForce 200 series, GeForce 300 series</td></tr></tbody></table><p>高通公司GPU架构:</p><table><thead><tr><th>Microarchitecture</th><th>GPUs</th><th>Graphic cards &#x2F; SoCs</th></tr></thead><tbody><tr><td>Adreno 500 series</td><td>Adreno 510, Adreno 530, Adreno 540Adreno 512</td><td>Snapdragon 430, 625, 650, 652, 660,820, 821, 835</td></tr><tr><td>Adreno 400 series</td><td>Adreno 418,Adreno 420,Adreno 430</td><td>Snapdragon 415, 615, 616, 617, 805, 808, 810</td></tr><tr><td>Adreno 300 series</td><td></td><td>Snapdragon 200, 208, 210, 212, 400, 410, 412, 600, 800, 801</td></tr></tbody></table><p>ARM公司GPU架构:</p><table><thead><tr><th>ARM</th><th>GPUs</th><th>Graphic cards &#x2F; SoCs</th></tr></thead><tbody><tr><td>Bifrost</td><td>Mali-G71, …</td><td>Kirin 960, 970, Exynos 8895, MediaTek Helio P23 (MT6763T), Helio P30</td></tr><tr><td>Midgard 4th</td><td>Mali-T860, Mali-T830, Mali-T880</td><td>Exynos 8890, Exynos 7880, Exynos 7870, Kirin 950, 955, MediaTek MT6738, MT6750, Helio X20 (MT6797), X25 (MT6797T), P10 (MT6755), P20 (MT6757)</td></tr><tr><td>Midgard 3rd</td><td>Mali-T760, …</td><td>Exynos 7420, Exynos 5433, MT6752, MT6732, RK3288</td></tr><tr><td>Midgard 2nd</td><td>Mali-T600 series, T720</td><td>Exynos 5250, 5260, 5410, 5420, 5422, 5430, 5800, 7580, Mediatek MT6735, MT6753, Kirin 920, 925, 930, 935</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> GPUAartch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GPU架构</title>
      <link href="/2022/07/09/GPUAartch/GPU%E6%9E%B6%E6%9E%84/"/>
      <url>/2022/07/09/GPUAartch/GPU%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="GPU架构"><a href="#GPU架构" class="headerlink" title="GPU架构"></a>GPU架构</h1><p>参考资料:</p><p><a href="http://haifux.org/lectures/267/Introduction-to-GPUs.pdf">Introduction to GPU Architecture</a></p><p><a href="https://www.amd.com/Documents/GCN_Architecture_whitepaper.pdf">GCN_Architecture</a></p><p><a href="https://anteru.net/blog/2018/intro-to-compute-shaders/index.html">Compute Shader</a></p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>主要简单介绍GPU架构，已经架构带来的性能优化代码编写问题。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>同过总结上面的资料，大概梳理了相关内容。</p><span id="more"></span><h3 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h3><p> 一个完整的任务，可以理解为一次渲染程序的提交（包括一次vertex或者fragment）</p><p>下面是一个片段着色器的编译结果。</p><p><img src="/../../images/img/Shader.jpg"></p><p>下面是来自Unity内部的一段编译代码。</p><p><strong>查看Unity的CompiledShader可以看一个Pass的一个vertex或者一个fragment可以算作一个Domain。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader Disassembly:<br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Generated by Microsoft (R) D3D Shader Disassembler</span><br><span class="hljs-comment">// Input signature:</span><br><span class="hljs-comment">// Name   Index   Mask Register SysValue  Format   Used</span><br><span class="hljs-comment">// -------------------- ----- ------ -------- -------- ------- </span><br><span class="hljs-comment">// POSITION   0   xyz         0     NONE   float   xyz </span><br><span class="hljs-comment">// Output signature:</span><br><span class="hljs-comment">// Name        Index   Mask Register SysValue  Format   Used</span><br><span class="hljs-comment">// -------------------- ----- ------ -------- -------- ------- </span><br><span class="hljs-comment">// SV_Position       0   xyzw        0      POS   float   xyzw</span><br>      vs_5_0<br>      dcl_globalFlags refactoringAllowed<br>      dcl_constantbuffer CB0[<span class="hljs-number">4</span>], immediateIndexed<br>      dcl_constantbuffer CB1[<span class="hljs-number">51</span>], immediateIndexed<br>      dcl_input v0.xyz<br>      dcl_output_siv o0.xyzw, position<br>      dcl_temps <span class="hljs-number">4</span><br>   <span class="hljs-number">0</span>: mov r0.x, cb0[<span class="hljs-number">0</span>].y<br>   <span class="hljs-number">1</span>: mov r0.y, cb0[<span class="hljs-number">1</span>].y<br>   <span class="hljs-number">2</span>: mov r0.z, cb0[<span class="hljs-number">2</span>].y<br>   <span class="hljs-number">3</span>: add r1.xyw, cb0[<span class="hljs-number">3</span>].xyxz, -cb1[<span class="hljs-number">50</span>].xyxz<br>   <span class="hljs-number">4</span>: mov r0.w, r1.y<br>   <span class="hljs-number">5</span>: mov r2.xyz, v0.xyzx<br>   <span class="hljs-number">6</span>: mov r2.w, l(<span class="hljs-number">1.000000</span>)<br>   <span class="hljs-number">7</span>: dp4 r0.x, r0.xyzw, r2.xyzw<br>   <span class="hljs-number">8</span>: mul r0.xyzw, r0.xxxx, cb1[<span class="hljs-number">34</span>].xyzw<br>   <span class="hljs-number">9</span>: mov r3.w, r1.x<br>  <span class="hljs-number">10</span>: mov r3.x, cb0[<span class="hljs-number">0</span>].x<br>  <span class="hljs-number">11</span>: mov r3.y, cb0[<span class="hljs-number">1</span>].x<br>  <span class="hljs-number">12</span>: mov r3.z, cb0[<span class="hljs-number">2</span>].x<br>  <span class="hljs-number">13</span>: dp4 r3.x, r3.xyzw, r2.xyzw<br>  <span class="hljs-number">14</span>: mad r0.xyzw, cb1[<span class="hljs-number">33</span>].xyzw, r3.xxxx, r0.xyzw<br>  <span class="hljs-number">15</span>: mov r1.x, cb0[<span class="hljs-number">0</span>].z<br>  <span class="hljs-number">16</span>: mov r1.y, cb0[<span class="hljs-number">1</span>].z<br>  <span class="hljs-number">17</span>: mov r1.z, cb0[<span class="hljs-number">2</span>].z<br>  <span class="hljs-number">18</span>: dp4 r1.x, r1.xyzw, r2.xyzw<br>  <span class="hljs-number">19</span>: mad r0.xyzw, cb1[<span class="hljs-number">35</span>].xyzw, r1.xxxx, r0.xyzw<br>  <span class="hljs-number">20</span>: add o0.xyzw, r0.xyzw, cb1[<span class="hljs-number">36</span>].xyzw<br>  <span class="hljs-number">21</span>: ret <br><span class="hljs-comment">// Approximately 0 instruction slots used</span><br></code></pre></td></tr></table></figure><h3 id="Domain的执行"><a href="#Domain的执行" class="headerlink" title="Domain的执行"></a>Domain的执行</h3><p>要执行一个Domain需要一个类似CPU的处理器。</p><p><img src="/../../images/img/ShaderExe.jpg"></p><p><strong>然后就可以逐行执行右侧的Domain。Execution Context是存储单元，ALU是计算单元，Fetch&#x2F;Decode可以理解指令寄存器。</strong></p><h3 id="Workgroup"><a href="#Workgroup" class="headerlink" title="Workgroup"></a>Workgroup</h3><p>一个Domain可以划分成多个WorkGroup。WorkGroup之间独立互不依赖（有可能会产生依赖），放入同一个计算单元的多条指令可以理解为一个WorkGroup。</p><p><img src="/../../images/img/ShaderExe2.jpg"></p><h3 id="Workitem"><a href="#Workitem" class="headerlink" title="Workitem"></a>Workitem</h3><p><strong>Workgroup的一条指令我理解就是Workitem。</strong></p><p>例如一个加法指令。</p><p>这些指令操作的是一个运算单元的不同部件。</p><p>而且在一个指令操作寄存器的时候，别的微指令可以操作累加器，这样的特点可以让运算单元进行<strong>指令流水</strong>。</p><h3 id="SIMD-units"><a href="#SIMD-units" class="headerlink" title="SIMD units"></a>SIMD units</h3><p>如果我在不同的时间重复执行同一个指令四次（<strong>由四个16位宽的SIMD执行</strong>），那么就可以错开对寄存器的使用。如下图所示（图片来自上面的链接，暂时不看文字描述），这就算是<strong>指令流水</strong>。<strong>GPU当中主要是访问寄存器带来的指令流水</strong></p><p><img src="/../../images/img%5CSIMD.jpg"></p><p>也就是单指令多数据 SIMD。</p><p><strong>这时我们发现，我提交一条指令以后，虽然所有的部件都在进行运算，但是指令寄存器停滞了</strong>，也就是图中表示的<strong>wait</strong>。</p><p>为了让指令寄存器也提高利用率，GPU用了下面的方案：</p><p><img src="/../../images/img%5CSIMD_multi.jpg"></p><p>也就是一个指令寄存器（我猜的，可以能不是指的指令寄存器，但是就是上面的Issue Instruction）同时控制四组SIMD。<strong>上面的Issue Instruction是同一个，只不过控制了不同的SIMD。</strong></p><p>上面是从执行时间上看的，我们从物理架构上看应该长这样：</p><p><img src="/../../images/img/Structure.jpg"></p><p>因为要用同一个指令寄存器所以还要变成：</p><p><img src="/../../images/img/Structure2.jpg"></p><p>这是参考链接拿来的示意图，ALU和Ctx数量没有对上。</p><h3 id="Compute-units"><a href="#Compute-units" class="headerlink" title="Compute units"></a>Compute units</h3><p><strong>总结来说：GPU的一个CU（计算单元），就是一个指令寄存器控制的多组SIMD单元。</strong></p><p>每个CU内部的SIMD必须同时执行，所以<strong>一次指令会提交给四个SIMD</strong>，<strong>每个SIMD会通过类似指令流水执行四次</strong>，SIMD是16宽的，<strong>也就是一次同时处理16个数据。</strong></p><h3 id="Wavefront-or-Wave"><a href="#Wavefront-or-Wave" class="headerlink" title="Wavefront or Wave"></a>Wavefront or Wave</h3><p>一次完整的指令流水：16 * 4 * 4 &#x2F; 4 ，一个CU的吞吐量就是64（一个指令对应一个时钟周期，一个时钟周期同时处理了64个数据）。看图的话实际上也是一个指令同时处理64个数据（这是最小的处理单元），这个叫做<strong>Wavefront 或者Wave</strong></p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>下面是参考链接的一个并行架构示意图。</p><p><img src="/../../images/img/parallel.jpg"></p><p>下面是执行的示意图。</p><p><img src="/../../images/img/parallel2.jpg"></p><p>在参考资料中有提到，一个向量寄存器和标量寄存器的使用比较。</p><p>在一个ALU当中，原本的指令会变成向量指令。</p><p><img src="/../../images/img/I.jpg"></p><p>把指令向量化：</p><p><img src="/../../images/img/I2.jpg"></p><p>所以一个非uniform的vector变量类型，为了提高利用率，在一个CU当中需要占用16（float大小）*3（向量维度）*8（并行数）大小的寄存器。</p><p>所以一个ALU可以对应多组数据。</p><p><img src="/../../images/img/Structure3.jpg"></p><p>这个物理结构就和前面的寄存器流水结合起来了，一个ALU每次处理8组数据，分别切换1,2,3,4四组寄存器</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>如果并行程序中遇到分支：一个Wave的总耗时是不变的，只是通过遮盖的方式来不执行。</p><p>如下图如果遇到分支，首先会生成一个Mask，<strong>是针对每个ALU的（ALU逻辑运算单元，也是上面说的CU(Compute Unit) 而非CPU中的Control Unit）。</strong></p><p><img src="/../../images/img/branch.jpg"></p><p>通过遮盖来切换分支，并没有节省时间。</p><p><img src="/../../images/img/branch2.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> GPUAartch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>手机图形硬件工作方式</title>
      <link href="/2022/07/09/GPUAartch/%E6%89%8B%E6%9C%BAGPU%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>/2022/07/09/GPUAartch/%E6%89%8B%E6%9C%BAGPU%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="手机图形硬件工作方式"><a href="#手机图形硬件工作方式" class="headerlink" title="手机图形硬件工作方式"></a>手机图形硬件工作方式</h1><p>这部分内容参考SIGGRAPH 2016，Computer Graphics&amp;Interactive Technique. Course.</p><p>这部分主要是总结<strong>手机硬件的工作方式</strong>以及<strong>如何来让手机硬件发挥出更高的性能</strong>。由于没有做过手机开发，所以看完资料在总结上来可能不是很准确。这里只了解了一小部分，后面涉及到再补全。</p><p>首先是在任何平台上面都适用的方法：减少在屏幕上绘制物体的数量：<strong>降低帧率、降低分辨率、只有在需要重新绘制的时候才绘制。这些不在这里讨论</strong>。</p><p>这里讨论的是如何进行<strong>高性能的3D渲染。</strong></p><h2 id="手机芯片"><a href="#手机芯片" class="headerlink" title="手机芯片"></a>手机芯片</h2><p>下面是手机架构的一个简介：</p><p><img src="/../../images/img/MobleArchitecture.jpg" alt="MobleArchitecture"></p><p>手机的GPU设计通常和PC完全不同。</p><ul><li>手机的GPU通常来说是tiling的（也有例外），有多个Tilers（不知道怎么翻译），PC通常是立即渲染模式（Immediate-mode renderers）。</li><li>手机使用的是系统RAM，而PC使用的是分离的local memory和一个链接到GPU的总线，应该是PCI。</li><li>手机有多核处理器（但是没有太多的超线程技术），大部分为了低能耗做了优化而非高性能。<span id="more"></span></li></ul><h2 id="Tiling-Render"><a href="#Tiling-Render" class="headerlink" title="Tiling Render"></a>Tiling Render</h2><p>首先手机有很多tiling的渲染方式，不同的方式可能适合不同的优化。</p><p>经典的及时渲染模式直接按照图元提交的顺序渲染。</p><p>而Tiling渲染方式，首先需要执行一个Binning Pass。用来判断提交的所有图元都影响了哪些平铺片Tilers。每个三角形轮流测试，然后通过某种方式记录下Tilers中要渲染的三角形。</p><p>然后每个Tiler逐个运行，只处理影响这个Tile的图元和和这个Tile相交的图元。</p><p>光栅化是在一个芯片上的存储器（on-chip memory）进行的（包括overdraw和z comparison），之后才会写入到最终的内存。</p><h3 id="优化tiler"><a href="#优化tiler" class="headerlink" title="优化tiler"></a>优化tiler</h3><h4 id="Binning-Pass"><a href="#Binning-Pass" class="headerlink" title="Binning Pass"></a>Binning Pass</h4><p>Binning Pass只需要顶线信息。所以可以专门为Binning准备一组顶点信息。</p><p>某些硬件运行Cutdown shader，也就是在Bining Pass过程中使用一个精简版的顶点Shader。</p><h4 id="GPU-pipeline"><a href="#GPU-pipeline" class="headerlink" title="GPU pipeline"></a>GPU pipeline</h4><p>通过流水的方式处理。</p><p><img src="/../../images/img/MobleArchitecturepipeline.jpg" alt="MobleArchitecturepipeline"></p><p>大部分的手机GPU可以执行这一帧的binning pass的时候执行上一帧的光栅化。</p><p>可以上ALU-heavy的顶点操作和textrure-heavy的纹理操作同时进行，保证GPU利用率。</p><p>GLES和类似的API上，pass之间的依赖不明确。而Vulkan之间的依赖比较明确。</p><p>binning和rastersing同时执行的策略只有在避免了依赖的情况下才会有效。不过OpenGL ES之类的API比较容易做到。如果一个bining pass 依赖于上一个rasterising 就会造成暂停。</p><p>对于OPGL ES这个API而言依赖比较隐晦，比如：vertexshader依赖于上一帧的渲染或者每帧都会改变纹理（下一帧才会光栅化），这样就会得到错误的渲染结果。对于更新纹理而言，也可以每一帧保存没有更新的纹理，但是这样做开销比较大。</p><p>对于Vulkan而言，每个阶段之间的依赖很明确，可以判断那个策略结束了。</p><p>下面是Vulkan的pipeline：</p><p><img src="/../../images/img/vulkanpipeline.jpg" alt="vulkanpipeline"></p><p>可以看出在一个tier上，vertex shading发生在Binning pass阶段。</p><p>fragment shadering发生在Rasterising阶段。然后数据统一写入到内存。</p><p>Vulkan会让应用暂停，等待他需要的所有的资源都准备完毕，或者等待一个阶段的输出完毕。</p><p>Vulkan的每一个阶段都很明确：</p><p><img src="/../../images/img/vulkanpipelinestage.jpg" alt="vulkanpipelinestage"></p><p>这些阶段可以用来判断什么时候可以开始、什么时候完成。 可以让你分辨Binning pass和Rasterising pass。</p><p>有几个需要注意的：</p><p>VK_PIPELINE_STAGE_VERTEX_INPUT_BIT 定点计算</p><p>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT 片元着色</p><p>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT  结果输出</p><h4 id="FrameBuffer"><a href="#FrameBuffer" class="headerlink" title="FrameBuffer"></a>FrameBuffer</h4><p>下面是加上FrameBuffer的渲染过程：</p><p><img src="/../../images/img/vulkanpipelinestagefb.jpg" alt="vulkanpipelinestagefb"></p><p><strong>在一般的应用程序中渲染速度的瓶颈是一个新的渲染目标是否可用。</strong></p><p>binning pass和渲染目标无关，所以binnning pass可以在渲染目标准备好之前进行。但是，rasterising pass需要等待。</p><h4 id="subpass"><a href="#subpass" class="headerlink" title="subpass"></a>subpass</h4><p>我们知道一次完整的着色包括多个subpass：Geometry，lighting，Shading。</p><p>每一个SubPass都需要一次binning和rasterising。<strong>subpass之间也可以重叠这两个过程。</strong></p><p>正常的结果：</p><p><img src="/../../images/img/vulkanpipelinestagesp.jpg" alt="vulkanpipelinestagesp"></p><p>如果出现依赖，那么有依赖的这个subpass就必须等待上一个subpass完成rasterising pass 才能开始自己的 Binning pass。</p>]]></content>
      
      
      <categories>
          
          <category> GPUAartch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TeraScale</title>
      <link href="/2022/07/09/GPUAartch/TeraScale%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/"/>
      <url>/2022/07/09/GPUAartch/TeraScale%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="TeraScale"><a href="#TeraScale" class="headerlink" title="TeraScale"></a>TeraScale</h1><p>TeraScale架构是AMD公司在2011年之前的早期GPU架构。</p><p>TeraScale使用超长指令字架构。</p><p>使用TeraScale的图形显卡: HD 2000 - 6000 </p><h2 id="架构拆解"><a href="#架构拆解" class="headerlink" title="架构拆解"></a>架构拆解</h2><p>TeraScale的结构如下图：</p><p><img src="/../../images/img/TelascaleArch.jpg" alt="TelascaleArch"></p><p>上面的架构：</p><ol><li><p>包含10个SIMD核心，每一个包括了32个32bit流处理单元，总共320个。</p></li><li><p>包括4个纹理单元。</p></li></ol><p>一个SIMD core结构示意图：</p><p><img src="/../../images/img/SIMDcore.jpg" alt="SIMDcore"></p><p>上面的SIMD core：</p><ol><li><p>包括了16个Stream Processing Units（标量流处理单元），和16KB的本地数据共享存储器。</p></li><li><p>有一组运行的线程共享一个逻辑控制单元。</p></li><li><p>四个专用纹理单元和L1 Cache。</p></li></ol><p>下面是一组Stream Processing Units结构：</p><p><img src="/../../images/img/StreamProcessingUnits.jpg" alt="StreamProcessingUnits"></p><p>对于Stream Processing Units：</p><ol><li>有自己的通用寄存器</li><li>我的猜测四个小的黄色格子应该就是ALU。产生指令流水。<span id="more"></span></li></ol><h2 id="并行方式"><a href="#并行方式" class="headerlink" title="并行方式"></a>并行方式</h2><p>一次并行应该是一次WaveFront的提交，这个时候应该是一组SIMD运行单个指令执行多个数据。</p><p>假设编译后执行顺序确定如下：</p><p><img src="/../../images/img/TelascaleWavefrontA.jpg" alt="TelascaleWavefrontA"></p><p>那么执行过程应该是：</p><p><img src="/../../images/img/TelascaleWavefrontB.jpg" alt="TelascaleWavefrontB"></p><p>可以看出Telascale指令流水的切换方式应该是独立命令之间的流水切换。</p><h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>​这种架构的优势是处理Shader，但是缺陷是它专门为图形设计不适用于通用计算。</p><p>​指令的执行必须提前确定好，不适用于异步计算。</p><p>​以来指令不能连续，无法使用指令流水。</p><p>​指令对于图形友好，并行性好。</p><p>​可以看出来这个是2011年之前的架构，整个设计比较古老简单，能够看得出来专门为图形渲染设计。这种显卡基本上已经被淘汰了。</p><p>​要针对这种做优化的话就是降低代码上下依赖，使用局部变量之类的。具体要看代码编译以后的结构。 </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://meseec.ce.rit.edu/551-projects/fall2014/3-4.pdf">AMD’s Graphics Core Next (GCN) Architecture</a></p><p><a href="http://s08.idav.ucdavis.edu/houston-amd-terascale.pdf">Anatomy of AMD’s TeraScale Graphics Engine</a></p><p><a href="https://en.wikipedia.org/wiki/TeraScale_(microarchitecture)#cite_note-4">TeraScale (microarchitecture)</a></p>]]></content>
      
      
      <categories>
          
          <category> GPUAartch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Partial_Derivatives(DDX)原理与设备实现差异</title>
      <link href="/2022/07/09/GPUAartch/Partial_Derivatives(DDX)%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E5%AE%9E%E7%8E%B0%E5%B7%AE%E5%BC%82/"/>
      <url>/2022/07/09/GPUAartch/Partial_Derivatives(DDX)%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E5%AE%9E%E7%8E%B0%E5%B7%AE%E5%BC%82/</url>
      
        <content type="html"><![CDATA[<h1 id="Partial-Derivatives-DDX-原理与设备实现差异"><a href="#Partial-Derivatives-DDX-原理与设备实现差异" class="headerlink" title="Partial_Derivatives(DDX)原理与设备实现差异"></a>Partial_Derivatives(DDX)原理与设备实现差异</h1><h2 id="DDX-DDY的硬件条件"><a href="#DDX-DDY的硬件条件" class="headerlink" title="DDX\DDY的硬件条件"></a>DDX\DDY的硬件条件</h2><p>​“导数”意思是在某一点上“函数的变化”。在图形处理当中，指的是相邻像素之间的变化。</p><p>​ddx和ddy是常用的简单的图像导数，它们比较相邻的两个像素的垂直或水平值。具体的实现方法以及<strong>结果</strong>依赖于GPU的特殊架构结构细节。</p><p>​在图形计算过程中，像素着色阶段的最小调度单元是一个warp，一个warp执行同一段程序，包括了最少32个线程。但是最小的执行单元是一个quad。也就是说一次最少需要执行一个2 * 2的像素，而不需要的像素会被丢弃掉。</p><p>​这4个像素也就对应了四个线程，他们共同申请使用设备上下文，也就是说可以在硬件上，方便的访问到隔壁像素的数据。</p><p>​根据硬件这一特性，我们可以利用ddx、ddy获取到更多的信息。</p><span id="more"></span><h2 id="DDX-DDY的使用方式"><a href="#DDX-DDY的使用方式" class="headerlink" title="DDX\DDY的使用方式"></a>DDX\DDY的使用方式</h2><p>​我们通过DDX和DDY可以访问当前像素的导数。</p><p>​<strong>注意，DDY和DDX返回的是屏幕像素的导数，因为计算的依据是屏幕像素的2 * 2的Block。</strong></p><p>​具体的实现方式就是通过2 * 2 quad中的上（或下）、右（或左）相邻像素计算差值，获取到导数。</p><ol><li>通常我们可以用导数计算法线：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">surf</span> <span class="hljs-params">(Input IN, inout SurfaceOutput o)</span> &#123;<br>    o.Albedo = normalize(cross(ddy(IN.worldPos),ddx(IN.worldPos)));<br>&#125;<br></code></pre></td></tr></table></figure><p>2.通过导数我们也可以判断边缘，用来模糊或者锐化边界：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">surf</span> <span class="hljs-params">(Input IN, inout SurfaceOutput o)</span> &#123;<br>    half4 c = tex2D(_MainTex, IN.uv_MainTex);<br>    <span class="hljs-comment">//c += ddx(c)*2 + ddy(c)*2; //这行代码开启和关闭的效果</span><br>    o.Albedo = c.rgb;<br>    o.Alpha = c.a;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DDX-DDY的硬件差异"><a href="#DDX-DDY的硬件差异" class="headerlink" title="DDX\DDY的硬件差异"></a>DDX\DDY的硬件差异</h2><p>​在上面的两个案例当中，通常我们是看不出任何差异的，因为我们使用的仅仅是<strong>导数本身</strong>。</p><p>​并且当图像的变化比较平缓的时候（最大变化频率小于一个像素）。导数值可以代表周围一小个区域的导数（微积分的基础理论），此时看不出硬件和驱动的差异，但是在一些特殊的案例中就需要考虑硬件区别了。</p><p>​对于一个屏幕上2 * 2的quad而言：</p><p><img src="/../../images/Partial_Derivatives(DDX)%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E5%AE%9E%E7%8E%B0%E5%B7%AE%E5%BC%82/image-20201123160345783.png" alt="image-20201123160345783"></p><p>​判断屏幕某个像素位置(x,y)所处的quad像素位置（A?B?C?D?）,可以使用下面代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">INDEX <span class="hljs-title function_">CheckQuadPos</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><br>&#123;<br><span class="hljs-keyword">if</span>(x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; y % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> A;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">if</span>(x % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; y % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> B;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>​如果当前线程处在A则DDX、DDY返回的一定是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">TYPE <span class="hljs-title function_">DDX</span><span class="hljs-params">(TYPE value)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> B - A;<br>&#125;<br><br>TYPE <span class="hljs-title function_">DDY</span><span class="hljs-params">(TYPE value)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> C - A;<br>&#125;<br></code></pre></td></tr></table></figure><p>​通常可以假设：B-A可以代表周围几个像素的x方向的导数，包括位置C和位置D的x方向的倒数。所以通常对于一个quad中，驱动只需要计算B-A的值就可以知道整个quad的x方向偏导数。</p><p>​但是如果我们想知道D-C怎么办？<strong>返回的值和具体的图像API有关、不同的供应商对这个函数接口的实现可能也会有所差异。</strong></p><p>以下是实验结果：</p><p>对于ddx(C):</p><p>​<strong>在DX11上返回的是B-A，但是在openglES3、vulkan上，返回的是D-C。也就是说DX11可能对导数的实现进行了省略。</strong></p><p>对于ddy(D)</p><p>​<strong>在DX11上返回的是C-A，在OpenglES3、vulkan上，返回的是D-B。</strong></p><p>在一些特殊的应用当中我们就必须要考虑这个差异。</p><p>​例如：</p><p>​想在D线程上用ddx还原C的值：我在D处进行了纹理采样，想要通过ddx还原C的准确值，那么如果直接执行D-ddx(D)得到的结果可能是：D- B+A，这是对C的估计值而并非C的准确值。</p><p>​<strong>所以，ddx并不能用来节省纹理采样，因为结果依赖具体的图形接口。</strong></p><h2 id="Partial-Derivatives-与if语句"><a href="#Partial-Derivatives-与if语句" class="headerlink" title="Partial Derivatives 与if语句"></a><strong>Partial Derivatives</strong> 与if语句</h2><p>​在使用if语句的时候使用导数功能同样要特别注意！</p><p>​导数计算是基于一个着色器的多个实例在GPU硬件上的并行执行。</p><p>​<strong>标量操作通过SIMD(单指令多数据)架构在寄存器上执行，寄存器包含一个2×2像素块的4个值的向量。这意味着在执行的每一步，属于每个2×2块的着色器实例都是同步的，使得导数计算快速且易于在硬件中实现，只是简单地将包含在同一寄存器中的值进行减法。</strong></p><p>​但是在条件分支的情况下会发生什么呢?在这种情况下，如果不是一个核心中的所有线程都采用同一个分支，<strong>那么在代码执行中就会出现分歧</strong>。<strong>除了分支的效率和性能损失外，发散还破坏了块中像素之间的同步，使得导数操作无法定义。</strong></p><p>​当涉及到纹理采样，问题又变得不同了（需要用到mipmap级别选择、各向异性滤波等方面的<strong>导数</strong>）。当遇到这样的问题时，着色器编译器可以平化分支(从而避免它)，或者尝试重新排列代码，将纹理读取移动到分支控制流之外。当采样纹理时，使用显式导数（这里的显示导数指的是SampleGrad，而非DDX、DDY）或mipmap级别可以避免这个问题。</p><p>还有其他的细节可以参考：<a href="http://www.aclockworkberry.com/shader-derivative-functions/">An introduction to shader derivative functions</a></p>]]></content>
      
      
      <categories>
          
          <category> GPUAartch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于Cuda\Shader中if语句执行原理</title>
      <link href="/2022/07/09/GPUAartch/%E5%85%B3%E4%BA%8ECuda%E3%80%81Shader%E4%B8%ADif%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2022/07/09/GPUAartch/%E5%85%B3%E4%BA%8ECuda%E3%80%81Shader%E4%B8%ADif%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="关于Cuda-Shader中if语句执行原理"><a href="#关于Cuda-Shader中if语句执行原理" class="headerlink" title="关于Cuda\Shader中if语句执行原理"></a>关于Cuda\Shader中if语句执行原理</h1><p>目前大部分人认为：shader当中动态if判断性能很低，只是用来做条件判断的，要避免使用。实际上if语句是可以用来做性能优化的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>主要来自于几个文档：</p><ol start="0"><li><p><a href="http://haifux.org/lectures/267/Introduction-to-GPUs.pdf">http://haifux.org/lectures/267/Introduction-to-GPUs.pdf</a> 直接说明了GPU分支是如何工作的。</p></li><li><p>第一个是GPU Gems 2当中提到的流控制<a href="https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter34.html">Chapter 34. GPU Flow-Control Idioms</a></p></li></ol><p>里面提到了对于Z-cull来说分支和warp分布的关系。</p><ol start="2"><li><p>和GPU分支优化相关的文章：[Reducing_branch_divergence_in_GPU_programs]，上面也提到了分支发散，并且提到了：</p><p>In the presence of a datadependent branch that causes diﬀerent threads in the same warp to follow diﬀerent paths (also known as branch divergence), the warp serially executes each branch path taken, disabling threads that are not on that path.</p><p>说明如果一个Warp没有进行分支发散，是所有warp只走一个分支的。</p></li><li><p>手机部分GPU架构主要是高通和AMD，目前找到了高通的资料：<a href="%5Bfile:///C:/Users/liangzhe/Desktop/80-nb295-11_a.pdf%5D(file:///C:/Users/liangzhe/Desktop/80-nb295-11_a.pdf)">Qualcomm® Snapdragon™ Mobile Platform OpenCL General Programming and Optimization</a></p><p>这里面提到了避免分支发散（Avoid branch divergence）可以从文本中推测出，手机的GPU架构和PC是一样的，有同Warp优化功能，并不会两个分支都走。</p></li><li><p>《GPU编程与优化》当中提到没有分支的Warp可以省略空跑分支。</p><span id="more"></span></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>更直观的解释参考<a href="GPU%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E6%80%A7%E8%83%BD.md">GPU分支语句性能</a></p>]]></content>
      
      
      <categories>
          
          <category> GPUAartch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>谈谈那些early_depth_testing技术（草拟）</title>
      <link href="/2022/07/09/GPUAartch/%E8%B0%88%E8%B0%88%E9%82%A3%E4%BA%9Bearly_depth_testing%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/07/09/GPUAartch/%E8%B0%88%E8%B0%88%E9%82%A3%E4%BA%9Bearly_depth_testing%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="谈谈那些early-depth-testing技术（草拟）"><a href="#谈谈那些early-depth-testing技术（草拟）" class="headerlink" title="谈谈那些early_depth_testing技术（草拟）"></a>谈谈那些early_depth_testing技术（草拟）</h1><h2 id="Early-Z（Immediate-Mode-Renderers-IMRs-：Nvidia-：-GeForces-and-Radeons）"><a href="#Early-Z（Immediate-Mode-Renderers-IMRs-：Nvidia-：-GeForces-and-Radeons）" class="headerlink" title="Early Z（Immediate Mode Renderers (IMRs) ：Nvidia ： GeForces and Radeons）"></a>Early Z（Immediate Mode Renderers (IMRs) ：Nvidia ： GeForces and Radeons）</h2><p>在OPengl 4.5 强制开启下面是原文。</p><h2 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h2><p>Early fragment tests, as an optimization, exist to prevent unnecessary executions of the <a href="https://www.khronos.org/opengl/wiki/Fragment_Shader">Fragment Shader</a>. If a fragment will be discarded based on the <a href="https://www.khronos.org/opengl/wiki/Depth_Test">Depth Test</a> (due perhaps to being behind other geometry), it saves performance to avoid executing the fragment shader. There is specialized hardware that makes this particularly efficient in many GPUs.</p><p>The most effective way to use early depth test hardware is to run a depth-only pre-processing pass. This means to render all available geometry, using minimal shaders and a rendering pipeline that <a href="https://www.khronos.org/opengl/wiki/Write_Mask">only writes to the depth buffer</a>. The <a href="https://www.khronos.org/opengl/wiki/Vertex_Shader">Vertex Shader</a>should do nothing more than transform positions, and the <a href="https://www.khronos.org/opengl/wiki/Fragment_Shader#Optional">Fragment Shader does not even need to exist</a>.</p><p>This provides the best performance gain if the fragment shader is expensive, or if you intend to use multiple passes across the geometry.</p><span id="more"></span><h3 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h3><p>The <a href="https://www.khronos.org/opengl/wiki/OpenGL_Specification">OpenGL Specification</a> states that these operations happens after fragment processing. However, a specification only defines apparent behavior, so the implementation is only required to behave “as if” it happened afterwards.</p><p>Therefore, an implementation is free to apply early fragment tests if the <a href="https://www.khronos.org/opengl/wiki/Fragment_Shader">Fragment Shader</a> being used does not do anything that would impact the results of those tests. So if a fragment shader writes to gl_FragDepth, thus changing the fragment’s depth value, then early testing cannot take place, since the test must use the new computed value.</p><p><strong>Note:</strong> Do recall that if a fragment shader writes to gl_FragDepth, even conditionally, it must write to it at least once on all codepaths.</p><p>There can be other hardware-based limitations as well. For example, some hardware will not execute an early depth test if the (deprecated) alpha test is active, as these use the same hardware on that platform. Because this is a hardware-based optimization, OpenGL has no direct controls that will tell you if early depth testing will happen.</p><p>Similarly, if the <a href="https://www.khronos.org/opengl/wiki/Fragment_Shader#Special_operations">fragment shader discards the fragment with the discard keyword</a>, this will almost always turn off early depth tests on some hardware. Note that even <em>conditional</em> use of discard will mean that the FS will turn off early depth tests.</p><p><strong>Note:</strong> All of the above limitations apply only to early testing as an optimization. They do not apply to anything below.</p><h2 id="Explicit-specification"><a href="#Explicit-specification" class="headerlink" title="Explicit specification"></a>Explicit specification</h2><table><thead><tr><th align="left"></th><th></th><th></th></tr></thead><tbody><tr><td align="left">Core in version</td><td>4.6</td><td></td></tr><tr><td align="left">Core since version</td><td>4.2</td><td></td></tr><tr><td align="left">Core ARB extension</td><td><a href="http://www.opengl.org/registry/specs/ARB/shader_image_load_store.txt">ARB_shader_image_load_store</a></td><td></td></tr></tbody></table><p>More recent hardware can force early depth tests, using a special fragment shader layout qualifier: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">layout(early_fragment_tests) in;<br></code></pre></td></tr></table></figure><p>This will also perform early stencil tests.</p><p>There is a caveat with this. This feature <em>cannot</em> be used to violate the sanctity of the depth test. When this is activated, any writes to gl_FragDepth will be <em>ignored</em>. The value written to the depth buffer will be exactly what was tested <em>against</em> the depth buffer: the fragment’s depth computed through rasterization.</p><p>This feature exists to ensure proper behavior when using <a href="https://www.khronos.org/opengl/wiki/Image_Load_Store">Image Load Store</a> or other <a href="https://www.khronos.org/opengl/wiki/Incoherent_Memory_Access">incoherent memory writing</a>. Without turning this on, fragments that fail the depth test would still perform their Image Load&#x2F;Store operations, since the fragment shader that performed those operations successfully executed. However, with early fragment tests, those tests were run before the fragment shader. So this ensures that image load&#x2F;store operations will only happen on fragments that pass the depth test.</p><p>Note that enabling this feature has consequences for <a href="https://www.khronos.org/opengl/wiki/Fragment_Discarding">the results of a discarded fragment.</a></p><h2 id="HSR（TBDR：Imagination：PowerVR）"><a href="#HSR（TBDR：Imagination：PowerVR）" class="headerlink" title="HSR（TBDR：Imagination：PowerVR）"></a>HSR（TBDR：Imagination：PowerVR）</h2><ol><li>通常在TBDR(iphone , PowerVR)架构的手机GPU当中，有HSR技术，所以不需要Early-Z。并且HSR比Early-Z的效果更好，完全没有OverDraw。</li></ol><h2 id="Forward-Pixel-Kill（TBD：ARM-Mali-GPUs-from-Mali-T62X-and-T678-onwards-）"><a href="#Forward-Pixel-Kill（TBD：ARM-Mali-GPUs-from-Mali-T62X-and-T678-onwards-）" class="headerlink" title="Forward Pixel Kill（TBD：ARM Mali GPUs from Mali-T62X and T678 onwards ）"></a>Forward Pixel Kill（TBD：ARM Mali GPUs from Mali-T62X and T678 onwards ）</h2><p>在Opengl ES3.1 当中规定了 Early z的说明。</p><p><strong>Early Z + FPK.</strong></p><p>材料1:<a href="https://community.arm.com/developer/tools-software/graphics/b/blog/posts/killing-pixels---a-new-optimization-for-shading-on-arm-mali-gpus">https://community.arm.com/developer/tools-software/graphics/b/blog/posts/killing-pixels---a-new-optimization-for-shading-on-arm-mali-gpus</a></p><p>材料2：Forward Pixel Kill专利书</p><p>材料3：Arm® Mali™ GPU Best Practices</p><p>重要的一句话：</p><p><strong>All Mali GPUs since the Mali-T620 GPU includes the FPK optimization. FPK provides automatic hidden surface removal of fragments that are occluded, but early-zs testing does not kill. This is due to the use of a back-to-front render order for opaque geometry. However, do not rely on the FPK optimization alone. An early-zs test is always more energy-efficient, consistent, and works on older Mali GPUs that do not include hidden surface removal.</strong></p><p>联想 ：<strong>FPK对CLIP像素是否有效?</strong></p><h2 id="Qualcomm-Adreno"><a href="#Qualcomm-Adreno" class="headerlink" title="Qualcomm Adreno"></a>Qualcomm Adreno</h2><p>在Opengl ES3.1 当中规定了 Early z的说明。</p><p><strong>Early Z rejection</strong> </p><p>Adreno 3xx and 4x can reject occluded pixels at up to four times the drawn pixel fill rate。To get maximum benefit from this feature, QTI recommends drawing a scene with primitives  sorted out from front-to-back; i.e., near-to-far. This ensures that the Z-reject rate is higher for the  far primitives, which is useful for applications that have high-depth complexity.</p>]]></content>
      
      
      <categories>
          
          <category> GPUAartch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个三角形在GPU中的一生</title>
      <link href="/2022/07/09/GPUAartch/%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%E5%9C%A8GPU%E4%B8%AD%E7%9A%84%E4%B8%80%E7%94%9F/"/>
      <url>/2022/07/09/GPUAartch/%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%E5%9C%A8GPU%E4%B8%AD%E7%9A%84%E4%B8%80%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="一个三角形在GPU中的一生"><a href="#一个三角形在GPU中的一生" class="headerlink" title="一个三角形在GPU中的一生"></a>一个三角形在GPU中的一生</h1><p>这篇笔记总结自<a href="https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline">Life of a triangle - NVIDIA’s logical pipeline</a> 和知乎文章<a href="https://blog.uwa4d.com/archives/USparkle_GPU.html">渲染优化-从GPU的结构谈起</a>。</p><p>主要记录了GPU硬件是如何详细的工作的。另外附加了一些笔记和自己的理解。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先进的Fermi架构已经发布十年了（2010年左右发布），现在是时候更新它的基础图形架构了。</p><p>Fermi是Nvidia的第一个实现了完全可扩展的图形引擎（fully scalable graphics engine的概念请查阅wiki，有说明），在Kepler和Maxwell架构当中也能找到他的影子。</p><p>下面的文章，特别是下面的“精简的管道知识”图片，应该作为各种学习材料的。这篇文章主要从图形的角度讨论GPU是如何工作的，尤其是一些原则，比如：着色程序代码是如何执行的，对于计算来说是一样的。</p><h2 id="GPU管线架构"><a href="#GPU管线架构" class="headerlink" title="GPU管线架构"></a>GPU管线架构</h2><p>下面是一张涵盖了整个GPU架构的图片，后面会详细分开讲解。</p><p><img src="/../../images/%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%E5%9C%A8GPU%E4%B8%AD%E7%9A%84%E4%B8%80%E7%94%9F/fermipipeline.png" alt="NVIDIA&#39;s logical pipeline"></p><span id="more"></span><h2 id="gpu是超级并行工作分发器"><a href="#gpu是超级并行工作分发器" class="headerlink" title="gpu是超级并行工作分发器"></a>gpu是超级并行工作分发器</h2><p>在图形中，我们必须处理数据放大（很少的数据提交会产生很大的变化的工作负载：指的是整个图形流水线处理一个很少的渲染模型）。他的复杂性来源于：</p><blockquote><ul><li>每个drawcall可以生成不同数量的三角形。</li><li>裁剪后的顶点数量与三角形发生变化。</li><li>经过背面和深度剔除后，并不是所有的三角形都需要屏幕上的像素。</li><li>一个屏幕尺寸大小的三角形的意味着它需要数百万像素或者根本不需要（被挡住不渲染）。</li></ul></blockquote><p>因此，现代gpu让它们的基本类型(三角形、线、点)遵循<strong>逻辑管道</strong>，而不是<strong>物理管道</strong>。在G80的统一架构(DX9、ps3、xbox360)之前的日子里，流水线在芯片上表现为不同的<strong>硬件模块</strong>，工作一个接一个地通过这些硬件模块串行执行。（<strong>不同的物理硬件处理不同的数据</strong>）。G80能够让顶点和片段着色器重用一些硬件单元，但是它仍然有很多用于图元&#x2F;栅格化等阶段的硬件，是串行执行的。有了Fermi，管道变得完全并行化了，这意味着通过重用芯片上的多个引擎（不同的功能组件）实现了<strong>逻辑管道</strong>(我们后面要讲的三角形处理步骤)。</p><p>假设我们有两个三角形：A 和B。他们的不同部分可能在不同的逻辑阶段。A已经完成了空间转换操作需要进行光栅化。那么，A的一部分可能已经完成了Pixel-shader的执行，一部分可能被z-cull剪裁掉了，还有一部分可已经写入到了frame buffer，还有一部分可能在等待执行。除此之外，我们可以拉取三角形B的顶点数据。因此，虽然每个三角形都必须经过所有的逻辑步骤，但它们可能处在其生命周期的不同步骤中。这些工作会被划分成任务甚至子任务，然后并行执行。每个任务都被调度到可用的资源中，这并不局限于特定类型的任务。</p><h2 id="GPU-architecture：基础硬件结构"><a href="#GPU-architecture：基础硬件结构" class="headerlink" title="GPU architecture：基础硬件结构"></a>GPU architecture：基础硬件结构</h2><p>下图是Maxwell GPU架构，他和Fermi架构基本类似。</p><ul><li><strong>Giga Thread Engine</strong> ：有一个Giga线程引擎（<strong>Giga Thread Engine</strong> ）来管理所有正在进行的工作。</li><li><strong>Graphics Processing Cluster</strong>:GPU被划分为多个GPCs(图形处理集群：<strong>Graphics Processing Cluster</strong>)</li><li>每个都有多个SMs(流多处理器：<strong>Streaming Multiprocessor</strong>)和一个栅格引擎（<strong>Raster Engine</strong>）。</li><li><strong>Crossbar</strong>:在这个过程中有很多的互连，最明显的是一个<strong>Crossbar</strong> ，它允许各种任务在GPCs或其他功能单元(例如：ROP(<strong>render output unit</strong>))之间迁移。</li><li><strong>Shader</strong>是在SMs上完成的。SMs它包含许多核心<strong>Cores</strong> ，为线程执行数学操作（<strong>核心之间以SIMD的方式运行</strong>）。一个线程既可以是vertex shader 也可以是fragment shader.</li><li>这些核心和其他单元由<strong>Warp Schedulers</strong>驱动，<strong>Warp Schedulers</strong>以32个线程为一组进行管理，并将执行的指令交给<strong>Dispatch Units</strong>。</li><li><strong>代码逻辑</strong>由调度器<strong>Warp Schedulers</strong>处理，而不是在核心<strong>Cores</strong> 内部。<strong>Cores</strong> 只会看到调度程序中的类似“<strong>用寄存器4235和寄存器4234求和，并存储在4230中</strong>”的内容。（也就是说<strong>Cores</strong>一次只能执行一条Shader指令）。</li><li><strong>一个核心本身是相当愚蠢的，相比之下，一个CPU的核心是相当聪明的。</strong>GPU将智能提升到更高的层次，它可以执行一个整体(或者多个)的工作。(SIMD)</li><li>在GPU上，这些单元中的数量(每个GPC有多少 SMs，有多少GPC ..)取决于芯片配置本身。</li><li>SMs的设计本身(cores的数量，指令单元，schedulers…)也随着时间一代一代的变化(见第一张图片)，并保证芯片高效运行，它们可以从高端台式电脑扩展到笔记本电脑和移动设备。</li></ul><p><img src="/../../images/%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%E5%9C%A8GPU%E4%B8%AD%E7%9A%84%E4%B8%80%E7%94%9F/fermipipeline_maxwell_gpu.png" alt="fermipipeline_maxwell_gpu"></p><h2 id="The-logical-pipeline-逻辑管线"><a href="#The-logical-pipeline-逻辑管线" class="headerlink" title="The logical pipeline 逻辑管线"></a>The logical pipeline 逻辑管线</h2><p>这里开始介绍上面的物理硬件是如何通过逻辑管线配合起来的。</p><p>说明：假设<strong>drawcall</strong>引用了<strong>index buffer</strong>和<strong>vertex buffer</strong>，这些<strong>index buffer</strong>和<strong>vertex buffer</strong>已经被数据填满了，并且位于<strong>GPU</strong>的<strong>DRAM</strong>中，并且只使用了<strong>vertexshader</strong> 和 <strong>pixelshader</strong>。</p><ol><li><p>程序在图形api(DX or GL).中进行提交一个drawcall。这个drawcall将会在随后到达驱动程序（<strong>driver</strong>）。驱动程序会执行一系列验证确保操作合法，然后将指令<strong>以GPU可以读取的编码方式</strong>插入<strong>pushbuffer</strong>。在此时可能产生CPU端瓶颈，这就是为什么程序员需要合理的利用api和技术来利用gpu。（通过GPU功能降低drawcall）。</p></li><li><p>经过一段时间或显式的调用”flush” 指令后，驱动程序（<strong>driver</strong>）已在<strong>push buffer</strong>中缓冲了足够的任务并且发送给GPU进行处理（有操作系统的参与）。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> GPUAartch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>纹理缓存</title>
      <link href="/2022/07/09/GPUAartch/%E7%BA%B9%E7%90%86%E7%BC%93%E5%AD%98/"/>
      <url>/2022/07/09/GPUAartch/%E7%BA%B9%E7%90%86%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="纹理缓存"><a href="#纹理缓存" class="headerlink" title="纹理缓存"></a>纹理缓存</h1><p>参考文献：</p><p><img src="/../../images/%E7%BA%B9%E7%90%86%E7%BC%93%E5%AD%98/1574825701596.png" alt="1574825701596"><br><a href="https://fileadmin.cs.lth.se/cs/Personal/Michael_Doggett/pubs/doggett12-tc.pdf">https://fileadmin.cs.lth.se/cs/Personal/Michael_Doggett/pubs/doggett12-tc.pdf</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>纹理缓存是现代GPU的基础组件，是实现实时渲染的性能的重要部分。</p><p>纹理缓存对GPU来说是Read-Only的。主要在texture-mapping阶段由GPU程序读取。</p><p>纹理缓存有很高的命中率，因为相邻像素之间有大量的重用，而且通常位于着色器处理器附近，所以纹理数据具有高吞吐量和低读延迟。</p><p>GPU的架构对程序员是不可见的，特备隐藏在API之下，这些架构包括纹理缓存被频繁的更新，基础的架构如图所示,L1和L2共同构成了GPU的分级内存：<img src="/../../images/%E7%BA%B9%E7%90%86%E7%BC%93%E5%AD%98/1573179467830.png" alt="1573179467830"></p><p>关于上图的描述：</p><p>紫色的部分是Texture Cache。<br>从最上边开始看，Thread Scheduler为不同的图形处理阶段收集任务。然后把任务安排到不同的Graphic Core上。<br>Graphic Core有一些固定功能的图像逻辑（Geometr，Raster），包括了几个处理功能和光栅化功能。<br>接着是Shader，包括了逻辑控制和ALU单元阵列，用于以SIMD的方式处理shader程序。Shader执行阶段使用了L1 数据指令Cache、texture mapping和与其关联的L1Texture Cache。Shader的输出和L1和L2之间需要通过crossbar来传输。<br>Crossbar连接了各种内存单元，包括L2Cache、ROP和内存控制器。内存控制器链接在了保存了framebuffer的外部内存上。大部分相邻的blocks是彼此链接的。</p><p>为了理解对纹理缓存的需求，我们首先要了解影响纹理缓存的功能：texture mapping和rasterization. </p><span id="more"></span><h2 id="Texture-Mapping"><a href="#Texture-Mapping" class="headerlink" title="Texture Mapping"></a>Texture Mapping</h2><p>纹理映射指获取图像数据并将其填充到几何表面的过程。屏幕上的每一个像素需要在纹理当中找到对应的图像数据。在贴图上的一个像素称为一个纹素。模型每一个顶点保存了一个贴图上的2D位置。这些位置称为纹理坐标，uv表示。这个坐标用来查找纹理贴图上的像素位置，st坐标下的位置。</p><p>通过整数坐标来查找单个颜色叫做nearestfiltering，并且可能产生走样。为了避免走样，通常使用邻域像素进行滤波，常用的滤波是bilinear。这个平滑操作可以解决纹理映射时产生的走样，但是无法解决纹理缩小时产生走样。</p><p><img src="/../../images/%E7%BA%B9%E7%90%86%E7%BC%93%E5%AD%98/1573202554755.png" alt="1573202554755"></p><p>​解决纹理所缩小的走样问题需要时用mipmap技术。Mipmap预先滤波是将纹理贴图生成一系列分辨率减半的贴图，构成一个图像金字塔。Trilinear mipmap是通过搜索金字塔相邻两层的贴图，然后在每个贴图上进行bilinear插值之后再用这两个值进行线性插值，最终会得到Trilinear滤波结果。下图可以看到在level0和level1上选择的2*2的像素进行bilinear 滤波。为了选择这两张贴图，需要计算lod值。lod值的计算需要计算相邻2*2像素的所对应的纹理坐标的偏差。</p><p><img src="/../../images/%E7%BA%B9%E7%90%86%E7%BC%93%E5%AD%98/1573532955239.png" alt="1573532955239"></p><h2 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h2><p>光栅会是将三角形转换成屏幕像素的过程，三角形是GPU使用的基本图元，通过限制使用三角形进行光栅化，算法可以根据硬件实现优化。最简单的像素生成顺序就是从上到下进行水平臊面。这个方法很直观，但这个不是最有的方法，所以通常顺序会进行修改来改进效率。</p><p>*** GPU的光栅化会把屏幕像素分成2*2的block，通常也称作QUAD。每一个像素保存了uv坐标和纹理梯度，纹理梯度是<br>$$ \frac{ \delta u }{ \delta x} $$<br>等内容，是通过计算邻域像素纹理坐标的差值得到的。这些纹理梯度，用于计算LOD。如果一个三角形没有覆盖完整的quad，GPU也会为空的像素产生开销，也就是会占据GPU计算引擎的空间。这回导致单一像素的三角形对于GPU来说十分低效，但是也有一些解决方案提出来。 ***</p><p>有关Texture Mapping和光栅化的更多的细节可以参考：[9] T. Akenine-M¨oller, E. Haines, and N. Hoffman, Real-Time Rendering, 3rd ed. AK Peters Ltd., 2008</p><h2 id="Texture-Map-Memory"><a href="#Texture-Map-Memory" class="headerlink" title="Texture Map Memory"></a>Texture Map Memory</h2><p>纹素被访问的顺序可以是与光栅化顺序有关的任何方向（The order of texels accessed in a texture map can have any orientation with respect to the rasterization order，不是很理解，列出原文）。如果纹素在贴图中以简单的行主序存储，纹理映射是水平进行的。缓存会保存很长的一条水平纹素提高命中率，但是如果纹理映射顺序旋转了90度那么，每一个像素都会丢失，每次访问都需要一次新的访存，读取新的一行，为了避免这种依赖朝向的纹理，纹理在内存中是以tile为单位保存的，或者是blocked。每一个纹理被分成n*n的tile，并且所有的纹素成组保存的。</p><p>研究显示如果要提高命中率，tile的尺寸需要和cacheline的尺寸一样大，128K或者256K，那么tile的大小就是8*8或者16*16</p><p>另外一个重要的概念是工作集尺寸working set size。Working Set Size指的是渲染一帧的图像分辨率（ ’The Principle of Texture Thrift’ ）研究显示，如果工作集匹配Cache丢失率会降低。</p><p>纹理缓存是只读的，因为他典型的使用就是放入三角形。但是使用GPU将计算的值放入纹理是一个常用的操作（RTT）。所以尽管他是只读的，他仍然可以改成可写的。如果纹理map改成了可写的，那么所有on-chip的对纹理的引用都会失效，然后GPU就可以写写入纹理了。也可以使用一个更简单的方法：直接刷新GPU的所有缓存。缓存失效是为了保证所有的缓存在一个一致状态。</p><h2 id="Tile-Rasterization"><a href="#Tile-Rasterization" class="headerlink" title="Tile Rasterization"></a>Tile Rasterization</h2><p>和一个内存中保存的是tilling的纹素一样，同样在光栅阶段tiling技术改进了纹理数据的访问顺序。一个简单的光栅化过程以行主序的方式生成像素，从三角形左边按行处理到右侧。每一个大的三角形一个纹理缓存进行填充，伴随像素按照逐行生成，并且进入下一行的时候上一行的像素已经丢弃了。这个水平的光栅化会造成纹理读取随着三角形宽度宽度变化。为了改进空间局部性，使用了tiled-rasterization，他会将屏幕分成等大小的矩形，通常的2的指数大小。每个tile逐个光栅化。</p><h2 id="Texture-Cache-Architecture"><a href="#Texture-Cache-Architecture" class="headerlink" title="Texture Cache Architecture"></a>Texture Cache Architecture</h2><p>纹理缓存的角色在出现了L2Cache的时候发生了变化。就Cache的尺寸而言，现代GPU的L1缓存的大小一般为：12KB，16KB等。L2分布在每一个DRAM通道上，通过cross Bar和L1相连。把一个L2 Cache放在内存控制器上，能够方便GPU进行规模的变化。设计内存架构的时候L2通常是线性内存（相对于根据纹理定制格式来说更好）。它就匀速L2Cache不知能把纹理当做Client还能用作别的内容的缓存。</p><p>其他的还有一些纹理并行和纹理压缩的问题。</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>纹理缓存的设计主要是为了性能。</p><p>如果纹理访问没有命中就需要重off-Chip的内存读取，会产生很大的延迟。为了隐藏延迟，需要需先计算需要的纹理地址，预先抓取缓存行。</p><p>略。</p>]]></content>
      
      
      <categories>
          
          <category> GPUAartch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>手游GPU架构与优化之UnifiedShaderCore</title>
      <link href="/2022/07/09/GPUAartch/%E6%89%8B%E6%B8%B8GPU%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BC%98%E5%8C%96%E4%B9%8BUnifiedShaderCore/"/>
      <url>/2022/07/09/GPUAartch/%E6%89%8B%E6%B8%B8GPU%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BC%98%E5%8C%96%E4%B9%8BUnifiedShaderCore/</url>
      
        <content type="html"><![CDATA[<h1 id="手游GPU架构与优化之UnifiedShaderCore"><a href="#手游GPU架构与优化之UnifiedShaderCore" class="headerlink" title="手游GPU架构与优化之UnifiedShaderCore"></a>手游GPU架构与优化之UnifiedShaderCore</h1><p>在手游优化的过程中发现Metal当中出现了VSShder饱和PSShader等待的情况。</p><p>这主要是由于当前的渲染是VS密集型的。</p><p>但是在最新的GPU中已经使用了Unified Shader Cores。VS和PS应该可以进行统一的线程分配。</p><p>为了了解这个问题进一步研究了手机架构。</p><p>下面是ARM的图片，首先可以发现UTGARD基础架构的GPU还是Separate Shader Cores.也就是说会出现互相等待的情况。</p><p><img src="https://images.anandtech.com/doci/10375/4.%20Tech%20Day%20Bifrost%20FINAL-04_575px.png" alt="img"></p><p>使用ARM Mali芯片的主要是 联发科、华为海思、三星。</p><p>开始使用USA(Unified Shading Architecture a hardware design by which all shader processing units of a piece of graphics hardware are capable of handling any type of shading tasks. )的：</p><p>ATI架构在Radeon HD2000(PC)</p><p>Nvidia从GeForce 8系列(PC) 使用Tesla架构</p><p>高通Adreno 200 series  <a href="https://en.wikipedia.org/wiki/Adreno">wiki介绍</a></p><p>Mali Midgrad</p><p>PowerVR SGX</p>]]></content>
      
      
      <categories>
          
          <category> GPUAartch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FBXFileFormat</title>
      <link href="/2022/07/09/3DBasic/FBXFileFormat/"/>
      <url>/2022/07/09/3DBasic/FBXFileFormat/</url>
      
        <content type="html"><![CDATA[<h1 id="FBX-test-version-file-format-specification"><a href="#FBX-test-version-file-format-specification" class="headerlink" title="FBX test version file format specification"></a>FBX test version file format specification</h1><p><em>This post is extract from <a href="https://archive.blender.org/wiki/index.php/User:Mont29/Foundation/FBX_File_Structure/">blender Doc :FBX File Structure</a>.</em></p><h2 id="Generalities"><a href="#Generalities" class="headerlink" title="Generalities"></a>Generalities</h2><p>FBX is a nodal format, with a root element (which is never explicitly written) and a tree of children.</p><p>Each element has an id (byte string), and can have data and children elements.</p><p>Data are a set of (values, type) tuples, available types are: bool, short, int, long, float, double, bytes, string, and arrays of those types.</p><p>Here is a (JSON) representation of an element:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Element_ID&quot;</span><span class="hljs-punctuation">,</span>                         # ID<br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;data_string&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">13</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>              # Data<br>     <span class="hljs-string">&quot;SI&quot;</span><span class="hljs-punctuation">,</span>                             # Data types<span class="hljs-punctuation">,</span> as single-char codes (S for String<span class="hljs-punctuation">,</span> I for Integer<span class="hljs-punctuation">,</span> etc.)<br>     <span class="hljs-punctuation">[</span>__other_children_elements__<span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>Everything is based on this simple schema.</p><span id="more"></span><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Properties are a way to add heavily typed data.</p><p>Properties are represented by elements children of a “Properties70” element, which does not contain any data.</p><p>Each property is an element. Its ID does not seem to be important (usually, it’s “P” or “PS” for all of them). Their data layout follow that schema:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;PropName&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;PropType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Label(?)&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Flags&quot;</span><span class="hljs-punctuation">,</span> __values__<span class="hljs-punctuation">,</span> …<span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>In other words, the four first data of a property are always strings (its name, its type, presumably its label (often empty), and some flags (optional)), they are the “metadata” of the property. The other data are the property’s value (usually only one, but e.g. for colors or 3D vectors they are three - and some property types have no value :&#x2F;), and their type depends on the data type!</p><p>Bellow are some basic examples of properties:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JSON">Integer<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;some_name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;int&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Integer&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSI&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>Double<span class="hljs-punctuation">:</span>  <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;some_name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;double&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Number&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1.0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSD&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>Color<span class="hljs-punctuation">:</span>   <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;some_name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;ColorRGB&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Color&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSDDD&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><h2 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h2><p>Each template is defined by an “ObjectType” element, which takes a single property, the name of the template, which is also the name of the Object they “define” (e.g. “Model”, “Geometry”, “Material”, etc.).</p><p>Each template has two children: “Count” is the number of Objects using this template, and “PropertyTemplate”, which simply contains some properties.</p><p>To summarize, here is the generic structure of a template definition:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ObjectType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Geometry&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span>            # Start of template definition<br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Count&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>                   # Number of Objects using this template<br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;PropertyTemplate&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KFbxMesh&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span>  # Start of template&#x27;s properties<br>        <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Properties70&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Color&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;ColorRGB&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Color&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.8</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.8</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.8</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSDDD&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;BBoxMin&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Vector3D&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Vector&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSDDD&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;BBoxMax&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Vector3D&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Vector&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSDDD&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            ...<br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><h2 id="Top-Structure"><a href="#Top-Structure" class="headerlink" title="Top Structure"></a>Top Structure</h2><p>A valid FBX file must contain a set of standard elements:</p><ul><li><strong>FBXHeaderExtension</strong>: Mandatory? Contains the metadata of the file.</li><li><strong>FileId</strong>: Mandatory. Some kind of (currently) obscure hash, apparently based on the CreationTime data.</li><li><strong>CreationTime</strong>: Mandatory. The date&#x2F;time of creation of that file, as a single string (e.g. “2013-08-05 10:27:44:000”).</li><li><strong>Creator</strong>: Mandatory? A string identifying the tool used to create that FBX.</li><li><strong>GlobalSettings</strong>: Mandatory? A set of properties defining general data, like the orientation of the scene…</li><li><strong>Documents</strong>: Optional. Not sure what it is used for actually, so far only saw FBX files with a single doc definition here… Maybe it allows for several scenes in a single FBX?</li><li><strong>References</strong>: ???</li><li><strong>Definitions</strong>: Optional. Here templates are defined.</li><li><strong>Objects</strong>: Optional. Here real, useful, static (?) data are stored (objects, geometries, textures, materials, etc.).</li><li><strong>Connections</strong>: Optional. Here are defined links between data defined in Objects (e.g. which object uses which material, etc.).</li><li><strong>Takes</strong>: Optional. Here animations are defined?</li></ul><h2 id="Main-Data-Objects"><a href="#Main-Data-Objects" class="headerlink" title="Main Data - Objects"></a>Main Data - Objects</h2><h3 id="Mesh-Data"><a href="#Mesh-Data" class="headerlink" title="Mesh Data"></a>Mesh Data</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Geometry&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">152167664</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Name::Geometry&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Mesh&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;LSS&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Vertices&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_floats&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;d&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;PolygonVertexIndex&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_integers&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Edges&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_integers&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;GeometryVersion&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">124</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementNormal&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Version&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">101</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;MappingInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ByVertice&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ReferenceInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Direct&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Normals&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_floats&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;d&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>     <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementSmoothing&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Version&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">102</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;MappingInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ByPolygon&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ReferenceInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Direct&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Smoothing&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_integers&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span>  # Yep<span class="hljs-punctuation">,</span> int32 for bool values...<br>     <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementUV&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Version&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">101</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;UVMap&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;MappingInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ByPolygonVertex&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ReferenceInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;IndexToDirect&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;UV&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_floats&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;d&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;UVIndex&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_integers&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementUV&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Version&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">101</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;UVMap.001&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;MappingInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ByPolygonVertex&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ReferenceInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;IndexToDirect&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;UV&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_floats&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;d&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;UVIndex&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_integers&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementMaterial&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Version&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">101</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;gold&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;MappingInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;AllSame&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ReferenceInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;IndexToDirect&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Materials&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>     <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Layer&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Version&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">100</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElement&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>             <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Type&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementNormal&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>             <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;TypedIndex&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>         <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElement&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>             <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Type&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementMaterial&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>             <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;TypedIndex&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>         <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElement&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>             <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Type&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementSmoothing&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>             <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;TypedIndex&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>         <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>     <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Layer&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Version&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">100</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElement&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>             <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Type&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementUV&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>             <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;TypedIndex&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>         <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><h3 id="Armature-and-Bones"><a href="#Armature-and-Bones" class="headerlink" title="Armature and Bones"></a>Armature and Bones</h3><p>In FBX, there is no real armature concept, you rather have chains of bones, which are nearly only defined by “Model” elements (FbxNode), i.e. loc&#x2F;rot&#x2F;scale from parent bone. Root bones are children of an empty object (Model), which plays the role of an armature.</p><p>In other words, armatures are presented more like a set of chains of parented-hooks.</p><p>Each bone&#x2F;hook is represented by a “LimbNode”, which also contains a “Size” parameter (its length), not sure this is used&#x2F;understood by all importers though.</p><p>Bones and mesh are “linked” first by a BindPose element, which stores the (transform) matrix of the mesh and all bones in global (world) space, at the time of binding.</p><h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><p>(New) animation in FBX is actually fairly simple: you have a Stack (usually only one per FBX file, else you may have compatibility issues), to which a set of Layers are linked.</p><p>A set of CurveNodes is linked to each AnimLayer, which define which properties are animated:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;AnimationCurveNode&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">2045776</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;T::AnimCurveNode&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;LSS&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Properties70&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;d&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Compound&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSS&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;d|X&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Number&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;A&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2.227995</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSD&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;d|Y&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Number&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;A&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3.0238389999999997</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSD&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;d|Z&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Number&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;A&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-1.49012e-08</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSD&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;AnimationCurve&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">924545958</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;::AnimCurve&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;LSS&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Default&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">-120.30426094607161</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;D&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyVer&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">4008</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyTime&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">1847446320</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3694892640</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5542338960</span><span class="hljs-punctuation">,</span> <span class="hljs-number">7389785280</span><span class="hljs-punctuation">,</span> <span class="hljs-number">9237231600</span><span class="hljs-punctuation">,</span> <span class="hljs-number">11084677920</span><span class="hljs-punctuation">,</span> <span class="hljs-number">12932124240</span><span class="hljs-punctuation">,</span> <span class="hljs-number">14779570560</span><span class="hljs-punctuation">,</span> <span class="hljs-number">16627016880</span><span class="hljs-punctuation">,</span> <span class="hljs-number">18474463200</span><span class="hljs-punctuation">,</span> <span class="hljs-number">20321909520</span><span class="hljs-punctuation">,</span> <span class="hljs-number">22169355840</span><span class="hljs-punctuation">,</span> <span class="hljs-number">24016802160</span><span class="hljs-punctuation">,</span> <span class="hljs-number">25864248480</span><span class="hljs-punctuation">,</span> <span class="hljs-number">27711694800</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29559141120</span><span class="hljs-punctuation">,</span> <span class="hljs-number">31406587440</span><span class="hljs-punctuation">,</span> <span class="hljs-number">33254033760</span><span class="hljs-punctuation">,</span> <span class="hljs-number">35101480080</span><span class="hljs-punctuation">,</span> <span class="hljs-number">36948926400</span><span class="hljs-punctuation">,</span> <span class="hljs-number">38796372720</span><span class="hljs-punctuation">,</span> <span class="hljs-number">90524869680</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;l&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyValueFloat&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">-90.00000762939453</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-90.16700744628906</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-90.67182159423828</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-91.51591491699219</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-92.69371032714844</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-94.19062042236328</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-95.98118591308594</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-98.02799224853516</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-100.28105926513672</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-102.67914581298828</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-105.1521224975586</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-107.62510681152344</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-110.02317810058594</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-112.27626037597656</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-114.32304382324219</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-116.11365509033203</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-117.61054229736328</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-118.78833770751953</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-119.63243103027344</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-120.13725280761719</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-120.30426025390625</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-120.30426025390625</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;f&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyAttrFlags&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">24840</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyAttrDataFloat&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">0.0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">9.419963346924634e-30</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;f&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyAttrRefCount&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">22</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyAttrFlags&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>A<span class="hljs-punctuation">,</span> B<span class="hljs-punctuation">,</span> A<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyAttrDataFloat&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>A1<span class="hljs-punctuation">,</span> A2<span class="hljs-punctuation">,</span> A3<span class="hljs-punctuation">,</span> A4<span class="hljs-punctuation">,</span> B1<span class="hljs-punctuation">,</span> B2<span class="hljs-punctuation">,</span> B3<span class="hljs-punctuation">,</span> B4<span class="hljs-punctuation">,</span> A1<span class="hljs-punctuation">,</span> A2<span class="hljs-punctuation">,</span> A3<span class="hljs-punctuation">,</span> A4<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;f&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyAttrRefCount&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">10</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span> <span class="hljs-number">10</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 3DBasic </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ColorGrading中LUT的生成与使用</title>
      <link href="/2022/07/09/Art/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/07/09/Art/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ColorGrading中LUT的生成与使用"><a href="#ColorGrading中LUT的生成与使用" class="headerlink" title="ColorGrading中LUT的生成与使用"></a>ColorGrading中LUT的生成与使用</h1><p>场景的LUT贴图有两种生成方式：</p><ol><li>通常DaVinCi生成的是.cube文件，需要用cube文件转换。</li><li>直接在PS当中调整。</li></ol><h2 id="PS直接调整"><a href="#PS直接调整" class="headerlink" title="PS直接调整"></a>PS直接调整</h2><p>对于用ps直接调整来说，只要把参考图片和Natural LUT一起调整即可，最终Natural LUT的结果就是我们要的LUT。</p><span id="more"></span><h2 id="cube文件转换"><a href="#cube文件转换" class="headerlink" title="cube文件转换"></a>cube文件转换</h2><p>打开PS，加载默认的LUT文件（就是netrual lut，不对图像产生影响的lut）。</p><p><img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1590739624304.png" alt="1590739624304"></p><p>确定颜色模式为RGB</p><p><img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1590739649754.png" alt="1590739649754"></p><p>开启颜色查找功能：</p><p><img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1590739676967.png" alt="1590739676967"></p><p>使用默认选项点击确认，得到lut图层：</p><p><img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1590739706978.png" alt="1590739706978"></p><p><img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1590739721058.png" alt="1590739721058"></p><p>下面是LUT的图层控制面板：</p><p><img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1590739883952.png" alt="1590739883952"></p><p>配置完成之后就得到了修改好的lut，保存成非压缩的png即可：</p><p><img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1590739972583.png" alt="1590739972583"></p><h2 id="下面是两种Natural-Lut"><a href="#下面是两种Natural-Lut" class="headerlink" title="下面是两种Natural Lut"></a>下面是两种Natural Lut</h2><p>64*64<img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/neutral-lut.png" alt="neutral-lut"></p><p>32*32</p><p><img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/reshade-neutral-lut-768x24.png" alt="reshade-neutral-lut-768x24"></p>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PS颜色风格</title>
      <link href="/2022/07/09/Art/%E9%A2%9C%E8%89%B2%E9%A3%8E%E6%A0%BC/"/>
      <url>/2022/07/09/Art/%E9%A2%9C%E8%89%B2%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="PS颜色风格"><a href="#PS颜色风格" class="headerlink" title="PS颜色风格"></a>PS颜色风格</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>日系，ins风格，低饱和度，平和。</p><p>欧美系，高饱和，有侵略性。</p><p>明度，轻盈舒适。</p><p>低明度，压抑称重，有质感，金属—&gt; 铁和铝箔的IBL。</p><p>同类色-&gt; 15%的色相环，-&gt;靠明度和饱和度达到设计和层次感。–&gt;ToneMapping。</p><p><img src="/../../images/%E9%A2%9C%E8%89%B2%E9%A3%8E%E6%A0%BC/1592918191766.png" alt="1592918191766"></p><h2 id="Camera-Raw"><a href="#Camera-Raw" class="headerlink" title="Camera Raw"></a>Camera Raw</h2><p>Ctrl + Shift + A进入PS的Camera Raw风格。</p><p> 主要用来编辑Raw文件的。</p><p><img src="/../../images/%E9%A2%9C%E8%89%B2%E9%A3%8E%E6%A0%BC/1592918699887.png" alt="1592918699887"></p><p>自动白平衡和手动白平衡。</p><p>下面的图像有没有色偏？可以有也可以没有，但是自动白平衡会去掉。</p><p><img src="/../../images/%E9%A2%9C%E8%89%B2%E9%A3%8E%E6%A0%BC/1592919134345.png" alt="1592919134345"></p><p>渲染当中白色光就没有色偏！！怎么做。</p><span id="more"></span><h3 id="曝光工具"><a href="#曝光工具" class="headerlink" title="曝光工具"></a>曝光工具</h3><p>暗部不实，亮部不实，不通透。</p><p>过渡饱和，——&gt;细节丢失。</p><h2 id="日系风格"><a href="#日系风格" class="headerlink" title="日系风格"></a>日系风格</h2><p>主要特点：明度高 + 冷色调 + 饱和度低 + 大光圈（背景虚化）+ 有光线感觉 + 有点缀的暖色。</p><h2 id="欧美蓝调（胶片风）"><a href="#欧美蓝调（胶片风）" class="headerlink" title="欧美蓝调（胶片风）"></a>欧美蓝调（胶片风）</h2><p>欧美风格主要特点：色彩对比高 + 明暗对立感强 + 饱和度高 + 亮度低（画面的质感）+ 比较多的利用胶片感、湿润感 + 亮部暗部都不实（高光柔和）+ 使用暖色。</p><p>高光不刺眼： 湿润感。</p><p>阴影提亮、灰蒙蒙：光线感、空气感。</p><p>蓝调：阴影加入颜色。</p><p><strong>色彩曲线</strong></p><h2 id="欧美暗调"><a href="#欧美暗调" class="headerlink" title="欧美暗调"></a>欧美暗调</h2><p>色相统一 + 蓝色调为主 + 画面元素简单</p><p><strong>混合模式法</strong>：</p><p>柔光：</p><p>正片叠底：</p><p>滤色：</p><p>颜色、色相、饱和度、明度：使用原图层的信息和新图层的信息结合。</p><p><strong>色温法：</strong></p><p>对于中性色为主才有效。</p><p><strong>色调分离法：</strong></p><p>先去掉饱和度，然后通过高光和阴影加入颜色。</p><h2 id="赛博朋克"><a href="#赛博朋克" class="headerlink" title="赛博朋克"></a>赛博朋克</h2><p>色相统一 （洋红色 + 青色 的对比色）+ 整体饱和度高 + 未来感、科幻感 + 以夜景照片为主。</p><p><strong>色相饱和度工具：</strong></p><p>色相可以任意转换的。色彩变化范围比HSL工具更加广泛，可以同时调整多种颜色。</p><h2 id="浓郁胶片风"><a href="#浓郁胶片风" class="headerlink" title="浓郁胶片风"></a>浓郁胶片风</h2><p>饱和度高 +油润感 + 明暗对比反差大 + 没有大面积死黑 + 用阴影压暗 + 高光亮不过量、没有高光 + 高光偏灰色 + 空气感（左端点没有凸起，没有纯黑色） + 整体暖色调，有冷色调互补。+ 照片颗粒感 + 暗角。</p><p>黑色白色：画面通透度。</p><p>色调感：混合模式。</p><p>空气感（蒙上灰尘的感觉）：看看画面中是否有重元素（大面积黑色）</p><h2 id="青橙色调"><a href="#青橙色调" class="headerlink" title="青橙色调"></a>青橙色调</h2><p>橙色作为人物肤色的色相 + 人物颜色的反差色 得到了青橙色调的选择。</p><p>色相统一（青色橙色） + 整体亮度比较低（直方图靠左）+ 对比度高（明暗反差大） 。</p><p>核心特点就是色彩<strong>转化</strong> ，将其他颜色饱和度<strong>降低</strong>。</p><p><strong>可选颜色工具：</strong> </p><p>一个颜色受什么颜色控制：<strong>最大值</strong>和<strong>最大值和中间值的混合色</strong>，一种颜色最多受到两种颜色的控制。</p><h2 id="港风色调"><a href="#港风色调" class="headerlink" title="港风色调"></a>港风色调</h2><p>主要特点：对比度高 + 亮暗反差大 + 青色（冷色只有青色）、橙色、换色、红色为主，暗部红橙色，亮部青色 + 整体饱和度比较强。</p><p><strong>色彩感受：</strong></p><p><strong>基调颜色</strong>：-&gt;修改色温，得到基色 -&gt; 对基色进行HSL或者是可选颜色工具进行调整。</p><h2 id="Ins温暖风"><a href="#Ins温暖风" class="headerlink" title="Ins温暖风"></a>Ins温暖风</h2><p>色调统一（橙色调，有低饱和青色作为点缀）+ 饱和度偏高 + 空气感 </p>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BRDF与色彩与明暗</title>
      <link href="/2022/07/09/Art/BRDF%E4%B8%8E%E8%89%B2%E5%BD%A9%E4%B8%8E%E6%98%8E%E6%9A%97/"/>
      <url>/2022/07/09/Art/BRDF%E4%B8%8E%E8%89%B2%E5%BD%A9%E4%B8%8E%E6%98%8E%E6%9A%97/</url>
      
        <content type="html"><![CDATA[<h1 id="BRDF与色彩与明暗"><a href="#BRDF与色彩与明暗" class="headerlink" title="BRDF与色彩与明暗"></a>BRDF与色彩与明暗</h1><p>最近看了一些和色彩相关的文章。在美术当中，明暗变化和颜色的过度是紧紧关联起来的（例如：油画变暗并不是单纯地混入黑色），与BRDF模拟有一些差别（单纯考虑明暗，多个通道同样的明暗衰退过程），原画师、插画师一般是从HSV空间（色相环之类的）下手。</p><h2 id="BRDF明暗与美术明暗"><a href="#BRDF明暗与美术明暗" class="headerlink" title="BRDF明暗与美术明暗"></a>BRDF明暗与美术明暗</h2><p>在美术配色当中，颜色的变化并不只是混入黑色，现实世界同样是，<strong>亮度的降低往往伴随了饱和度的升高</strong>（下图蓝色）。</p><p>但是BRDF总是等比例降低RGB大小（下图黄色），饱和度没有变化。导致画面看起来暗部部分变脏。</p><p>brdf和实际的明暗在拾色器中的变化如下图：<br><img src="/../../images/brdf.jpg" alt="brdf"></p><p>在Cel Shading当中，画面通常需要保证高饱和度，所以通常需要通过后期的Tone Mapping或者Ramp Map的方式调整暗部颜色。</p><p>这里需要注意，BRDF符合正确的物理明暗变化，但是艺术处理上有所欠缺。</p><span id="more"></span><h2 id="色彩练习"><a href="#色彩练习" class="headerlink" title="色彩练习"></a>色彩练习</h2><p>下图是学了色彩之后的练习。主要为了思考明暗和光线以及BRDF的关系，亮度降低伴随了饱和度的升高。可以得到比较好的明暗结果。</p><p><img src="/../../images/color.jpg" alt="color"></p><h2 id="色彩练习2"><a href="#色彩练习2" class="headerlink" title="色彩练习2"></a>色彩练习2</h2><p>这次练习单一颜色的明暗处理。下面的图片只是使用了亮度和饱和度不同的红色。感觉上可以通过单一颜色的数学方法而不是Ramp Map来调整暗部。</p><p><img src="/../../images/sample.jpg" alt="sample"></p><p><img src="/../../images/color2.jpg" alt="color2"></p>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DaVinCi色彩处理原理</title>
      <link href="/2022/07/09/Art/DaVinCi%E8%89%B2%E5%BD%A9%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/"/>
      <url>/2022/07/09/Art/DaVinCi%E8%89%B2%E5%BD%A9%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="DaVinCi色彩处理原理"><a href="#DaVinCi色彩处理原理" class="headerlink" title="DaVinCi色彩处理原理"></a>DaVinCi色彩处理原理</h1><h2 id="Data-Level（pdf，P215）"><a href="#Data-Level（pdf，P215）" class="headerlink" title="Data Level（pdf，P215）"></a>Data Level（pdf，P215）</h2><p>不同的媒体数据文件使用不同范围的数据表示。通常来讲处理的是10bit的数据(0-1023)，有两种不同的data level用来保存图像数据：</p><ul><li><p><strong>Video：</strong>所有的图像数据从0-1的颜色强度，会映射到64-940之间。Y通道[64-940]，CB和CR[64-960],小于64用于表示比黑色更黑的区域，941&#x2F;961–1019 表示超过白色的区域。过低过高的数据称作：undershoots 和overshoots。</p></li><li><p><strong>Full：</strong>对于RGB444数据，数据强度0-1映射到4-1023。</p></li></ul><p>无论哪种数据类型，都有0-100的最大和最小亮度。当数据格式转换时，范围会重新映射：</p><ul><li>(minimum Video Level) 64 &#x3D; 4 (Data Level minimum) </li><li>(maximum Video Level) 940 or 960 &#x3D; 1023 (Data Level maximum）</li></ul><p>​      数据格式的转换几乎不会有变化，因为合法数据会被被保存下来。区别是undershoots 和overshoots可能丢失，但是Resolve软件内部会记录下来，保证之后可以还原。</p><p>   <strong>在DaVinci Resolve中，所有的图像格式都会以Full的格式进行处理。并且是未被压缩的32bit浮点数表示。</strong>也就是说，每一个图片无论原始的bit-depth是多少，都会转换成32bit的数据。转换的质量依赖于原始数据，总之是无压缩的转换。</p><span id="more"></span><h2 id="Color-management"><a href="#Color-management" class="headerlink" title="Color management"></a>Color management</h2><p>色彩被处理的方式依赖于Color Science设置。有四种：DaVinci YRGB、DaVinci YRGB Color Managed、 DaVinci ACEScc, 和 DaVinci ACEScct。</p><h3 id="RCM概念"><a href="#RCM概念" class="headerlink" title="RCM概念"></a>RCM概念</h3><p>指定输入数据的颜色空间、处理数据的颜色空间和输出的颜色空间。</p><p><strong>可以使用数值处理和LUT处理，如果过超过LUT范围会被clip。所以通常还需要执行preLUT调整</strong>。</p><p><img src="/../../images/DaVinCi%E8%89%B2%E5%BD%A9%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/1590046403438.png" alt="1590046403438"></p><h3 id="RCM设置"><a href="#RCM设置" class="headerlink" title="RCM设置"></a>RCM设置</h3><p>Color SpaceSetting中可以设置。</p><p>DaVinCi的颜色管理可以控制输入输出的图片格式——<strong>色域</strong>gamut和<strong>EOTF曲线</strong>gamma。</p><p>主要控制内容有两种，打开Use Separate Color Space and Gamma，就可以分别控制<strong>色域</strong>和<strong>EOTF曲线</strong>：</p><p><img src="/../../images/DaVinCi%E8%89%B2%E5%BD%A9%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/1590027078511.png" alt="1590027078511"></p><p>同时针对每一个Clip也可以独立的设置：</p><p><img src="/../../images/DaVinCi%E8%89%B2%E5%BD%A9%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/1590047180142.png" alt="1590047180142"></p><p>关闭Use Separate Color Space and Gamma，就能同时的修改。</p><h2 id="203nit对齐"><a href="#203nit对齐" class="headerlink" title="203nit对齐"></a>203nit对齐</h2><p>100nits的颜色亮度和和203nit的亮度的映射。</p><blockquote><p>  SDR content to HDR by mapping 100 nits to 203 nits (defined as the diffuse white level) according to the BT.2100 recommendation</p></blockquote><p>当输入数据是SDR输出数据是HDR的时候会进行转换。</p><h2 id="Gamut对齐"><a href="#Gamut对齐" class="headerlink" title="Gamut对齐"></a>Gamut对齐</h2><p>我们通常发布的数据格式会在一个很大的色域上，Rec.2020。但是需要把颜色限制在比较小的色域范围上来满足Consumer的显示器。</p><p>这样我们需要设置Gamut。</p><p>设置OutPutColor Space来保证输出的色域是宽色域，设置Limit Output Gamut来保证颜色范围是在小色域上（直接clip掉），以支持演示器的显示。</p>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>材质制作参数F0</title>
      <link href="/2022/07/09/Art/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E5%8F%82%E6%95%B0F0/"/>
      <url>/2022/07/09/Art/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E5%8F%82%E6%95%B0F0/</url>
      
        <content type="html"><![CDATA[<p>- <a href="#%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E5%8F%82%E6%95%B0f0">材质制作参数F0</a><br>    - <a href="#%E9%9D%9E%E9%87%91%E5%B1%9E">非金属</a><br>    - <a href="#%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8">金属材质</a><br>    - <a href="#%E5%B8%B8%E8%A7%81%E9%87%91%E5%B1%9E%E5%8F%82%E6%95%B0">常见金属参数</a></p><h1 id="材质制作参数F0"><a href="#材质制作参数F0" class="headerlink" title="材质制作参数F0"></a>材质制作参数F0</h1><h2 id="非金属"><a href="#非金属" class="headerlink" title="非金属"></a>非金属</h2><p>网上可以查到很多物体的折射率</p><p>对于非金属来说，将折射率转化成F0的公式：</p><p>$$ F0 &#x3D; \frac{(n-1)^2}{(n+1)^2} $$</p><p>不同物体的Fresnel的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Charcoal       0.04<br>Fresh asphalt  0.04<br>Worn asphalt   0.12<br>Bare soil      0.17<br>Green grass    0.25<br>Desert sand    0.40<br>New concrete   0.55<br>Ocean Ice      0.5–0.7<br>Fresh snow     0.80–0.90<br>Quartz    0.045593921<br>ice       0.017908907<br>Water     0.020373188<br>Alcohol   0.01995505<br>Glass     0.04<br>Milk      0.022181983<br>Ruby      0.077271957<br>Crystal   0.111111111<br>Diamond   0.171968833<br>Skin      0.028<br></code></pre></td></tr></table></figure><p>更多参数可以参考：<a href="https://www.btbat.com/12032.html">常见材质IOR</a>，不过因为电介质材质的IOR通常很小在渲染中一般为0.04即可。</p><p><strong>但是对于非金属的宝石之类的特殊物体，需要比较高的IOR，这个时候一般的金属工作流是不适用的，应为他需要特殊的F0</strong>.</p><p>电介质F0的定义准则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">No value under <span class="hljs-number">0.02</span><br>Common gemstones <span class="hljs-number">0.05</span><span class="hljs-number">-0.17</span><br>Common liquids <span class="hljs-number">0.02</span><span class="hljs-number">-0.04</span><br>When not finding reference <span class="hljs-keyword">for</span> a dielectric material, setting a value of <span class="hljs-number">0.04</span> (around plastic)<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="金属材质"><a href="#金属材质" class="headerlink" title="金属材质"></a>金属材质</h2><p>金属的处理和电介质是不同的。金属材料的折射率是<strong>复数</strong> ：$$ c &#x3D; n+ik $$.</p><p>金属的F0</p><p>$$  F0 &#x3D; \frac{(c-1)(c*-1)}{(c+1)(c*+1)} $$<br>其中，c*是c的共轭复数，而1代表的是真空折射率。</p><p>更复杂的推导：<a href="https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/">Memo on Fresnel equations</a></p><p>具体的各种金属的n和k的值可以在<a href="https://refractiveindex.info/">refractiveindex.info</a>中查看。这个网站同时给出了折射率、透光度等数据。他的结论也是一样的从折射率推导F0（也就是下面的R（0）),如下图：</p><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E5%8F%82%E6%95%B0F0/1575080116258.png" alt="1575080116258"></p><p>同时给出了一个基础的F0原则： The basic rule for metal is to setup a value above 0.5.</p><h2 id="常见金属参数"><a href="#常见金属参数" class="headerlink" title="常见金属参数"></a>常见金属参数</h2><p>下面有一些可以参考的F0.线性空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">               R            G            B<br>Silver      <span class="hljs-number">0.971519</span>    <span class="hljs-number">0.959915</span>    <span class="hljs-number">0.915324</span><br>Aluminium   <span class="hljs-number">0.913183</span>    <span class="hljs-number">0.921494</span>    <span class="hljs-number">0.924524</span><br>Gold        <span class="hljs-number">1</span>           <span class="hljs-number">0.765557</span>    <span class="hljs-number">0.336057</span><br>Copper      <span class="hljs-number">0.955008</span>    <span class="hljs-number">0.637427</span>    <span class="hljs-number">0.538163</span><br>Chromium    <span class="hljs-number">0.549585</span>    <span class="hljs-number">0.556114</span>    <span class="hljs-number">0.554256</span><br>Nickel      <span class="hljs-number">0.659777</span>    <span class="hljs-number">0.608679</span>    <span class="hljs-number">0.525649</span><br>Titanium    <span class="hljs-number">0.541931</span>    <span class="hljs-number">0.496791</span>    <span class="hljs-number">0.449419</span><br>Cobalt      <span class="hljs-number">0.662124</span>    <span class="hljs-number">0.654864</span>    <span class="hljs-number">0.633732</span><br>Platinum    <span class="hljs-number">0.672411</span>    <span class="hljs-number">0.637331</span>    <span class="hljs-number">0.585456</span><br></code></pre></td></tr></table></figure><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E5%8F%82%E6%95%B0F0/metalness.png" alt="metalness"></p>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>材质制作数值标准总结</title>
      <link href="/2022/07/09/Art/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/09/Art/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><p>- <a href="#%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93">材质制作数值标准总结</a></p><p>​    - <a href="#%E6%9D%90%E8%B4%A8%E5%8F%82%E6%95%B0%E8%8C%83%E5%9B%B4">材质参数范围</a></p><p>​        - <a href="#basecolorrgb-srgb">BaseColor（RGB-sRGB）</a></p><p>​            - <a href="#guidelines">Guidelines</a></p><p>​        - <a href="#metallic">Metallic</a></p><p>​            - <a href="#f0">F0</a></p><p>​            - <a href="#%E9%87%91%E5%B1%9E">金属</a></p><p>​            - <a href="#%E9%9D%9E%E9%87%91%E5%B1%9E">非金属</a></p><p>​            - <a href="#guideline">Guideline</a></p><p>​        - <a href="#roughness">Roughness</a></p><p>​            - <a href="#guideline">GuideLine</a></p><p>​        - <a href="#ao">AO</a></p><p>​            - <a href="#guidline">Guidline</a></p><p>​        - <a href="#%E6%80%BB%E7%BB%93">总结</a></p><p>​    - <a href="#gamma%E7%A9%BA%E9%97%B4">Gamma空间</a></p><p>​    - <a href="#%E9%AA%8C%E8%AF%81">验证</a></p><span id="more"></span><!-- /TOC --><h1 id="材质制作数值标准总结"><a href="#材质制作数值标准总结" class="headerlink" title="材质制作数值标准总结"></a>材质制作数值标准总结</h1><h2 id="材质参数范围"><a href="#材质参数范围" class="headerlink" title="材质参数范围"></a>材质参数范围</h2><h3 id="BaseColor（RGB-sRGB）"><a href="#BaseColor（RGB-sRGB）" class="headerlink" title="BaseColor（RGB-sRGB）"></a>BaseColor（RGB-sRGB）</h3><p>在metal&#x2F;roughness工作流中，非金属的反射颜色和金属的反射率（F0）保存在Abledo贴图中。</p><h4 id="Guidelines"><a href="#Guidelines" class="headerlink" title="Guidelines"></a>Guidelines</h4><ol><li><p>BaseColor是物体的固有色，没有色调的变化。所以对比度要比一般的DiffuseMap（画出光影的颜色贴图）低。</p></li><li><p>物体的色调往往比印象中的浅，过暗的色调无法被照亮:安全的颜色范围： 50 - 240 sRGB 或者（50-243. ）。控制得当可以使用更广的范围:  30 - 240 sRGB。（最黑的是煤炭，最亮的是雪）下面是参考范围:</p><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/1574848708374.png" alt="1574848708374"></p></li><li><p>BaseColor当中保存了非金属反射信息，所以不能包括光线本身的信息，比如：AO。但是可以添加微小的遮挡，但是当添加了微小遮挡之后，也必须在规定的亮度范围之内。</p></li></ol><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/1574843302369.png" alt="1574843302369"></p><ol start="4"><li><p>金属的折射率(就是Color)应该从实际测量中获得，通常的范围是：<strong>sRGB range of 180-255</strong>.下面是一部分金属颜色：下图是一部分可以参考的颜色：</p><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/1574839815423.png" alt="1574839815423"></p></li><li><p>如果金属出现了氧化和污渍不能被当做金属，尤其是当BaseColor当中加入了这种颜色，那么金属度也必须发生变化。</p></li></ol><h3 id="Metallic"><a href="#Metallic" class="headerlink" title="Metallic"></a>Metallic</h3><p>通常用于区分金属与非金属。通常当做Mask使用,非金属的F0通常不是手动创建的，如果一个位置的金属度是0，会把这个位置的F0当做0.04处理。</p><h4 id="F0"><a href="#F0" class="headerlink" title="F0"></a>F0</h4><p>F0&#x3D;Fresnel Reflectance at 0 Degrees</p><ol><li><p>电介质(dielectrics)  :  0.02-0.05  如果不确定可以设置成0.04</p></li><li><p>导体(conductors) :  0.5-1.0</p></li></ol><p>表面的反射率由折射率决定：</p><p>$$ F0 &#x3D;( \frac{n-1}{n+1})^2 $$</p><p>非金属（电介质&#x2F;绝缘体）应该是灰色值，金属（导体）应该是RGB值。对于光滑的表面电介质F0应该在 2%和5% of 之间,斜略角100%  他的F0变化不大。金属变化比较明显。</p><p>通常F0和导体和绝缘体相关，宝石是例外。</p><h4 id="金属"><a href="#金属" class="headerlink" title="金属"></a>金属</h4><p>我们通过折射率算出的折射光线是被吸收的光线。对于金属来说部分光线反射，折射光线直接被吸收。金属的颜色来自于折射的光线也就是F0,也就是说金属的F0就是金属的颜色。</p><p>虽然金属度为1通常是剖光金属，通常金属可以在 <strong>235-255 sRGB</strong> 之间，这个区间的材质反射率需要满足： 70-100%（Base ColorMap <strong>180-255 sRGB</strong> ）。</p><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/1574840422730.png" alt="1574840422730"></p><p>腐蚀金属在金属度贴图上是黑色，当做电介质处理。</p><p>涂漆金属被当做电介质。</p><p>污渍同样被当做非金属。</p><p>例子：</p><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/1574840762049.png" alt="1574840762049"></p><h4 id="非金属"><a href="#非金属" class="headerlink" title="非金属"></a>非金属</h4><p>非金属没有导电性，折射的光线、被散射或者被吸收（大部分会再次从表面发散出去）所以被散射和被吸收后再次发射的光线构成了Albedo颜色。但是他的折射率很低比金属底，所以颜色更低贴图中的颜色要暗。</p><p>被反射的颜色为F0，为0.02-0.05.（ 0.017-0.067 (40-75 sRGB) ），这些值通常会被硬编码成固定的0.04，特殊的：宝石会大于0.4。</p><h4 id="Guideline"><a href="#Guideline" class="headerlink" title="Guideline"></a>Guideline</h4><ol><li>腐蚀、氧化、污渍的金属不是金属,黑色的金属度，和灰色的非金属程度。</li><li>金属度应该被当做一个Mask，用来告诉Shader如何解释Albedo贴图中的颜色信息。（金属：反射率，非金属：反射颜色）</li><li>金属度不能总是0-1，在0-1之间应该有很窄的过渡灰。</li><li>金属度为0.85-1（ <strong>235-255 sRGB</strong> ）的区域需要有高于70-100%（180-255 sRGB 或者 186-255）的反射率。</li><li>如果金属度低于235 sRGB 那么需要降低对应BaseColor当中的颜色。降低程度可以根据氧化层、污渍层、腐蚀层的程度来决定。</li></ol><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/1574844210517.png" alt="1574844210517"></p><h3 id="Roughness"><a href="#Roughness" class="headerlink" title="Roughness"></a>Roughness</h3><p>描述表面不规则情况，和光线的散射程度。粗糙&#x3D;更大更黯淡的高光。</p><p>粗糙度用来描述同一种材质上的变化。磨损、折旧、风化、磨光。</p><p>粗糙度需要和法线贴图相关联。</p><h4 id="GuideLine"><a href="#GuideLine" class="headerlink" title="GuideLine"></a>GuideLine</h4><p>可以灵活的使用。</p><h3 id="AO"><a href="#AO" class="headerlink" title="AO"></a>AO</h3><p>描述环境光被遮挡。通常AO影响的是由环境贴图产生的环境光（amibient lighting）IBL。而不应该影响高光和直接光，所以不能放置在Albedo当中。尤其是对于金属，如果加到了Aldedo当中，对IBL和高光的影响会更加明显。</p><h4 id="Guidline"><a href="#Guidline" class="headerlink" title="Guidline"></a>Guidline</h4><p>从高度图或者根据模型烘焙生成。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/79369760-f4dd-4823-b2de-64a54e85ff8e.png" alt="img"></p><h2 id="Gamma空间"><a href="#Gamma空间" class="headerlink" title="Gamma空间"></a>Gamma空间</h2><p>需要被标记为Gamma的贴图：base color, diffuse, specular 和emissive. </p><p>需要被标记为线性空间的： roughness, ambient occlusion, normal, metallic, and height.</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>SD:</p><p><em>PBR Metal&#x2F;Roughness Validate</em> ：</p><p><strong>Material Filters &gt; PBR Utilities</strong>. 可以进行材质颜色、金属度的验证。</p><p>错-》对 ： 红&gt; 黄&gt; 绿</p><p>SP:</p><p><em>PBR Metal&#x2F;Roughness Validate (filter)</em> <a href="https://share.allegorithmic.com/libraries/824The">下载链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HDRColorGrading技术方案</title>
      <link href="/2022/07/09/Art/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
      <url>/2022/07/09/Art/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>- <a href="#hdrcolorgrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88">HDRColorGrading技术方案</a></p><p>​    - <a href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B">整体流程</a></p><p>​    - <a href="#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B">详细流程</a></p><p>​        - <a href="#pq%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2">PQ空间转换</a></p><p>​        - <a href="#amplify">Amplify</a></p><p>​        - <a href="#pg%E7%A9%BA%E9%97%B4colorgrading">PG空间ColorGrading</a></p><p>​        - <a href="#%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4tonemapping">线性空间ToneMapping</a></p><p>​        - <a href="#%E6%98%BE%E7%A4%BA%E5%99%A8%E4%BA%AE%E5%BA%A6%E9%85%8D%E9%80%82">显示器亮度配适</a></p><p>​            - <a href="#%E5%AF%B9%E4%BA%8Ehdr%E6%98%BE%E7%A4%BA%E5%99%A8">对于hdr显示器</a></p><p>​            - <a href="#%E5%AF%B9%E4%BA%8Esdr%E6%98%BE%E7%A4%BA%E5%99%A8">对于sdr显示器</a></p><p>​        - <a href="#tonemapping">ToneMapping</a></p><p>​            - <a href="#hdr%E6%98%BE%E7%A4%BA%E5%99%A8displaymapping%E6%9B%B2%E7%BA%BF%E8%AE%BE%E8%AE%A1">hdr显示器Displaymapping曲线设计</a></p><p>​            - <a href="#sdr%E6%98%BE%E7%A4%BA%E5%99%A8display-mapping%E6%9B%B2%E7%BA%BF%E8%AE%BE%E8%AE%A1">Sdr显示器Display Mapping曲线设计</a></p><p>​        - <a href="#gumatmapping">GumatMapping</a></p><p>​    - <a href="#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%E5%88%B6%E4%BD%9C">相关资源制作</a></p><p>​        - <a href="#davinci-colorgrading-lut%E5%88%B6%E4%BD%9C">DaVinCi ColorGrading Lut制作</a></p><p>​        - <a href="#%E5%BC%95%E6%93%8E%E4%B8%AD%E5%AF%BC%E5%87%BA%E5%9B%BE%E7%89%87%E6%88%96%E8%A7%86%E9%A2%91">引擎中导出图片或视频</a></p><p>​        - <a href="#davinci%E8%AE%BE%E7%BD%AE">DaVinCi设置</a></p><p>​        - <a href="#davinci%E5%AF%BC%E5%85%A5%E5%9B%BE%E7%89%87">DaVinCi导入图片</a></p><p>​        - <a href="#lut%E5%AF%BC%E5%87%BAcube">Lut导出cube</a></p><p>​        - <a href="#cube%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E5%BC%95%E6%93%8E%E5%8F%AF%E7%94%A8%E7%9A%84lut">cube文件转换成引擎可用的lut</a></p><span id="more"></span><h1 id="HDRColorGrading技术方案"><a href="#HDRColorGrading技术方案" class="headerlink" title="HDRColorGrading技术方案"></a>HDRColorGrading技术方案</h1><p>为了兼容HDR显示屏和SDR显示屏，重新设计了ColorGading和ToneMapping的技术方案。</p><p>重点是合理控制颜色空间、亮度和显示器的配适。</p><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>首先整体流程：</p><ol><li><p>定义lighting Render Target，格式为R16G16B16A16.</p></li><li><p>光照计算结果需进行限制：65535，这部分是为了防止数据溢出。</p></li><li><p>进行HDR阶段的后处理。</p></li><li><p>HDR最后阶段：PQ空间的ColorGrading。这里需要有一个信号放大，用来缩放屏幕亮度和nits的匹配关系。</p></li><li><p>针对nits的ToneMapping：根据显示器的nits值选择对应的ToneMapping曲线。</p></li></ol><blockquote><p>  为了能够更好地控制亮度的变化，我尝试使用显示器的nits值来做不同的ToneMapping。sdr为100nits, hdr为10000nits。sdr执行高强度的mapping，hdr执行低强度的mapping。其实原理和很简单，只要对颜色亮度做一个压缩，调整一下亮度范围即可。</p></blockquote><ol start="6"><li>Gamut Mapping。</li><li>配适显示器亮度曲线。</li></ol><p>颜色处理部分的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> Amplify = <span class="hljs-number">3</span>;<br><span class="hljs-type">float</span> ExposureFract = <span class="hljs-number">0.0001</span> * Amplify;<br><br>HDRColor *= ExposureFract;<br>float3 pqSpace = InvertPQcurve(saturate(HDRColor));<br><br><span class="hljs-comment">//PQ SPACE ColorLookupTable</span><br><br>HDRColor = PQcurve(pqSpace);<br>HDRColor /= ExposureFract;<br><br><span class="hljs-comment">// HDR Display</span><br>&#123;<br>OUT.Color.xyz = ToneMapping1(HDRColor * Amplify);<br>&#125;<br><span class="hljs-comment">// LDR Display</span><br>&#123;<br>OUT.Color.xyz = ToneMapping2(HDRColor * Amplify);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h2><p>这部分说明关键步骤详细流程。</p><h3 id="PQ空间转换"><a href="#PQ空间转换" class="headerlink" title="PQ空间转换"></a>PQ空间转换</h3><p>这里我们使用PQ空间，这样使用更多的数据位表示暗部数据。</p><blockquote><p>  Note:</p><p>  这里对于哪个空间更好还是存疑的，因为使用PQ曲线是寒霜引擎的推荐（但是他针对的是端游），同时最后一步还要执行一次PQ，这样精度损失理论上是最小，不过还需要测试和对比。</p></blockquote><p>PQ空间转换代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 <span class="hljs-title function_">InvertPQcurve</span><span class="hljs-params">(float3 x)</span>&#123;<br>    <span class="hljs-type">float</span> c2 = <span class="hljs-number">2413.0</span> / <span class="hljs-number">128</span>;<br>    <span class="hljs-type">float</span> c3 = <span class="hljs-number">2392.0</span> / <span class="hljs-number">128</span>;<br>    <span class="hljs-type">float</span> c1 = c3 - c2 + <span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">float</span> m1 = <span class="hljs-number">1305.0</span> / <span class="hljs-number">8192</span>;<br>    <span class="hljs-type">float</span> m2 = <span class="hljs-number">2523.0</span> / <span class="hljs-number">32</span>;<br><br>    float3 y = <span class="hljs-built_in">pow</span>( (c1 +  c2 * <span class="hljs-built_in">pow</span>(x,m1) )/(<span class="hljs-number">1</span> +  c3 * <span class="hljs-built_in">pow</span>(x,m1)), m2);<br>    <span class="hljs-keyword">return</span> y ;<br>&#125;<br></code></pre></td></tr></table></figure><p>PQ空间还原代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">def <span class="hljs-title function_">PQcurve</span><span class="hljs-params">(x)</span>:<br>    c2 = <span class="hljs-number">2413.0</span> / <span class="hljs-number">4096</span> * <span class="hljs-number">32</span><br>    c3 = <span class="hljs-number">2392.0</span> / <span class="hljs-number">4096</span> * <span class="hljs-number">32</span><br>    c1 = <span class="hljs-number">3424</span> / <span class="hljs-number">4096</span> <br>    m1 = <span class="hljs-number">2610.0</span> / <span class="hljs-number">4096</span> / <span class="hljs-number">4</span><br>    m2 = <span class="hljs-number">2523.0</span> / <span class="hljs-number">4096</span> * <span class="hljs-number">128</span><br><br>    y = <span class="hljs-built_in">pow</span>((<span class="hljs-built_in">pow</span>(x,<span class="hljs-number">1</span>/m2)-c1) / (c2-c3*<span class="hljs-built_in">pow</span>(x,<span class="hljs-number">1</span>/m2)), <span class="hljs-number">1.0</span>/m1)<br>    <span class="hljs-keyword">return</span> y <br></code></pre></td></tr></table></figure><p>PQ空间曲线：</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590136497248.png" alt="1590136497248"></p><h3 id="Amplify"><a href="#Amplify" class="headerlink" title="Amplify"></a>Amplify</h3><p>为了更好的配适亮度，需要一个缩放Amplify，模拟拍摄过程中的模拟信号放大。</p><h3 id="PG空间ColorGrading"><a href="#PG空间ColorGrading" class="headerlink" title="PG空间ColorGrading"></a>PG空间ColorGrading</h3><p>进入PQ空间之后采样制作好的PQ空间LUT：</p><p>这一步结束之后HDR的ColorGrading就制作完成了。</p><h3 id="线性空间ToneMapping"><a href="#线性空间ToneMapping" class="headerlink" title="线性空间ToneMapping"></a>线性空间ToneMapping</h3><p>颜色制作完成之后，我们就需要执行tonemap </p><blockquote><p>   Note:</p><p>  我还是考虑使用计算方式的tonemap，不过大部分项目都选择把ToneMapping结合到lut当中去，这里也可以延续这个做法。</p><p>  但是有个关键的问题是ColorGrading可以用来修改气氛，不同的场景是可以修改的，并且最好sdr和hdr使用同一套内容。所以优先希望简化tonemapping曲线，而不是合并lut。</p></blockquote><p>针对不同的显示器需要不同的曲线。</p><h3 id="显示器亮度配适"><a href="#显示器亮度配适" class="headerlink" title="显示器亮度配适"></a>显示器亮度配适</h3><blockquote><p>  在输出之前要确定亮度正确的编码，以被不同的显示器正确显示。</p></blockquote><h4 id="对于hdr显示器"><a href="#对于hdr显示器" class="headerlink" title="对于hdr显示器"></a>对于hdr显示器</h4><p>如果使用R10G10B10A2格式（目前确认过，HDR支持全部使用这种格式）需要使用PQ曲线进行mapping。</p><p>如果使用R16G16B16，使用线性缩放。</p><h4 id="对于sdr显示器"><a href="#对于sdr显示器" class="headerlink" title="对于sdr显示器"></a>对于sdr显示器</h4><p>如果使用sRGB8，使用线性压缩。</p><p>如果使用RGB8U，使用Gamma曲线mapping。</p><h3 id="ToneMapping"><a href="#ToneMapping" class="headerlink" title="ToneMapping"></a>ToneMapping</h3><h4 id="hdr显示器Displaymapping曲线设计"><a href="#hdr显示器Displaymapping曲线设计" class="headerlink" title="hdr显示器Displaymapping曲线设计"></a>hdr显示器Displaymapping曲线设计</h4><p>可以考虑使用UE的FilmToneMapping，这部分会和Sdr显示器有较大区别。</p><h4 id="Sdr显示器Display-Mapping曲线设计"><a href="#Sdr显示器Display-Mapping曲线设计" class="headerlink" title="Sdr显示器Display Mapping曲线设计"></a>Sdr显示器Display Mapping曲线设计</h4><p>目前根据常规做法，可以使用ACESFilmToneMapppiong曲线。</p><blockquote><p>  Note</p><p>  当然也可以使用UE的Filmic，不过参数完全不同，效果也一样会有所差别。</p></blockquote><h3 id="GumatMapping"><a href="#GumatMapping" class="headerlink" title="GumatMapping"></a>GumatMapping</h3><p>颜色空间的映射需要确定，目前来看是没有进行任何mapping。</p><h2 id="相关资源制作"><a href="#相关资源制作" class="headerlink" title="相关资源制作"></a>相关资源制作</h2><h3 id="DaVinCi-ColorGrading-Lut制作"><a href="#DaVinCi-ColorGrading-Lut制作" class="headerlink" title="DaVinCi ColorGrading Lut制作"></a>DaVinCi ColorGrading Lut制作</h3><p>需要制作的资源主要是lut。</p><h3 id="引擎中导出图片或视频"><a href="#引擎中导出图片或视频" class="headerlink" title="引擎中导出图片或视频"></a>引擎中导出图片或视频</h3><p><strong>导出的图片是linear空间的hdr数据，直接进行PQ编码，得到PQ编码后的文件。此时的数据范围为：0-1.</strong></p><h3 id="DaVinCi设置"><a href="#DaVinCi设置" class="headerlink" title="DaVinCi设置"></a>DaVinCi设置</h3><p>我们所有的设置都在HDR的PQ空间中进行。所以对于不同的显示器只需要用同一个LUT即可。</p><p>DaVinCi的设置大部分保持默认，LookUpTabbles保证为空：</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590733135642.png" alt="1590733135642"></p><p>在HDR显示器上进行Lut制作时的设置：</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590733737966.png" alt="1590733737966"></p><p>在SDR显示器上进行Lut制作时的设置，<strong>这里设置取决于我们如何执行Gamut Mapping</strong>，也可以保持和HDR一样：</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590734156399.png" alt="1590734156399"></p><p>我们不需要开启Node的HDR mode，只是控制有所区别，对于结果没有影响。</p><h3 id="DaVinCi导入图片"><a href="#DaVinCi导入图片" class="headerlink" title="DaVinCi导入图片"></a>DaVinCi导入图片</h3><p>直接将图片拖拽到Clip中即可，然后打开Color面板进行调整。</p><h3 id="Lut导出cube"><a href="#Lut导出cube" class="headerlink" title="Lut导出cube"></a>Lut导出cube</h3><p>完成设置后右键clip点击Generate 3D LUT(33 Point Cube)即可。</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590735234391.png" alt="1590735234391"></p><p>此时我们会得到一张.cube文件，大小为33 * 33 * 33的三维纹理。</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590736942822.png" alt="1590736942822"></p><h3 id="cube文件转换成引擎可用的lut"><a href="#cube文件转换成引擎可用的lut" class="headerlink" title="cube文件转换成引擎可用的lut"></a>cube文件转换成引擎可用的lut</h3><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590736912628.png" alt="1590736912628"></p><p>下面我们要把从DaVinCi当中导出的.cube文件转化成二维纹理。</p><p>打开PS，加载默认的LUT文件（就是netrual lut，不对图像产生影响的lut）。</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590739624304.png" alt="1590739624304"></p><p>确定颜色模式为RGB</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590739649754.png" alt="1590739649754"></p><p>开启颜色查找功能：</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590739676967.png" alt="1590739676967"></p><p>使用默认选项点击确认，得到lut图层：</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590739706978.png" alt="1590739706978"></p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590739721058.png" alt="1590739721058"></p><p>下面是LUT的图层控制面板：</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590739883952.png" alt="1590739883952"></p><p>配置完成之后就得到了修改好的lut，保存成非压缩的png即可：</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590739972583.png" alt="1590739972583"></p><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>色彩表示的前世今生</title>
      <link href="/2022/07/09/Art/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/2022/07/09/Art/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="色彩表示的前世今生"><a href="#色彩表示的前世今生" class="headerlink" title="色彩表示的前世今生"></a>色彩表示的前世今生</h1><h2 id="眼睛"><a href="#眼睛" class="headerlink" title="眼睛"></a>眼睛</h2><p>因此，彩色光的表观亮度的变化是由于棒效应的叠加造成的，在视杆细胞上只刺激光感</p><p>眼睛的亮度感受： 10000:1<br>眼睛的色彩接收器：Rods and Cones<br>因此，光敏感曲线和暗敏感曲线基本上是单独作用于视锥细胞和视杆细胞的<br>猫的眼睛受视杆细胞支配。</p><h2 id="首先是从波长到颜色感知-CIE-1931-color-space来源-wiki"><a href="#首先是从波长到颜色感知-CIE-1931-color-space来源-wiki" class="headerlink" title="首先是从波长到颜色感知-CIE 1931 color space来源 wiki"></a><strong>首先是从波长到颜色感知</strong>-CIE 1931 color space来源 <a href="https://en.wikipedia.org/wiki/CIE_1931_color_space">wiki</a></h2><p>CIE是国际照明委员会（ <a href="https://en.wikipedia.org/wiki/International_Commission_on_Illumination">International Commission on Illumination</a>）的缩写。制定了与光和颜色相关的国际标准。</p><p>CIE 1931颜色空间是第一个在<strong>电磁可见光谱中波长分布</strong>（波长）和人类色觉中生理感知的颜色（颜色）之间的定量联系。</p><p>定义这些颜色空间的数学关系是颜色管理的基本工具，在处理彩色油墨、发光显示器和数字相机等记录设备时非常重要。</p><span id="more"></span><h2 id="从色彩感知要色彩表示"><a href="#从色彩感知要色彩表示" class="headerlink" title="从色彩感知要色彩表示"></a>从色彩感知要色彩表示</h2><p>CIE与1931年提出了 <strong>CIE 1931 RGB color space</strong> 和 <strong>CIE 1931 XYZ color space</strong>。从实验得出的标准。</p><p>将实验结果结合到CIE RGB颜色空间，又推到得到了CIE XYZ颜色空间。</p><h2 id="三色表示"><a href="#三色表示" class="headerlink" title="三色表示"></a>三色表示</h2><h3 id="LMS-color-space"><a href="#LMS-color-space" class="headerlink" title="LMS color space"></a>LMS color space</h3><p>LMS(长、中、短)是一个颜色空间，它代表了人眼三种视锥细胞的反应，以它们在长、中、短波长的响应(灵敏度)峰值命名。</p><p><strong>数值范围通常不指定，只是下端通常以0为界。</strong>在进行颜色适应(估计样品在不同光源下的外观)时，通常使用LMS颜色空间。它在色盲的研究中也很有用，当一个或多个锥体类型有缺陷时。</p><p><strong>视力正常的人眼有三种感知光的视锥细胞。</strong>（简而言之，具有光谱灵敏度的峰值 (“S”, 420 nm – 440 nm), middle (“M”, 530 nm – 540 nm), and long (“L”, 560 nm – 580 nm) ）</p><p><strong>下图是波长和感知能力的对应和亮度没有关系。</strong></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1280px-Cones_SMJ2_E.svg.png" alt="1280px-Cones_SMJ2_E.svg"></p><p>这些视锥细胞构建了对中、高亮度感知的基本能力。在很暗的环境下色觉减弱。</p><p>对于低亮度、单色的夜视感知器叫做视杆细胞.</p><p>三个颜色的强度对应三种视锥细胞的刺激水平，原则上描述任何人类的颜色感觉。根据三种视锥细胞的光谱灵敏度对总光功率谱进行加权，得到三种刺激的有效值。显示器就的制造就是来分别刺激三个颜色视锥细胞。这三个值构成了光谱客观颜色的三刺激规范。</p><p>这三个参数分别表示为“S”、“M”和“L”，并使用一个名为“LMS颜色空间”的三维空间表示，LMS颜色空间是用来量化人类颜色视觉的众多颜色空间之一</p><h3 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h3><p>与颜色空间相关的三色刺激值可以在三色加色的颜色模型中被概念化为三原色的数量。</p><p>颜色空间将物理的混合光线映射到一个人眼的客观感觉范围，但并不是在LMS空间（视锥细胞感知铭感度）与颜色空间相关的三色刺激值可以在三色加色的颜色模型中被概念化为三原色的数量。</p><p><strong>在某些颜色空间中，包括LMS和XYZ空间，使用的原色不是真正的颜色，因为它们不能在任何光谱中生成。</strong></p><p><strong>因为：LMS描述了三个分量，但是在光谱上他们是重合的。因此，某些三刺激值在物理上是不可能的，例如LMS三刺激值对于M分量为非零，对于L和S分量都为零。</strong></p><h2 id="XYZ颜色空间"><a href="#XYZ颜色空间" class="headerlink" title="XYZ颜色空间"></a>XYZ颜色空间</h2><p>CIE XYZ颜色空间包含了对视力一般的人可见的所有颜色感觉。它是定义许多其他颜色空间的标准参考。他的三坐标位置，例如主位置[1,0,0]、[0,1,0]和[0,0,1]，对应于可能的LMS坐标空间之外的假想颜色。假想的颜色不符合任何波长的光谱分布，因此没有物理现实。</p><h2 id="颜色三角形"><a href="#颜色三角形" class="headerlink" title="颜色三角形"></a>颜色三角形</h2><p>对于加法模型来说，描述了颜色的分布，三原色位于三个顶点。颜色可能超过这个范围。出现某个通道的负数，色品范围不是三角形，无法覆盖。</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/CIExy1931_srgb_gamut.png" alt="CIExy1931_srgb_gamut"></p><h3 id="光度函数"><a href="#光度函数" class="headerlink" title="光度函数"></a>光度函数</h3><p>人类倾向于认为光谱中绿色部分的光比同等功率的红色或蓝色光更亮,因此，描述不同波长感知亮度的光度函数与M锥的光谱灵敏度大致类似。</p><h3 id="XYZ推到"><a href="#XYZ推到" class="headerlink" title="XYZ推到"></a>XYZ推到</h3><p>CIE模型利用了这一事实，将Y设为亮度。Z等于蓝色，或者说S锥响应，X是非负响应曲线的组合。将Y设为亮度，得到的有用结果是，对于任何给定的Y值，XZ平面将包含该亮度下所有可能的色度</p><p><strong>三刺激值的单位X、Y和Z通常是任意选择的，因此Y &#x3D; 1或Y &#x3D; 100是彩色显示器所支持的最亮的白色。</strong></p><h2 id="CIE-xy-chromaticity-diagram-and-the-CIE-xyY-color-space"><a href="#CIE-xy-chromaticity-diagram-and-the-CIE-xyY-color-space" class="headerlink" title="CIE xy chromaticity diagram and the CIE xyY color space"></a>CIE xy chromaticity diagram and the CIE xyY color space</h2><p>将色品和亮度分离，下面的图片是色度图</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/300px-CIE-1931_diagram_in_LAB_space.svg-1582861390979.png" alt="300px-CIE-1931_diagram_in_LAB_space.svg"></p><ul><li>该图代表了普通人可见的所有色度，色域的弯曲边缘称为光谱轨迹，对应于单色光（每个点代表一个单一波长的纯色调）。色域下半部分的直线称为紫色线，这些颜色虽然处于色域的边缘，但在单色光中没有对应的颜色。较不饱和的颜色出现在图的内部，白色在中间</li><li></li></ul><h2 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h2><h2 id="颜色标准"><a href="#颜色标准" class="headerlink" title="颜色标准"></a>颜色标准</h2><p> IEC 61966-2-2  scRGB</p><h2 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h2><p>色域都是 100% SRGB<br>对比度 1000:1&#x2F;3000:1&#x2F;1000:1&#x2F;1000:1 </p><h1 id="Illuminant-D65"><a href="#Illuminant-D65" class="headerlink" title="Illuminant D65"></a>Illuminant D65</h1><p>D65大致相当于西欧&#x2F;北欧的平均正午光(包括直射光和晴空散射光)，因此它也被称为日光发光体。</p><p><strong>D65是一个表格式的SPD，从300nm到830nm递增5 nm的光谱分布。</strong></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/SPD_D65.png" alt="SPD_D65"></p><h2 id="色温"><a href="#色温" class="headerlink" title="色温"></a>色温</h2><p>黑体辐射</p><p><strong>黑体辐射</strong>指处于热力学平衡态的<strong>黑体</strong>发出的电磁<strong>辐射</strong>。 <strong>黑体辐射</strong>的电磁波谱只取决于<strong>黑体</strong>的温度。 另一方面，所謂<strong>黑體輻射</strong>其實就是光和物質達到平衡所表現出的現象。</p><p>在<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%AD%A6">物理学</a>中，<strong>普朗克黑体辐射定律</strong>（也简称作<strong>普朗克定律</strong>或**<a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E4%BD%93%E8%BE%90%E5%B0%84">黑体辐射</a>定律<strong>，英文：</strong>Planck’s law**, <strong>Blackbody radiation law</strong>）。</p><h3 id="黑体-wiki"><a href="#黑体-wiki" class="headerlink" title="黑体 wiki"></a>黑体 <a href="%5Bhttps://zh.wikipedia.org/wiki/%E9%BB%91%E4%BD%93_(%E7%89%A9%E7%90%86%E5%AD%A6)%5D(https://zh.wikipedia.org/wiki/%E9%BB%91%E4%BD%93_(%E7%89%A9%E7%90%86%E5%AD%A6)">wiki</a></h3><p>​黑体对于任何<a href="https://zh.wikipedia.org/wiki/%E6%B3%A2%E9%95%BF">波长</a>的<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E7%A3%81%E6%B3%A2">电磁波</a>的吸收系数为1，<a href="https://zh.wikipedia.org/wiki/%E9%80%8F%E5%B0%84%E4%BF%82%E6%95%B8">透射系数</a>为0。但黑体未必是黑色的，即使不反射任何的电磁波，它也可以放出电磁波，而这些电磁波的波长和能量则全取决于黑体的<a href="https://zh.wikipedia.org/wiki/%E6%BA%AB%E5%BA%A6">温度</a>，不因其他因素而改变。</p><p>​对于人的视觉而言，黑体在700<a href="https://zh.wikipedia.org/wiki/%E7%B5%95%E5%B0%8D%E6%BA%AB%E6%A8%99">K</a>以下时看起来是黑色的，这是由于在700K之下的黑体所放出来的辐射能量很小且辐射波长在<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E8%A6%8B%E5%85%89">可见光</a>范围之外。若黑体的温度高过上述的温度的话，黑体则不会再是黑色的了，它会开始变成红色，并且随着温度的升高，而分别有橘色、黄色、白色等颜色出现，即黑体吸收和放出电磁波的过程遵循了<a href="https://zh.wikipedia.org/wiki/%E5%85%89%E8%AD%9C">光谱</a>，其<a href="https://zh.wikipedia.org/wiki/%E8%BD%A8%E8%BF%B9">轨迹</a>为普朗克轨迹（或称为黑体轨迹）。<a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E9%AB%94%E8%BC%BB%E5%B0%84">黑体辐射</a>实际上是黑体的<a href="https://zh.wikipedia.org/wiki/%E7%86%B1%E8%BC%BB%E5%B0%84">热辐射</a>。在黑体的光谱中，<strong>由于高温引起高频率即短波长</strong>，因此较高温度的黑体靠近光谱结尾的蓝色区域而较低温度的黑体靠近红色区域。</p><h2 id="色温-1"><a href="#色温-1" class="headerlink" title="色温"></a>色温</h2><p>从理想黑体发射出的电磁辐射的<strong>色温定义为其表面温度</strong>，单位为开尔文或微观倒数度(深陷于)。<strong>这样就可以定义一个比较光源的标准。</strong></p><h2 id="色彩平衡"><a href="#色彩平衡" class="headerlink" title="色彩平衡"></a>色彩平衡</h2><h2 id="显示器的色域、色数、对比度"><a href="#显示器的色域、色数、对比度" class="headerlink" title="显示器的色域、色数、对比度"></a>显示器的色域、色数、对比度</h2><p>2.显示器是彩色的，显示器的彩色是由红绿蓝三色混合而成，刚才计算出每个颜色可以有256级的灰阶变化，那三种颜色可以有多少变化呢？就是256的3次方，256^3&#x3D;16777216，也就是1670万。</p><p>同样的方法，计算6bit&#x2F;10bit，结果分别是26万&#x2F;10亿。</p><p>色域 sRGB 100%   sRGB124%   Adobe RGB≥99.5%</p><p>色数 16.7M   1.07B  </p><p>可视角度 IPS 178°&#x2F;178°(CR&gt;10)</p><p>对比度   1000:1    3000:1    4000:1  20000000：1（动态）</p><p>基本定义：对比度简单些的定义是显示器的白色亮度与黑色亮度的比值。比如一台显示器在显示全白画面（255）时实测亮度值为200cd&#x2F;㎡，全黑画面实测亮度为0.5cd&#x2F;㎡，那么它的对比度就是400：1。</p><p>亮度 220 cd&#x2F;m2  300cd&#x2F;m2   450nits, 350nits, 280nits  720 cd &#x2F;m?（标准），1000 cd &#x2F;m?（峰值） 4000 nits</p><h2 id="Nivida对HDR的定义："><a href="#Nivida对HDR的定义：" class="headerlink" title="Nivida对HDR的定义："></a>Nivida对HDR的定义：</h2><ul><li><p>Deep blacks: Contrast of 50k:1 or better ：More contrast and detail in shadows</p></li><li><p>4K or higher resolution</p></li><li><p>Wide color gamut  ：Richer colors</p></li><li><p>Bright display: 750 cm&#x2F;m  minimum, 1000-10,000 cd&#x2F;m 2 highlights ：Realistic highlights</p></li></ul><p><strong>HDR isn’t simply about making brighter images</strong></p><p>亮度的增加 会带来：</p><p>色彩饱和度的感知提升。</p><p>空间分辨能力提升。</p><h1 id="Tonemapping"><a href="#Tonemapping" class="headerlink" title="Tonemapping"></a>Tonemapping</h1><p><strong>No one true tone mapper, choice depends on the desired aesthetics</strong></p><p><strong>For best results in HDR the tone mapper must understand the output luminance range of the display.</strong></p><h2 id="亮度和HDR的关系"><a href="#亮度和HDR的关系" class="headerlink" title="亮度和HDR的关系"></a>亮度和HDR的关系</h2><p><a href="https://developer.nvidia.com/displaying-hdr-nuts-and-bolts">https://developer.nvidia.com/displaying-hdr-nuts-and-bolts</a></p><p>First, as has been the case since Windows Vista, fp16 swap chains are expected to have linear color data. By this I mean that there is no gamma encoding. Secondly, with traditional displays, 1.0 always just meant the brightest intensity. With HDR, things have moved to a color space based on scRGB and a scheme where the value represents an absolute output level rather than a relative one. </p><p>Now, 1.0 is interpreted as the level of 80 nit white. This is the standard white level set by the sRGB standard for displays, and it is probably a white at or slightly dimmer compared to the white for the monitor you are reading this on. 12.5 represents the 1000 nit white that is the practical limit for most HDR displays you can buy today. </p><h1 id="摄像设备色彩压缩"><a href="#摄像设备色彩压缩" class="headerlink" title="摄像设备色彩压缩"></a>摄像设备色彩压缩</h1><p><a href="https://www.rocketstock.com/blog/tips-for-log-color-space-compositing/">https://www.rocketstock.com/blog/tips-for-log-color-space-compositing/</a></p><p>现在，几乎所有的相机制造商都提供自己的对数曲线(或多个)，摄像设备通常保存数据，使用了对数空间，厂商常用的空间包括 <strong>S-Log 2&amp;3</strong> (Sony), <strong>LogC</strong> (Arri), <strong>Canon Log</strong>, <strong>V-Log</strong> (panasonic), <strong>Red Logfilm</strong>, <strong>Blackmagic Log</strong>,。，这条曲线通常会根据传感器信息定制曲线，它们每一个都是不同的，通常是为特定制造商的产品的颜色科学定制的。<strong>目的就是:就能够保存尽可能多的传感器信息（并非为人眼保存，而是为了保存更多的原始数据）。</strong>它对摄像机看到的东西进行对数编码.</p><p>线性色彩空间具有恒定不变的亮度值，与场景中的精确数学值一致。在人眼看来，这将看起来非常黑暗和泥泞的某些地区和过度暴露的其他，<strong>因为我们的眼睛(和监视器的问题)看到的颜色不同于他们的确切亮度值</strong>,可以看到更多的细节在光明和黑暗的领域。.因此，我们必须应用一个不同的颜色空间，以更美观的方式看到颜色信息</p><ol><li><p>就像我们看到了，这个曲线向上推，以保留更多的阴影数据。</p></li><li><p>Rec. 709并不是一个完全线性的颜色空间，但它更接近于线性而不是对数。</p></li><li><p><strong>convert your CGI element from Rec. 709 to Log</strong>.</p></li></ol><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/Log-Curve.jpg" alt="Understanding LOG and Color Space In Compositing — LOG vs Linear"></p><p><strong>在特效合成领域</strong> ，例如：AE软件。我们的VFX特效数据通常是。</p><p>我们的拍摄素材是log空间的，这样各种素材才能保证尽可能多的数据，和准确度。但是我们的素材、特效通常是在Gamma空间的（接近线性空间），所以我们需要将素材转换到log空间。通常我们使用LUT表。可以执行颜色空间转换。可以将我们的素材转换到log空间。为了看到正确的结果，我们在把整个图像从log空间转换回sRGB空间。</p><p>影视大量的使用了Rec709颜色的特效和Log的背景。</p><p><img src="https://i1.wp.com/www.xdcam-user.com/wp-content/uploads/2014/10/Slide12.jpg?resize=474,356" alt="Slide12 Using S-log2 and S-Log3 from the A7S (色彩表示的前世今生/Slide12.jpg) in post production."></p><p>wiki的资料</p><p><a href="https://en.wikipedia.org/wiki/Log_profile">https://en.wikipedia.org/wiki/Log_profile</a></p><h1 id="Gamma"><a href="#Gamma" class="headerlink" title="Gamma"></a>Gamma</h1><p>Gamma编码：</p><p>A gamma value &lt; 1 is sometimes called an <strong>encoding gamma</strong>{会让颜色变亮}, and the process of encoding with this compressive power-law nonlinearity is called <strong>gamma compression</strong>; </p><p>conversely a gamma value &gt; 1 is called a <strong>decoding gamma</strong> and the application of the expansive power-law nonlinearity is called <strong>gamma expansion</strong>.</p><p>图像Gamma编码的作用：</p><p>Gamma encoding of images is used to <strong>optimize the usage of bits</strong> when encoding an image, or bandwidth used to transport an image, by taking <strong>advantage of the non-linear manner in which humans perceive light and color。</strong></p><p>The human perception of brightness, under common illumination conditions (<strong>neither pitch black nor blindingly bright</strong>), follows an approximate <a href="https://en.wikipedia.org/wiki/Power_function">power function</a> <strong>(note: no relation to the <a href="https://en.wikipedia.org/wiki/Gamma_function">gamma function</a>),</strong> with greater sensitivity to relative differences between darker tones than between lighter tones, consistent with the <a href="https://en.wikipedia.org/wiki/Stevens_power_law">Stevens power law</a> for brightness perception.</p><p>计算机显示器的Gamma：</p><p>In most computer display systems, images are encoded with a gamma of about 0.45 and decoded with the reciprocal gamma of 2.2. </p><p>CRT中Gamma作用：</p><p>Output to CRT-based television receivers and monitors does not usually require further gamma correction, since the standard video signals that are transmitted or stored in image files incorporate gamma compression that provides a pleasant image after the gamma expansion of the CRT</p><p>Although gamma encoding was developed originally to compensate for the input–output characteristic of <a href="https://en.wikipedia.org/wiki/Cathode_ray_tube">cathode ray tube</a> (CRT) displays, that is not its main purpose or advantage in modern systems. In CRT displays, the light intensity varies nonlinearly with the electron-gun voltage. **Altering the input signal by gamma compression can cancel this nonlinearity, such that the output picture has the intended luminance. **。</p><p>文件保存机制</p><p>The pixel’s intensity values in a given image file; that is, the binary pixel values are stored in the file in such way that they <strong>represent the light intensity via gamma-compressed values instead of a linear encoding</strong>. This is done systematically with digital video files (as those in a <a href="https://en.wikipedia.org/wiki/DVD">DVD</a> movie), in order to <strong>minimize the gamma-decoding step while playing, and maximize image quality for the given storage.</strong> </p><h1 id="显示器测试"><a href="#显示器测试" class="headerlink" title="显示器测试"></a>显示器测试</h1><p>一个HDR显示器支持的SwapChain格式：</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1583807985870.png" alt="1583807985870"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSurfaceFormatKHR</span> &#123;</span><br>    VkFormat           format;<br>    VkColorSpaceKHR    colorSpace;<br>&#125; VkSurfaceFormatKHR;<br><br><span class="hljs-comment">// Format进入swapchain的自动转码、读取的自动解码。</span><br>VK_FORMAT_B8G8R8A8_UNORM  +  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR<br>VK_FORMAT_B8G8R8A8_SRGB  +  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR<br>VK_FORMAT_R16G16B16A16_SFLOAT + VK_COLOR_SPACE_HDR10_ST2084_EXT<br><br></code></pre></td></tr></table></figure><p>VK_FORMAT_B8G8R8A8_SRGB ： specifies a four-component, 32-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit R component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3.<br>A通道是线性的。</p><p>VK_FORMAT_B8G8R8A8_SRGB：specifies a four-component, 32-bit unsigned normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3</p><p><strong>format 的作用</strong>：While the format of a presentable image refers to the encoding of each pixel, </p><p><strong>color space 的作用</strong>： the colorSpace determines how the presentation engine interprets the pixel values. 显示器。A color space in this document refers to a specific color space (defined by the chromaticities of its primaries and a white point in CIE Lab), and a transfer function that is applied before storing or transmitting color data in the given color space. 读取和写入的时候执行转换操作。</p><p>On the other hand, <strong>non-*_SRGB formats</strong> will be very likely exposed in pair with a <strong>SRGB color space.</strong> <strong>This means, the hardware will not apply any transfer function when reading from or writing to such images, yet they will still be presented on a device with sRGB display characteristics</strong></p><p><strong>normalized :表示0-1</strong></p><h3 id="测试1-输入线性数据-sRGB纹理-sRGB-EOTF"><a href="#测试1-输入线性数据-sRGB纹理-sRGB-EOTF" class="headerlink" title="测试1:输入线性数据+sRGB纹理 + sRGB EOTF"></a>测试1:输入线性数据+sRGB纹理 + sRGB EOTF</h3><p>如果使用Format格式为sRGB。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">VK_FORMAT_B8G8R8A8_SRGB +  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR（暗示了EOTF的类型）<br></code></pre></td></tr></table></figure><p>Shader当中直接方式输出颜色：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// SwapChain格式Format</span><br><br><span class="hljs-comment">//CPU端</span><br><span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Vertex&gt; vertices = &#123;<br>&#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;&#125;,<br>&#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;&#125;,<br>&#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;&#125;,<br>&#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;&#125;<br>&#125;;<br><span class="hljs-comment">// Shader PS程序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//outColor = vec4(fragColor, 1.0);</span><br>    outColor = vec4(fragColor, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-comment">//outColor = texture(texSampler, fragTexCoord);</span><br>    <span class="hljs-comment">//outColor = outColor*outColor;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出这个颜色的原因是，写入时执行了sRGB的编码（颜色变亮）。然后将buffer当中的内容当做sRGB空间颜色进行显示。<strong>下面这个效果就是线性颜色！！</strong></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1583818583086.png" alt="1583818583086"></p><h3 id="测试2-输入Gamma解码数据-sRGB纹理-sRGB-EOTF"><a href="#测试2-输入Gamma解码数据-sRGB纹理-sRGB-EOTF" class="headerlink" title="测试2:输入Gamma解码数据+sRGB纹理 + sRGB EOTF"></a>测试2:输入Gamma解码数据+sRGB纹理 + sRGB EOTF</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>   <span class="hljs-comment">// 设备会在写入时进行sRGB编码，然后数据当做sRGB内容在显示器进行显示。</span><br>    outColor = vec4(fragColor * fragColor, <span class="hljs-number">1.0</span>); <br>...<br></code></pre></td></tr></table></figure><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1583818522774.png" alt="1583818522774"></p><h3 id="测试3-输入线性数据-UNORM纹理-sRGB-EOTF"><a href="#测试3-输入线性数据-UNORM纹理-sRGB-EOTF" class="headerlink" title="测试3:输入线性数据+UNORM纹理 + sRGB EOTF"></a>测试3:输入线性数据+UNORM纹理 + sRGB EOTF</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">VK_FORMAT_B8G8R8A8_UNORM  +  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>    <span class="hljs-comment">// </span><br>    outColor = vec4( fragColor, <span class="hljs-number">1.0</span>); <br>...<br></code></pre></td></tr></table></figure><p>同样是正常的：</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1583818684976.png" alt="1583818684976"></p><h3 id="测试4-输入线性数据-Float16纹理-hdr-EOTF"><a href="#测试4-输入线性数据-Float16纹理-hdr-EOTF" class="headerlink" title="测试4:输入线性数据+Float16纹理 + hdr EOTF."></a>测试4:输入线性数据+Float16纹理 + hdr EOTF.</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">VK_FORMAT_R16G16B16A16_SFLOAT  VK_COLOR_SPACE_HDR10_ST2084_EXT<br>VK_COLOR_SPACE_HDR10_ST2084_EXT :specifies support <span class="hljs-keyword">for</span> the <span class="hljs-title function_">HDR10</span> <span class="hljs-params">(BT2020 color)</span> space to be displayed using the SMPTE ST2084 Perceptual <span class="hljs-title function_">Quantizer</span> <span class="hljs-params">(PQ)</span> EOTF.<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>    <span class="hljs-comment">// </span><br>    outColor = vec4( fragColor, <span class="hljs-number">1.0</span>); <br>...<br></code></pre></td></tr></table></figure><p>同样是线性响应函数：得到的和第一组测试一模一样。</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1583820889870.png" alt="1583820889870"></p><h2 id="电信号转换-：电阻发热导致的能量损失。"><a href="#电信号转换-：电阻发热导致的能量损失。" class="headerlink" title="电信号转换 ：电阻发热导致的能量损失。"></a>电信号转换 ：电阻发热导致的能量损失。</h2><h1 id="显示器如何还原颜色"><a href="#显示器如何还原颜色" class="headerlink" title="显示器如何还原颜色"></a>显示器如何还原颜色</h1><p>参考资料：<a href="https://www.tftcentral.co.uk/articles/pointers_gamut.htm">https://www.tftcentral.co.uk/articles/pointers_gamut.htm</a></p><p>颜色可以被分成亮度和色品。</p><p>亮度就是亮度。</p><p>色品就是构成光的不同波长的波的比例。</p><p>有两种定义色品的方式：</p><ol><li>the CIE 1931 xy chromaticity diagram。</li><li>the CIE 1976 u’v’ chromaticity diagram.</li></ol><h2 id="CIE-1931-xy-chromaticity-diagram"><a href="#CIE-1931-xy-chromaticity-diagram" class="headerlink" title="CIE 1931 xy chromaticity diagram"></a>CIE 1931 xy chromaticity diagram</h2><p>​完整来源和推导，暂时搁置。</p><p>简而言之，就是针对人眼的感受实验，CIE创造了两个标准：</p><ol><li>CIE 1931 XYZ </li><li>CIE 1931 RGB color spaces.</li></ol><p>从这两个颜色标准中，推导出了 CIE 1931 xyY 颜色空间。</p><p>xy就是色品分量，而Y就是亮度分量。</p><p>CIE1931色品图就是所有xyY色彩空间中不同人眼可见色品的可视化结果。它是一种手段来描述不同色域的颜色空间或显示的色度三原色。</p><p><img src="https://www.tftcentral.co.uk/images/pointers_gamut/large%20versions%20(wider%20than%20720px)/figure1_cie1931_small.jpg" alt="img"></p><h2 id="光谱轨迹"><a href="#光谱轨迹" class="headerlink" title="光谱轨迹"></a>光谱轨迹</h2><p>光谱轨迹是上图舌型去向。描述了所有的单色，波形范围在380和700nm之间。</p><h2 id="紫色线"><a href="#紫色线" class="headerlink" title="紫色线"></a>紫色线</h2><p>紫色线的颜色是波长380和700的混合，所有这些颜色都是完全饱和的</p><h2 id="普朗克黑体轨迹"><a href="#普朗克黑体轨迹" class="headerlink" title="普朗克黑体轨迹"></a>普朗克黑体轨迹</h2><p>舌形区域内的曲线称为普朗克轨迹。组成普朗克轨迹的点是由具有一定开尔文温度的黑体辐射体发出的光的色度坐标。横过普朗克轨迹的线就是等温线。</p><h2 id="CIE-1976-u’v’-chromaticity-diagram"><a href="#CIE-1976-u’v’-chromaticity-diagram" class="headerlink" title="CIE 1976 u’v’ chromaticity diagram"></a>CIE 1976 u’v’ chromaticity diagram</h2><p><img src="https://www.tftcentral.co.uk/images/pointers_gamut/large%20versions%20(wider%20than%20720px)/figure3_MacAdam%20ellipses%20CIE1931_small.jpg" alt="img"></p><p>变化成</p><p><img src="https://www.tftcentral.co.uk/images/pointers_gamut/large%20versions%20(wider%20than%20720px)/figure4_cie1976_small.jpg" alt="img"></p><h2 id="Pointer’s-gamut"><a href="#Pointer’s-gamut" class="headerlink" title="Pointer’s gamut"></a>Pointer’s gamut</h2><p>Michael R. Pointer (1980)的研究表示，所有可以被人眼看见的颜色，来自反射，反射是<strong>减法模型</strong>。</p><p>前面讨论的两个色度图是使用加性混色的一组颜色的可视化。</p><h3 id="Additive-color-mixing"><a href="#Additive-color-mixing" class="headerlink" title="Additive color mixing"></a>Additive color mixing</h3><p>通过添加颜色混合，您可以通过混合不同波长的光和改变亮度来创建一个新的颜色。</p><p>例如，如果你取一个波长为585 nm的光源(琥珀黄色)和另一个波长为485 nm的光源(明亮的天蓝色)，你可以在585 nm和485 nm之间复制任何颜色，通过改变两个光源的亮度。</p><p>这也意味着，如果一对色度单体之间的那条线与另一对色度单体之间的那条线相交，那么这两对色度单体就可以创造出一种对两对来说都是相同的颜色，但光谱分布不同。<strong>这种效应被称为异色现象，是彩色显示的基础:在不同的系统中使用不同的三原色来描述或再现被认为相同但光谱分布不同的颜色。</strong></p><h3 id="Subtractive-color-mixing"><a href="#Subtractive-color-mixing" class="headerlink" title="Subtractive color mixing"></a>Subtractive color mixing</h3><p>在减色法混色中，光不是由“光源”发出的，而是被反射回来的。我们所感知到的任何物体的颜色都是光源(通常是太阳，但也有人造光源)反射的物体的波长的组合。光源的所有其他波长都被物体吸收。</p><h2 id="Diffuse-reflection-vs-specular-reflection"><a href="#Diffuse-reflection-vs-specular-reflection" class="headerlink" title="Diffuse reflection vs. specular reflection"></a>Diffuse reflection vs. specular reflection</h2><p>不同的反射器，漫反射是反射颜色的，高光反射会反射光源颜色。减色法混色也对表面平滑度高度敏感。Pointer针对的是漫反射。高光反射会超过Pointer的颜色范围。</p><p><strong>金属工作流当中的PBR计算。</strong></p><h2 id="Pointer’s-gamut-in-CIE-1931-xy-chromaticity-diagram"><a href="#Pointer’s-gamut-in-CIE-1931-xy-chromaticity-diagram" class="headerlink" title="Pointer’s gamut in CIE 1931 xy chromaticity diagram"></a>Pointer’s gamut in CIE 1931 xy chromaticity diagram</h2><p><img src="https://www.tftcentral.co.uk/images/pointers_gamut/figure6_Pointer%20in%20CIE1931.jpg" alt="img"></p><h2 id="RGB-Color-spaces"><a href="#RGB-Color-spaces" class="headerlink" title="RGB Color spaces"></a>RGB Color spaces</h2><p>现在几乎所有的捕获或显示设备都使用RGB颜色模型来描述每个像素的颜色。</p><p><strong>每个通道8位颜色深度的像素，RGB值[255;0;0]显然是红色的。但是，如果没有指定的颜色空间，就无法知道红色的色度应该是多少。</strong>如果捕获设备的色域与显示设备的色域相同，并且两者是直接连接的，那么这就不是问题。不幸的是，事实并非如此。</p><h3 id="Rec-709-x2F-sRGB"><a href="#Rec-709-x2F-sRGB" class="headerlink" title="Rec. 709 &#x2F; sRGB"></a>Rec. 709 &#x2F; sRGB</h3><p>The ITU-R Recommendation BT. 709, or simply Rec. 709, 在1990年将高端显示器的格式标准化了。它指定了<strong>图像显示</strong>的许多方面，但我们感兴趣的是主色度。</p><table><thead><tr><th>Primary</th><th>CIE 1931 xy chromaticity diagram</th><th></th><th>CIE 1976 u’v’ chromaticity diagram</th><th></th></tr></thead><tbody><tr><td>x</td><td>y</td><td>u’</td><td>v’</td><td></td></tr><tr><td>Red</td><td>0.640</td><td>0.330</td><td>0.451</td><td>0.523</td></tr><tr><td>Green</td><td>0.300</td><td>0.600</td><td>0.125</td><td>0.563</td></tr><tr><td>Blue</td><td>0.150</td><td>0.060</td><td>0.175</td><td>0.158</td></tr></tbody></table><p>当在CIE 1931年的xy或CIE 1976年的u ‘ v色度图中绘制时，很明显，这是一个相当小的颜色空间。在CIE 1931年的xy色度图中，它只涵盖了33.5%的色度和69.4%的指针色域。在CIE 1976 u ‘ v中，这些值分别为33.2%和70.2%。</p><p><img src="https://www.tftcentral.co.uk/images/pointers_gamut/figure8_sRGB%20and%20pointer%20CIE1931.jpg" alt="img"></p><h3 id="BT-2020"><a href="#BT-2020" class="headerlink" title="BT .2020"></a>BT .2020</h3><p>Rec. 2020 defines a bit depth of either 10 bits per sample or 12 bits per sample.</p><h4 id="Resolution-edit-分辨率"><a href="#Resolution-edit-分辨率" class="headerlink" title="Resolution[edit] 分辨率"></a>Resolution[<a href="https://en.wikipedia.org/w/index.php?title=Rec._2020&action=edit&section=2">edit</a>] 分辨率</h4><p>Rec. 2020 defines two resolutions of <a href="https://en.wikipedia.org/wiki/4K_resolution#Ultra_HD">3840 × 2160</a> (“4K”) and <a href="https://en.wikipedia.org/wiki/8K_resolution#Resolutions">7680 × 4320</a> (“8K”).[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a> These resolutions have an <a href="https://en.wikipedia.org/wiki/Aspect_ratio_(image)">aspect ratio</a> of <a href="https://en.wikipedia.org/wiki/16:9">16:9</a> and use square <a href="https://en.wikipedia.org/wiki/Pixels">pixels</a>.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a></p><h4 id="Frame-rate-edit-帧率"><a href="#Frame-rate-edit-帧率" class="headerlink" title="Frame rate[edit] 帧率"></a>Frame rate[<a href="https://en.wikipedia.org/w/index.php?title=Rec._2020&action=edit&section=3">edit</a>] 帧率</h4><p>Rec. 2020 specifies the following frame rates: 120p, 119.88p, 100p, 60p, 59.94p, 50p, 30p, 29.97p, 25p, 24p, 23.976p.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a> Only <a href="https://en.wikipedia.org/wiki/Progressive_scan">progressive scan</a> frame rates are allowed.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a></p><h4 id="Digital-representation-数据表示"><a href="#Digital-representation-数据表示" class="headerlink" title="Digital representation 数据表示"></a>Digital representation 数据表示</h4><p>10-bits per sample Rec. 2020 uses video levels where the <a href="https://en.wikipedia.org/wiki/Black_level">black level</a> is defined as code 64 and the nominal peak is defined as code 940.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a> Codes 0–3 and 1,020–1,023 are used for the timing reference.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a> Codes 4 through 63 provide video data below the black level while codes 941 through 1,019 provide video data above the nominal peak.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a></p><p>12-bits per sample Rec. 2020 uses video levels where the black level is defined as code 256 and the nominal peak is defined as code 3760.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a> Codes 0–15 and 4,080–4,095 are used for the timing reference.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a> Codes 16 through 255 provide video data below the black level while codes 3,761 through 4,079 provide video data above the nominal peak.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/300px-CIExy1931_Rec_2020.svg.png" alt="img"></p><table><thead><tr><th align="center"><a href="https://en.wikipedia.org/wiki/Color_space">Color space</a></th><th align="center"><a href="https://en.wikipedia.org/wiki/White_point">White point</a></th><th align="center"><a href="https://en.wikipedia.org/wiki/Primary_color">Primary colors</a></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th></th></tr></thead><tbody><tr><td align="center">xW</td><td align="center">yW</td><td align="center">xR</td><td align="center">yR</td><td align="center">xG</td><td align="center">yG</td><td align="center">xB</td><td align="center">yB</td><td></td></tr><tr><td align="center">ITU-R BT.2020</td><td align="center">0.3127</td><td align="center">0.3290</td><td align="center">0.708</td><td align="center">0.292</td><td align="center">0.17</td><td align="center">0.797</td><td align="center">0.131</td><td>0.046</td></tr></tbody></table><h3 id="sRGB"><a href="#sRGB" class="headerlink" title="sRGB"></a><strong>sRGB</strong></h3><p>sRGB是由惠普和微软在1996年创建的RGB彩色空间，用于显示器、打印机和互联网。sRGB颜色空间使用与Rec. 709相同的三原色和白点。这两者之间最大的区别是sRGB只是一个绝对的颜色空间，只指定基色和白点的色度和伽玛校正曲线。</p><h3 id="Adobe-Wide-Gamut-RGB（Wide-gamut-RGB-color-space）宽色域"><a href="#Adobe-Wide-Gamut-RGB（Wide-gamut-RGB-color-space）宽色域" class="headerlink" title="Adobe Wide Gamut RGB（Wide-gamut RGB color space）宽色域"></a>Adobe Wide Gamut RGB（Wide-gamut RGB color space）宽色域</h3><p>这就引出了下一个问题:这样大小的颜色空间需要高颜色深度来避免色调分离效果(颜色带)。</p><p><strong>大多数被指定为具有10位颜色深度的显示器实际上是常规的8位颜色深度面板，在显示电子设备中实现了frc模块。</strong></p><table><thead><tr><th align="center">Color</th><th align="center">CIE x</th><th align="center">CIE y</th><th align="center">Wavelength</th></tr></thead><tbody><tr><td align="center">Red</td><td align="center">0.7347</td><td align="center">0.2653</td><td align="center">700 nm</td></tr><tr><td align="center">Green</td><td align="center">0.1152</td><td align="center">0.8264</td><td align="center">525 nm</td></tr><tr><td align="center">Blue</td><td align="center">0.1566</td><td align="center">0.0177</td><td align="center">450 nm</td></tr><tr><td align="center">White point</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/325px-CIExy1931_AdobeWGRGB.png" alt="img"></p><h2 id="量子点显示器"><a href="#量子点显示器" class="headerlink" title="量子点显示器"></a>量子点显示器</h2><h2 id="接口规范"><a href="#接口规范" class="headerlink" title="接口规范"></a>接口规范</h2><p>接口规范：SMPTE 292M, SMPTE 372M, HDMI、没有说明EOTF、OETF和颜色的任何信息。</p><h2 id="TransferSystem"><a href="#TransferSystem" class="headerlink" title="TransferSystem"></a>TransferSystem</h2><p><a href="https://www.displaydaily.com/article/display-daily/hlg-vs-pq-systems-for-hdr-television">https://www.displaydaily.com/article/display-daily/hlg-vs-pq-systems-for-hdr-television</a></p><p><strong>One thing that must be understood is that both PQ and HLG are <em>Systems</em>, not simply transfer curves.</strong><br>Finally, there are three terms that must be used in trying to explain the difference between the PQ and HLG systems:</p><ul><li>OETF: Opto-Electronic Transfer Function. This is the <strong>non-linear relationship between</strong> the light falling on the camera sensor and the digital electronic signal generated by the camera.对于渲染来说没有这一部分。</li><li>EOTF: Electro-Optical Transfer Function. This is the non-linear relationship between the digital electronic signal received by the display and the light emitted by the display. </li><li>OOTF:  Optical-Optical Transfer Function. This is the overall relationship between the light falling on the image sensor and the light coming out of the display.</li></ul><p>The OOTF relationship is not normally linear in a camera-to-display signal chain and is often characterized by a Gamma value. One key to understanding the PQ vs HGL issue is the <strong>OOTF gamma value preferred by viewers and content creators varies with viewing conditions, which include both display brightness and the ambient surround light when the display is being viewed.</strong></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/BBC_Generic_End-to-end_resize.jpg" alt="BBC Generic End to end resize"></p><p> The goal of this accommodation is to preserve the artistic intent of the content creators even when the content is seen by <strong>the viewer under different conditions than used by the content creators.</strong></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/BBC_HLG_PQ_End-to-end_Labeled_2_resize.jpg" alt="BBC HLG PQ End to end Labeled 2 resize"></p><p>When a PQ signal is shown on a display where the display and display environment does not match the mastering display, the OOTF is adjusted using metadata from the mastering environment.</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/BBC_OOTF_PQ_resize.jpg" alt="BBC OOTF PQ resize"></p><h2 id="OETF"><a href="#OETF" class="headerlink" title="OETF"></a>OETF</h2><p>图像捕捉OETF标准：ITU-R Rec. BT.601, 709, 2020。</p><p>他只是一个相对设置。在拍摄过程中，相机曲线会根据个人喜好进行调整。</p><p>教科书中的Rec709函数几乎从未在实践中使用过。</p><h2 id="EOTF"><a href="#EOTF" class="headerlink" title="EOTF"></a>EOTF</h2><p><strong>但是图像的显示标准并不是图像捕捉标准的翻转（But image display ≠ inverse of image capture ）</strong> 因为：</p><ol><li>特殊渲染意图。</li><li>捕捉环境和渲染环境亮度不匹配。</li></ol><p>EOTF的意义：</p><ol><li>参考显示器上的图像才是真正定义信号的东西</li><li>描述了如何将数字代码转换成亮度信息。</li><li>在查看参考显示时，艺术家会对内容的外观做出创造性的决定.</li><li>所有的显示必须使用同一个标准。</li></ol><p>随着crt几乎绝迹，官方开始努力记录它们的响应曲线。</p><p>OETF函数(如Rec.709和类似的函数中所使用的)派生自display EOTF，而不是反过来：</p><ol><li>早起的EOTF是由于CRT物理硬件决定的。</li><li>OETF就是将EOTF反过来然后<strong>根据渲染环境进行调整。</strong></li></ol><p>目前的EOTF只针对了CRT显示器的亮度范围，但是目前我们有HDR所以需要更大的亮度和动态范围的EOTF曲线。</p><h3 id="构建EOTF曲线"><a href="#构建EOTF曲线" class="headerlink" title="构建EOTF曲线"></a>构建EOTF曲线</h3><ol><li>最大化利用数据。</li><li>符合人眼习惯。</li></ol><p>下面这张图是根据实际人眼感知的实验结论，他表示随着亮度变化。人眼对于亮度对比度的分辨能力，注意下图是指数坐标单位。</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584929902806.png" alt="1584929902806"></p><p>常见的曲线：</p><h4 id="OpenEXR"><a href="#OpenEXR" class="headerlink" title="OpenEXR"></a>OpenEXR</h4><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584930032370.png" alt="1584930032370"></p><h4 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h4><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1589776195725.png" alt="1589776195725"></p><h4 id="Gamma（Rec1886）"><a href="#Gamma（Rec1886）" class="headerlink" title="Gamma（Rec1886）"></a>Gamma（Rec1886）</h4><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584930055803.png" alt="1584930055803"></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584931609084.png" alt="1584931609084"></p><h4 id="PQ曲线"><a href="#PQ曲线" class="headerlink" title="PQ曲线"></a>PQ曲线</h4><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584931714881.png" alt="1584931714881"></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584931744448.png" alt="1584931744448"></p><h2 id="OOTF"><a href="#OOTF" class="headerlink" title="OOTF"></a>OOTF</h2><h2 id="CSF"><a href="#CSF" class="headerlink" title="CSF"></a>CSF</h2><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1589776858973.png" alt="1589776858973"></p><h1 id="色彩处理技术"><a href="#色彩处理技术" class="headerlink" title="色彩处理技术"></a>色彩处理技术</h1><h2 id="ToneMapping"><a href="#ToneMapping" class="headerlink" title="ToneMapping"></a>ToneMapping</h2><ol><li>Lut严重依赖于ToneMapping的效果。</li><li>原始的管线中，无法对高光部分进行精确ToneMapping。</li><li>这是一个固定的分布，不同的光照标准-&gt;不同的ToneMapping-&gt;不同的LUT</li><li>在luma&#x2F;chroma空间进行计算（hue preserving）：只在亮度空间附加shoulder，根据shoulder部位逐步降低饱和度。</li><li>tonemapping的hue preserving也会有问题 ：通过LUT模拟黑体颜色。</li></ol><p>For pixel values above the peak luminance of the display, a reference monitor should “clip” those values back to the maximum capabilities of the display. ，Tone mapping changes the luminance of the pixel to the maximum value of the display, but not the chromaticity of the pixel. Such a change just in luminance may change our perception of the pixel (a bright yellow pixel looks yellow but a dim yellow pixel looks brown). </p><p>Clipping can also mean adjusting the chromaticity of the pixel.  </p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1589968162850.png" alt="1589968162850"></p><h2 id="Gamut-mapping"><a href="#Gamut-mapping" class="headerlink" title="Gamut mapping"></a>Gamut mapping</h2><p>refers to the remapping of color values that exceed the capabilities of the display to the native gamut of the display.</p><p>​色彩学家讨论的问题之一是——在特定的电脑屏幕上可以显示的颜色范围是什么?或者在特定的打印机上可以复制到纸上的颜色范围是什么?这个范围称为显示或打印机的色域。他们问的另一个问题是——<strong>如果我想复制的颜色不在我的显示器或打印机的色域内，我应该如何修改它们，使它们可以显示，而不过度扭曲我的图像的整体设计</strong>。修改过程称为色域映射，在遗传算法中避免颜色失真的替代策略(有几种)</p><p><a href="https://graphics.stanford.edu/courses/cs178/applets/gamutmapping.html">https://graphics.stanford.edu/courses/cs178/applets/gamutmapping.html</a></p><h2 id="Reference-Monitors"><a href="#Reference-Monitors" class="headerlink" title="Reference Monitors"></a>Reference Monitors</h2><p>用于调节色彩数据的显示器。</p><p>显示器亮度范围达不到PQ，范围。These are supposed to be highly accurate monitors but they are not capable of displaying the full range of luminance in the PQ standard, nor the full range of colors in the BT.2020 color gamut. </p><p>显示器色彩范围达不到BT.2020 , Today, there are two practical reference monitors at 1000 and 4000 cd&#x2F;m² with each supporting the DCI-P3 color gamut, which is smaller than the BT.2020 color gamut. </p><p>对于HDR来说，BT.2020是必须的，但是不需要有2020的色彩基色，但是需要有2020的色度图. In the world of HDR for consumers, BT.2020 is mandatory. <strong>This does not mean that the display has to have 2020 primaries, but it should follow BT.2020 colorimetry.</strong></p><h3 id="System-colorimetry-edit"><a href="#System-colorimetry-edit" class="headerlink" title="System colorimetry[edit]"></a>System colorimetry[<a href="https://en.wikipedia.org/w/index.php?title=Rec._2020&action=edit&section=5">edit</a>]</h3><table><thead><tr><th align="center"><a href="https://en.wikipedia.org/wiki/Color_space">Color space</a></th><th align="center"><a href="https://en.wikipedia.org/wiki/White_point">White point</a></th><th align="center"><a href="https://en.wikipedia.org/wiki/Primary_color">Primary colors</a></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th></th></tr></thead><tbody><tr><td align="center">xW</td><td align="center">yW</td><td align="center">xR</td><td align="center">yR</td><td align="center">xG</td><td align="center">yG</td><td align="center">xB</td><td align="center">yB</td><td></td></tr><tr><td align="center">ITU-R BT.2020</td><td align="center">0.3127</td><td align="center">0.3290</td><td align="center">0.708</td><td align="center">0.292</td><td align="center">0.17</td><td align="center">0.797</td><td align="center">0.131</td><td>0.046</td></tr></tbody></table><p>The Rec. 2020 (UHDTV&#x2F;UHD-1&#x2F;UHD-2) color space can reproduce colors that cannot be shown with the <a href="https://en.wikipedia.org/wiki/Rec._709">Rec. 709</a> (HDTV) color space.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-TVTechnologyDecember2012SuperHiVision-6">6]</a>[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-NHKannualreport2010-7">7]</a> The RGB primaries used by Rec. 2020 are equivalent to monochromatic light sources on the <a href="https://en.wikipedia.org/wiki/CIE_1931_color_space#CIE_xy_chromaticity_diagram_and_the_CIE_xyY_color_space">CIE 1931 spectral locus</a>.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-NHKannualreport2010-7">7]</a>[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-NHKOpenHouse2013Exhibit20-8">8]</a></p><p>2020的物理亮度参数。The <a href="https://en.wikipedia.org/wiki/Wavelength">wavelength</a> of the Rec. 2020 <a href="https://en.wikipedia.org/wiki/Primary_color">primary colors</a> is 630 <a href="https://en.wikipedia.org/wiki/Nanometre">nm</a> for the red primary color, 532 nm for the green primary color, and 467 nm for the blue primary color.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-NHKOpenHouse2013Exhibit20-8">8]</a>[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-DavidWoodDecidingTomorrowsTelevision-9">9]</a> </p><h2 id="Lut"><a href="#Lut" class="headerlink" title="Lut"></a>Lut</h2><h3 id="LUTspace"><a href="#LUTspace" class="headerlink" title="LUTspace"></a>LUTspace</h3><h2 id="在HDR显示器上还原"><a href="#在HDR显示器上还原" class="headerlink" title="在HDR显示器上还原"></a>在HDR显示器上还原</h2><p>Tonemapping  进行LUT还原Tonemap 变回hdr值。 因为Shoulder不是无限的，所以也有clip的值。</p><h2 id="卡通渲染的真实风格"><a href="#卡通渲染的真实风格" class="headerlink" title="卡通渲染的真实风格"></a>卡通渲染的真实风格</h2><p>饱和度和亮度的控制。</p><h2 id="Perceptual-Quantizer"><a href="#Perceptual-Quantizer" class="headerlink" title="Perceptual Quantizer"></a>Perceptual Quantizer</h2><p><strong>Perceptual Quantizer (PQ)</strong>, published by <a href="https://en.wikipedia.org/wiki/Society_of_Motion_Picture_and_Television_Engineers">SMPTE</a> as <strong>SMPTE ST 2084</strong>, is a transfer function that allows for the display of <a href="https://en.wikipedia.org/wiki/High_dynamic_range">high dynamic range</a> (HDR) video with a <a href="https://en.wikipedia.org/wiki/Luminance">luminance</a> level of up to 10,000 <a href="https://en.wikipedia.org/wiki/Cd/m2">cd&#x2F;m2</a> and can be used with the <a href="https://en.wikipedia.org/wiki/Rec._2020">Rec. 2020</a> color space.[<a href="https://en.wikipedia.org/wiki/High-dynamic-range_video#cite_note-HPATechFebruary2014-32">32]</a>[<a href="https://en.wikipedia.org/wiki/High-dynamic-range_video#cite_note-SMPTE2084HDR2014-33">33]</a>[<a href="https://en.wikipedia.org/wiki/High-dynamic-range_video#cite_note-HDRReportSMPTE2015MESA-34">34]</a>[<a href="https://en.wikipedia.org/wiki/High-dynamic-range_video#cite_note-GradingHDR2015studiodaily-35">35]</a> PQ is a non-linear <a href="https://en.wikipedia.org/wiki/Optical_transfer_function">electro-optical transfer function</a> (EOTF).</p><p><strong>L0表示的是压缩到0-1的亮度， 也就是1表示10000 nits 。所以要根据实际要显示的亮度，渲染我们的颜色亮度，所以还有隐含的一步就是从计算的颜色FP16 到L0，然后再从L0压缩到[0,1].</strong></p><p>对于Dolby Vsion来说，需要能够表达0-10000nis的亮度，目前的SDR显示器使用8bits表示0-100nits的数据，如果过使用相同的曲线，需要14bits，才能避免眼睛看到banding，但是这个时候亮度部分就浪费了，所以我们使用了12bits的 pq曲线。不给过大部分HDR方法，使用的是10bits。（10bit总是在可视曲线之上），但是噪声可以遮蔽掉banding效果。</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1590027884175.png" alt="1590027884175"></p><p>下面是PQ EOTF曲线（x的坐标时0-1024，深度是10 bit）：</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584935346381.png" alt="1584935346381"></p><p>一定要注意下面说的是<strong>PT Inverse EOTF！！！！</strong></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584499216410.png" alt="1584499216410"></p><p>Inverse EOTF曲线（OETF曲线）：</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584935431610.png" alt="1584935431610"></p><h2 id="Hue-Preserving-and-Hue-shifts"><a href="#Hue-Preserving-and-Hue-shifts" class="headerlink" title="Hue Preserving and Hue shifts"></a>Hue Preserving and Hue shifts</h2><p>颜色从饱和色 转换到白色的时候（去饱和度），色相是否变化。</p><p>这一点也影响到ColorGrading的效果，所以ToneMapping 要放在最后。</p><h3 id="如何做到HuePreserving"><a href="#如何做到HuePreserving" class="headerlink" title="如何做到HuePreserving"></a>如何做到HuePreserving</h3><p> 分离亮度和饱和度，对亮度应用shoulder。对色度，应用降低饱和度（根据shoudler的位置，并且使用不同的速度）。</p><p>使用ICtcpya 空间</p><h2 id="tongMapping带来的改变"><a href="#tongMapping带来的改变" class="headerlink" title="tongMapping带来的改变"></a>tongMapping带来的改变</h2><p>Toe</p><p>Hue shits</p><p>对比度变化</p><h1 id="HDR-标准与文件格式"><a href="#HDR-标准与文件格式" class="headerlink" title="HDR 标准与文件格式"></a>HDR 标准与文件格式</h1><p>​      <strong>HDR技术通常使用不同的方法，来将数据转化成HDR显示器可以接受的格式。基本上是一个接近log函数的型号编码方式。然后对应的显示器将这些数据还原会标准信号。由于Log函数的原因，所以如果过直接在SDR显示器上观察（没有HDR显示器的还原功能）那么数据是低饱和度，很灰暗的。类似Log函数的编码标准有：</strong></p><ul><li><p>Dolby Vision</p></li><li><p>HDR10</p></li><li><p>HDR10 +</p></li><li><p>Hybird Log-Gamma(HLG)</p></li></ul><h3 id="HDR10"><a href="#HDR10" class="headerlink" title="HDR10"></a>HDR10</h3><p> wide-gamut <a href="https://en.wikipedia.org/wiki/Rec._2020">Rec. 2020</a> color space, </p><ul><li><p>EOTF: SMPTE ST 2084 (<a href="https://en.wikipedia.org/wiki/Perceptual_quantization">PQ</a>)</p></li><li><p><a href="https://en.wikipedia.org/wiki/Bit_depth_(computer_graphics)">Bit Depth</a>: 10-bit </p></li><li><p>static metadata</p></li></ul><h3 id="HDR10-1"><a href="#HDR10-1" class="headerlink" title="HDR10+"></a>HDR10+</h3><ul><li>EOTF: SMPTE ST 2084 (<a href="https://en.wikipedia.org/wiki/Perceptual_quantization">PQ</a>)</li><li>Resolution: Agnostic (2K&#x2F;4K&#x2F;8K[<a href="https://en.wikipedia.org/wiki/HDR10%2B#cite_note-10">10]</a>, etc.)</li><li><a href="https://en.wikipedia.org/wiki/Bit_depth_(computer_graphics)">Bit Depth</a>: 10-bit or more (up to 16-bit)</li><li>Color Primaries: <a href="https://en.wikipedia.org/wiki/Rec._2020">ITU-R BT.2020</a></li><li>Maximum linearized pixel value: 10,000 <a href="https://en.wikipedia.org/wiki/Candela_per_square_metre">cd&#x2F;m2</a> for each color R&#x2F;G&#x2F;B (content)</li><li>Metadata (Required): Mastering Display Color Volume Metadata[<a href="https://en.wikipedia.org/wiki/HDR10%2B#cite_note-11">11]</a></li><li>Metadata (Optional): MaxCLL, MaxFALL[<a href="https://en.wikipedia.org/wiki/HDR10%2B#cite_note-12">12]</a></li><li>dynamic metadata</li></ul><p>HDR10+ technology can support the full range of HDR standards to 10,000 cd&#x2F;m2, 8K and BT.2020 color gamut. Being resolution agnostic, metadata needs to be created only once and can be applied to any target resolution.</p><p>HDR10+ is applicable for HEVC and <a href="https://en.wikipedia.org/wiki/VP9">VP9</a> compatibility via WebM[<a href="https://en.wikipedia.org/wiki/HDR10%2B#cite_note-13">13]</a> as well as any codec that supports ITU-T T.35 metadata.</p><h3 id="Dolby-Vision"><a href="#Dolby-Vision" class="headerlink" title="Dolby Vision"></a>Dolby Vision</h3><h3 id="HLG"><a href="#HLG" class="headerlink" title="HLG"></a>HLG</h3><p>HDR编码标准允许更高的最大亮度，并使用至少10位动态范围。</p><p>虽然技术上“HDR”严格指的是最大和最小亮度之间的比例，但术语“HDR视频”通常被理解为也意味着广泛的色域</p><p>HDR video当中记录了一个亮度的等级，不同的HDR技术会把文件数据当中的亮度等级映射到“一种长得像指数的空间”，显示器会用对应的EOTF将这个数据正确的显示。</p><p>在DaVinCi当中颜色通常是10bit的数据。当使用HDR模式的时候，他就变成了绝对亮度。</p><p>亮度对应为：</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/2020320-160254.jpg" alt="2020320-160254"></p><p>同样也可以，开启“Enable HDR Scopes for ST.2084”选项来查看实际的nit亮度。</p><h2 id="HDR的文件格式"><a href="#HDR的文件格式" class="headerlink" title="HDR的文件格式"></a>HDR的文件格式</h2><h3 id="Raw"><a href="#Raw" class="headerlink" title="Raw"></a>Raw</h3><p>原始文件之所以这样命名，是因为它们还没有被处理，因此还不能使用位图图形编辑器打印或编辑。</p><p>传统CCD每个像素只能感光一种颜色，根据感光的强度不同转换成不同的数字，不同的CCD这一数字范围是不同的，早期的8bit，到10bit、12bit。8bit就是一个点感光从最暗到最亮分为256个层次，10bit就是1024个层次，以此类推。</p><p>RAW文件几乎是未经过处理而直接从CCD或CMOS上得到的信息,·也许RAW最大的优点就是可以将其转化为16位的图像。也就是有65536个层次可以被调整.</p><p><strong>·成像芯片是线性装置。这意味着当一个像素点的采光量是另一个的两倍时，也将会产生2倍的电压。</strong>曝光中止时，亮度值是以其对数来呈现的，这就是说一个未修正的照片会看起来比较暗，因此需要通过色调曲线来调整正确。</p><table><thead><tr><th>富士</th><th>*.raf</th></tr></thead><tbody><tr><td>佳能</td><td><em>.crw，</em>.cr2,*.cr3</td></tr><tr><td>柯达</td><td>*.kdc</td></tr><tr><td>美能达</td><td>*.mrw</td></tr><tr><td>尼康</td><td><em>.nef,</em>.cr2</td></tr><tr><td>奥林巴斯</td><td>*.orf</td></tr><tr><td>adobe</td><td>*.dng</td></tr><tr><td>宾得</td><td><em>.ptx，</em>.pef</td></tr><tr><td>索尼</td><td>*.arw</td></tr><tr><td>适马</td><td>*.x3f</td></tr><tr><td>松下</td><td>*.rw2</td></tr></tbody></table><p><a href="https://www.aftershotpro.com/en/pages/raw-file/">https://www.aftershotpro.com/en/pages/raw-file/</a></p><h3 id="Camera’s-CCD"><a href="#Camera’s-CCD" class="headerlink" title="Camera’s CCD"></a>Camera’s CCD</h3><p>参考资料：</p><p><a href="https://electronics.howstuffworks.com/cameras-photography/digital/digital-camera2.htm">https://electronics.howstuffworks.com/cameras-photography/digital/digital-camera2.htm</a></p><p>​<strong>数码相机的传感器可以将光线转换成电荷</strong>，而不是胶片。大多数数码相机采用的图像传感器是电荷耦合器件(CCD)。一些相机使用互补的金属氧化物半导体(CMOS)技术代替。CCD和CMOS图像传感器都能将光转换成电子。</p><p>接受光信号，（相机会重置CCD，将其暴露在光线下，产生电荷，直到快门关闭。）然后编码成二进制文件。（ADC测量电荷并创建数字信号，表示每个像素的电荷值。）</p><p>文件类型：No matter what type of storage they use, all digital cameras need lots of room for pictures. They usually store images in one of two formats – TIFF, which is uncompressed, and JPEG, which is compressed, but some use RAW format. </p><h3 id="Camera’s-ACD"><a href="#Camera’s-ACD" class="headerlink" title="Camera’s ACD"></a>Camera’s ACD</h3><p>参考资料：</p><p><a href="https://www.lifewire.com/the-adc-of-a-digital-camera-493714">https://www.lifewire.com/the-adc-of-a-digital-camera-493714</a></p><p>ADC是数码相机内部的一个芯片，模拟型号和电信号转换芯片（Analog to Digital Converter (variously called the <em>ADC</em>, <em>AD Converter</em>, and the <em>A&#x2F;D Converter</em>).）<strong>，它的工作是将像素的电压划分为亮度级别</strong>，并将每个级别指定为由0和1组成的二进制数。大多数消费级数码相机至少使用8位ADC，单个像素的亮度最多可达256个值。</p><p>ADC的最小比特率由**传感器的动态范围(精度)**决定（对电压的感受精度）。一个大的动态范围至少需要一个10位ADC来产生大量的tone并避免任何信息丢失。然而，相机制造商通常会过度指定ADC(比如12位而不是10位)，以避免任何错误。</p><p>多出来的数据防止<strong>色调映射（ tonal curves）</strong>时产生banding效果。</p><p>一个12位和14位的图像之间的差异将是非常轻微的，甚至可能在大多数照片是不明显的。同时，这一切都取决于传感器的动态范围。如果动态范围没有随着ADC的增大而增大，那么它就不能有效地改善图像质量。</p><h3 id="ACD-tonal-curve"><a href="#ACD-tonal-curve" class="headerlink" title="ACD tonal curve"></a>ACD tonal curve</h3><p>参考资料：</p><p><a href="https://www.dpreview.com/articles/5426898916/ins-and-outs-of-iso-where-iso-gets-complex">https://www.dpreview.com/articles/5426898916/ins-and-outs-of-iso-where-iso-gets-complex</a></p><p>过去针对不同的ISO，图片的亮度会变的不一样。这就是在调节模拟信号。他们使用的是同一个Tone Curve。</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/ISO_pre_2006_green-1590543885563.png" alt="img"></p><p>上图注意，模拟信号放大一倍，曝光级别降低一个曝光级别。所有图像都是用相同的ToneMapping，也就是中灰度亮度是固定的。数据分布也是一致的。</p><p>随后不同的ISO等级（模拟信号放大）使用的不同tone curve和模拟信号放大：</p><p>​<strong>模拟信号放大会减少噪声，但是会减少动态范围（亮度范围），使用较低的放大可以得到更大的亮度范围。</strong></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/ISO_post_2006_green.png" alt="img"></p><h3 id="ISO"><a href="#ISO" class="headerlink" title="ISO"></a>ISO</h3><p>摄影中的流程，ISO是在特定的光照环境增强敏感度，以达到想要的亮度，但是ISO只是单纯的增加曝光么：</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/ISO_Flow_Chart.png" alt="img"></p><p>实际上ISO的处理包括了很多阶段：</p><ul><li><strong>Exposure</strong>：通过照明亮度、快门速度和光圈大小控制的曝光亮度。</li><li>CCD：传感器对光的响应，无法修改。光学元件决定的。</li><li><strong>Lightening</strong>：A&#x2F;D，从曝光当中获得期望的亮度，模拟型号放大和ToneCurve。</li></ul><p>很多摄像机有动态范围模式：佳能的高光调优先级和理光的高光校正DR模式都做到了这一点：</p><p>使用一个比标准模式小的停止放大来保存高光数据，否则会放大到剪切。</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/Fujfilm_DR_alt_green_rough.png" alt="img"></p><h3 id="EV"><a href="#EV" class="headerlink" title="EV"></a>EV</h3><p>EV值：</p><p>它的目的是通过将快门速度和f-数字(例如f&#x2F;16的1&#x2F;125 s)的组合替换为一个数字来简化相机曝光设置的选择</p><p>$$ &#x3D;log _{2}{\frac{N^{2}}{t}}$$</p><ul><li><em>N</em> is the <a href="https://en.wikipedia.org/wiki/F-number">f-number</a></li><li><em>t</em> is the exposure time (“<a href="https://en.wikipedia.org/wiki/Shutter_speed">shutter speed</a>“) in seconds[<a href="https://en.wikipedia.org/wiki/Exposure_value#cite_note-no_units-2">2]</a></li></ul><p>曝光值每增加1就相当于曝光值的一个“台阶”(或者更常见的是一个“停止”)的变化（也就是一个bit），即通过将曝光时间减半或将光圈面积减半，或将上述变化结合起来，可以减少一半的曝光量。更大的曝光值适用于在更明亮的情况下拍摄，或更高的ISO速度。</p><p>拍摄不同的环境通常需要参考的曝光.</p><p><strong>根据固定的曝光（EV）决定，光圈、快门、感光度。</strong></p><p><a href="https://en.wikipedia.org/wiki/Exposure_value">https://en.wikipedia.org/wiki/Exposure_value</a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="热度图的作用"><a href="#热度图的作用" class="headerlink" title="热度图的作用"></a>热度图的作用</h2>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>后处理ColorGrading</title>
      <link href="/2022/07/09/Art/%E5%90%8E%E5%A4%84%E7%90%86ColorGrading/"/>
      <url>/2022/07/09/Art/%E5%90%8E%E5%A4%84%E7%90%86ColorGrading/</url>
      
        <content type="html"><![CDATA[<h1 id="Why-Color-Grading"><a href="#Why-Color-Grading" class="headerlink" title="Why Color Grading"></a>Why Color Grading</h1><p>Color Grading（或者Color Correction）几乎是每一个游戏、视频必定会涉及的话题。但是我们的工作重点总是<strong>如何迁移一个算法</strong>，图程和TA的工作停留在算法层面就无法理解他在美术、设计中真正起到的作用。</p><p>这篇笔记主要来自于DaVinci的用户文档，解释了我们为什么需要这样的技术、不同的工具解决的问题是什么。</p><h2 id="Color-Correction的作用"><a href="#Color-Correction的作用" class="headerlink" title="Color Correction的作用"></a>Color Correction的作用</h2><p>Color Correction的作用是要保证每一个视频看起来是最佳的状态。</p><p>视频编辑人员的目的是通过艺术的风格呈现图像，以实现艺术化的效果，手段就是需要调整图片的色彩和对比度，最终的结果是尽可能接近导演和摄影师的想法。</p><ol><li>在处理的过程当中需要<strong>解决曝光异常、白平衡等问题</strong>，这些是在视频拍摄过程中不可避免的问题。此外，你可以做一些<strong>细微的调整来增加温暖感或对比度</strong>，这在拍摄过程中是没有的，但摄影师会喜欢的效果。</li><li>新一代的数字电影摄像机能够拍摄原始的色彩空间图像数据，或带有L指数曝光的RGB图像数据，以便在色彩校正过程中保留最大数量的图像数据以供操作。然而，当你以这种方式获取图像数据时，<strong>它必须通过颜色校正转换成可视图像</strong>，就像底片必须先冲洗并打印成正片一样。</li><li>色彩校正过程中另一个重要的方面是<strong>对视频内的特定元素进行强调或弱化的能力</strong>。它在概念上类似于音频混合中的均衡，因为您可以使用多种技术来选择要增强或抑制哪些颜色值。例如用一个Power窗口包围图像的特定部分，这可以引导观看者的视线。<span id="more"></span></li></ol><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>Color Corection的目的主要是调节色相、饱和度和对比度。我们有很多方式。</p><p>Color balance wheels能够通过调节三个颜色通道，在特定范围内改变场景的色温： lift, gamma, 和 gain。</p><p>这里简单的介绍一下Color Grading的使用方式。</p><p>在Nuke、DaVinCi之类的软件中经常会用到这些操作。</p><h2 id="色彩区域与操作"><a href="#色彩区域与操作" class="headerlink" title="色彩区域与操作"></a>色彩区域与操作</h2><p>high light：高亮度区域</p><p>mid tone: 中等亮度区域</p><p>shadow：暗部</p><p>DaVinCi软件的解释：</p><p><img src="/../../images/%E5%90%8E%E5%A4%84%E7%90%86ColorGrading/1584523933324.png" alt="1584523933324"></p><p>操作影响的强度曲线：</p><p><img src="/../../images/%E5%90%8E%E5%A4%84%E7%90%86ColorGrading/1584524629621.png" alt="1584524629621"></p><p>Lift操作主要用来定位图像的阴影区域。</p><p>Gamma操作主要用来定位图像的中灰度区域。</p><p>Gain操作主要用来定位图像的高亮区域。</p><p>下面操作的强度曲线：</p><p><img src="/../../images/%E5%90%8E%E5%A4%84%E7%90%86ColorGrading/1584524661341.png" alt="1584524661341"></p><p>Shadows 调节暗部的亮度分布。</p><p>Midtone 调节中灰度的亮度分布。</p><p>Highlights  调节高亮部分的亮度分布。</p><h2 id="操作的数学解释"><a href="#操作的数学解释" class="headerlink" title="操作的数学解释"></a>操作的数学解释</h2><p>下图是图示说明：</p><p><img src="/../../images/%E5%90%8E%E5%A4%84%E7%90%86ColorGrading/nuke_lift_gamma_gain.jpg" alt="img"></p><p>在软件当中的控制方式：</p><p><img src="/../../images/%E5%90%8E%E5%A4%84%E7%90%86ColorGrading/davinci_color_wheel.jpg" alt="img"></p><p>Gain:这个操作影响白点，而保持黑点不变。</p><p>$$ Output &#x3D; input * gain $$</p><p>Lift: 这个操作影响黑点，而保持白点不变。</p><p>$$ Output &#x3D; ( input * ( 1 – lift ) ) + lift $$</p><p>不同的处理实际上就是对颜色整体亮度或者单个通道进行数学操作。</p><p>Offset: 亮度整体偏移：</p><p>$$ Output &#x3D; input + offset  $$</p><p>Lift and Gain together：</p><p>$$ Output &#x3D; ( input * ( gain – lift ) ) + lift $$</p><p>Gamma：</p><p>$$ Output &#x3D; input^{(1&#x2F;gamma)} $$ </p><p>Contrast：</p><p>$$ Output &#x3D; – ( input * (1 + contrast ) ) – (contrast &#x2F; 2 ) $$</p><p>Greyscale :</p><p>$$ (R<em>0.299 + G</em>0.587 + B*0.114). $$</p><p>饱和度调整：</p><p>$$ Output &#x3D; Saturation * input + (1 – Saturation ) * Greyscale $$</p>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Density Volume使用方式</title>
      <link href="/2022/07/09/HDRPartist/Density%20Volume%203D%E7%BA%B9%E7%90%86%E5%88%B6%E4%BD%9C%E6%96%B9%E6%A1%88/"/>
      <url>/2022/07/09/HDRPartist/Density%20Volume%203D%E7%BA%B9%E7%90%86%E5%88%B6%E4%BD%9C%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Density-Volume使用方式"><a href="#Density-Volume使用方式" class="headerlink" title="Density Volume使用方式"></a>Density Volume使用方式</h1><p>Density Volume主要用来设置局部雾，界面如下：</p><p><img src="/../../images/img/density_volume.jpg.jpg" alt="density_volume.jpg"></p><h2 id="基础参数"><a href="#基础参数" class="headerlink" title="基础参数"></a>基础参数</h2><p>Fog Distance ：雾的可见距离，单位：m（米），值越小表示雾越浓，越大雾越稀薄，推荐值：5-100。</p><p>Blend Distance ：局部雾边界的衰减距离。边界处雾浓度为0，越向内部走浓度越大。这个值表示从边界开始到雾最浓的位置的距离。</p><p>Distance Fade Start：雾浓度的开始衰减位置，与摄像机的距离。</p><p>Distance Fade End：雾浓度衰减到0的位置，与摄像机的距离。</p><p>Texture：雾的纹理。</p><p>Scroll Speed：雾纹理的流动速度。</p><p>Tiling ：雾纹理的Tiling数。</p><p>更具体参数说明见：<a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@5.3/manual/Volumetric-Fog.html">官方文档</a></p><h2 id="Density-Mask-Texture制作方式"><a href="#Density-Mask-Texture制作方式" class="headerlink" title="Density Mask Texture制作方式"></a>Density Mask Texture制作方式</h2><p>Density Mask Texture主要用来给雾添加一些简单的纹理和噪声，无法制作复杂的结构。只支持分辨率为32 * 32 * 32的3D纹理。纹理制作方式如下：</p><p>使用Houdini可以生成Texture的纹理。</p><p>制作方式：</p><p>1.Houdini当中的操作：</p><p>1.1 在Houdini里做一个自己想要的Volume形态</p><p><img src="/../../images/img/cloud.png" alt="cloud"></p><p>1.2 使用GameDev ROP Volume Texture节点将Volume输出1024*32的黑白图片格式。</p><p><img src="/../../images/img/node.png" alt="node"></p><p>1.3 节点属性设置</p><p><img src="/../../images/img/export.png" alt="export"></p><p>1.4 最终会生成 1024*32分辨率的jpg格式图片，如下图所示：</p><p><img src="/../../images/img/aaa.jpg" alt="aaa"></p><p>2.将生成的图片导入Unity，导入设置如下图所示：</p><p><img src="/../../images/img/texture_import.jpg" alt="texture_import"></p><p>3.通过导入的图片，生成VolumeTexture。打开Window&#x2F;Rendering&#x2F;Density Volume Texture Tool。拖入图片，将Texture Slice Size设置成32（只能是32），点击Create 3D Texture，生成3D纹理。</p><p><img src="/../../images/img/generation.jpg" alt="generation"></p><p>4.使用。上一步中生成的3D纹理和输入图片在同一目录中。生成的3D纹理文件名为：XXXX_Texture3D，可以直接用做Density Mask Texture。</p><p><img src="/../../images/img/result.jpg" alt="result"></p><p>5.结果。</p><p><img src="/../../images/img/result2.jpg" alt="result2"></p>]]></content>
      
      
      <categories>
          
          <category> HDRPartist </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CubeMap生成与使用</title>
      <link href="/2022/07/09/HDRPartist/CubeMap%E7%94%9F%E6%88%90/"/>
      <url>/2022/07/09/HDRPartist/CubeMap%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h1 id="CubeMap生成与使用"><a href="#CubeMap生成与使用" class="headerlink" title="CubeMap生成与使用"></a>CubeMap生成与使用</h1><h2 id="使用工具生成CubeMap"><a href="#使用工具生成CubeMap" class="headerlink" title="使用工具生成CubeMap"></a>使用工具生成CubeMap</h2><p>主要内容来自于<a href="https://docs.unrealengine.com/en-US/Engine/Content/Types/Textures/Cubemaps/index.html">UE4官方文档</a></p><h3 id="需要一张HDR贴图"><a href="#需要一张HDR贴图" class="headerlink" title="需要一张HDR贴图"></a>需要一张HDR贴图</h3><p>在<a href="https://hdrihaven.com/hdris/category/?c=skies">HDRIhaven</a>中可以搜索到很多免费的HDRI贴图。</p><p>是一张：railway_bridges_4k.hdr的贴图</p><p><img src="/../../images/CubeMap%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1574128098932.png" alt="1574128098932"></p><h2 id="从HDRI到映射到Cubemap"><a href="#从HDRI到映射到Cubemap" class="headerlink" title="从HDRI到映射到Cubemap"></a>从HDRI到映射到Cubemap</h2><p>这个时候需要用到xNormal工具。</p><ol><li>点击High definition加载一个Cube的mesh。</li></ol><p><img src="/../../images/CubeMap%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1574133444216.png" alt="1574133444216"></p><p>2.点击Base Texture to bake，加载这张hdri贴图</p><p><img src="/../../images/CubeMap%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1574133454919.png" alt="1574133454919"></p><p>3.点击Low definition meshes，加载一个Sphere形状的mesh。</p><p><img src="/../../images/CubeMap%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1574133470000.png" alt="1574133470000"></p><p>4.点击Bake Options，Size设置成4096, 512. (本身应该是6:1但是这里没有3072这个选项).。Maps to Render 设置成Bake base texture。Output File设置一个合适的名字：</p><p><img src="/../../images/CubeMap%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1574133482559.png" alt="1574133482559"></p><p>5.点击右下角的Generation Maps，生成结果：</p><p><img src="/../../images/CubeMap%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1574133497943.png" alt="1574133497943"></p><h3 id="调整Cubemap格式和尺寸"><a href="#调整Cubemap格式和尺寸" class="headerlink" title="调整Cubemap格式和尺寸"></a>调整Cubemap格式和尺寸</h3><ol><li><p>需要一个NVIDIA的ps4插件工具：<a href="https://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop">NVIDIA Texture Tools for Adobe Photoshop</a>, 注意支持的ps版本。</p></li><li><p>用ps打开上面的贴图</p><p><img src="/../../images/CubeMap%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1574133528409.png" alt="1574133528409"></p></li><li><p>调整到正确的尺寸6:1，（下面图片有点错误）</p></li></ol><p><img src="/../../images/CubeMap%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1574133585920.png" alt="1574133585920"></p><ol start="4"><li>存储为dds</li></ol><p><img src="/../../images/CubeMap%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1574132648798.png" alt="1574132648798"></p><ol start="5"><li>点击保存会显示，注意下面的格式，CubeMap  、8888、No MIP maps（unity和ue4会生成自己的mipmap应该）：</li></ol><p><img src="/../../images/CubeMap%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1574132674591.png" alt="1574132674591"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>这张cubemap可以直接在Unity和UE4当中使用。</p><h2 id="CubeMap的采样"><a href="#CubeMap的采样" class="headerlink" title="CubeMap的采样"></a>CubeMap的采样</h2><h3 id="Unity非HDRP"><a href="#Unity非HDRP" class="headerlink" title="Unity非HDRP"></a>Unity非HDRP</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">half3 <span class="hljs-title function_">Unity_GlossyEnvironment</span> <span class="hljs-params">(UNITY_ARGS_TEXCUBE(tex), half4 hdr, Unity_GlossyEnvironmentData glossIn)</span><br>&#123;<br>    half perceptualRoughness = glossIn.roughness <span class="hljs-comment">/* perceptualRoughness */</span> ;<br><span class="hljs-comment">// 这部分是让其尽快模糊起来</span><br>    perceptualRoughness = perceptualRoughness*(<span class="hljs-number">1.7</span> - <span class="hljs-number">0.7</span>*perceptualRoughness);<br><br>    half mip = perceptualRoughnessToMipmapLevel(perceptualRoughness);<br>    half3 R = glossIn.reflUVW; <span class="hljs-comment">// 反射方向</span><br>    half4 rgbm = UNITY_SAMPLE_TEXCUBE_LOD(tex, R, mip); <span class="hljs-comment">// 采样贴图</span><br><br>    <span class="hljs-keyword">return</span> DecodeHDR(rgbm, hdr);<br>&#125;<br><br><span class="hljs-comment">// 从粗糙度到mipmap等级</span><br>half <span class="hljs-title function_">perceptualRoughnessToMipmapLevel</span><span class="hljs-params">(half perceptualRoughness)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> perceptualRoughness * UNITY_SPECCUBE_LOD_STEPS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Unity-HDRP的cubemap采样"><a href="#Unity-HDRP的cubemap采样" class="headerlink" title="Unity HDRP的cubemap采样"></a>Unity HDRP的cubemap采样</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"> R = lerp(R, preLightData.iblR, saturate(smoothstep(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, roughness * roughness)));<br><br><span class="hljs-comment">// 计算的效果</span><br>preLightData.iblPerceptualRoughness = bsdfData.perceptualRoughness;<br><span class="hljs-comment">/// 计算要采样的mipmap的层级</span><br>   iblMipLevel = PerceptualRoughnessToMipmapLevel(preLightData.iblPerceptualRoughness);<br><br><span class="hljs-comment">/// 和非HDRP的效果一样</span><br>real <span class="hljs-title function_">PerceptualRoughnessToMipmapLevel</span><span class="hljs-params">(real perceptualRoughness, uint mipMapCount)</span><br>&#123;<br>    perceptualRoughness = perceptualRoughness * (<span class="hljs-number">1.7</span> - <span class="hljs-number">0.7</span> * perceptualRoughness);<br><br>    <span class="hljs-keyword">return</span> perceptualRoughness * mipMapCount;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="UE4"><a href="#UE4" class="headerlink" title="UE4"></a>UE4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> REFLECTION_CAPTURE_ROUGHEST_MIP 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REFLECTION_CAPTURE_ROUGHNESS_MIP_SCALE 1.2</span><br><br>half <span class="hljs-title function_">ComputeReflectionCaptureMipFromRoughness</span><span class="hljs-params">(half Roughness, half CubemapMaxMip)</span><br>&#123;<br><span class="hljs-comment">// Heuristic that maps roughness to mip level</span><br><span class="hljs-comment">// This is done in a way such that a certain mip level will always have the same roughness, regardless of how many mips are in the texture</span><br><span class="hljs-comment">// Using more mips in the cubemap just allows sharper reflections to be supported</span><br>half LevelFrom1x1 = <span class="hljs-number">1</span> - <span class="hljs-number">1.2</span> * log2(Roughness);<br><span class="hljs-keyword">return</span> CubemapMaxMip - <span class="hljs-number">1</span> - LevelFrom1x1;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HDRPartist </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HDRP基础Shader</title>
      <link href="/2022/07/09/HDRPartist/HDRP%E5%9F%BA%E7%A1%80Shader/"/>
      <url>/2022/07/09/HDRPartist/HDRP%E5%9F%BA%E7%A1%80Shader/</url>
      
        <content type="html"><![CDATA[<h2 id="HDRP版本"><a href="#HDRP版本" class="headerlink" title="HDRP版本"></a>HDRP版本</h2><p>目前用户可以使用的是HDRP6.0.0+2019.2.0a4</p><h2 id="Deferred和Forward"><a href="#Deferred和Forward" class="headerlink" title="Deferred和Forward"></a>Deferred和Forward</h2><p>Shader渲染物体，目前还是分为：<strong>deferred</strong>和<strong>forward</strong>两种模式。程序设置需要打开全部的两种：</p><p><img src="/../../images/img/1.png"></p><p>Motion Vectors : 用于制作反走样和动态模糊</p><p>Dithering Cross-fade：开启LOD的过渡，HDRP内置支持不需要自己实现。</p><p>Transparent Backface: 允许透明物体渲染背面；（可以再透明物体材质上开启这个选项，否则透明物体双面渲染不生效）。</p><p>Transparent Depth Prepass：允许给透明物体渲染深度。（也需要在材质中开启），可以接受Decal。</p><p>等。</p><p>以上内容都在材质中有对应选项。</p><p>##主要Shader类型</p><p>目前可以直接创建或通过ShaderGraph创建的Shader有一下几种：</p><ul><li>Unlit  不受光材质</li><li>Lit  受光材质</li><li>HairGraph</li><li>Decal </li><li>DecalGraph</li><li>UnlitGraph</li><li>LitGraph</li><li>LayeredLit</li><li>TillingLit</li></ul><p>上面的Shader有很多特性，比如SSS，自发光。但是最终的效果会由于所处的渲染模式（<strong>deferred</strong>和<strong>forward</strong>）有所区别，比如：<u>在Deferred模式下，自发光会受AO贴图影响。</u></p><p>##HDRP材质特性</p><p>LitShader可以看到大部分的材质特性。下面详细介绍基础Lit材质的特性。</p><p><img src="/../../images/img/2.PNG"></p><h3 id="Surface-Options"><a href="#Surface-Options" class="headerlink" title="Surface Options"></a>Surface Options</h3><p>**Surface Type:**表面类型可以分为：Opaque和Transparent。透明不透明和Standard基本一样。</p><p>如果选择Opaque那么下面的<strong>Rendering Pass就只有Default</strong></p><p>如果选择Transparent那么Surface下面会变成：</p><p><img src="/../../images/img/3.PNG"></p><p><strong>Rendering Pass：</strong>当中会多了一个选项<strong>Before Refraction</strong>：表示这个物体不会受到折射的影响。</p><p><strong>Blending Mode ：</strong>只有标准的三种透明物体混合类型。</p><p><strong>Preserve specular lighting：</strong>当受光物体打开高光的时候，在完全透明的地方会发生高光反射，如果希望Alpha为0的地方就是完全透明，那么就取消选择。下面是比较：</p><p><img src="/../../images/img/4.PNG" alt="没有开启保护高光选项"></p><p><img src="/../../images/img/5.PNG" alt="开启保护高光选项"></p><p><strong>Sorting Priority:</strong> 代替原来的Render Queue，数字越大渲染越晚。HDRP不建议手动修改Render Queue。透明物体的渲染顺序通过Render Queue来设置。每一个Shader的渲染队列最好是固定的。</p><p><strong>Receive fog ：</strong>接受雾。</p><p>Back Then Front Rendering:先渲染物体背面 然后渲染正面。</p><p>Trans Depth Prepass ：用于让这个透明物体能够正确的接受某些后处理效果。比如decal。</p><p>Trans Depth Postpass ：用于让这个透明物体能够正确的接受某些后处理效果。比如dof。</p><p>上面三个效果不建议开启，非常影响性能。每多开一个，这个类型的材质就会多一个pass。</p><p><strong>Double-Sided：</strong>双面渲染，如果开启就会多一个Normal Model，用来设置反面的法线。</p><p><strong>Alpha Clipping：</strong>开启cutout功能，如果开启就会多一个Threshold，用于设置cutout的阈值。</p><p><img src="/../../images/img/6.png"></p><p>上面<strong>Use Shadow Threshold</strong>如果打开，那么计算阴影可以单独设置cutout阈值，比如头发，希望投射的阴影少一点，那么就把这个值调大。</p><p><strong>Receive Decals：</strong>接受Decal</p><p><strong>Receive SSR：</strong>接受SSR</p><p>透明物体不接受decal。</p><p><strong>Geomeric Specular AA ：</strong>某种反走样 没研究。</p><p><strong>Displacement Mode :</strong> 开启顶点移动，或者开启视差贴图（或者叫做BumpOfsfet或者POM）。</p><p>Vertex Displacement 就是开启顶点移动功能。 这个功能特效常用。</p><p>Pixel Displacement 就是开启视差贴图。</p><p>这两个打开都会开启一张高度图。还有一些设置。具体需求具体分析。</p><h3 id="Vertex-Animation"><a href="#Vertex-Animation" class="headerlink" title="Vertex Animation"></a>Vertex Animation</h3><p>会为顶点动画计算MotionVector（正常情况是只为一个gameobect计算），只在特殊的地方会用，默认关闭。</p><h3 id="Surface-Inputs"><a href="#Surface-Inputs" class="headerlink" title="Surface Inputs"></a>Surface Inputs</h3><p>BaseMap :</p><p>Metallic:</p><p>Smoothness:</p><p>MaskMap :  R通道 : Metallic </p><p>​             G通道 : Ambient occlusion  </p><p>​     B : Detial mask  后面解释 </p><p>​                     A通道 :Smothness</p><p>Normal:</p><p>BentNormal: 环境法线，在计算环境光照（LightMap和lightProbe）的时候替代原本的法线，进行计算。（Normal和BentNormal必须属于同一个空间）。这个方向用来描述主要的进光方向。也就是说，环境光不在使用法线进行凹凸的模拟，而是使用BentNormal进行明暗计算。</p><p>Coat Mask ： 没研究。</p><p>Base UV mapping 使用的UV通道。 同时支持Triplanar 和Planar。</p><h3 id="Detial-Map"><a href="#Detial-Map" class="headerlink" title="Detial Map"></a>Detial Map</h3><p>细节贴图： R: 颜色深浅 </p><p>​   G: 细节法线的y通道</p><p>​                  B：平滑度</p><p>​                  A：细节法线x通道</p><p>​默认值 0.5 0.5 0.5 0.5 表示不对原始材质产生任何影响。0表示减弱，1表示增强。</p><p>​上面的MaskMap的B通道：Detial mask 用于选择那些区域受 DetialMap影响。</p><p>如果在DetialMap 上放入了纹理就会出现更多选项。</p><p><img src="/../../images/img/7.PNG"></p><p>Detial UV mapping 表示要使用的通道。可以有自己的Tilling。</p><p>下面的三个滑块用于进一步调节范围。</p><h3 id="Emisstion-Inputs"><a href="#Emisstion-Inputs" class="headerlink" title="Emisstion Inputs"></a>Emisstion Inputs</h3><p>自发光。可以使用单独的UV。</p><h3 id="Advanced-Options"><a href="#Advanced-Options" class="headerlink" title="Advanced Options"></a>Advanced Options</h3><p>GPU Instancing</p><p>Secular Occlusion from bent nomral  ：BentNormal除了计算自发光之外同时也影响高光的明暗。</p>]]></content>
      
      
      <categories>
          
          <category> HDRPartist </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shader Graph</title>
      <link href="/2022/07/09/HDRPartist/Shader%20Graph/"/>
      <url>/2022/07/09/HDRPartist/Shader%20Graph/</url>
      
        <content type="html"><![CDATA[<h1 id="Shader-Graph"><a href="#Shader-Graph" class="headerlink" title="Shader Graph"></a>Shader Graph</h1><h2 id="ShaderGraph基本面板"><a href="#ShaderGraph基本面板" class="headerlink" title="ShaderGraph基本面板"></a>ShaderGraph基本面板</h2><p>​shader基本面板如下：连线表示所控制面板的开关。</p><p><img src="/../../images/img/8.PNG"></p><p>目前Shader Graph有bug会导致BlackBoard消失。需要复制一下Graph文件再打开就好了。</p><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>作用：Shader <strong>Graph可以</strong>创建不同的Shader（<strong>主要是Master节点</strong>，如上图的PBR Master，不同的Master主要用来渲染不同的物体，比如Hair Master就是头发，Fabric Master就是布料，Lit Master就是一般的受光物体，Unlit Master就是一般的不受光物体，Decal Master就是贴花）。</p><p><img src="/../../images/img/11.png"></p><p>我们可以创建很多种Graph，<strong>这些ShaderGraph的区别就是这个Master节点</strong>。</p><p><strong>每一个Master节点都接收一组特定的输入，就是上图中左侧的一排参数</strong>（根据Feature设定，输入会发生变化，后面会会说明）。Master节点内部是一种光照模型，会根据这些参数计算出最终的颜色。</p><p><strong>ShaderGraph的主要作用就是获取材质面板当中的输入（如何设置材质的输入参数，以及如何计算后面说明），来计算这个Master节点的输入。</strong></p><h3 id="Master-Feature"><a href="#Master-Feature" class="headerlink" title="Master Feature"></a>Master Feature</h3><p>每个Shader又可以选择不同的特性（Feature），特性设置的地方见下图：</p><p><img src="/../../images/img/9.PNG"></p><p><strong>每一个Master节点打开的这个特性面板是不一样的。</strong>（上面的PBR Master节点主要是为了兼容非HDRP版本的贴图。）</p><p><strong>这些特性基本上全部可以在默认的Lit 当中看到。</strong>（除此以外还有一些特殊的Shader有一些特殊的功能，比如头发，布料。）</p><p>可以新建不同的Shader Graph然后查看这个面板有什么不同，在调整这些参数看看，会多出哪些输入。</p><p>例如下面的Lit Master，Feature面板当中的全部内容，都可以再Lit的说明中找到。</p><p><img src="/../../images/img/12.PNG"></p><h3 id="BlackBoard"><a href="#BlackBoard" class="headerlink" title="BlackBoard"></a>BlackBoard</h3><p><strong>作用</strong>:BlackBoard主要的作用就是显示所有的材质输入（和ASE当中Properties属性的节点一样）。</p><p>如下图所示：</p><p><img src="/../../images/img/10.png"></p><p><strong>添加</strong>:材质的输入，可以通过右上角的加号添加，而上方图片当中已经包括了可以使用的全部类型。这些数据会显示在材质列表当中。点开每一个具体的参数还能够进行更详细的设置。</p><h3 id="Main-Preview"><a href="#Main-Preview" class="headerlink" title="Main Preview"></a>Main Preview</h3><p>就是材质预览</p><h2 id="Shader-节点"><a href="#Shader-节点" class="headerlink" title="Shader 节点"></a>Shader 节点</h2><p>目前已经知道ShaderGraph的才做包括：<strong>基础面板、添加材质参数、开关Shader特性、查看材质预览</strong>。</p><p>现在就是需要读取材质输入参数，然后通过连接节点进行计算，最终输出到Master节点当中。</p><p>在空白处单击右键可以创建节点，如下：</p><p><img src="/../../images/img/13.PNG"></p><p><strong>Artistic ：</strong> 预定义的计算：颜色通道转换，Color Mask获取，法线混合，颜色混合，颜色空间装换，颜色翻转、替换、白平衡调节等。</p><p><strong>Channel：</strong> 颜色通道的合并、拆分、替换、反转。</p><p><strong>Input:</strong> 表示所有可能类型的输入，包括Unity内置的一些全局设置：烘焙的GI贴图，反射探针，屏幕的位置，雾的参数,屏幕颜色，屏幕深度等等（没测试过）。这些内容是ASE做不到的。</p><p><strong>Math：</strong> 就是一些数学计算</p><p><strong>Procedural</strong>: 程序生成的几何体，噪声。</p><p><strong>Properties</strong>：<strong>Blackboard当中的输入。</strong></p><p><strong>Utility:</strong> 对于参数的判断：是否是非法数据，分支（不是宏），与或非，参数是否非0，颜色是否全是0等。<strong>这里有个Preview工具，能够让美术对中间步骤进行检查。</strong></p><p><strong>UV:</strong> UV工具，能够对UV进行各种运算 ，映射。</p><p><strong>和ASE最大的区别就是：目前无法定义宏。</strong></p><p><strong>Master：</strong> 一个Graph当中可以存在多个节点。会发生什么还没有研究</p><h2 id="和ShaderGraph相关的问题"><a href="#和ShaderGraph相关的问题" class="headerlink" title="和ShaderGraph相关的问题"></a>和ShaderGraph相关的问题</h2><h3 id="普通Decal无法控制"><a href="#普通Decal无法控制" class="headerlink" title="普通Decal无法控制"></a>普通Decal无法控制</h3><p>这个说的应该是，Decal材质当中没有参数，这就需要自己写Shader。</p><p>ShaderGraph提供了制作DecalGraph的功能。在Asset中创建一个Decal Graph（如果没有可能是版本太老，可以使用HDRP 6.0.0）</p><p><img src="/../../images/img/14.PNG"></p><p>Decal 和原来的版本一样就是从一个方向上朝一个表面投射一种材质。原理就是使用你计算出来的颜色、法线、金属度、AO、平滑度等去<strong>覆盖</strong>原本平面的这些内容。</p><p><strong>Positon</strong>：对于Decal这个参数一般不懂。</p><p><strong>BaseColor :</strong> 表示要用来覆盖原始颜色的内容。</p><p><strong>BaseColor Opacity</strong>: 表示颜色覆盖的程度。</p><p><strong>Normal：</strong>表示要用来覆盖的法线。</p><p><strong>Normal Opacity：</strong>表示法线混合的程度。</p><p><strong>Metallic:</strong></p><p><strong>AO:</strong></p><p><strong>Smothness:</strong></p><p><strong>MAOS Opacity:</strong> 同时控制Metallic  AO Smothness三个参数的覆盖程度。</p><p>如果使用默认的Decal，如下图。</p><p><img src="/../../images/img/15.PNG"></p><p>默认的材质贴图主要也是Decal Graph的内容，只不过这个Shader有一个自己的编辑器，所以选项可以变化。不过支持的参数内容是一样的。其中Mask Map 中B通道是透明度，A通道是平滑度。</p><p>下面有一样注释：</p><p><strong>Control of  AP and Metal is based on Option ………… 。 这个是说需要在HDRP设置当中打开Enable Metal and AO properties 功能才能使用金属度和AO的覆盖。同时有性能开销。</strong></p><p><strong>需要注意的是，这个选项如果不打开，Decal Graph当中的功能也不能用，虽然提供了输入。</strong></p><h3 id="UnlitDecal"><a href="#UnlitDecal" class="headerlink" title="UnlitDecal"></a>UnlitDecal</h3><p>unity在HDRP6.3.0 版本当中提供了Decal自发光的功能，也就是Unlit功能。在DecalGraph当中就可以看到多了一个emission的接口。</p><h3 id="顶点动画"><a href="#顶点动画" class="headerlink" title="顶点动画"></a>顶点动画</h3><p>我查看了Base_Ice_weapon当中的顶点动画，就是计算一个向量，然后移动模型的顶点位置。</p><p><strong>所有的Graph都提供了这个功能，可以任意创建一个Shader Graph，Master节点第一个参数就是Postion. 这个位置可以进行修改。</strong></p>]]></content>
      
      
      <categories>
          
          <category> HDRPartist </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity物理摄像机属性</title>
      <link href="/2022/07/09/HDRPartist/unity%E7%89%A9%E7%90%86%E6%91%84%E7%9B%B8%E6%9C%BA/"/>
      <url>/2022/07/09/HDRPartist/unity%E7%89%A9%E7%90%86%E6%91%84%E7%9B%B8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity物理摄像机属性"><a href="#Unity物理摄像机属性" class="headerlink" title="Unity物理摄像机属性"></a>Unity物理摄像机属性</h1><p>物理摄像机有机身和透镜，机身决定了传感器的尺寸，透镜决定了焦距。这些属性共同决定了水平和垂直的视野。</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>A physical camera’s vertical field of view and aspect ratio are driven by the<br>sensor size and focal length.</p><p>物理摄像机的视野和视角比例是根据传感器尺寸和焦距决定的。</p><p>Sensor Type、SensorSize 、Focal Length共同决定了摄像机视口和纵横比。（如果要开启这一功能还需要在Genaral设置当中勾选Link FOV to Physical Camera）</p><p><img src="/../../images/img/Camera.jpg"></p><p>下面就是参数之间的关系：</p><p><img src="/../../images/img/Camera2.jpg"></p><p>水平的FOV的计算：<br>$$<br>    fov &#x3D; 2 * (\frac{180}{\pi}) * atan(\frac{sensorSize.y}{2*focalLength})<br>$$<br>纵横比的计算：<br>$$<br>aspect&#x3D;\frac{SensorSize.x}{SensorSize.y}<br>$$</p><h2 id="Additions-to-the-Camera-Inspector"><a href="#Additions-to-the-Camera-Inspector" class="headerlink" title="Additions to the Camera Inspector"></a>Additions to the Camera Inspector</h2><p>The <strong>Physical Camera</strong> checkbox enables or disables the physical camera<br>mode.(目前这个已经不是了)</p><p><strong>Lens shift</strong>：可以用来修改、矫正透视效果，具体参见Unity 文档</p><h1 id="灯光设置"><a href="#灯光设置" class="headerlink" title="灯光设置"></a>灯光设置</h1><h2 id="物理摄像机控制场景亮度"><a href="#物理摄像机控制场景亮度" class="headerlink" title="物理摄像机控制场景亮度"></a>物理摄像机控制场景亮度</h2><p>在摄影当中控制画面亮度的参数：</p><p>Aperture：光圈</p><p>Iso：感光度</p><p>Shutter Speed：快门速度</p><p>在摄像机的三个参数当中，可以通过控制这三个参数来调整画面的亮度。</p><p>如果要启用给予物理的控制，还需要在后处理当中设置Exposure为：<strong>Use Physical Camera</strong>。</p><p>在Exposure当中还有曝光补偿（Compensation），用来整体调整画面亮暗。</p><h2 id="灯光亮度设置"><a href="#灯光亮度设置" class="headerlink" title="灯光亮度设置"></a>灯光亮度设置</h2><p>在物理摄像机当中，有个重要的改进就是可以使用真实的灯光参数单位：Lux。</p><p>如果不用物理摄像机，那么这个灯光参数就还是无法和物理世界光的亮度对应起来，例如太阳亮度：60000-100000lux，大气光亮度：5000-10000，如果不用物理摄像机这两个值就还是需要凭感觉调整。</p><p>使用物理摄像机之后就可以查找真实的Lux和Luminance参数，直接设置给光源 或者自发光物体。</p><h2 id="给予物理参数的灯光配置流程"><a href="#给予物理参数的灯光配置流程" class="headerlink" title="给予物理参数的灯光配置流程"></a>给予物理参数的灯光配置流程</h2><h3 id="1-首先要配置基本的灯光环境"><a href="#1-首先要配置基本的灯光环境" class="headerlink" title="1.首先要配置基本的灯光环境"></a>1.首先要配置基本的灯光环境</h3><p><strong>配置场景的直线光环境光</strong>,光照强度需要根据真实的物理世界进行调整，太阳直射为：32000-100000。<strong>这里只需要设置环境光强度即可。</strong></p><p><img src="/../../images/img/%E7%9B%B4%E7%BA%BF%E5%85%89.jpg"></p><p>下面的表格来自于wikipedia，可以参考用来设置光源亮度</p><table><thead><tr><th>Illuminance (lux)</th><th>Surfaces illuminated by</th></tr></thead><tbody><tr><td>0.0001</td><td>Moonless, overcast night sky (<a href="https://en.wikipedia.org/wiki/Star#Radiation">starlight</a>)[<a href="https://en.wikipedia.org/wiki/Lux#cite_note-radfaq-3">3]</a></td></tr><tr><td>0.002</td><td>Moonless clear night sky with <a href="https://en.wikipedia.org/wiki/Airglow">airglow</a>[<a href="https://en.wikipedia.org/wiki/Lux#cite_note-radfaq-3">3]</a></td></tr><tr><td>0.05–0.3</td><td>Full moon on a clear night[<a href="https://en.wikipedia.org/wiki/Lux#cite_note-4">4]</a></td></tr><tr><td>3.4</td><td>Dark limit of <a href="https://en.wikipedia.org/wiki/Twilight#Civil_twilight">civil twilight</a> under a clear sky[<a href="https://en.wikipedia.org/wiki/Lux#cite_note-5">5]</a></td></tr><tr><td>20–50</td><td>Public areas with dark surroundings[<a href="https://en.wikipedia.org/wiki/Lux#cite_note-NOAO_CaRLLI-6">6]</a></td></tr><tr><td>50</td><td>Family living room lights (Australia, 1998)[<a href="https://en.wikipedia.org/wiki/Lux#cite_note-energyrating-7">7]</a></td></tr><tr><td>80</td><td>Office building hallway&#x2F;<a href="https://en.wikipedia.org/wiki/Toilet_(room)">toilet</a> lighting[<a href="https://en.wikipedia.org/wiki/Lux#cite_note-8">8]</a>[<a href="https://en.wikipedia.org/wiki/Lux#cite_note-9">9]</a></td></tr><tr><td>100</td><td>Very dark overcast day[<a href="https://en.wikipedia.org/wiki/Lux#cite_note-radfaq-3">3]</a></td></tr><tr><td>150</td><td>Train station platforms[<a href="https://en.wikipedia.org/wiki/Lux#cite_note-10">10]</a></td></tr><tr><td>320–500</td><td>Office lighting[<a href="https://en.wikipedia.org/wiki/Lux#cite_note-energyrating-7">7]</a>[<a href="https://en.wikipedia.org/wiki/Lux#cite_note-11">11]</a>[<a href="https://en.wikipedia.org/wiki/Lux#cite_note-12">12]</a>[<a href="https://en.wikipedia.org/wiki/Lux#cite_note-13">13]</a></td></tr><tr><td>400</td><td><a href="https://en.wikipedia.org/wiki/Sunrise">Sunrise</a> or <a href="https://en.wikipedia.org/wiki/Sunset">sunset</a> on a clear day.</td></tr><tr><td>1000</td><td>Overcast day;[<a href="https://en.wikipedia.org/wiki/Lux#cite_note-radfaq-3">3]</a> typical <a href="https://en.wikipedia.org/wiki/TV_studio">TV studio</a> lighting</td></tr><tr><td>10,000–25,000</td><td>Full <a href="https://en.wikipedia.org/wiki/Daylight">daylight</a> (not direct sun)[<a href="https://en.wikipedia.org/wiki/Lux#cite_note-radfaq-3">3]</a></td></tr><tr><td>32,000–100,000</td><td>Direct <a href="https://en.wikipedia.org/wiki/Sunlight">sunlight</a></td></tr></tbody></table><h3 id="2-配置环境光（Ambition-Light）"><a href="#2-配置环境光（Ambition-Light）" class="headerlink" title="2.配置环境光（Ambition Light）"></a>2.配置环境光（Ambition Light）</h3><p>环境光是依赖于天空球的：</p><p><img src="/img/Sky.jpg"></p><p><strong>环境光</strong>主要就是来源于<strong>Amient Mode</strong>的设置，这个设置会关联到下面的<strong>Static Lighting Sky</strong> 。会根据选择天空球计算环境光。这个环境光，会bake到光照探针当中，也会影响静态物体的LightMap。</p><p>目前HDRI Sky当中有Lux单位的环境光设置，而Preocedural Sky，所以建议使用HDRI天空球。</p><p><strong>另外，不建议使用Precedural Sky的太阳，也不要把太阳直接制作到HDRI上，建议使用另外的球或者片代替太阳。</strong></p><h3 id="3-上面两步设置完成之后"><a href="#3-上面两步设置完成之后" class="headerlink" title="3.上面两步设置完成之后"></a>3.上面两步设置完成之后</h3><p>需要开启自动曝光，并且选择Use Physical Camera模式：</p><p><img src="/img/Exposure.jpg"></p><p>其中Compensation是物理摄像机的曝光补偿默认为0，只是略微整体调整画面亮度和实现特殊效果的，最好不要用来整体修改亮度。</p><p><strong>此时，如果天空是黑的，需要增强曝光度让天空变蓝。</strong></p><h3 id="4-调整直线光和环境光、加入补光和额外光源"><a href="#4-调整直线光和环境光、加入补光和额外光源" class="headerlink" title="4.调整直线光和环境光、加入补光和额外光源"></a>4.调整直线光和环境光、加入补光和额外光源</h3><p>到目前为止得到了一个基本正确的光照环境，<strong>需要在Game视图中观察实际亮度</strong>，Scene视图目前无法使用物理摄像机：</p><p><img src="/img/env.jpg"></p><p>添加点光源等局部光。添加光照探针和反射探针。</p><h3 id="5-进行场景烘焙"><a href="#5-进行场景烘焙" class="headerlink" title="5. 进行场景烘焙"></a>5. 进行场景烘焙</h3><p>再完成场景光源设置后可以进行 场景烘焙。</p><p>烘焙完成后需要使用不同金属度和平滑度的材质球测试环境的反应。</p><p>如果材质效果不满意需要通过补光添加光照探针等方式进一步调整</p><h3 id="6-增加雾等后处理效果"><a href="#6-增加雾等后处理效果" class="headerlink" title="6. 增加雾等后处理效果"></a>6. 增加雾等后处理效果</h3><h2 id="物理摄像机的底层原来"><a href="#物理摄像机的底层原来" class="headerlink" title="物理摄像机的底层原来"></a>物理摄像机的底层原来</h2><p>实际上就是在Shader当中完成光照计算之后，乘上一个预先生成的曝光图。可以在HDRP的ShaderPassForward.hlsl文件当中找到。</p><p>在Frag函数当中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>    <br>diffuseLighting *= GetCurrentExposureMultiplier();<br>specularLigting *= GetCurrentExposureMultiplier();<br>...<br></code></pre></td></tr></table></figure><p>这部分内容可以通过方法内部的贴图去搜索如何完成的计算。</p>]]></content>
      
      
      <categories>
          
          <category> HDRPartist </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在Substance当中使用Unity的Shading模型</title>
      <link href="/2022/07/09/HDRPartist/SubstanceUseUnityShading/"/>
      <url>/2022/07/09/HDRPartist/SubstanceUseUnityShading/</url>
      
        <content type="html"><![CDATA[<h1 id="在Substance当中使用Unity的Shading模型"><a href="#在Substance当中使用Unity的Shading模型" class="headerlink" title="在Substance当中使用Unity的Shading模型"></a>在Substance当中使用Unity的Shading模型</h1><p>​在PBR的游戏资源制作中，最常用的贴图绘制工具就是Substance Painter。</p><p>​一般的流程是在SP当中绘制到模型贴图然后在导入到unity当中。</p><p>​在这个过程中美术会遇到很严重的效果不匹配的问题，在Unity中效果不理想就需要返回SP当中重新调整。因为SP的光照模型和Unity的光照模型不同，尤其是在Unity升级了HDRP以后光照计算再次出现了变化。<strong>为了能够让贴图绘制人员能够在SP和Unity当中看到的效果一致，我们需要重写SP的光照计算Shader。</strong></p><p>​SP提供了这个功能，参考的文件夹位于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Substance Painter\resources\shelf\allegorithmic\shaders<br></code></pre></td></tr></table></figure><p>​这个目录下面有很多glsl文件，语法使用glsl语法，能够控制的部分类似于Unity Legac的Surface Shader。 </p><p>​下面是我实现的SPShader，使用了和Unity一样的光照模型，支持<strong>Substance Painter 2019.1.0</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//- Allegorithmic Metal/Rough PBR shader</span><br><span class="hljs-comment">//- ====================================</span><br><span class="hljs-comment">//-</span><br><span class="hljs-comment">//- Import from libraries.</span><br>import lib-sss.glsl<br>import lib-pbr.glsl<br>import lib-emissive.glsl<br>import lib-pom.glsl<br>import lib-utils.glsl<br><br><span class="hljs-comment">//- Declare the iray mdl material to use with this shader.</span><br><span class="hljs-comment">//: metadata &#123;</span><br><span class="hljs-comment">//:   &quot;mdl&quot;:&quot;mdl::alg::materials::skin_metallic_roughness::skin_metallic_roughness&quot;</span><br><span class="hljs-comment">//: &#125;</span><br><br><span class="hljs-comment">//- Channels needed for metal/rough workflow are bound here.</span><br><span class="hljs-comment">//: param auto channel_basecolor</span><br>uniform SamplerSparse basecolor_tex;<br><span class="hljs-comment">//: param auto channel_roughness</span><br>uniform SamplerSparse roughness_tex;<br><span class="hljs-comment">//: param auto channel_metallic</span><br>uniform SamplerSparse metallic_tex;<br><span class="hljs-comment">//: param auto channel_specularlevel</span><br>uniform SamplerSparse specularlevel_tex;<br><br><span class="hljs-comment">// -----------------------------------------------------------------------------</span><br><span class="hljs-comment">// Constants</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HALF_MAX        65504.0 <span class="hljs-comment">// (2 - 2^-10) * 2^15</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HALF_MAX_MINUS1 65472.0 <span class="hljs-comment">// (2 - 2^-9) * 2^15</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPSILON         1.0e-4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI              3.14159265359</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TWO_PI          6.28318530718</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOUR_PI         12.56637061436</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INV_PI          0.31830988618</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INV_TWO_PI      0.15915494309</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INV_FOUR_PI     0.07957747155</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HALF_PI         1.57079632679</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INV_HALF_PI     0.636619772367</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLT_EPSILON     1.192092896e-07 <span class="hljs-comment">// Smallest positive number, such that 1.0 + FLT_EPSILON != 1.0</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLT_MIN         1.175494351e-38 <span class="hljs-comment">// Minimum representable positive floating-point number</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLT_MAX         3.402823466e+38 <span class="hljs-comment">// Maximum representable floating-point number</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFAULT_SPECULAR_VALUE 0.04</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLT_INF  asfloat(0x7F800000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLT_EPS  5.960464478e-8  <span class="hljs-comment">// 2^-24, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HALF_MIN 6.103515625e-5  <span class="hljs-comment">// 2^-14, the same value for 10, 11 and 16-bit: https://www.khronos.org/opengl/wiki/Small_Float_Formats</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HALF_MAX 65504.0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UINT_MAX 0xFFFFFFFFu</span><br><br><span class="hljs-comment">// HDRP模拟光源</span><br><br><span class="hljs-comment">//: param custom &#123; &quot;default&quot;: [10.0, 10.0, 10.0], &quot;label&quot;: &quot;Light Direction&quot;, &quot;min&quot;: -20, &quot;max&quot;: 20 &#125;</span><br>uniform vec3 lightDir;<br><span class="hljs-comment">//: param custom &#123; &quot;default&quot;: 1.0, &quot;label&quot;: &quot;Light Color&quot;, &quot;widget&quot;: &quot;color&quot; &#125;</span><br>uniform vec3 lightColor;<br><span class="hljs-comment">//: param custom &#123; &quot;default&quot;: 1.0, &quot;label&quot;: &quot;Diffuse Dimmer&quot;, &quot;min&quot;: 0.0, &quot;max&quot;: 32.0 &#125;</span><br>uniform <span class="hljs-type">float</span> diffuseDimmer;<br><span class="hljs-comment">//: param custom &#123; &quot;default&quot;: 1.0, &quot;label&quot;: &quot;Specular Dimmer&quot;, &quot;min&quot;: 0.0, &quot;max&quot;: 32.0 &#125;</span><br>uniform <span class="hljs-type">float</span> specularDimmer;<br><br><span class="hljs-comment">//: param custom &#123; &quot;default&quot;: 1.0, &quot;label&quot;: &quot;Lihgt Intensity&quot;, &quot;min&quot;: 0.0, &quot;max&quot;: 32.0 &#125;</span><br>uniform <span class="hljs-type">float</span> lightIntensity;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DirectLighting</span></span><br><span class="hljs-class">&#123;</span><br>    vec3 diffuse;<br>    vec3 specular;<br>&#125;;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">F_Schlick</span><span class="hljs-params">(<span class="hljs-type">float</span> f0, <span class="hljs-type">float</span> f90, <span class="hljs-type">float</span> u)</span><br>&#123;<br>    <span class="hljs-type">float</span> x = <span class="hljs-number">1.0</span> - u;<br>    <span class="hljs-type">float</span> x2 = x * x;<br>    <span class="hljs-type">float</span> x5 = x * x2 * x2;<br>    <span class="hljs-keyword">return</span> (f90 - f0) * x5 + f0;                <span class="hljs-comment">// sub mul mul mul sub mad</span><br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">F_Schlick</span><span class="hljs-params">(<span class="hljs-type">float</span> f0, <span class="hljs-type">float</span> u)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> F_Schlick(f0, <span class="hljs-number">1.0</span>, u);               <span class="hljs-comment">// sub mul mul mul sub mad</span><br>&#125;<br><br>vec3 <span class="hljs-title function_">F_Schlick</span><span class="hljs-params">(vec3 f0, <span class="hljs-type">float</span> f90, <span class="hljs-type">float</span> u)</span><br>&#123;<br>    <span class="hljs-type">float</span> x = <span class="hljs-number">1.0</span> - u;<br>    <span class="hljs-type">float</span> x2 = x * x;<br>    <span class="hljs-type">float</span> x5 = x * x2 * x2;<br>    <span class="hljs-keyword">return</span> f0 * (<span class="hljs-number">1.0</span> - x5) + (f90 * x5);        <span class="hljs-comment">// sub mul mul mul sub mul mad*3</span><br>&#125;<br><br>vec3 <span class="hljs-title function_">F_Schlick</span><span class="hljs-params">(vec3 f0, <span class="hljs-type">float</span> u)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> F_Schlick(f0, <span class="hljs-number">1.0</span>, u);               <span class="hljs-comment">// sub mul mul mul sub mad*3</span><br>&#125;<br><br><br><span class="hljs-type">float</span> <span class="hljs-title function_">DV_SmithJointGGX</span><span class="hljs-params">(<span class="hljs-type">float</span> NdotH, <span class="hljs-type">float</span> NdotL, <span class="hljs-type">float</span> NdotV, <span class="hljs-type">float</span> roughness, <span class="hljs-type">float</span> partLambdaV)</span><br>&#123;<br>    <span class="hljs-type">float</span> a2 = (roughness * roughness);<br>    <span class="hljs-type">float</span> s = (NdotH * a2 - NdotH) * NdotH + <span class="hljs-number">1.0</span>;<br><br>    <span class="hljs-type">float</span> lambdaV = NdotL * partLambdaV;<br>    <span class="hljs-type">float</span> lambdaL = NdotV * <span class="hljs-built_in">sqrt</span>((-NdotL * a2 + NdotL) * NdotL + a2);<br><br>    vec2 D = vec2(a2, s * s);            <span class="hljs-comment">// Fraction without the multiplier (1/Pi)</span><br>    vec2 G = vec2(<span class="hljs-number">1</span>, lambdaV + lambdaL); <span class="hljs-comment">// Fraction without the multiplier (1/2)</span><br><br>    <span class="hljs-comment">// This function is only used for direct lighting.</span><br>    <span class="hljs-comment">// If roughness is 0, the probability of hitting a punctual or directional light is also 0.</span><br>    <span class="hljs-comment">// Therefore, we return 0. The most efficient way to do it is with a max().</span><br>    <span class="hljs-keyword">return</span> INV_PI * <span class="hljs-number">0.5</span> * (D.x * G.x) / max(D.y * G.y, FLT_MIN);<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">DisneyDiffuseNoPI</span><span class="hljs-params">(<span class="hljs-type">float</span> NdotV, <span class="hljs-type">float</span> NdotL, <span class="hljs-type">float</span> LdotV, <span class="hljs-type">float</span> perceptualRoughness)</span><br>&#123;<br>    <span class="hljs-comment">// (2 * LdotH * LdotH) = 1 + LdotV</span><br>    <span class="hljs-comment">// float fd90 = 0.5 + 2 * LdotH * LdotH * perceptualRoughness;</span><br>    <span class="hljs-type">float</span> fd90 = <span class="hljs-number">0.5</span> + (perceptualRoughness + perceptualRoughness * LdotV);<br>    <span class="hljs-comment">// Two schlick fresnel term</span><br>    <span class="hljs-type">float</span> lightScatter = F_Schlick(<span class="hljs-number">1.0</span>, fd90, NdotL);<br>    <span class="hljs-type">float</span> viewScatter = F_Schlick(<span class="hljs-number">1.0</span>, fd90, NdotV);<br><br>    <span class="hljs-comment">// Normalize the BRDF for polar view angles of up to (Pi/4).</span><br>    <span class="hljs-comment">// We use the worst case of (roughness = albedo = 1), and, for each view angle,</span><br>    <span class="hljs-comment">// integrate (brdf * cos(theta_light)) over all light directions.</span><br>    <span class="hljs-comment">// The resulting value is for (theta_view = 0), which is actually a little bit larger</span><br>    <span class="hljs-comment">// than the value of the integral for (theta_view = Pi/4).</span><br>    <span class="hljs-comment">// Hopefully, the compiler folds the constant together with (1/Pi).</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> / <span class="hljs-number">1.03571</span>) * (lightScatter * viewScatter);<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">DisneyDiffuse</span><span class="hljs-params">(<span class="hljs-type">float</span> NdotV, <span class="hljs-type">float</span> NdotL, <span class="hljs-type">float</span> LdotV, <span class="hljs-type">float</span> perceptualRoughness)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> INV_PI * DisneyDiffuseNoPI(NdotV, NdotL, LdotV, perceptualRoughness);<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">GetSmithJointGGXPartLambdaV</span><span class="hljs-params">(<span class="hljs-type">float</span> NdotV, <span class="hljs-type">float</span> roughness)</span><br>&#123;<br>    <span class="hljs-type">float</span> a2 = (roughness * roughness);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((-NdotV * a2 + NdotV) * NdotV + a2);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">BSDF</span><span class="hljs-params">(  vec3 V, </span><br><span class="hljs-params">            vec3 L, </span><br><span class="hljs-params">            <span class="hljs-type">float</span> NdotL, </span><br><span class="hljs-params">            <span class="hljs-type">float</span> unclampNdotV, </span><br><span class="hljs-params">            vec3 fresnel0, </span><br><span class="hljs-params">            <span class="hljs-type">float</span> roughness, </span><br><span class="hljs-params">            <span class="hljs-type">float</span> perceptualRoughness,</span><br><span class="hljs-params">            out vec3 diffuseLighting,</span><br><span class="hljs-params">            out vec3 specularLighting)</span><br>&#123;<br>    <span class="hljs-type">float</span> LdotV, NdotH, LdotH, NdotV, invLenLV;<br>    LdotV = dot(L, V);<br>    invLenLV = inversesqrt(max(<span class="hljs-number">2.0</span> * LdotV + <span class="hljs-number">2.0</span>, FLT_EPS));<br>    NdotH = clamp((NdotL + unclampNdotV) * invLenLV,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>); <br>    LdotH = clamp(invLenLV * LdotV + invLenLV,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    NdotV = max(unclampNdotV, <span class="hljs-number">0.0001</span>);<br><br>    vec3 F = F_Schlick(fresnel0, LdotH);<br><br>    <span class="hljs-type">float</span> partLambdaV = GetSmithJointGGXPartLambdaV(NdotV, roughness);<br>    <span class="hljs-type">float</span> DV = DV_SmithJointGGX(NdotH, NdotL, NdotV, roughness, partLambdaV);<br>    <br>    specularLighting = F * DV;<br><br>    <span class="hljs-comment">//float  diffuseTerm = Lambert();</span><br>    <span class="hljs-type">float</span> diffuseTerm = DisneyDiffuse(NdotV, NdotL, LdotV, perceptualRoughness);<br><br>    diffuseLighting = vec3(diffuseTerm,diffuseTerm,diffuseTerm);<br>&#125;<br><br><br><br>DirectLighting <span class="hljs-title function_">ShadeSurface_Directional</span><span class="hljs-params">(vec3 baseColor,</span><br><span class="hljs-params">                                        <span class="hljs-type">float</span> roughness,</span><br><span class="hljs-params">                                        <span class="hljs-type">float</span> metallic,</span><br><span class="hljs-params">                                        vec3 fresnel0,</span><br><span class="hljs-params">                                        vec3 N, </span><br><span class="hljs-params">                                        vec3 V)</span><br>&#123;<br>    DirectLighting lighting;<br>    <span class="hljs-comment">//ZERO_INITIALIZE(DirectLighting, lighting);</span><br><br>    vec3 L     = normalize(lightDir); <span class="hljs-comment">// 光线方向</span><br>    vec3 color = lightIntensity *lightColor;<br><br>    <span class="hljs-type">float</span>  NdotL = dot(N, L); <span class="hljs-comment">// Do not saturate</span><br>    <span class="hljs-type">float</span>  NdotV = dot(N, V);<br><br>    vec3 diffuseBsdf, specularBsdf;<br>    BSDF(V, L, NdotL, NdotV, fresnel0, roughness*roughness, roughness,diffuseBsdf, specularBsdf);<br><br>    <span class="hljs-type">float</span> intensity =  max(NdotL,<span class="hljs-number">0</span>);<br><br>    lighting.diffuse  = diffuseBsdf  * (intensity * diffuseDimmer);<br>    lighting.specular = specularBsdf * (intensity * specularDimmer);<br>  <br>    lighting.diffuse  *= color * baseColor;<br>    lighting.specular *= color * baseColor;<br><br><br>    <span class="hljs-keyword">return</span> lighting;<br>&#125;<br><br>vec3 <span class="hljs-title function_">ComputeFresnel0</span><span class="hljs-params">(vec3 baseColor, <span class="hljs-type">float</span> metallic, <span class="hljs-type">float</span> dielectricF0)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> mix(vec3(dielectricF0,dielectricF0,dielectricF0), baseColor, metallic);<br>&#125;<br><span class="hljs-comment">//- Shader entry point.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">shade</span><span class="hljs-params">(V2F inputs)</span><br>&#123;<br>  <span class="hljs-comment">// Apply parallax occlusion mapping if possible</span><br>  vec3 viewTS = worldSpaceToTangentSpace(getEyeVec(inputs.position), inputs);<br>  applyParallaxOffset(inputs, viewTS);<br><br>  <span class="hljs-comment">// Fetch material parameters, and conversion to the specular/roughness model</span><br>  <span class="hljs-type">float</span> roughness = getRoughness(roughness_tex, inputs.sparse_coord);<br>  vec3 baseColor = getBaseColor(basecolor_tex, inputs.sparse_coord);<br>  <span class="hljs-type">float</span> metallic = getMetallic(metallic_tex, inputs.sparse_coord);<br>  <span class="hljs-type">float</span> specularLevel = getSpecularLevel(specularlevel_tex, inputs.sparse_coord);<br><br><br>  vec3 diffColor = generateDiffuseColor(baseColor, metallic);<br>  vec3 specColor = generateSpecularColor(specularLevel, baseColor, metallic);<br>  <span class="hljs-type">float</span> occlusion = getAO(inputs.sparse_coord) * getShadowFactor();<br>  <span class="hljs-type">float</span> specOcclusion = specularOcclusionCorrection(occlusion, metallic, roughness);<br><br>  LocalVectors vectors = computeLocalFrame(inputs);<br>  vec3 fresnel0 = ComputeFresnel0(baseColor, metallic, DEFAULT_SPECULAR_VALUE);<br><br><br>  <span class="hljs-comment">//HDRP光照计算部分</span><br>  DirectLighting lighting = ShadeSurface_Directional(   baseColor,<br>                                                        roughness,<br>                                                        metallic,<br>                                                        fresnel0,<br>                                                        vectors.normal, <br>                                                        vectors.eye);<br><br>  <span class="hljs-comment">// Feed parameters for a physically based BRDF integration</span><br>  <span class="hljs-comment">//emissiveColorOutput(pbrComputeEmissive(emissive_tex, inputs.sparse_coord));</span><br>  <span class="hljs-comment">//albedoOutput(diffColor);</span><br>  <span class="hljs-comment">//diffuseShadingOutput(occlusion * envIrradiance(vectors.normal));</span><br>  diffuseShadingOutput(lighting.diffuse * getShadowFactor());<br>  specularShadingOutput(lighting.specular * getShadowFactor());<br>  <span class="hljs-comment">//sssCoefficientsOutput(getSSSCoefficients(inputs.sparse_coord));</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面的是SP的glslShader。为了能够更好的理解Unity HDRP的光照模型，我用unity的格式写了一个直线光计算的Shader，提取自Lit.Shader代码。下面的文件是Unity的hlsl语法Shader，比较重要的部分就是bsdf函数，可以直接放在HDRP5.10.0版本以上使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Unlit/SubstacnePainter&quot;</span><br>&#123;<br>    Properties<br>    &#123;<br>        baseColor (<span class="hljs-string">&quot;baseColor&quot;</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>        roughness (<span class="hljs-string">&quot;roughness&quot;</span>, Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">1</span><br>        metallic (<span class="hljs-string">&quot;metallic&quot;</span>, Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">1</span><br><br><br>        diffuseDimmer (<span class="hljs-string">&quot;diffuseDimmer&quot;</span>, Float) = <span class="hljs-number">1</span><br>        specularDimmer (<span class="hljs-string">&quot;specularDimmer&quot;</span>, Float) = <span class="hljs-number">1</span><br>        <br><br>        lightColor (<span class="hljs-string">&quot;lightColor&quot;</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>        lightIntensity (<span class="hljs-string">&quot;lightIntensity&quot;</span>, Float) = <span class="hljs-number">1</span><br><br>                                                    <br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags &#123; <span class="hljs-string">&quot;RenderType&quot;</span>=<span class="hljs-string">&quot;Opaque&quot;</span> &#125;<br>        LOD <span class="hljs-number">100</span><br><br>        Pass<br>        &#123;<br>            HLSLPROGRAM<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br> <br>            <span class="hljs-keyword">struct</span> appdata<br>            &#123;<br>                float4 vertex : POSITION;<br>                float2 uv : TEXCOORD0;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span></span><br><span class="hljs-class">            &#123;</span><br>                float2 uv : TEXCOORD0;<br>                float4 vertex : SV_POSITION;<br>                float3 worldPos : TEXCOORD1;<br>                float3 worldNormal : TEXCOORD2;<br>            &#125;;<br><br>            float4 baseColor;<br>            float4 lightColor;<br><br>            <span class="hljs-type">float</span> roughness;<br>            <span class="hljs-type">float</span> metallic;<br><br>            uniform <span class="hljs-type">float</span> diffuseDimmer;<br>            uniform <span class="hljs-type">float</span> specularDimmer;<br><br><br>            uniform float3 lightDir;<br>            uniform <span class="hljs-type">float</span> lightIntensity;<br><br><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;</span></span><br>            <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl&quot;</span></span><br><br>            <span class="hljs-comment">// -----------------------------------------------------------------------------</span><br>            <span class="hljs-comment">// Constants</span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> HALF_MAX        65504.0 <span class="hljs-comment">// (2 - 2^-10) * 2^15</span></span><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> HALF_MAX_MINUS1 65472.0 <span class="hljs-comment">// (2 - 2^-9) * 2^15</span></span><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> EPSILON         1.0e-4</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> PI              3.14159265359</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> TWO_PI          6.28318530718</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> FOUR_PI         12.56637061436</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> INV_PI          0.31830988618</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> INV_TWO_PI      0.15915494309</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> INV_FOUR_PI     0.07957747155</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> HALF_PI         1.57079632679</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> INV_HALF_PI     0.636619772367</span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> FLT_EPSILON     1.192092896e-07 <span class="hljs-comment">// Smallest positive number, such that 1.0 + FLT_EPSILON != 1.0</span></span><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> FLT_MIN         1.175494351e-38 <span class="hljs-comment">// Minimum representable positive floating-point number</span></span><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> FLT_MAX         3.402823466e+38 <span class="hljs-comment">// Maximum representable floating-point number</span></span><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFAULT_SPECULAR_VALUE 0.04</span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> FLT_INF  asfloat(0x7F800000)</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> FLT_EPS  5.960464478e-8  <span class="hljs-comment">// 2^-24, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)</span></span><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> HALF_MIN 6.103515625e-5  <span class="hljs-comment">// 2^-14, the same value for 10, 11 and 16-bit: https://www.khronos.org/opengl/wiki/Small_Float_Formats</span></span><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> HALF_MAX 65504.0</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">define</span> UINT_MAX 0xFFFFFFFFu</span><br><br>            <span class="hljs-comment">// HDRP模拟光源</span><br><br><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DirectLighting</span></span><br><span class="hljs-class">            &#123;</span><br>                float3 diffuse;<br>                float3 specular;<br>            &#125;;<br><br>            <span class="hljs-type">float</span> <span class="hljs-title function_">F_Schlick</span><span class="hljs-params">(<span class="hljs-type">float</span> f0, <span class="hljs-type">float</span> f90, <span class="hljs-type">float</span> u)</span><br>            &#123;<br>                <span class="hljs-type">float</span> x = <span class="hljs-number">1.0</span> - u;<br>                <span class="hljs-type">float</span> x2 = x * x;<br>                <span class="hljs-type">float</span> x5 = x * x2 * x2;<br>                <span class="hljs-keyword">return</span> (f90 - f0) * x5 + f0;                <span class="hljs-comment">// sub mul mul mul sub mad</span><br>            &#125;<br><br>            <span class="hljs-type">float</span> <span class="hljs-title function_">F_Schlick</span><span class="hljs-params">(<span class="hljs-type">float</span> f0, <span class="hljs-type">float</span> u)</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> F_Schlick(f0, <span class="hljs-number">1.0</span>, u);               <span class="hljs-comment">// sub mul mul mul sub mad</span><br>            &#125;<br><br>            float3 <span class="hljs-title function_">F_Schlick</span><span class="hljs-params">(float3 f0, <span class="hljs-type">float</span> f90, <span class="hljs-type">float</span> u)</span><br>            &#123;<br>                <span class="hljs-type">float</span> x = <span class="hljs-number">1.0</span> - u;<br>                <span class="hljs-type">float</span> x2 = x * x;<br>                <span class="hljs-type">float</span> x5 = x * x2 * x2;<br>                <span class="hljs-keyword">return</span> f0 * (<span class="hljs-number">1.0</span> - x5) + (f90 * x5);        <span class="hljs-comment">// sub mul mul mul sub mul mad*3</span><br>            &#125;<br><br>            float3 <span class="hljs-title function_">F_Schlick</span><span class="hljs-params">(float3 f0, <span class="hljs-type">float</span> u)</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> F_Schlick(f0, <span class="hljs-number">1.0</span>, u);               <span class="hljs-comment">// sub mul mul mul sub mad*3</span><br>            &#125;<br><br>            float3 <span class="hljs-title function_">ComputeFresnel0</span><span class="hljs-params">(float3 baseColor, <span class="hljs-type">float</span> metallic, <span class="hljs-type">float</span> dielectricF0)</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> lerp(dielectricF0.xxx, baseColor, metallic);<br>            &#125;<br><br><br>            <span class="hljs-type">float</span> <span class="hljs-title function_">DV_SmithJointGGX</span><span class="hljs-params">(<span class="hljs-type">float</span> NdotH, <span class="hljs-type">float</span> NdotL, <span class="hljs-type">float</span> NdotV, <span class="hljs-type">float</span> roughness, <span class="hljs-type">float</span> partLambdaV)</span><br>            &#123;<br>                <span class="hljs-type">float</span> a2 = (roughness * roughness);<br>                <span class="hljs-type">float</span> s = (NdotH * a2 - NdotH) * NdotH + <span class="hljs-number">1.0</span>;<br><br>                <span class="hljs-type">float</span> lambdaV = NdotL * partLambdaV;<br>                <span class="hljs-type">float</span> lambdaL = NdotV * <span class="hljs-built_in">sqrt</span>((-NdotL * a2 + NdotL) * NdotL + a2);<br><br>                float2 D = float2(a2, s * s);            <span class="hljs-comment">// Fraction without the multiplier (1/Pi)</span><br>                float2 G = float2(<span class="hljs-number">1</span>, lambdaV + lambdaL); <span class="hljs-comment">// Fraction without the multiplier (1/2)</span><br><br>                <span class="hljs-comment">// This function is only used for direct lighting.</span><br>                <span class="hljs-comment">// If roughness is 0, the probability of hitting a punctual or directional light is also 0.</span><br>                <span class="hljs-comment">// Therefore, we return 0. The most efficient way to do it is with a max().</span><br>                <span class="hljs-keyword">return</span> INV_PI * <span class="hljs-number">0.5</span> * (D.x * G.x) / max(D.y * G.y, FLT_MIN);<br>            &#125;<br><br>            <span class="hljs-type">float</span> <span class="hljs-title function_">DisneyDiffuseNoPI</span><span class="hljs-params">(<span class="hljs-type">float</span> NdotV, <span class="hljs-type">float</span> NdotL, <span class="hljs-type">float</span> LdotV, <span class="hljs-type">float</span> perceptualRoughness)</span><br>            &#123;<br>                <span class="hljs-comment">// (2 * LdotH * LdotH) = 1 + LdotV</span><br>                <span class="hljs-comment">// float fd90 = 0.5 + 2 * LdotH * LdotH * perceptualRoughness;</span><br>                <span class="hljs-type">float</span> fd90 = <span class="hljs-number">0.5</span> + (perceptualRoughness + perceptualRoughness * LdotV);<br>                <span class="hljs-comment">// Two schlick fresnel term</span><br>                <span class="hljs-type">float</span> lightScatter = F_Schlick(<span class="hljs-number">1.0</span>, fd90, NdotL);<br>                <span class="hljs-type">float</span> viewScatter = F_Schlick(<span class="hljs-number">1.0</span>, fd90, NdotV);<br><br>                <span class="hljs-comment">// Normalize the BRDF for polar view angles of up to (Pi/4).</span><br>                <span class="hljs-comment">// We use the worst case of (roughness = albedo = 1), and, for each view angle,</span><br>                <span class="hljs-comment">// integrate (brdf * cos(theta_light)) over all light directions.</span><br>                <span class="hljs-comment">// The resulting value is for (theta_view = 0), which is actually a little bit larger</span><br>                <span class="hljs-comment">// than the value of the integral for (theta_view = Pi/4).</span><br>                <span class="hljs-comment">// Hopefully, the compiler folds the constant together with (1/Pi).</span><br>                <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> / <span class="hljs-number">1.03571</span>) * (lightScatter * viewScatter);<br>            &#125;<br><br>            <span class="hljs-type">float</span> <span class="hljs-title function_">DisneyDiffuse</span><span class="hljs-params">(<span class="hljs-type">float</span> NdotV, <span class="hljs-type">float</span> NdotL, <span class="hljs-type">float</span> LdotV, <span class="hljs-type">float</span> perceptualRoughness)</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> INV_PI * DisneyDiffuseNoPI(NdotV, NdotL, LdotV, perceptualRoughness);<br>            &#125;<br><br>            <span class="hljs-type">float</span> <span class="hljs-title function_">GetSmithJointGGXPartLambdaV</span><span class="hljs-params">(<span class="hljs-type">float</span> NdotV, <span class="hljs-type">float</span> roughness)</span><br>            &#123;<br>                <span class="hljs-type">float</span> a2 = (roughness * roughness);<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((-NdotV * a2 + NdotV) * NdotV + a2);<br>            &#125;<br><br>            <span class="hljs-type">void</span> <span class="hljs-title function_">BSDF</span><span class="hljs-params">(  float3 V, </span><br><span class="hljs-params">                        float3 L, </span><br><span class="hljs-params">                        <span class="hljs-type">float</span> NdotL, </span><br><span class="hljs-params">                        <span class="hljs-type">float</span> unclampNdotV, </span><br><span class="hljs-params">                        float3 fresnel0, </span><br><span class="hljs-params">                        <span class="hljs-type">float</span> roughness, </span><br><span class="hljs-params">                        <span class="hljs-type">float</span> perceptualRoughness,</span><br><span class="hljs-params">                        out float3 diffuseLighting,</span><br><span class="hljs-params">                        out float3 specularLighting)</span><br>            &#123;<br>                <span class="hljs-type">float</span> LdotV, NdotH, LdotH, NdotV, invLenLV;<br><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                GetBSDFAngle(V, L, NdotL, preLightData.NdotV, LdotV, NdotH, LdotH, NdotV, invLenLV);</span><br><span class="hljs-comment">                */</span><br>                LdotV = dot(L, V);<br>                invLenLV = rsqrt(max(<span class="hljs-number">2.0</span> * LdotV + <span class="hljs-number">2.0</span>, FLT_EPS));<br>                NdotH = clamp((NdotL + unclampNdotV) * invLenLV, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <br>                LdotH = clamp(invLenLV * LdotV + invLenLV, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>                NdotV = max(unclampNdotV, <span class="hljs-number">0.0001</span>);<br><br>                float3 F = F_Schlick(fresnel0, LdotH);<br><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                计算彩虹色</span><br><span class="hljs-comment">                if (HasFlag(bsdfData.materialFeatures, MATERIALFEATUREFLAGS_LIT_IRIDESCENCE))</span><br><span class="hljs-comment">                &#123;</span><br><span class="hljs-comment">                    F = lerp(F, bsdfData.fresnel0, bsdfData.iridescenceMask);</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                */</span><br>                <span class="hljs-type">float</span> partLambdaV = GetSmithJointGGXPartLambdaV(NdotV, roughness);<br>                <span class="hljs-type">float</span> DV = DV_SmithJointGGX(NdotH, NdotL, NdotV, roughness, partLambdaV);<br>                <br>                specularLighting = F * DV;<br><br>                <span class="hljs-comment">//float  diffuseTerm = Lambert();</span><br>                <span class="hljs-type">float</span> diffuseTerm = DisneyDiffuse(NdotV, NdotL, LdotV, perceptualRoughness);<br><br>                diffuseLighting = float3(diffuseTerm,diffuseTerm,diffuseTerm);<br>            &#125;<br><br><br><br>            DirectLighting <span class="hljs-title function_">ShadeSurface_Directional</span><span class="hljs-params">(float3 baseColor,</span><br><span class="hljs-params">                                                    <span class="hljs-type">float</span> roughness,</span><br><span class="hljs-params">                                                    <span class="hljs-type">float</span> metallic,</span><br><span class="hljs-params">                                                    float3 fresnel0,</span><br><span class="hljs-params">                                                    float3 N, </span><br><span class="hljs-params">                                                    float3 V)</span><br>            &#123;<br>                DirectLighting lighting;<br>                <span class="hljs-comment">//ZERO_INITIALIZE(DirectLighting, lighting);</span><br><br>                float3 L     = normalize(-lightDir); <span class="hljs-comment">// 光线方向</span><br>                float3 color = lightIntensity * lightColor;<br><br>                <span class="hljs-type">float</span>  NdotL = dot(N, L); <span class="hljs-comment">// Do not saturate</span><br>                <span class="hljs-type">float</span>  NdotV = dot(N, V);<br><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                计算阴影和光照衰减</span><br><span class="hljs-comment">                float attenuation;</span><br><span class="hljs-comment">                EvaluateLight_Directional(lightLoopContext, posInput, light, builtinData, N, L, NdotL, color, attenuation);</span><br><span class="hljs-comment">                */</span><br><br>                <span class="hljs-comment">//ClampRoughness(roughness, light.minRoughness);</span><br>                roughness = max(roughness, <span class="hljs-number">0.001225</span>);  <br><br>                float3 diffuseBsdf, specularBsdf;<br>                BSDF(V, L, NdotL, NdotV, fresnel0, roughness*roughness, roughness,diffuseBsdf, specularBsdf);<br><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                计算反射透射</span><br><span class="hljs-comment">                bool surfaceReflection = NdotL &gt; 0;</span><br><span class="hljs-comment">                if (surfaceReflection)</span><br><span class="hljs-comment">                &#123;</span><br><span class="hljs-comment">                */</span><br>                <span class="hljs-comment">// so there NdotL must be bigger than 0</span><br>                <span class="hljs-type">float</span> intensity =  saturate(NdotL);<br><br>                lighting.diffuse  = diffuseBsdf  * (intensity * diffuseDimmer);<br>                lighting.specular = specularBsdf * (intensity * specularDimmer);<br>              <br>                lighting.diffuse  *= color * baseColor;<br>                lighting.specular *= color * baseColor;<br><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                计算透射</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                else if (MaterialSupportsTransmission(bsdfData))</span><br><span class="hljs-comment">                &#123;</span><br><span class="hljs-comment">                     // Apply wrapped lighting to better handle thin objects at grazing angles.</span><br><span class="hljs-comment">                    float wrapNdotL = ComputeWrappedDiffuseLighting(NdotL, TRANSMISSION_WRAP_LIGHT);</span><br><span class="hljs-comment">                    float intensity = attenuation * wrapNdotL;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                    // We use diffuse lighting for accumulation since it is going to be blurred during the SSS pass.</span><br><span class="hljs-comment">                    // Note: Disney&#x27;s LdoV term in &#x27;diffuseBsdf&#x27; does not hold a meaningful value</span><br><span class="hljs-comment">                    // in the context of transmission, but we keep it unaltered for performance reasons.</span><br><span class="hljs-comment">                    lighting.diffuse  = transmittance * (diffuseBsdf * (intensity * light.diffuseDimmer));</span><br><span class="hljs-comment">                    lighting.specular = 0; // No spec trans, the compiler should optimize</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                */</span><br><br>                <span class="hljs-keyword">return</span> lighting;<br>            &#125;<br><br>            v2f <span class="hljs-title function_">vert</span> <span class="hljs-params">(appdata v)</span><br>            &#123;<br>                v2f o;<br>                o.vertex = mul(UNITY_MATRIX_VP,mul(UNITY_MATRIX_M,v.vertex));<br>                o.worldPos = GetAbsolutePositionWS(mul(UNITY_MATRIX_M, v.vertex));<br>                o.worldNormal = TransformObjectToWorldNormal(v.normal);<br><br>                o.uv = v.uv;<br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            float4 <span class="hljs-title function_">frag</span> <span class="hljs-params">(v2f i)</span> : SV_Target<br>            &#123;<br>                float3 fresnel0 = ComputeFresnel0(baseColor, metallic, DEFAULT_SPECULAR_VALUE);<br>                float3 V = normalize(_WorldSpaceCameraPos.xyz - i.worldPos);<br>                float3 N = normalize(i.worldNormal);<br>                <span class="hljs-comment">//HDRP光照计算部分</span><br>                DirectLighting lighting = ShadeSurface_Directional( baseColor,<br>                                                                    roughness,<br>                                                                    metallic,<br>                                                                    fresnel0,<br>                                                                    N, <br>                                                                    V);<br><br>                <span class="hljs-keyword">return</span> float4(lighting.diffuse.xyz + lighting.specular.xyz,<span class="hljs-number">1</span>);<br>            &#125;<br>            ENDHLSL<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>下面就是Unity和SubstancePainter的光照结果对比。</p><p><img src="/../../images/img/UnityLightModeForSP.jpg" alt="UnityLightModeForSP"></p>]]></content>
      
      
      <categories>
          
          <category> HDRPartist </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TA工作内容</title>
      <link href="/2022/07/09/HDRPartist/TA%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9/"/>
      <url>/2022/07/09/HDRPartist/TA%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="算法性能优化："><a href="#算法性能优化：" class="headerlink" title="算法性能优化："></a>算法性能优化：</h2><ul><li>BRDF 计算优化： GGX : F \Geometry\NDF\IBL等。(手游上比较重要)</li><li>Texture Atlasing 工具：PBR贴图Pack在一起，合成一个大的贴图，Shader种类必须特别小。</li><li>IBL cubemap Normalization：看一下战神的PBR（主要改进的是效果）</li></ul><h2 id="生产力优化："><a href="#生产力优化：" class="headerlink" title="生产力优化："></a>生产力优化：</h2><ul><li>Light probe 自动摆放工具：能走区域(Nav Mesh)，贪心，光照变化。</li><li>Texture Streaming工具：Unity内置支持一些功能。</li><li>GPU LightMapper&#x2F; Enlighten 动态设置工具。</li><li>程序化生成工具，地形生成、物体摆放、模型生成。</li><li>资源管理工具。</li></ul><h2 id="标准制定："><a href="#标准制定：" class="headerlink" title="标准制定："></a>标准制定：</h2><ul><li>文档+培训。</li><li>所见即所得的工具：帮助美术更好的理解PBR制作的结果，查看工具。</li><li>多个版本的标准光照环境：确认资产和灯光得到正确结果：场景，亮度适中、光源没有色彩倾向、没有强烈明暗对比。为了很好的辨识固有色、色相、光滑度、法线、金属度、AO。只用ACES：不用曝光和其他后处理（就是白平衡场景）。</li><li>灯光的强度参考：各种常见的光强范围、自动曝光设置方式。</li><li>把工具嵌入在流程当中。</li><li>定制的SP环境：定制Shader和定制后处理。</li></ul><h2 id="Shader相关："><a href="#Shader相关：" class="headerlink" title="Shader相关："></a>Shader相关：</h2><ul><li>Shader Strip 工具。</li><li>Shader 变体控制。</li><li>Shader Warmup</li><li>Shader Feature</li></ul><h2 id="TA工作内容分类"><a href="#TA工作内容分类" class="headerlink" title="TA工作内容分类"></a>TA工作内容分类</h2><p>程序化生成：包括地形、材质、贴图、模型、特效的程序化建模。</p><p>渲染：效果实现，熟悉渲染管线、熟悉shader、熟悉GPU、BRDF等。</p><p>动作：骨骼、动画、蒙皮、IK。</p><p>优化：GPU架构、模型面熟、烘焙、资源管理、profile。</p><p>工具开发：DCC工具开发，资源管理工具、debug工具，资源检查工具。提升美术工作效率，完善生产工作流。</p>]]></content>
      
      
      <categories>
          
          <category> HDRPartist </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>场景反射策略</title>
      <link href="/2022/07/09/HDRPartist/%E5%9C%BA%E6%99%AF%E5%8F%8D%E5%B0%84%E7%AD%96%E7%95%A5/"/>
      <url>/2022/07/09/HDRPartist/%E5%9C%BA%E6%99%AF%E5%8F%8D%E5%B0%84%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="场景反射策略"><a href="#场景反射策略" class="headerlink" title="场景反射策略"></a>场景反射策略</h1><p>目前，Unity已有的反射功能：</p><ul><li>屏幕空间反射：SSR</li><li>平面反射：Planar Reflection Prob</li><li>反射探针：Reflection Probe</li></ul><h2 id="反射功能基本使用"><a href="#反射功能基本使用" class="headerlink" title="反射功能基本使用"></a>反射功能基本使用</h2><h3 id="反射功能的具体调节位置"><a href="#反射功能的具体调节位置" class="headerlink" title="反射功能的具体调节位置"></a>反射功能的具体调节位置</h3><p>在RenderPipelineAsset设置当中 ：LIghting -&gt; Reflections，可以设置反射贴图分辨率等内容。</p><h3 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h3><p>由于默认的HDRP工程没有开启SSR，所以需要开启SSR：</p><p>在RenderPipelineAsset设置当中 ：LIghting -&gt; Reflections：勾选Screen Space Reflection。</p><p><img src="/../../images/img/11.jpg" alt="11"></p><p>在RenderPipelineAsset设置当中 ：Default Frame Settings -&gt; Lighting：勾选SSR。</p><p>如果这个选项打开场景中有可能会始终存在SSR，不需要SSR的物体要关闭材质上的Receive SSR开关。</p><p>在要接收SSR的Lit材质球上或者Shader Graph上开启，Receive SSR：</p><p><img src="/../../images/img/13.jpg" alt="13"></p><p>在Post Volume中添加SSR：</p><p><img src="/../../images/img/14.jpg" alt="14"></p><p>SSR效果如下：</p><p><img src="/../../images/img/15.jpg" alt="15"></p><h3 id="平面反射探针"><a href="#平面反射探针" class="headerlink" title="平面反射探针"></a>平面反射探针</h3><p>在Hierachy当中右键 -&gt;Light -&gt; Planar Reflecition Probe创建一个平面反射探针。</p><p><img src="/../../images/img/8.jpg" alt="8"></p><p>通过调整平面的位置和平面的角度（<strong>最上方的右边两个按钮</strong>），可以影响反射的内容。</p><p>修改<strong>Influence Volume</strong>可以调整反射内容影响的物体。</p><p>平面反射效果：</p><p><img src="/../../images/img/9.jpg" alt="9"></p><p>Influence Volume：</p><p><img src="/../../images/img/10.jpg" alt="10"></p><h3 id="反射探针"><a href="#反射探针" class="headerlink" title="反射探针"></a>反射探针</h3><p>在Hierachy当中右键 -&gt;Light -&gt; Reflecition Probe创建一个反射探针。</p><p><img src="/../../images/img/1.jpg" alt="1"></p><p>打开Window-&gt;Rendering-&gt;Lighting Settings 设置。关闭右下角Aoto Generate。</p><p><img src="/../../images/img/2.jpg" alt="2"></p><p>此时把Reflection Probe 的Type改成 Baked，最下方就会出现Bake按钮，如下图。</p><p><img src="/../../images/img/3.jpg" alt="3"></p><p>根据需求修改上图参数，之后点击bake就会生成对应的探针。探针会影响所有在<strong>Influence Volume</strong>当中的物体。反射效果如下图所示。</p><p><img src="/../../images/img/4.jpg" alt="4"></p><p>Influence Volume如下图所示：</p><p><img src="/../../images/img/5.jpg" alt="5"></p><p>同时，反射的内容是根据Base Shape决定的：下图是不同的base Shape对应的不同反射效果。</p><p><img src="/../../images/img/6.jpg" alt="6"></p><p><img src="/../../images/img/7.jpg" alt="7"></p><h2 id="反射策略"><a href="#反射策略" class="headerlink" title="反射策略"></a>反射策略</h2><h3 id="SSR的使用场景"><a href="#SSR的使用场景" class="headerlink" title="SSR的使用场景"></a>SSR的使用场景</h3><p>使用场景：</p><p>​屏幕空间反射通常应用于需要和场景对齐的反射面，例如：冰面、湖面。同时可以应用在凹凸不平的地面。</p><p>下面是常见问题和解决方案。</p><h4 id="1-像素丢失"><a href="#1-像素丢失" class="headerlink" title="1. 像素丢失"></a>1. 像素丢失</h4><p>SSR最常见的问题就是像素丢失。如果在纵深方向，场景过于复杂，SSR的效果就会很差。如下图所示，红色框内部就是因为场景前方的木棒，导致后方的墙无法反射出来：</p><p><img src="/../../images/img/20.jpg" alt="20"></p><p>解决方法是可以增加Max Number of Ray Steps。但是会导致性能变差。</p><p>同时要避免在这样的场景当中使用SSR。</p><h4 id="2-屏幕缺角"><a href="#2-屏幕缺角" class="headerlink" title="2. 屏幕缺角"></a>2. 屏幕缺角</h4><p>SSR第二个缺陷就是缺角，屏幕的左右下角会根据视线角度发生一定程度的丢失，如下图，可以调节Screen Edge Fade Distance 来让边界不这么明显。</p><p><img src="/../../images/img/21.jpg" alt="21"></p><h4 id="3-平滑表面反射"><a href="#3-平滑表面反射" class="headerlink" title="3. 平滑表面反射"></a>3. 平滑表面反射</h4><p>SSR第三个问题就是不适合纯平表面。如果物体表面非常平滑（没有法线扰动），会导致SSR效果不够自然。</p><p>通常使用SSR的表面都会添加法线扰动。如下图所示，下面的反射看起来效果自然很多，错误并不明显，并且性能也能够保证：</p><p><img src="/../../images/img/22.jpg" alt="22"></p><h4 id="4-参数根据场景变动"><a href="#4-参数根据场景变动" class="headerlink" title="4. 参数根据场景变动"></a>4. 参数根据场景变动</h4><p>由于不同的参数适应不同的场景，所以最好不同的位置使用不同的Volume 来控制SSR的参数。</p><h3 id="反射探针使用场景"><a href="#反射探针使用场景" class="headerlink" title="反射探针使用场景"></a>反射探针使用场景</h3><h4 id="1-反射探针常用场景"><a href="#1-反射探针常用场景" class="headerlink" title="1. 反射探针常用场景"></a>1. 反射探针常用场景</h4><p>所有的不需要和场景对齐的物体建议都使用反射探针，同时需要关闭接受SSR，如下图：</p><p><img src="/../../images/img/25.jpg" alt="25"></p><p>通常反射探针的开销比ssr小。如果同时存在，反射探针会覆盖SSR。他们的边界会出现不自然的过度。</p><h4 id="2-使用反射探针的特殊场景"><a href="#2-使用反射探针的特殊场景" class="headerlink" title="2. 使用反射探针的特殊场景"></a>2. 使用反射探针的特殊场景</h4><p>对于垂直的小墙面，正方形的房子，反射探针也能够得到很好的效果。</p><p>如果要得到足够好的反射效果，需要合理的调整反射探针的内容和位置。</p><p>下面是反射探针的效果：</p><p><img src="/../../images/img/23.jpg" alt="23"></p><p>只要反射探针的volume能够和墙面对齐，就能够得到基本正确的结果，但是反射探针也有自己的问题，如下图，位置完全偏离：</p><p><img src="/../../images/img/24.jpg" alt="24"></p><p>所以，通常反射探针用在反射效果不需要和场景完全对齐的物体上，例如：非常光滑的金属部件，水坑，眼球。</p><h4 id="3-没有正确的设置反射探针"><a href="#3-没有正确的设置反射探针" class="headerlink" title="3. 没有正确的设置反射探针"></a>3. 没有正确的设置反射探针</h4><p>​如果没有正确的放置反射探针，会导致物体的反射效果和场景不融，尤其是金属物体。会造成光照很突兀。</p><h3 id="平面反射使用场景"><a href="#平面反射使用场景" class="headerlink" title="平面反射使用场景"></a>平面反射使用场景</h3><p>平面反射探针可以应付所有的平面镜面反射，但是开销极高，除非在特别简单的场景，否则不建议使用。</p>]]></content>
      
      
      <categories>
          
          <category> GameAnalysis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>美术资源优化思路与原理</title>
      <link href="/2022/07/09/HDRPartist/%E5%9C%BA%E6%99%AF%E7%BE%8E%E6%9C%AF%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"/>
      <url>/2022/07/09/HDRPartist/%E5%9C%BA%E6%99%AF%E7%BE%8E%E6%9C%AF%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="美术资源优化思路与原理"><a href="#美术资源优化思路与原理" class="headerlink" title="美术资源优化思路与原理"></a>美术资源优化思路与原理</h1><h2 id="美术资源可能带来的性能问题"><a href="#美术资源可能带来的性能问题" class="headerlink" title="美术资源可能带来的性能问题"></a>美术资源可能带来的性能问题</h2><ol><li><p>游戏内存： 场景当中要绘制的所有东西都需要保存到内存中，其中最重要的就是：<strong>模型、贴图</strong>。</p></li><li><p>drawcall：每绘制一种东西（不同的模型：即使是相同的材质球也算不同的模型，除非合并他们的mesh），<strong>内存都需要把相关的渲染参数、模型数据、贴图数据传递到GPU</strong>，这个速度非常慢，所以看到的模型越多，drawcall越多。</p></li><li><p>GPU渲染速度：模型的材质越复杂，渲染越慢。这个靠TA来制定标准即可。</p></li></ol><p>美术制作资源是需要关注前两点。</p><h2 id="场景美术资源优化策略"><a href="#场景美术资源优化策略" class="headerlink" title="场景美术资源优化策略"></a>场景美术资源优化策略</h2><p>场景美术资源优化主要有个以下方面：</p><ol><li><p>模型拆分，模型组件复用：美术制作场景时，复用模型资源进行摆放。<strong>只是为了提升工作效率，拆分之后还是需要尽可能使用相同材质，最终还是要合并。</strong></p></li><li><p>贴图Tiling，贴图复用：能够直接降低内存开销。<strong>为了效果可以使用更少、分辨率更高的贴图。</strong></p></li><li><p>材质复用：不同的模型使用同一个材质球（必须是同一个材质球，而不是不同的材质球同一个参数。）<strong>材质复用的目的，是最终要合并网格以减少drawcall，如果不合并那么材质复用就没有意义。</strong> <strong>Dynamic Batch</strong> 就是这个原理，但是他会在内存生成一份合并后的mesh，相当于内存占用翻倍，浪费内存。<strong>Static Batch</strong>也是一样，只不过是静态合并好。但是合并的物体覆盖全场景。还会导致遮挡剔除失效，同样占内存。</p></li><li><p>Prefab复用（包括组件的Prefab，完整模型的Prefab）：直接提升资源利用率。这种服用就是一模一样的mesh和材质，可以直接合并。</p></li></ol><h3 id="游戏性能瓶颈：模型"><a href="#游戏性能瓶颈：模型" class="headerlink" title="游戏性能瓶颈：模型"></a>游戏性能瓶颈：模型</h3><p>由于场景资源复杂，可能遇到的性能瓶颈：</p><ol><li><p>模型数量：模型数量越多（ 一个submesh算一个模型 ）drawcall越多，成正比。</p></li><li><p>一个模型的面数：模型越大，越占内存。（不使用static batch的原因）。</p></li><li><p>模型属性太多（比如各个uv通道全部使用，normal、tangent全部使用）：属性使用的越多，越占内存。</p></li></ol><p><strong>模型的内存开销&#x3D;模型数量 * 一个模型的面数 * 模型属性</strong></p><p><strong>模型的drawcall 开销&#x3D; 场景中的模型数量。</strong></p><h3 id="游戏性能优化：模型"><a href="#游戏性能优化：模型" class="headerlink" title="游戏性能优化：模型"></a>游戏性能优化：模型</h3><ol><li><p>美术在3Dmax当中合并不同的mesh。（相同材质的合并，通过合理分布uv可以让大部分mesh复用同一个材质）。<strong>能够在模型总内存消耗不变的情况下降低drawcall。</strong></p></li><li><p>如果材质的属性不使用，就不要输出，例如：第二套uv，顶点色，切线信息。<strong>直接降低内存开销。</strong></p></li><li><p>控制模型面数，场景当中看不到的面裁切掉。<strong>直接降低内存开销。</strong></p></li></ol><h3 id="游戏性能瓶颈：贴图"><a href="#游戏性能瓶颈：贴图" class="headerlink" title="游戏性能瓶颈：贴图"></a>游戏性能瓶颈：贴图</h3><ol><li><p><strong>场景中涉及到的</strong>贴图数量越多，内存占用越大。（例如：一张1024*1024的三通道贴图，相当于一个100万点的只记录了顶点位置的模型，相当于10万顶点并记录了顶点色的模型），美术需要考虑模型和贴图之间的平衡。</p></li><li><p><strong>场景中涉及到的</strong>贴图越大，内存占用越多。</p></li><li><p><strong>场景中涉及到的</strong>贴图开启mipmap占用内存越多。</p></li><li><p>如果贴图不在场景中，那他就只是占用内存而已。</p></li></ol><p><strong>贴图内存开销&#x3D; 贴图数量 * 贴图大小。</strong></p><p><strong>贴图drawcall开销 &#x3D; 基本只和内存有关。</strong></p><p>*<strong>注：</strong>“场景当中涉及到的”指的是客户端从硬盘加载到内存的场景数据。</p><h3 id="游戏性能优化：贴图"><a href="#游戏性能优化：贴图" class="headerlink" title="游戏性能优化：贴图"></a>游戏性能优化：贴图</h3><p><strong>贴图内存开销&#x3D; 贴图数量 * 贴图大小。</strong></p><ol><li><p>使用Tiling方式的贴图。<strong>减小贴图大小。</strong></p></li><li><p>提高利用率。<strong>减少贴图数量。</strong></p></li></ol><h3 id="游戏性能瓶颈：材质"><a href="#游戏性能瓶颈：材质" class="headerlink" title="游戏性能瓶颈：材质"></a>游戏性能瓶颈：材质</h3><ol><li><p><strong>场景中涉及到的材质</strong>数量越多drawcall越多。</p></li><li><p><strong>场景中涉及到的材质</strong>使用的贴图越多占用内存越多。</p></li></ol><p>材质内存开销 &#x3D;  几乎不考虑。</p><p>材质drawcall开销&#x3D; 主要看mesh，因为如果同一个mesh 使用不同的材质，那么drawcall还是两个。</p><p><strong>材质复用的真正目的是为了能够合并场景中使用相同材质的mesh。以直接减少drawcall。</strong></p><h3 id="游戏性能优化：材质"><a href="#游戏性能优化：材质" class="headerlink" title="游戏性能优化：材质"></a>游戏性能优化：材质</h3><p><strong>材质复用的真正目的：为了能够合并场景中使用相同材质的mesh，以直接减少drawcall。</strong></p><ol><li><p><strong>使用相同的材质 + 不同的mesh</strong> 的策略来实现丰富的表现，方便合并。例如：用刷顶点色，代替mask贴图。</p></li><li><p>材质复用优先于mesh复用：如果mesh复用，而使用了不同的材质，那么drawcall不能再减少了。如果复用了材质（同一个材质球），而使用了不同的mesh，那么有很多方法来合并mesh以减少drawcall。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> HDRPartist </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>法线贴图旋转</title>
      <link href="/2022/07/09/HDRPartist/%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE%E6%97%8B%E8%BD%AC/"/>
      <url>/2022/07/09/HDRPartist/%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE%E6%97%8B%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="法线贴图旋转"><a href="#法线贴图旋转" class="headerlink" title="法线贴图旋转"></a>法线贴图旋转</h1><p>在场景材质制作过程中，可能会大量的使用tiling材质球。</p><p>有时候tiling材质的走向和想要的走向不同，可能希望可以对贴图进行旋转。</p><p>对于其他颜色贴图来说旋转没有什么影响。</p><p>但是，对于法线贴图来说，<strong>旋转法线贴图就会造成错误。</strong></p><p>下图是正确的法线贴图：</p><p><img src="/../../images/img/original.jpg" alt="original"></p><p>在法线贴图中，<strong>法线的朝向是切线空间中的方向</strong>，并且xy通道中的颜色从[-1,1]归一化到了[0,1]，所以默认法线方向为(0.5, 0.5, 1)<strong>，同时：在切线空间中，向下的方向是紫色，向右是蓝色，向左是粉色，向上是青色</strong>。</p><p>法线贴图颜色表示的是在切线空间的方向，也就是uv贴图中的朝向。例如，<strong>粉色表示切线空间中，法线偏向左侧，也就是u减小的方向。</strong></p><p>如果对法线贴图直接进行旋转，就会得到错误的法线贴图：</p><p><img src="/../../images/img/wrong.jpg" alt="wrong"></p><p>仔细观察发现，图形的下边界变成了粉色，表示下边界指向左侧。这个时候图形的边界方向不在向内偏，也就是说他不再是凹的了。这就是法线错误的原因。</p><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>为了能够让法线贴图进行旋转，需要对其进行特殊的处理。</p><p>只要将法线方向连同贴图一起旋转即可。</p><p>法线方向的旋转方式就是，让法线绕向量(0,0,1)与贴图旋转相同的角度即可。</p>]]></content>
      
      
      <categories>
          
          <category> HDRPartist </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>More Efﬁcient Virtual Shadow Maps for Many Lights</title>
      <link href="/2022/07/09/Paper/ClusterShadows/"/>
      <url>/2022/07/09/Paper/ClusterShadows/</url>
      
        <content type="html"><![CDATA[<h1 id="More-Efﬁcient-Virtual-Shadow-Maps-for-Many-Lights"><a href="#More-Efﬁcient-Virtual-Shadow-Maps-for-Many-Lights" class="headerlink" title="More Efﬁcient Virtual Shadow Maps for Many Lights"></a>More Efﬁcient Virtual Shadow Maps for Many Lights</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>这个方法主要用来解决大量灯光的实时阴影。</p><p>主要的方法是：</p><ol><li><p>硬件支持的virtual cube-map shadows, 来高效的实现数百个光源的实时阴影。</p></li><li><p>我们探讨了光线追踪对多光源阴影的效用，并提出了一种结合光线追踪与virtual cube-map的混合算法。</p></li></ol><p>主要优点：支持数百盏光源的高细节动态阴影。</p><p>​目前有很多技术支持上百盏实时灯光。这些技术把灯光划分到不同的屏幕tile当中。这样可以让Shader同时的访问多盏灯光，提高艺术创作的自由度。</p><p>​但是这些技术大部分是不计算阴影的，虽然有了更多的灯管细节和动态效果，但是没有阴影导致丢失了很多几何细节，画面看起来很平，没有立体感。</p><p>没有了阴影，会导致漏光。</p><p>​本文记得数就是捕获阴影的灯管，支持上百盏同时投射阴影的灯光。这些阴影是高和统一的质量，同时保持在一个有限的内存占用范围内。</p><h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ol><li><p>本文的主要贡献就是提出<strong>一个高效的基于tile的culling方式把投射阴影的物体渲染得到不同的cube shadow map中。</strong></p></li><li><p>对于静态灯光和静态几何体也是一样的，我们也会展示，如何利用这些信息，通过在帧之间保留部分阴影映射，进一步提高剔除效率和性能。</p></li><li><p>提出了一种快速估计每盏灯光ShadowMap分辨率</p></li><li><p>为了支持有效的内存管理，我们演示了如何利用硬件支持的虚拟阴影映射来只存储相关的阴影映射示例。为此，我们引入了一种有效的方法来确定每个虚拟阴影图中需要物理支持的部分。</p></li><li><p>我们探索了多盏灯光的raytracing性能，验证了一个混合了tray tracing和cubmap的方式，来提供shadowmap，这种方式比单独的始终各自的方法性能都更优。</p></li><li><p>我们提供了技术的细节和详细的算法测评，正面我们所提出的方法的确能够提供大量光源的实时高性能阴影。</p></li></ol><h2 id="前期工作"><a href="#前期工作" class="headerlink" title="前期工作"></a>前期工作</h2><p>相关算法的内容。</p><p>RealTime Many Light Shading： 各种着色技术，其中最重要的就是Tile Shading。</p><p>Shadow Algorithms：主要描述各种计算各个光源的阴影的方法。</p><p>Virtual Shadow Maps：对于单个光源的应用贴图。</p><p>Many light shadows：多光源阴影计算方式。</p><p>Ray Trace Shadow：</p><h2 id="回顾一下我们要解决的问题"><a href="#回顾一下我们要解决的问题" class="headerlink" title="回顾一下我们要解决的问题"></a>回顾一下我们要解决的问题</h2><p>​我们只研究全方位点光源，有限的照亮范围，在边界亮度衰减到0。</p><p>​这是一种普遍的灯光模型，易于控制影响屏幕的那些部分。也就是易于控制灯光的性能。其他的灯光模式也可以看做全方位光源（点光源）的一种。</p><p>对于实时渲染来使用的基本是经典的Shadow-Map（SM），或者他的变体。这种算法的普遍使用是有原因的，比如，固定的采样率，丰富的硬件支持，任意几何体都支持，可以用滤波平滑阴影。所以，我们也使用这种技术。因为使用的是点光源，所以使用ShadowCubemap。</p><p>​要使用多光源你的ShadowMap 需要解决一下的问题：</p><ul><li><p>决定哪些光源会投射可见的阴影。</p></li><li><p>决定每个光源ShadowMap的分辨率。</p></li><li><p>申请Shadow map的内存空间。</p></li><li><p>把投射阴影的几何体渲染到ShadowMap上。</p></li><li><p>使用灯光和其对应的Shadow渲染场景。</p><p>Clustered Shading技术：为每一个Cluster计算一个灯光列表。不在这个灯光列表当中的灯光，不会在这个Cluster当中投射任何的可见阴影。</p></li></ul><h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><p>我们的基本算法将在下面详细描述。基本算法是从Clustered deferred算法中构造出来的，我们对于阴影计算的扩展，用粗体标注：</p><ol><li>把场景渲染到Gbuffer。</li><li>Cluster的划分，根据当前的View，把场景划分成Cluster。</li><li>计算唯一的Cluster，计算紧凑的一个Cluster列表。</li><li>把灯光分配到各个Cluster当中。</li><li><strong>为每个灯选择Shadowmap渲染分辨率。</strong></li><li><strong>申请ShadowMap空间</strong></li><li><strong>Culling几何体。</strong></li><li><strong>光栅化ShadowCubeMap。</strong></li><li>着色。</li></ol><h3 id="Cluster-Shading简介"><a href="#Cluster-Shading简介" class="headerlink" title="Cluster Shading简介"></a>Cluster Shading简介</h3><p>在Cluster-Shading当中，View-Volume会被划分成一个三维的网格，屏幕上的2D网格是平均划分的，例如一个Tiles占据32*32个像素。 而深度方向上，根据深度逐渐增加网格的划分密度增加。</p><p>然后判断哪个Cluster中有可见的几何体，后面的计算只针对有内容的Cluster。然后再把灯光划分到这些cluster当中。</p><p>最后我们就产生了一组Cluster和灯光的配对信息。</p><p><img src="/../../images/ClusterShadows/1600660002764.png" alt="1600660002764"></p><p>上图中可以看出，C0到C3表示有几何体的Cluster。计算只会针对这些几何体，然后记录灯光L0和L1影响那些Cluster。最后就得到了C1-L0、C2_L0、C2-L1 ….这些Light-Cluster对。</p><p>灯光计算时，每个可见的sample（屏幕像素）通过查看其与所在Cluster有联系的灯，并总结它们的贡献（brdf和shadow）来着色。</p><p>这个过程产生的关键信息是：</p><ol><li>一组已占用的Cluster。</li><li>边界(用于估计几何体是否在内部)</li><li>每个Cluster有关的光集：<strong>Cluster-Light对。</strong></li></ol><p>这些信息将用于阴影计算.</p><h3 id="阴影分辨率动态计算"><a href="#阴影分辨率动态计算" class="headerlink" title="阴影分辨率动态计算"></a>阴影分辨率动态计算</h3><p>计算一个灯光阴影贴图分辨率的简单方式，就是计算灯光bouding-sphere的屏幕覆盖面积。这个方法的优点是速度快，但是不够准确。</p><p>还有一个方法是RMSM。这个方法是昂贵的，因为必须为每一个像素计算所需要的分辨率，保证每一个像素在阴影贴图中都有足够的精度。我们不需要这么准确的计算，所以文中使用的方法是计算每一个Cluster在一个Light的ShadowMap当中需要的精度，然后选择一个最低需要满足的标准，作为最终精度。</p><p>我们根据每一个Cluster的bounding-box进行计算。</p><p>假设我们需要的ShadowCubeMapd的分辨率是R。根据单位圆的固体角比例、占屏幕像素的大小进行估计：</p><p>$$ R &#x3D; \sqrt{\frac{S&#x2F;\alpha &#x2F; 4 \pi}{6}} $$</p><p><strong>每一个Light-Cluster对都会得到一个R，为每一个Light选择一个最大的R，作为ShadowMap的精度。</strong></p><p>这个过程产生的关键信息是：</p><ol><li>每一个Cluster-Light对，都会计算一个阴影分辨率R。</li><li>对Light选择一个与其关联的、最大的R。</li></ol><h3 id="Shadow-Map-Allocation-阴影贴图的空间申请"><a href="#Shadow-Map-Allocation-阴影贴图的空间申请" class="headerlink" title="Shadow Map Allocation 阴影贴图的空间申请"></a>Shadow Map Allocation 阴影贴图的空间申请</h3><p>使用上一步的分辨率计算方式，我们就可以为每一个灯光申请一个非0大小的Shadow Map。这并不是申请实际的物理空间，而是一个虚拟的范围。我们实际上需要使用Virtual Texture技术来管理Shadow Map的物理内存。</p><blockquote><p>  virtual texture的做法是，把一个巨大的非重复性纹理切割成无数的小page,通过一个indirection texture，通过记录mega texture 的uv offset,把这些page映射到到到这个indirection texture里。</p><p>  在Virtual Texture当中，Pages以一个固定大小的覆盖整个Texture。在我们渲染Shadow Map的时候，我们需要提交这些物理内存，然后在渲染时进行采样。</p></blockquote><p>因为我们需要调页，申请实际的内存，所以我们需要知道阴影贴图的那些位置是需要写入和读取的。我们一般可以逐个像素判断某个page是否需要，但是效率太低。我们使用一个Cluster是否覆盖某个Page的方式计算。只需要把CLuster的AABB投影到ShadowMap的空间上，就可以了，下面是投影算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">Rect <span class="hljs-title function_">xPlus</span><span class="hljs-params">(Aabb aabb)</span> <br>&#123; <br>    <span class="hljs-type">float</span> rdMin = <span class="hljs-number">1.0</span>/max(Epsilon, aabb.min.x); <br>    <span class="hljs-type">float</span> rdMax = <span class="hljs-number">1.0</span>/max(Epsilon, aabb.max.x);<br><span class="hljs-type">float</span> sMin = min(-aabb.max.z * rdMin, -aabb.max.z * rdMax); <br>    <span class="hljs-type">float</span> sMax = max(-aabb.min.z * rdMin, -aabb.min.z * rdMax);<br><span class="hljs-type">float</span> tMin = min(-aabb.max.y * rdMin, -aabb.max.y * rdMax); <br>    <span class="hljs-type">float</span> tMax = max(-aabb.min.y * rdMin, -aabb.min.y * rdMax);<br>Rect r;<br>r.min = clamp(float2(sMin, tMin),<span class="hljs-number">-1.0</span>,<span class="hljs-number">1.0</span>); r.max = clamp(float2(sMax, tMax),<span class="hljs-number">-1.0</span>,<span class="hljs-number">1.0</span>);<br><span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Culling-Shadow-Casting-Geometry"><a href="#Culling-Shadow-Casting-Geometry" class="headerlink" title="Culling Shadow-Casting Geometry"></a>Culling Shadow-Casting Geometry</h3><p>​剪裁渲染阴影的几何体。剪裁是实时渲染的一个重要的组成部分，把不需要的渲染内容去除掉是提升渲染性能的关键。我们根据几何体是否在Render Volume中来判断是否渲染。这种判断需要通过一个特殊的加速结构体进行优化，常用结构体包括KD-tree、八叉树、BVH。有效的剔除需要视口体积的大小和几何批次之间有一定的相关性。在我们的应用中，可视Volume就是灯光的Bound-Sphere.这个Volume要比正常的Volume要小。因此我们需要更小的三角形渲染集合。我们用bounding volume hierarchy（BVH），来保存不同级别的渲染集合.</p><p>​在这个算法当中View Volume就是灯光的bounding-sphere。这个Volume要比我们的主视口小的多，因此需要更小的Batch。我们使用BVH来保存需要渲染的三角形Batch，每一个batch包括一个AABB。</p><blockquote><p>  BVH可以理解成一种类似八叉树或者KD-Tree的场景物体保存方式。</p></blockquote><blockquote><p>  这部分的粗略对于场景的划分有很严格的要求，在实际游戏当中不一定用的到。</p></blockquote><h3 id="光栅化阴影投射的几何体。"><a href="#光栅化阴影投射的几何体。" class="headerlink" title="光栅化阴影投射的几何体。"></a>光栅化阴影投射的几何体。</h3><p>把几何体渲染到ShadowMap上，具体的方法和实现细节相关。</p><h3 id="Shading"><a href="#Shading" class="headerlink" title="Shading"></a>Shading</h3><p>Shading过程就是一个full-screen的pass。对于每一个像素点：循环的计算每一个灯光，然后根据灯光的索引找到对应的ShadowCubemap，计算阴影。通常使用Shadow cubemap Array来保存ShadowMap，<strong>但是为了支持不同尺寸的Shado cubeMap组成Array，还需要别的算法。</strong></p><h2 id="算法扩展"><a href="#算法扩展" class="headerlink" title="算法扩展"></a>算法扩展</h2><p>前一个章节只是简单介绍了基础的算法。这一章节会把重要的算法进行说明。</p><h3 id="Projection-Maps"><a href="#Projection-Maps" class="headerlink" title="Projection Maps"></a>Projection Maps</h3><p>为了改进渲染culling效率，我们应该避免渲染在ShadowMap当中不需要采样的部分。也就是说，我们需要一些信息来确定接受阴影物体（像素）的位置。类似于投影映射：在光子贴图中指引光子的分布。</p><p>​幸运的是，这个和为virtual texture建立page是同样的问题。我们仍然使用把AABB投影到Cube表面的方法。为了表示阴影接收器，每一个cube的表面都是一个32X32bit的Mask。</p><p>​</p><h3 id="Non-uniform-Light-Sizes"><a href="#Non-uniform-Light-Sizes" class="headerlink" title="Non-uniform Light Sizes"></a>Non-uniform Light Sizes</h3><p>根据之前的分辨率选择算法。如果过灯光范围过大，在屏幕上不同的额位置上需要的分辨率是不一样的，近处可能是密度过高的，会造成浪费。如果只有统一大小的灯，我们可以直接限制最高的分辨率。然而，正如我们的结果所显示的，如果我们有一个场景有照射范围大小不同的灯光，那么这就会影响内存分配。</p><p>为了解决这个问题，我们需要每一个光源申请数量不同的ShadowMap。我们使用一个固定的数字，因为这允许快速和简单的实现，每一个光源可以使用1到16张数量不同的阴影贴图。为了分配阴影贴图，我们添加了一个步骤，在每个光线影响的cluster上，对需求的分辨率建立一个直方图。每个直方图桶内的最大值被用来确认阴影贴图大小。建立阴影贴图索引后，我们用这个索引替换集群光照列表中的光照索引。然后，裁剪和绘制可以保持相同，除了我们有时必须注意分开光索引和阴影贴图索引</p><h3 id="Level-of-Detail"><a href="#Level-of-Detail" class="headerlink" title="Level of Detail"></a>Level of Detail</h3><h3 id="Explicit-Cluster-Bounds-确认Cluster的边界"><a href="#Explicit-Cluster-Bounds-确认Cluster的边界" class="headerlink" title="Explicit Cluster Bounds 确认Cluster的边界"></a>Explicit Cluster Bounds 确认Cluster的边界</h3><p>每一个Cluster都是 一个在视锥体当中的一个格子，每一个位置都有一个Bounding Volume.计算显式边界，来紧密拟合集群内的样本，Bounding Volume计算准确但是也会造成额外的开销。</p><p>因此，我们提出了一种新的设计，在现代gpu上 计算近似显式边界并且只有非常小的开销。具体方法是：</p><p>为每一个Cluster保存一个32-bit的整数。然后在逻辑上划分成三个10bit的区域。每一个都代表了隐式AABB中可能位置的范围。在这种模式下，显式的包围盒可以通过32-bit的原子或操作。</p><p>为了构造这个包围盒，我们利用内在的逐位函数从每个10位域的两个方向计数零，这些位然后被用来在每个轴方向上调整隐式AABB的大小</p><h3 id="Backface-Culling背面剪裁"><a href="#Backface-Culling背面剪裁" class="headerlink" title="Backface Culling背面剪裁"></a>Backface Culling背面剪裁</h3><p>不需要为背面朝向的光源的像素保存阴影数据。因为必定是不会被光源影响的。</p>]]></content>
      
      
      <categories>
          
          <category> Paper </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原神制作细节猜测</title>
      <link href="/2022/07/09/GameAnalysis/%E7%B1%B3%E5%93%88%E6%B8%B8%E5%8E%9F%E7%A5%9E%E7%BB%86%E8%8A%82%E5%AE%9E%E7%8E%B0%E7%8C%9C%E6%B5%8B/"/>
      <url>/2022/07/09/GameAnalysis/%E7%B1%B3%E5%93%88%E6%B8%B8%E5%8E%9F%E7%A5%9E%E7%BB%86%E8%8A%82%E5%AE%9E%E7%8E%B0%E7%8C%9C%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="原神制作细节猜测"><a href="#原神制作细节猜测" class="headerlink" title="原神制作细节猜测"></a>原神制作细节猜测</h1><p>之前没有研究过手游，这里通过原神的视频试试分析他用了哪些技巧。主要是电脑视频分辨率太低了看不出来太多细节。</p><h2 id="镜面反射"><a href="#镜面反射" class="headerlink" title="镜面反射"></a>镜面反射</h2><p>最开始出场，使用了平面反射。</p><p><img src="/../../images/img/mirrorreflection.jpg" alt="mirrorreflection"></p><p>但是进入大世界场景之后平面反射被关闭了。</p><p><img src="/../../images/img/mirrorreflection2.jpg" alt="mirrorreflection2"></p><p>后面就是反射探针了</p><p><img src="/../../images/img/mirrorreflection3.jpg" alt="mirrorreflection3"></p><h2 id="植被"><a href="#植被" class="headerlink" title="植被"></a>植被</h2><p>草关闭了阴影</p><p><img src="/../../images/img/grassshadow.jpg" alt="grassshadow"></p><p>树应该烘焙了整体法线：</p><p><img src="/../../images/img/tree.jpg" alt="tree"></p><p>草的渲染距离：</p><p><img src="/../../images/img/2019623%E6%97%A5-123620.jpg" alt="2019623日-123620"></p><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>人物接收阴影似乎经过了特殊的处理。似乎是标记了人物在什么位置接收阴影。<strong>因为他的阴影是突变了，没有一半在阴影中一般不在的状态。</strong>或者其他什么技术，可以看到下面的半阴影状态。</p><p><img src="/../../images/img/shadow.jpg" alt="shadow"></p><p><img src="/../../images/img/shadow2.jpg" alt="shadow2"></p><p>  阴影没了一大块：</p><p><img src="/../../images/img/shadow4.jpg" alt="shadow4"></p><p><img src="/../../images/img/shadow3.jpg" alt="shadow3"></p><p>有时候出现了奇怪的阴影这个应该是Bake的问题，有阴影没有物体。另外鱼没有阴影。</p><p><img src="/../../images/img/shadow5.jpg" alt="shadow5"></p><p>shadowmask下面的切换也很明显：</p><p><img src="/../../images/img/shadowmap6.jpg" alt="shadowmap6"></p><p><img src="/../../images/img/shadowmap4.jpg" alt="shadowmap4"></p><p><img src="/../../images/img/shadowmap5.jpg" alt="shadowmap5"></p><h2 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h2><p>感觉根据使用了很多标记区域，用来标记是否在水中，是否被打湿，是否在阴影中。</p><h2 id="扭曲"><a href="#扭曲" class="headerlink" title="扭曲"></a>扭曲</h2><p>特效专门做了一个扭曲的特效pass，按照崩坏3的思路应该是单独写一个扭曲的pass，然后在后处理做统一的扭曲，用grabpass太费了：</p><p><img src="/../../images/img/2019623%E6%97%A5-114222.jpg" alt="2019623日-114222"></p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>场景中只有角色开启了描边，其他物体似乎都没有。任务提示的箱子也没有。。</p><h2 id="LOD与CrossFade"><a href="#LOD与CrossFade" class="headerlink" title="LOD与CrossFade"></a>LOD与CrossFade</h2><p>下面两张图可以感受到LOD0的切换距离，从左上角的植被的细节，之所以说是LOD是因为他的模型和阴影是突变的：</p><p><img src="/../../images/img/LOD.jpg" alt="LOD"></p><p><img src="/../../images/img/LOD2.jpg" alt="LOD2"></p><p>从原到进 Shadow map的变化，整体的感觉是使用Cross Fade首先进行LOD替换，然后进行shadowmap第0级和第1级的替换。因为植物烘焙了整体法线所以看不出来cross fade效果。</p><p><img src="/../../images/img/shadowmap2.jpg" alt="shadowmap2"></p><p><img src="/../../images/img/shadowmap3.jpg" alt="shadowmap3"></p><p><img src="/../../images/img/shadowmap.jpg" alt="shadowmap"></p><p>进入城镇之后能够感受到其他物体LOD的距离，包括建筑的倒角细节和植物的：</p><p><img src="/../../images/img/lod3.jpg" alt="lod3"></p><p><img src="/../../images/img/lod4.jpg" alt="lod4"></p><h2 id="云的阴影"><a href="#云的阴影" class="headerlink" title="云的阴影"></a>云的阴影</h2><p>云飘过是的软阴影。</p><p><img src="/../../images/img/cloudshadow.jpg" alt="cloudshadow"></p><p><img src="/../../images/img/cloudshadow2.jpg" alt="cloudshadow2"></p><h2 id="场景交互"><a href="#场景交互" class="headerlink" title="场景交互"></a>场景交互</h2><p>和草有很多互动被燃烧、枯萎、我觉得被冰冻也可以加上,可能因为草需要交互所以尽可能的减少了交互，我觉得草的下半部分可以加深颜色，或者调整法线用来模拟一点阴影。</p><p><img src="/../../images/img/2019623%E6%97%A5-123252.jpg" alt="2019623日-123252"></p><p>技能落到地面上有水花，通过穿帮的地方能看出来是透明面片，游泳的水花也是一样的东西。</p><p><img src="/../../images/img/2019623%E6%97%A5-122904.jpg" alt="2019623日-122904"></p><p><img src="/../../images/img/2019623%E6%97%A5-122937.jpg" alt="2019623日-122937"></p><h2 id="Decal"><a href="#Decal" class="headerlink" title="Decal"></a>Decal</h2><p>可以看出来的部分，垂直方向的纹路被隐藏了，大部分都只能垂直向下投射，所以应该是有法线信息的，我猜测为了渲染Decal，额外多渲染了一次深度+法线，或者用已经有的深度贴图，渲染一次法线。</p><p><img src="/../../images/img/2019623%E6%97%A5-123941.jpg" alt="2019623日-123941"></p><p><img src="/../../images/img/2019623%E6%97%A5-124056.jpg" alt="2019623日-124056"><img src="/../../images/img/2019623%E6%97%A5-124006.jpg" alt="2019623日-124006"></p>]]></content>
      
      
      <categories>
          
          <category> GameAnalysis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BRDF常用高光项模型</title>
      <link href="/2022/07/09/RTR/BRDFSpecular/"/>
      <url>/2022/07/09/RTR/BRDFSpecular/</url>
      
        <content type="html"><![CDATA[<h1 id="BRDF常用高光项模型"><a href="#BRDF常用高光项模型" class="headerlink" title="BRDF常用高光项模型"></a>BRDF常用高光项模型</h1><p>在基础的BRDF当中，我们推到出了基础的BRDF公式结构：</p><p>$$f &#x3D; \frac{DGF}{4 (nl)(nv)}$$</p><p>D项：法线分布函数用来描述，法线方向在表面上的分布情况，积分结果为1。</p><p>G项：用来描述Shadow和masking项。用来描述不同的几何结构有多少光线被遮挡。</p><p>F项：用来描述在不同材质，不同角度上，反射光线所占的比例。</p><p>下面来分析不同的的实现，主要从<a href="https://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html">博客</a>翻译而来：</p><p>首先，UE4和unity HDRP当中对于roughness的计算都有一些特别。</p><p>例如UE，当中参与计算的roughness为：</p><p>$$ \alpha &#x3D; roughness^2 $$</p><p>unity HDRP当中使用的是smoothness，最终参与计算的roughness为:</p><p>$$ \alpha &#x3D; (1 - smothness)^2 $$</p><h2 id="法线分布函数NDF"><a href="#法线分布函数NDF" class="headerlink" title="法线分布函数NDF"></a>法线分布函数NDF</h2><p>法线分布函数主要用来描述高光分布，也是用来描述微表面朝向的分布。所以他的半球积分为1：</p><p>$$ \int_\Omega D(h)(n⋅h)d w_i &#x3D; 1$$ </p><p>其中m为半角，并且每一项都有一个$ \frac{1}{\pi \alpha^2} $ 因子。</p><h3 id="Blinn-Phong"><a href="#Blinn-Phong" class="headerlink" title="Blinn-Phong"></a>Blinn-Phong</h3><p>$$ D_{Blinn}(h) &#x3D; \frac{1}{\pi \alpha^2} (nh)^{\frac{2}{\alpha^2} -2} $$</p><h3 id="Beckmann"><a href="#Beckmann" class="headerlink" title="Beckmann"></a>Beckmann</h3><p>$$ D_{Beckmann}(h)&#x3D; \frac{1}{\pi \alpha^2 (nh)^4}\exp (\frac{(nh)^2 -1}{\alpha^2(nh)^2}) $$</p><h3 id="GGX-Trowbridge-Reitz"><a href="#GGX-Trowbridge-Reitz" class="headerlink" title="GGX (Trowbridge-Reitz)"></a>GGX (Trowbridge-Reitz)</h3><p>$$ D_{GGX}(h)&#x3D;\frac{\alpha^2}{\pi((nh)^2(\alpha^2-1)+1)^2} $$</p><h3 id="GGX-Anisotropic"><a href="#GGX-Anisotropic" class="headerlink" title="GGX Anisotropic"></a>GGX Anisotropic</h3><p>$$ D_{GGXaniso}(h)&#x3D;\frac{1}{\pi\alpha_x\alpha_y} \frac{1}{(\frac{(xh)^2}{\alpha_x^2} +\frac{(yh)^2}{\alpha_y^2}+(nh)^2)^2} $$</p><h2 id="几何结构项Geometric-Shadowing"><a href="#几何结构项Geometric-Shadowing" class="headerlink" title="几何结构项Geometric Shadowing"></a>几何结构项Geometric Shadowing</h2><p>几何结构项描述了微表面的对于光线的遮挡关系，他是一个对光线的削减比例，所以不需要满足积分为1。对光线遮挡的比例依赖于粗糙度和微表面分布（NDF）。</p><h3 id="Implicit"><a href="#Implicit" class="headerlink" title="Implicit"></a>Implicit</h3><p>$$  G_{Implicit}(l,v,h) &#x3D; (nl)(nv)$$</p><h3 id="Neumann"><a href="#Neumann" class="headerlink" title="Neumann"></a>Neumann</h3><p>$$  G_{Neumann}(l,v,h) &#x3D; \frac{(nl)(nv)}{max(nl,nv)}$$</p><h3 id="Cook-Torrance"><a href="#Cook-Torrance" class="headerlink" title="Cook-Torrance"></a>Cook-Torrance</h3><p>$$ G_{Cook-Torrance}(l,v,h)&#x3D;min(1, \frac{2(nh)(nv)}{vh}, \frac{2(nh)(nl)}{vh} )$$</p><h3 id="Kelemen"><a href="#Kelemen" class="headerlink" title="Kelemen"></a>Kelemen</h3><p>$$ G_{Kelemen } (l,v,h)&#x3D;\frac{(nl)(nv)}{(vh)^2}$$</p><h2 id="Smith方法描述的几何结构项"><a href="#Smith方法描述的几何结构项" class="headerlink" title="Smith方法描述的几何结构项"></a>Smith方法描述的几何结构项</h2><p>Smith方法根据不同的法线分布函数NDF，来构造对应的结构遮挡。Smith把遮挡拆分成了两项：灯光和视线，他们使用同一个函数。</p><p>$$ G(l,v,h)&#x3D;G_1(l)G_1(v) $$</p><p>下面根据不同的NDF来给出对应的$ G_1 $</p><h3 id="Blinn-Phong-1"><a href="#Blinn-Phong-1" class="headerlink" title="Blinn-Phong"></a>Blinn-Phong</h3><p>没有对应的$ G_1 $,建议使用Beckmann的$ G_1 $。</p><h3 id="Beckmann-1"><a href="#Beckmann-1" class="headerlink" title="Beckmann"></a><strong>Beckmann</strong></h3><p>$$ c&#x3D;\frac{nv}{\alpha\sqrt{1-(nv)^2}} $$</p><p>$$ G_{Beckmann}(v)&#x3D; $$</p><p>$$ if c &lt; 1.6 :  \frac{3.524c+2.181c^2}{1+2.276c+2.577c^2} $$</p><p>$$ else:  1 $$</p><h3 id="GGX"><a href="#GGX" class="headerlink" title="GGX"></a>GGX</h3><p>$$  G_{GGX}(v) &#x3D; \frac{2(nv)}{(nv)+\sqrt{\alpha^2+(1-\alpha^2)(nv)^2}}  $$</p><h3 id="Schlick-Beckmann"><a href="#Schlick-Beckmann" class="headerlink" title="Schlick-Beckmann"></a>Schlick-Beckmann</h3><p>$$k &#x3D; \alpha \sqrt{\frac{2}{\pi}}$$</p><p>$$ G_{Schlick}(v) &#x3D; \frac{nv}{(nv)(1-k)+k} $$</p><h3 id="Schlick-GGX"><a href="#Schlick-GGX" class="headerlink" title="Schlick-GGX"></a>Schlick-GGX</h3><p>$$k &#x3D;\frac{\alpha} {2}$$</p><p>$$ G_{GGX}(v) &#x3D; \frac{nv}{(nv)(1-k)+k} $$</p><h2 id="菲涅尔Fresnel"><a href="#菲涅尔Fresnel" class="headerlink" title="菲涅尔Fresnel"></a>菲涅尔Fresnel</h2><p>菲涅尔主要用来描述在不同的入射角度上，给出一个折射率（index of refraction），计算反射和折射的比例。</p><p>菲涅尔的规律是：入射角越大，光线反射比例越大。</p><p>通常我们使用的输入参数不是折射率（IoR），而是垂直入射时的反射比$ F_0 $，并且通常隐含了如果入射角度接近90度，那么反射比会趋近于1($ F_{90} &#x3D; 1$)。</p><h3 id="None"><a href="#None" class="headerlink" title="None"></a>None</h3><p>$$  F_{None}(vh) &#x3D; F_0$$</p><h3 id="Schlick"><a href="#Schlick" class="headerlink" title="Schlick"></a>Schlick</h3><p>$$ F_{Schlick}(v,h)&#x3D;F_0+(1-F_0)(1-(vh))^5 $$ </p><p>目前Unity使用的就是这种。</p><h3 id="Cook-Torrance-1"><a href="#Cook-Torrance-1" class="headerlink" title="Cook-Torrance"></a>Cook-Torrance</h3><p>$$ \eta &#x3D; \frac{1+\sqrt{F_0}}{1-\sqrt{F_0}}$$</p><p>$$ c&#x3D;vh $$</p><p>$$ g &#x3D; \sqrt{\eta^2 + c^2 -1} $$</p><p>$$ F_{Cook-Torrance}(vh)&#x3D;\frac{1}{2}(\frac{g-c}{g+c})^2(1+(\frac{(g+c)c-1}{(g-c)c+1})^2) $$</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>由于brdf计算过于复杂，brdf通常需要优化，优化方案通常有以下几种：</p><ol><li>将brdf作为一个整体进行约分化简。</li><li>使用预计算，把计算结果存储在贴图当中。</li><li>简化brdf公式，使用brdf公式的lod策略。</li></ol><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] Hoffman 2013, </p><p>“Background: Physics and Math of Shading”</p><p>[2] Blinn 1977, “Models of light reflection for computer synthesized pictures”</p><p>[3] Beckmann 1963, “The scattering of electromagnetic waves from rough surfaces”</p><p>[4] Walter et al. 2007, </p><p>“Microfacet models for refraction through rough surfaces”</p><p>[5] Burley 2012, </p><p>“Physically-Based Shading at Disney”</p><p>[6] Neumann et al. 1999, </p><p>“Compact metallic reflectance models”</p><p>[7] Kelemen 2001, </p><p>“A microfacet based coupled specular-matte brdf model with importance sampling”</p><p>[8] Smith 1967, “Geometrical shadowing of a random rough surface”</p><p>[9] Schlick 1994, </p><p>“An Inexpensive BRDF Model for Physically-Based Rendering”</p><p>[10] Karis 2013, </p><p>“Real Shading in Unreal Engine 4”</p><p>[11] Cook and Torrance 1982, </p><p>“A Reflectance Model for Computer Graphics”</p><p>[12] Reed 2013, </p><p>“How Is the NDF Really Defined?”</p>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Depth Peeling</title>
      <link href="/2022/07/09/RTR/DepthPeeling/"/>
      <url>/2022/07/09/RTR/DepthPeeling/</url>
      
        <content type="html"><![CDATA[<h1 id="Depth-Peeling"><a href="#Depth-Peeling" class="headerlink" title="Depth Peeling"></a>Depth Peeling</h1><p>在使用Blend方式进行混合的时候，通常是按照Object从后往前的顺序渲染透明物体，这会使透明效果看起来不正常。Depth Peeling主要用来解决透明物体渲染顺序的问题。</p><p>这里通过Unity HDRP当中的CustomRender方式实现，并且重写了对应的Shader。</p><p>实际上，如果要在Unity中实现这个效果没有这么麻烦。我这里为了练习SRP相关的东西，所以重写了整个Render和Shader。另外，DP算法根据我自己的理解做了一些修改。</p><p>首先是C#部分的脚本，需要使用Unity HDRP的摄像机：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.Experimental.Rendering.HDPipeline;<br><span class="hljs-keyword">using</span> UnityEngine.Experimental.Rendering;<br><span class="hljs-keyword">using</span> UnityEngine.Rendering;<br><br>[<span class="hljs-meta">ExecuteInEditMode,RequireComponent(typeof(HDAdditionalCameraData)), RequireComponent(typeof(Camera))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DepthPeeling</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123; <br>    <span class="hljs-keyword">private</span> Camera camera;<br><span class="hljs-comment">// 定义Depth Peeling当中需要使用的一个ColorBuffer和两个DepthBuffer</span><br>    <span class="hljs-keyword">private</span> RenderTexture colorBuffer;<br>    <span class="hljs-keyword">private</span> RenderTexture depthBuffer;<br>    <span class="hljs-keyword">private</span> RenderTexture depthDualBuffer;<br>    <span class="hljs-keyword">private</span> RenderTargetIdentifier colorBufferId;<br>    <span class="hljs-keyword">private</span> RenderTargetIdentifier depthBufferId;<br>    <span class="hljs-keyword">private</span> RenderTargetIdentifier depthDualBufferId;<br><br>    <span class="hljs-built_in">int</span> m_FrameCount;<br>    <span class="hljs-built_in">float</span> m_LastTime, m_Time;<br><br>    <span class="hljs-keyword">private</span> HDAdditionalCameraData cameraData;<br>    <span class="hljs-keyword">private</span> CommandBuffer cmd;<br>    <span class="hljs-keyword">private</span> RenderTargetIdentifier targetId;<br><br><span class="hljs-comment">// ShaderTagId主要用来声明需要渲染的Pass</span><br>    CullingResults cullingResults;<br>    ShaderTagId s_ColorPeeling;<br>    ShaderTagId s_DepthPeeling;<br>    ShaderTagId s_DepthDualPeeling;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    private void Awake()</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        s_DepthPeeling = new ShaderTagId(&quot;DepthPeeling&quot;);</span><br><span class="hljs-comment">        s_DepthOnly = new ShaderTagId(&quot;DepthOnly&quot;);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br><br><span class="hljs-comment">// CustomRender包括了完整的渲染流程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CustomRedner</span>(<span class="hljs-params">ScriptableRenderContext context, HDCamera hdCamera</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 摄像机剪裁：</span><br>        ScriptableCullingParameters cullingParams;<br>        camera.TryGetCullingParameters(<span class="hljs-keyword">out</span> cullingParams);<br>        cullingResults = context.Cull(<span class="hljs-keyword">ref</span> cullingParams);<br><br>        <span class="hljs-comment">// 设置物体排序方式</span><br>        <span class="hljs-keyword">var</span> sortingSettings = <span class="hljs-keyword">new</span> SortingSettings(hdCamera.camera)<br>        &#123;<br>            criteria = SortingCriteria.CommonOpaque<br>        &#125;;<br><br>        DrawingSettings drawSettings = <span class="hljs-keyword">new</span> DrawingSettings();<br><br>        <span class="hljs-comment">// 设置渲染队列</span><br>        RenderQueueRange k_DepthPeeling = <span class="hljs-keyword">new</span> RenderQueueRange &#123; lowerBound = (<span class="hljs-built_in">int</span>)<span class="hljs-number">1</span>, upperBound = (<span class="hljs-built_in">int</span>)<span class="hljs-number">4000</span> &#125;;<br>        FilteringSettings filterRenderersSettings = <span class="hljs-keyword">new</span> FilteringSettings(k_DepthPeeling);<br><br>        context.SetupCameraProperties(camera, camera.stereoEnabled, (<span class="hljs-built_in">int</span>)camera.stereoActiveEye);<br>        <br>        <span class="hljs-comment">// 清空数据缓存，同时设置摄像机参数</span><br>        cmd.Clear();<br>        cmd.SetRenderTarget(colorBuffer);<br>        cmd.ClearRenderTarget(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, Color.clear);<br>        cmd.SetRenderTarget(depthBuffer);<br>        cmd.ClearRenderTarget(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, Color.clear);<br>        cmd.SetRenderTarget(depthDualBuffer);<br>        cmd.ClearRenderTarget(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, Color.white);<br>        hdCamera.SetupGlobalParams(cmd, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        context.ExecuteCommandBuffer(cmd);<br>        cmd.Clear();<br><br><br>        <span class="hljs-comment">// 执行15层的DepthPeeling</span><br>        <span class="hljs-built_in">int</span> peelingLayer = <span class="hljs-number">15</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; peelingLayer; i++)<br>        &#123;<br><br>            <span class="hljs-comment">// 绘制深度：设置渲染目标</span><br>            <span class="hljs-comment">// 从远到近</span><br>            cmd.SetRenderTarget(depthBufferId);<br>            cmd.SetGlobalTexture(<span class="hljs-string">&quot;_DepthRT&quot;</span>, depthDualBufferId);<br>            cmd.ClearRenderTarget(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, Color.clear, <span class="hljs-number">0</span>);<br>            context.ExecuteCommandBuffer(cmd);<br>            cmd.Clear();<br><br>            <span class="hljs-comment">// 绘制深度：ZTest Greater, 剥离上次绘制的远处深度。</span><br>            drawSettings.SetShaderPassName(<span class="hljs-number">0</span>, s_DepthPeeling);<br>            context.DrawRenderers(cullingResults, <span class="hljs-keyword">ref</span> drawSettings, <span class="hljs-keyword">ref</span> filterRenderersSettings);<br><br><span class="hljs-comment">// 记录当前已经剥离的深度。</span><br>            cmd.Blit(depthBufferId, depthDualBufferId);<br>            context.ExecuteCommandBuffer(cmd);<br>            cmd.Clear();<br><br>            <span class="hljs-comment">// 设置当前层的颜色和深度层buffer</span><br>            cmd.SetRenderTarget(colorBuffer, depthBufferId);<br>            context.ExecuteCommandBuffer(cmd);<br>            cmd.Clear();<br><br>            <span class="hljs-comment">// 渲染当前深度层上的颜色 使用 ZTest Equal</span><br>            drawSettings.SetShaderPassName(<span class="hljs-number">0</span>, s_ColorPeeling);<br>            context.DrawRenderers(cullingResults, <span class="hljs-keyword">ref</span> drawSettings, <span class="hljs-keyword">ref</span> filterRenderersSettings);<br>        &#125;<br>        <br><br>        cmd.Blit(colorBuffer, targetId);<br>        context.ExecuteCommandBuffer(cmd);<br>        cmd.Clear();<br><br>        context.Submit();<br>    &#125;<br><br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">     * Unity的HDRP使用了大量的临时纹理作为GBuffer，DBuffer，Depth，ColorBuffer，最终统一绘制到屏幕上。</span><br><span class="hljs-comment">     * 下面是HDRP代码中生成纹理Buffer的代码。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> RenderTexture <span class="hljs-title">GenerateRT</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">int</span> slices = <span class="hljs-number">1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        DepthBits depthBufferBits = DepthBits.None,</span></span><br><span class="hljs-params"><span class="hljs-function">        GraphicsFormat colorFormat = GraphicsFormat.R8G8B8A8_SRGB,</span></span><br><span class="hljs-params"><span class="hljs-function">        FilterMode filterMode = FilterMode.Point,</span></span><br><span class="hljs-params"><span class="hljs-function">        TextureWrapMode wrapMode = TextureWrapMode.Repeat,</span></span><br><span class="hljs-params"><span class="hljs-function">        TextureDimension dimension = TextureDimension.Tex2D,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">bool</span> enableRandomWrite = <span class="hljs-literal">false</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">bool</span> useMipMap = <span class="hljs-literal">false</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">bool</span> autoGenerateMips = <span class="hljs-literal">true</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">bool</span> isShadowMap = <span class="hljs-literal">false</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">int</span> anisoLevel = <span class="hljs-number">1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">float</span> mipMapBias = <span class="hljs-number">0f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">bool</span> enableMSAA = <span class="hljs-literal">false</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">bool</span> bindTextureMS = <span class="hljs-literal">false</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">bool</span> useDynamicScale = <span class="hljs-literal">false</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">bool</span> xrInstancing = <span class="hljs-literal">false</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        RenderTextureMemoryless memoryless = RenderTextureMemoryless.None,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        </span>)</span><br>    &#123;<br>        RenderTexture rt;<br>        rt = <span class="hljs-keyword">new</span> RenderTexture(camera.pixelWidth, camera.pixelHeight, (<span class="hljs-built_in">int</span>)depthBufferBits, colorFormat)<br>        &#123;<br>            hideFlags = HideFlags.HideAndDontSave,<br>            volumeDepth = slices,<br>            filterMode = filterMode,<br>            wrapMode = wrapMode,<br>            dimension = dimension,<br>            enableRandomWrite = enableRandomWrite,<br>            useMipMap = useMipMap,<br>            autoGenerateMips = autoGenerateMips,<br>            anisoLevel = anisoLevel,<br>            mipMapBias = mipMapBias,<br>            bindTextureMS = bindTextureMS,<br>            memorylessMode = memoryless,<br>            name = CoreUtils.GetRenderTargetAutoName(camera.pixelWidth, camera.pixelHeight, slices, GraphicsFormatUtility.GetRenderTextureFormat(colorFormat), name, mips: useMipMap)<br>        &#125;;<br>        <span class="hljs-keyword">return</span> rt;<br>    &#125;<br>    <span class="hljs-comment">// 创建需要的rt</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateRT</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// RenderTexture的创建，参考RTHandle类的使用方式</span><br>        &#123;<br>            <br>            colorBuffer = GenerateRT(<span class="hljs-number">1</span>, DepthBits.None);<br>            depthBuffer = GenerateRT(colorFormat:GraphicsFormat.R32_SFloat,depthBufferBits:DepthBits.Depth32, enableRandomWrite: <span class="hljs-literal">true</span>);<br>            depthDualBuffer = GenerateRT(colorFormat: GraphicsFormat.R32_SFloat, depthBufferBits:DepthBits.Depth32, enableRandomWrite: <span class="hljs-literal">true</span>);<br> <br>            colorBufferId = <span class="hljs-keyword">new</span> RenderTargetIdentifier(colorBuffer);<br>            depthBufferId = <span class="hljs-keyword">new</span> RenderTargetIdentifier(depthBuffer);<br>            depthDualBufferId = <span class="hljs-keyword">new</span> RenderTargetIdentifier(depthDualBuffer);<br>            targetId = <span class="hljs-keyword">new</span> RenderTargetIdentifier(camera.targetTexture);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 释放rt</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ReleaseRT</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// RenderTexture的释放，参考RTHandle类的使用方式</span><br>        &#123;<br>            UnityEngine.Object.Destroy(depthDualBuffer);<br>            UnityEngine.Object.Destroy(depthBuffer);<br>            UnityEngine.Object.Destroy(colorBuffer);<br><br>            depthDualBuffer = <span class="hljs-literal">null</span>;<br>            depthDualBuffer = depthBuffer;<br>            depthDualBuffer = colorBuffer;<br><br>            colorBufferId = BuiltinRenderTextureType.None;<br>            depthBufferId = BuiltinRenderTextureType.None;<br>            depthDualBufferId = BuiltinRenderTextureType.None;<br>            targetId = BuiltinRenderTextureType.None;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 初始化depth peeling需要的参数。</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 这段代码提示不能再程序运行的时候执行，提示需要在Awake或者OnStart执行，不过需要重启场景或者重启unity，实验发现OnEnable里使用也可以。</span><br>        <span class="hljs-comment">// 这两个ShaderTagId对应了Shader当中的LightMode</span><br>        s_ColorPeeling = <span class="hljs-keyword">new</span> ShaderTagId(<span class="hljs-string">&quot;ColorPeeling&quot;</span>);<br>        s_DepthPeeling = <span class="hljs-keyword">new</span> ShaderTagId(<span class="hljs-string">&quot;DepthPeeling&quot;</span>);<br>        s_DepthDualPeeling = <span class="hljs-keyword">new</span> ShaderTagId(<span class="hljs-string">&quot;DepthDualPeeling&quot;</span>);<br>        cullingResults = <span class="hljs-keyword">new</span> CullingResults();<br><br>        camera = GetComponent&lt;Camera&gt;();<br>        cameraData = camera.GetComponent&lt;HDAdditionalCameraData&gt;();<br>        <br>        <span class="hljs-keyword">if</span> (cmd == <span class="hljs-literal">null</span>)<br>        &#123;<br>            cmd = <span class="hljs-keyword">new</span> CommandBuffer();<br>            cmd.name = <span class="hljs-string">&quot;Depth Peeling&quot;</span>;<br>        &#125;<br><br>        CreateRT();<br>        cameraData.customRender += CustomRedner;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>()</span><br>    &#123;<br>        ReleaseRT();<br><br>        cameraData.customRender -= CustomRedner;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>下面是对应的Shader：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;DepthPeelingShader&quot;</span><br>&#123;<br>    Properties<br>    &#123;<br>        _Color(<span class="hljs-string">&quot;Color&quot;</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0.5</span>)<br>        _ColorMap(<span class="hljs-string">&quot;ColorMap&quot;</span>,  <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span>&#123;&#125;<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags&#123; <span class="hljs-string">&quot;RenderPipeline&quot;</span>=<span class="hljs-string">&quot;HDRenderPipeline&quot;</span> <span class="hljs-string">&quot;RenderType&quot;</span> = <span class="hljs-string">&quot;HDLitShader&quot;</span> &#125;<br><br>        HLSLINCLUDE<br>        <span class="hljs-type">float</span> OffDepth;<br>        <span class="hljs-comment">// 计算屏幕坐标。</span><br>        float4 <span class="hljs-title function_">ComputeScreenPos</span> <span class="hljs-params">(float4 pos, <span class="hljs-type">float</span> projectionSign)</span><br>        &#123;<br>          float4 o = pos * <span class="hljs-number">0.5f</span>;<br>          o.xy = float2(o.x, o.y * projectionSign) + o.w;<br>          o.zw = pos.zw;<br>          <span class="hljs-keyword">return</span> o;<br>        &#125;<br>        ENDHLSL<br><br>        Pass<br>        &#123;<br><br>            Name <span class="hljs-string">&quot;ColorPeeling&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ColorPeeling&quot;</span> &#125;<br><br>            <span class="hljs-comment">// 这里只做深度测试，使用PrePass的深度</span><br>            ZWrite Off<br>            <span class="hljs-comment">// 这里使用Equal，对应剥离后每一层的深度。</span><br>            ZTest Equal<br>            <span class="hljs-comment">//ZTest Always</span><br>            <span class="hljs-comment">// 从后往前混合</span><br>            Blend SrcAlpha OneMinusSrcAlpha<br>            Cull Off<br><br>            HLSLPROGRAM<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> target 4.5</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;</span></span><br>            <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl&quot;</span></span><br><br><br>            <span class="hljs-keyword">struct</span> appdata<br>            &#123;<br>                float4 vertex : POSITION;<br>                float2 uv : TEXCOORD0;<br>                uint vertexID : SV_VertexID;<br>            &#125;;<br><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span></span><br><span class="hljs-class">            &#123;</span><br>                real2 uv : TEXCOORD0;<br>                real4 screenposition : TEXCOORD1;<br>                real4 vertex : SV_POSITION;<br>            &#125;;<br><br><br>            float4 _Color;<br><br>            TEXTURE2D(_DepthRT);<br><br>            v2f <span class="hljs-title function_">vert</span> <span class="hljs-params">(appdata v)</span><br>            &#123;<br>                v2f o;<br>                <br>                float3 positionWS = TransformObjectToWorld(v.vertex.xyz);<br>                float3 positionCS = TransformWorldToHClip(positionWS);<br><br>                o.vertex = mul(UNITY_MATRIX_VP,mul(UNITY_MATRIX_M,v.vertex));<br>                o.uv = v.uv;<br>                o.screenposition = ComputeScreenPos(o.vertex,_ProjectionParams.x);<br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            real4 <span class="hljs-title function_">frag</span> <span class="hljs-params">(v2f i)</span> : SV_Target<br>            &#123;<br><br>                float2 uv = i.screenposition.xy/i.screenposition.w ;<br>                real depth = LOAD_TEXTURE2D(_DepthRT,uv* _ScreenSize.xy).r;<br>                depth = Linear01Depth(depth,_ZBufferParams);<br>                <span class="hljs-comment">// 上面的代码都是为了测试，这里就直接输出一个颜色。</span><br>                <span class="hljs-keyword">return</span> _Color;<span class="hljs-comment">//Linear01Depth(i.vertex.z / i.vertex.w,_ZBufferParams) ;</span><br>            &#125;<br>            ENDHLSL<br>        &#125;<br><br>        Pass<br>        &#123;<br>            <br>            Name <span class="hljs-string">&quot;DepthPeeling&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;DepthPeeling&quot;</span> &#125;<br><br>            ZWrite On<br>            <span class="hljs-comment">// 绘制最远处的层</span><br>            ZTest Greater<br>            Cull Off<br><br>            HLSLPROGRAM<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> target 4.5</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;</span></span><br>            <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl&quot;</span></span><br><br>            <span class="hljs-comment">// 记录以及剥离后的层</span><br>            TEXTURE2D_FLOAT(_DepthRT);<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">appdata</span></span><br><span class="hljs-class">            &#123;</span><br>                float4 vertex : POSITION;<br>                float2 uv : TEXCOORD0;<br>            &#125;;<br><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span></span><br><span class="hljs-class">            &#123;</span><br>                real2 uv : TEXCOORD0;<br>                real4 vertex : SV_POSITION;<br>                real4 screenposition : TEXCOORD1;<br>            &#125;;<br><br>            v2f <span class="hljs-title function_">vert</span> <span class="hljs-params">(appdata v)</span><br>            &#123;<br>                v2f o;<br>                <br>                float3 positionWS = TransformObjectToWorld(v.vertex.xyz);<br>                float3 positionCS = TransformWorldToHClip(positionWS);<br><br>                o.vertex = mul(UNITY_MATRIX_VP,mul(UNITY_MATRIX_M,v.vertex));<br>                o.screenposition = ComputeScreenPos(o.vertex,_ProjectionParams.x);<br>                o.uv = v.uv;<br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            real <span class="hljs-title function_">frag</span> <span class="hljs-params">(v2f i)</span> : SV_Target<br>            &#123;<br><br>                float2 uv = i.screenposition.xy/i.screenposition.w ;<br>                <span class="hljs-comment">// 计算剥离层的01的线性深度</span><br>                real depth = LOAD_TEXTURE2D(_DepthRT,uv* _ScreenSize.xy).r;<br><br>                <span class="hljs-comment">//depth = Linear01Depth(depth,_ZBufferParams);</span><br>                <span class="hljs-comment">// 计算当前的01的线性深度</span><br>                <span class="hljs-type">float</span> currdepth = Linear01Depth(i.vertex.z/i.vertex.w,_ZBufferParams);<br>                <span class="hljs-comment">// 当前绘制的深度，不能比剥离过的还远。</span><br>                clip(depth - currdepth<span class="hljs-number">-0.0001</span>);<br>                <span class="hljs-keyword">return</span> currdepth;<br>            &#125;<br>            ENDHLSL<br>        &#125;<br><br>        <span class="hljs-comment">// 这个Pass没有用到</span><br>        Pass<br>        &#123;<br>            <br>            Name <span class="hljs-string">&quot;DepthDualPeeling&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;DepthDualPeeling&quot;</span> &#125;<br><br>            ZWrite On<br>            ZTest Less<br><br>            HLSLPROGRAM<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> target 4.5</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;</span></span><br>            <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl&quot;</span></span><br><br><br>            <span class="hljs-keyword">struct</span> appdata<br>            &#123;<br>                float4 vertex : POSITION;<br>                float2 uv : TEXCOORD0;<br>            &#125;;<br><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span></span><br><span class="hljs-class">            &#123;</span><br>                real2 uv : TEXCOORD0;<br>                real4 vertex : SV_POSITION;<br>            &#125;;<br><br>            v2f <span class="hljs-title function_">vert</span> <span class="hljs-params">(appdata v)</span><br>            &#123;<br>                v2f o;<br>                <br>                float3 positionWS = TransformObjectToWorld(v.vertex.xyz);<br>                float3 positionCS = TransformWorldToHClip(positionWS);<br><br>                o.vertex = mul(UNITY_MATRIX_VP,mul(UNITY_MATRIX_M,v.vertex));<br>                o.uv = v.uv;<br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            real4 <span class="hljs-title function_">frag</span> <span class="hljs-params">(v2f i)</span> : SV_Target<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            ENDHLSL<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果展示，能够看出透明物体之间是正常的混合效果：</p><p><img src="/../../images/img/DepthPeelingResult3.jpg" alt="DepthPeelingResult3"></p><p><img src="/../../images/img/DepthPeelingResult2.jpg" alt="DepthPeelingResult2"></p><p><img src="/../../images/img/DepthPeelingResult.jpg" alt="DepthPeelingResult"></p>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GPU渲染优化技术:Inside Geometry Instancing</title>
      <link href="/2022/07/09/RTR/GPU%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AFInside_Geometry_Instancing/"/>
      <url>/2022/07/09/RTR/GPU%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AFInside_Geometry_Instancing/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#gpu%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AFinside-geometry-instancing">GPU渲染优化技术:Inside Geometry Instancing</a><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#why-geometry-instancing">Why Geometry Instancing?</a></li><li><a href="#definitions">Definitions</a><ul><li><a href="#geometry-packet">Geometry Packet</a></li><li><a href="#instance-attributes">Instance Attributes</a></li><li><a href="#geometry-instance">Geometry Instance</a></li><li><a href="#render-and-texture-context">Render and Texture Context</a></li><li><a href="#geometry-batch">Geometry Batch</a></li></ul></li><li><a href="#implementation">Implementation</a><ul><li><a href="#static-batching">Static Batching</a></li><li><a href="#dynamic-batching">Dynamic Batching</a></li><li><a href="#vertex-constants-instancing">Vertex Constants Instancing</a></li><li><a href="#batching-with-the-geometry-instancing-api">Batching with the Geometry Instancing API</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="GPU渲染优化技术-Inside-Geometry-Instancing"><a href="#GPU渲染优化技术-Inside-Geometry-Instancing" class="headerlink" title="GPU渲染优化技术:Inside Geometry Instancing"></a>GPU渲染优化技术:Inside Geometry Instancing</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这里主要讨论对几何体的渲染优化技术：</p><p>参考内容为<a href="http://developer.nvidia.com/gpugems2">GPU Gems 2</a></p><p>为了制作一个完整的、令人信服的游戏世界，地图当中可能存在大量的细小的、零碎的模型，这些模型可能彼此之间只有微小的差别：颜色、位置等。</p><p>但是渲染大量的小物体，每一个只使用面很少的多边形，会造成GPU的大量开销。<strong>现在的图形API的设计对于渲染大量的小物体（面数少）是非常低效的</strong>。（Graphics APIs such as Direct3D and OpenGL are not designed to efficiently render a small number of polygons thousands of times per frame）</p><p><strong>这部分内容主要处理渲染大量相同几何体的问题。</strong></p><h2 id="Why-Geometry-Instancing"><a href="#Why-Geometry-Instancing" class="headerlink" title="Why Geometry Instancing?"></a>Why Geometry Instancing?</h2><p><strong>将三角形提交到GPU进行渲染是相对缓慢的操作（drawcall）</strong>。原文中提到的渲染限制：（Wloka 2003 shows that a 1 GHz CPU can render only around 10,000 to 40,000 batches per second in Direct3D.  On a more modern CPU, we can expect this number to be between 30,000 and 120,000 batches per second (around 1,000 to 4,000 batches per frame at 30 frames&#x2F;sec). )  <strong>这就说明我们不能提交过多的次数，也就是Drawcall的范围需要在1000- 4000之间，无论一个batch当中有多少个三角形，因为CPU时间限制，否则他没有更多的时间做别的事情。</strong></p><p>为了渲染更多的东西，应该尽可能最小化贴图和渲染状态的变化。<strong>一个比较好的方案是在同一个Batch当中，渲染多次三角形。这样可以最小化批次提交的次数，释放更多的CPU时间给别的系统（物理系统，游戏逻辑）。</strong></p><h2 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h2><p>首先明确几个概念：</p><h3 id="Geometry-Packet"><a href="#Geometry-Packet" class="headerlink" title="Geometry Packet"></a>Geometry Packet</h3><p>Geometry Packet指的是一堆需要被Instance的几何体，包括了顶点和索引的集合。一个Geometry Packet包括：顶点数据（position, texture coordinates, normal, possibly tangent space and bones information for skinning, and per-vertex colors）和索引数据流。这些数据以最有效的方式提交到GPU。</p><p>Geometry Packet是对一段几何图形的抽象描述，其中几何实体在模型空间中表示，没有保存和渲染上下文相关的信息（世界坐标矩阵、渲染状态）。</p><p>下面是一段Geometry Packet的例子：包括物体的几何信息和它的边界球:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GeometryPacket</span>  </span><br><span class="hljs-class">&#123;</span>    <br>    Primitive mPrimType;    <br>    <span class="hljs-type">void</span>* mVertices;   <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mVertexStride;      <span class="hljs-comment">//顶点列表</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>* mIndices;      <span class="hljs-comment">//索引列表</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mVertexCount;    <span class="hljs-comment">// 顶点数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mIndexCount;      <span class="hljs-comment">// 索引数 </span><br>    D3DXVECTOR3 mSphereCentre;   <span class="hljs-comment">// 包围球中心</span><br>    <span class="hljs-type">float</span> mSphereRadius;   <span class="hljs-comment">// 包围球半径</span><br>&#125;; <br></code></pre></td></tr></table></figure><h3 id="Instance-Attributes"><a href="#Instance-Attributes" class="headerlink" title="Instance Attributes"></a>Instance Attributes</h3><p>Instance Attributes是每个Instance物体的属性，可以包括:模型到世界的转换矩阵、实例颜色。（为了方便理解原文的其他属性省略了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InstanceAttributes</span>  &#123;</span>    <br>    D3DXMATRIX mModelMatrix;    <span class="hljs-comment">// 模型矩阵</span><br>    D3DCOLOR mInstanceColor;    <span class="hljs-comment">// Instance 颜色</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Geometry-Instance"><a href="#Geometry-Instance" class="headerlink" title="Geometry Instance"></a>Geometry Instance</h3><p>Geometry Instance是一个 geometry packet加上其用于实例化成被渲染物体的属性。</p><p>结构体如下图：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GeometryInstance</span>  &#123;</span>    <br>    GeometryPacket* mGeometryPacket;    <br>    InstanceAttributes mInstanceAttributes;  <br>&#125;; <br></code></pre></td></tr></table></figure><h3 id="Render-and-Texture-Context"><a href="#Render-and-Texture-Context" class="headerlink" title="Render and Texture Context"></a>Render and Texture Context</h3><p>渲染上下文指的是渲染状态：AlphaTest之类的。纹理上下文指的是当前激活的纹理，渲染目标之类的。</p><h3 id="Geometry-Batch"><a href="#Geometry-Batch" class="headerlink" title="Geometry Batch"></a>Geometry Batch</h3><p><strong>一个Geometry Batch包括：一组需要渲染的Geometry Instances、他们需要的渲染状态和纹理上下文的集合。它总是直接对应一个DrawIndexedPrimitive()调用。</strong> </p><p><strong>也就是说一个Batch对应了一个Redner Content、一个纹理上下文和多个Geometry Instances，对应了一个DrawCall也就是一次DrawIndexedPrimitive()的调用</strong></p><p><strong>RenderContext</strong>和<strong>TextureContext</strong>的Class(为了方便理解和原文做了调整)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 渲染下文</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RenderContext</span>  &#123;</span>  <br>public:     <br>    <span class="hljs-comment">// 开始设置 render context，使渲染状态激活</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">Begin</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;      <br>    <span class="hljs-comment">// 关闭 render context，还原之前的状态    </span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">End</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;    <br>private:      <br>    <span class="hljs-comment">// render state、pixel shader、vertex shader</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;    <br><br><span class="hljs-comment">// 需要用到的纹理</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextureContext</span>  &#123;</span>     <br>    Texture mDiffuseMap;    <br>    Texture mLightMap;      <br>    <span class="hljs-comment">// . . .    </span><br>&#125;; <br></code></pre></td></tr></table></figure><p>Geometry Batch类</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeometryBatch</span>  &#123;</span>  <br>public:      <br>    <span class="hljs-comment">// 清楚batch当中包含的全部Instance  </span><br>    virtual <span class="hljs-type">void</span> <span class="hljs-title function_">ClearInstances</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;      <br>    <span class="hljs-comment">// 添加一个Instance 返回Instance ID </span><br>    <span class="hljs-comment">// 如果不能在添加返回-1</span><br>    virtual <span class="hljs-type">int</span> <span class="hljs-title function_">AddInstance</span><span class="hljs-params">(GeometryInstance* instance)</span>;      <br>    <span class="hljs-comment">// 提交所有Instance, 渲染循环之前调用一次，或者Instance发生变化之后。  </span><br>    virtual <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Commit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = <span class="hljs-number">0</span>;      <br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">    更新Geometry batch, 最终会准备GPU数据提交给驱动程序，如果需要也回填充indexbuffer和vertexbuffer ，每帧调用一次。</span><br><span class="hljs-comment">*/</span>     <br>    virtual <span class="hljs-type">void</span> <span class="hljs-title function_">Update</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = <span class="hljs-number">0</span>;     <br>    <span class="hljs-comment">// 将batch提交给驱动程序，通常就是一次drawcall，一次DrawIndexedPrimitive的调用。 </span><br>    virtual <span class="hljs-type">void</span> <span class="hljs-title function_">Render</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-type">const</span> = <span class="hljs-number">0</span>;    <br>    <br>private:   <br>    <span class="hljs-comment">// Instance的列表</span><br>    GeometryInstancesCollection mInstances;      <br>   <br>&#125;; <br></code></pre></td></tr></table></figure><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>引擎的渲染只能通过Geometry Batch看到Geometry Instance的抽象接口。隐藏了instancing技术的实现细节， GeometryBatch还提供了管理Instance物体，更新和渲染的服务。这样引擎能够专注于batch排序、以最小化渲染状态的变化。Geometry Batch关注实际的实现和图形API的交互。</p><p>下面是一个通过排序GeometryBatch以最小化渲染状态变化的渲染过程伪代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 遍历所有的drawcall，也就是所有的batch</span><br>Foreach GeometryBatch in ActiveBatchesList    <br><span class="hljs-comment">// 更新这个batch</span><br>    GeometryBatch.Update();    <br>    <span class="hljs-comment">// Render phase  </span><br>    Foreach RenderContext  <br>    Begin    <br>    <span class="hljs-comment">// 渲染状态</span><br>        RenderContext.BeginRendering();    <br>        RenderContext.CommitStates();    <br><span class="hljs-comment">// 贴图状态</span><br>        Foreach TextureContext      <br>            Begin      <br>            <span class="hljs-comment">//应用贴图</span><br>                TextureContext.Apply();    <br>   <span class="hljs-comment">// 渲染Batch中的所有instance</span><br>                Foreach GeometryBatch in the texture context        <br>                GeometryBatch.Render();    <br>            End  <br>    End <br></code></pre></td></tr></table></figure><p>更新操作和渲染阶段可以保持分离，如果我们希望一次性更新所有batch，渲染多次。例如渲染Shadowmap。</p><p>现在我们讨论四种GeometryBatch的实现并且分析他们的性能特性：内存和灵活性。</p><p>下面比较重要所以保留了原文：</p><ul><li><strong>Static batching.</strong> The fastest way to instance geometry. Each instance is transformed once to world space, its attributes are applied, and then it’s sent already transformed to the GPU with every frame. Although simple, static batching is the least flexible technique.</li><li><strong>Dynamic batching.</strong> The slowest way to instance geometry. Each instance is streamed to GPU memory every frame, already transformed and with attributes applied. Dynamic batching seamlessly supports skinning and provides the most flexible implementation.</li><li><strong>Vertex constants instancing.</strong> A hybrid implementation in which multiple copies of the geometry for each instance are copied once into GPU memory. Instance attributes are then set every frame through vertex constants, and a vertex shader completes geometry instancing.</li><li><strong>Batching with Geometry Instancing API.</strong> Using the Geometry Instancing API provided by DirectX 9 and fully supported in hardware by GeForce 6 Series GPUs, this implementation offers a flexible and fast solution to geometry instancing. Unlike all other methods, this does not require geometry packet replication in the Direct3D vertex stream.</li></ul><h3 id="Static-Batching"><a href="#Static-Batching" class="headerlink" title="Static Batching"></a>Static Batching</h3><p>这个策略中，我们希望一次性处理全部的Instance，所以需要把所有内容拷贝到一个静态的vertex buffer中。vertex buffer object要足够的大，以保存所有的instance。因为是提前合并所有instance数据，所以设置成D3DUSAGE_WRITEONLY和MAX_STATIC_BUFFER_SIZE即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">HRESULT res;    <br>res = lpDevice-&gt;CreateVertexBuffer(MAX_STATIC_BUFFER_SIZE,    <br>                                   D3DUSAGE_WRITEONLY,    <br>                                   <span class="hljs-number">0</span>,    <br>                                   D3DPOOL_MANAGED,    <br>                                   &amp;mStaticVertexStream,    <br>                                   <span class="hljs-number">0</span>);    <br>ENGINE_ASSERT(SUCCEEDED(res)); <br></code></pre></td></tr></table></figure><p>然后实现 <code>Commit()</code>的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 遍历每一个Batch当中的instance</span><br>Foreach GeometryInstance in Instances  <br>Begin    <br><span class="hljs-comment">// 将所有的instance都转换到同一个空间。</span><br>    Transform geometry in mGeometryPacket to world space      with instance mModelMatrix    <br>    <span class="hljs-comment">// 应用所有的instance属性</span><br>    Apply other instance <span class="hljs-title function_">attributes</span> <span class="hljs-params">(like instance color)</span>    <br>    <span class="hljs-comment">// 将转换后的几何信息保存的vertex buffer</span><br>    Copy transformed geometry to the Vertex Buffer    <br>    <span class="hljs-comment">// 将索引根据不同instance增加一个offet保存到Indexbuffer</span><br>Copy <span class="hljs-title function_">indices</span> <span class="hljs-params">(with the right offset)</span> to the Index Buffer  <br>End <br></code></pre></td></tr></table></figure><p>现在就可以调用 <code>DrawIndexedPrimitive()</code>方法。所有的物体都变成了一个几何体</p><p><strong>限制</strong>：</p><ol><li>Large memory footprint.</li><li>No support for different levels of detail</li><li>No support for skinning.</li><li>No direct support for moving instances.</li></ol><h3 id="Dynamic-Batching"><a href="#Dynamic-Batching" class="headerlink" title="Dynamic Batching"></a>Dynamic Batching</h3><p>Dynamic batching 克服了static batching的缺点，但是降低了渲染效率。主要的有优点是能够不需要可编程管线GPU的支持。</p><p>首先需要创建一个vertexbuffer，内存分布更好的支持动态的更新。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">HRESULT res;    <br>res = lpDevice-&gt;CreateVertexBuffer(MAX_DYNAMIC_BUFFER_SIZE,    <br>                                   D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY,    <br>                                   <span class="hljs-number">0</span>,    <br>                                   D3DPOOL_DEFAULT,    <br>                                   &amp;mDynamicVertexStream,    <br>                                   <span class="hljs-number">0</span>); <br></code></pre></td></tr></table></figure><p>设置一个 <code>MAX_DYNAMIC_BUFFER_SIZE</code>是很重要的，有两个方案：</p><ol><li>选择一个足够大的值能够保证每一帧的所有instance都足够。</li><li>选择一个满足一定数量instance数量。</li></ol><p>第一个策略能够保证几何体更新和渲染是分开的，更新一次batch，提交一次渲染。更新一个batch的意义是将所有的instances放置到一个vertexbuffer当中：渲染只是提交 <code>DrawIndexedPrimitive()</code>渲染操作。但是这个方法需要足够大的图形内存。他可能是不可靠的：如果我们没有办法保证buffer在应用程序运行期间总是足够的大。</p><p>第二个策略需要交错的进行更新batch和提交渲染，当dynamicbuffer填充满的时候，提交渲染，并且丢弃buffer内容。然后继续填充。为了性能优化，选择合适的协议很重要。</p><p>选择哪一种依赖于具体的应用程序。本章节，我们选择第一个策略，因为更直接更容易解释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">Foreach GeometryInstance in Instances  <br>Begin    <br> Transform geometry in mGeometryPacket to world space with      instance mModelMatrix    <br> If instance needs skinning, request a <span class="hljs-built_in">set</span> of bones from      mAnimationPlayer and skin geometry    <br> Apply other instance <span class="hljs-title function_">attributes</span> <span class="hljs-params">(like instance color)</span>    <br> Copy transformed geometry to the Vertex Buffer    <br> Copy <span class="hljs-title function_">indices</span> <span class="hljs-params">(with the right offset)</span> to the Index Buffer    <br>Advance current pointer to the Vertex Buffer    <br>Advance current pointer to the Index Buffer  <br>    End <br></code></pre></td></tr></table></figure><p>这里的渲染调用也是简单的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">DrawIndexedPrimitive().<br></code></pre></td></tr></table></figure><h3 id="Vertex-Constants-Instancing"><a href="#Vertex-Constants-Instancing" class="headerlink" title="Vertex Constants Instancing"></a>Vertex Constants Instancing</h3><p>Vertex Constants Instance中，我们使用顶点常量来保存Instance数据。顶点常量的batching在渲染中速度非常快，并且它支持instance物体每帧移动，但是为了这样的灵活性需要有一定的代价。</p><p>限制：</p><ol><li>每一个batch的数量是有限制的，依赖于可用的常量数量；通常一个batch数量在50到100个。但是这个在降低CPU开销上是足够的。</li><li>无法进行蒙皮，顶点常量 已经用来存储instance属性。</li><li>需要图形硬件对于vertexshader的支持。</li></ol><p>下图是顶点数据的示意图，表示了VertexBuffer的布局：</p><p><img src="/../../images/GPU%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AFInside_Geometry_Instancing/03_instancing_02.jpg" alt="03_instancing_02.jpg"></p><p>原始的顶点格式需要增加一个整形的索引用来表示Constant用的是哪个Instance，指明所属的geometry patcket。这个和蒙皮一样，指定哪个顶点被哪几根骨骼影响。</p><p>顶点格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InstanceVertex</span>  &#123;</span>    <br>    D3DXVECTOR3  mPosition; <span class="hljs-comment">// Other vertex properties, such as normal and texture    </span><br>    <span class="hljs-comment">// coordinates      </span><br>    WORD  mInstanceIndex[<span class="hljs-number">4</span>]; <span class="hljs-comment">// Direct3D requires SHORT4  </span><br>&#125;; <br></code></pre></td></tr></table></figure><p>提交数据 <code>Commit()</code> ，当所有的Instance数据都加入到geometrybatch之后，提交修改后的顶点buffer(增加Instancebuffer)。</p><p>下一步就是为每一个instance更新渲染属性。假设我们只有模型矩阵，描述instance的位置和朝向和颜色。</p><p>当使用Dx9类的GPU时，我们最大使用256个常量数据，可以使用200用于Instance属性。在我们的例子当中，一个模型矩阵需要4个常量，一个颜色需要1个常量，那么对于一个Instance就需要5个常量，也就是一个batch最多支持40个Instance。</p><p>下面是Update()方法（用于更新顶点数据）的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">D3DXVECTOR4 instancesData[MAX_NUMBER_OF_CONSTANTS];    <br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;    <br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; GetInstancesCount(); ++i)  &#123;    <br>    <span class="hljs-comment">// write model matrix    </span><br>    instancesData[count++] = *(D3DXVECTOR4*)        <br>    &amp;mInstances[i].mModelMatrix.m11;    <br>    instancesData[count++] = *(D3DXVECTOR4*)        <br>    &amp;mInstances[i].mModelMatrix.m21;    <br>    instancesData[count++] = *(D3DXVECTOR4*)        <br>    &amp;mInstances[i].mModelMatrix.m31;    <br>    instancesData[count++] = *(D3DXVECTOR4*)        <br>    &amp;mInstances[i].mModelMatrix.m41;      <br>    <span class="hljs-comment">// write instance color      </span><br>    instanceData[count++] = ConvertColorToVec4(mInstances[i].mColor));  <br>&#125;    <br>lpDevice-&gt;SetVertexConstants(    <br>    INSTANCES_DATA_FIRST_CONSTANT,    <br>    instancesData,    <br>    count); <br></code></pre></td></tr></table></figure><p>Render()方法设置视口矩阵和所有的instance，并通过<code>DrawIndexedPrimitive()</code> 提交渲染。</p><p>可能的优化方式：可以将模型矩阵以四元组的形式保存可以节省两个顶点常量，最大支持的instance数量增加到70个左右。一个统一的缩放值保存在位移的w通道。模型矩阵在顶点数组中进行重构，但是会增加顶点Shader的复杂程度和计算时间。</p><h3 id="Batching-with-the-Geometry-Instancing-API"><a href="#Batching-with-the-Geometry-Instancing-API" class="headerlink" title="Batching with the Geometry Instancing API"></a>Batching with the Geometry Instancing API</h3><p>最后一个技术是通过图形API直接暴露的硬件功能。越来越多的图形硬件开始支持Geometry Insancing API，这个技术优雅的解决了顶点数据Instancing 的数量限制，内存占用有限，CPU几乎不需要干预。唯一的缺点就是他只能处理相同的Geometry Packet。</p><p>DX9提供下面的调用用来访问Geometry Instancing API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">HRESULT <span class="hljs-title function_">SetStreamSourceFreq</span><span class="hljs-params">(    UINT StreamNumber,    UINT FrequencyParameter)</span>; <br></code></pre></td></tr></table></figure><p><em>StreamNumber</em>表示了流数据的索引，<em>FrequencyParameter</em>表示了每一个顶点包含的Instance数量。</p><p>我们首先需要创造两个vertexbuffer，一个是静态的用于保存一个单一几何体的geometry packet ，这个几何体是我们想要进行多次Instance绘制的物体。还需要一个动态的buffer用于保存Instance 数据。两个vertex的stream如下图：</p><p><img src="/../../images/GPU%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AFInside_Geometry_Instancing/03_instancing_03.jpg" alt="03_instancing_03.jpg"></p><p><code>Commit()</code> 数据确保所有的Instance只使用同一个geometrypacket，并且把这个geometry拷贝到一个静态的buffer当中。</p><p> <code>Update()</code> 就简单的将所有的Instance的属性拷贝到第二个stream当中。这个方法看起来虽然和dynamic batch的策略很接近，但是CPU的介入和图形总线 (AGP or PCI Express)的带宽都是最小的。除此之外，我们能够分配一个足够大的内存给所有Instance的属性而不用担心图形内存，因为每一个Instance属性只使用一个几何体包的一小部分内存。</p><p> <code>Render()</code> 方法需要设置两个Stream和正确的Stream frequency和调用DrawIndexedPrimitive()来在一个batch中渲染全部Instance。</p><p>GPU会处理第一个stream的数据通过复制和第二个stream的数据打包。vertex shader会把模型空间的顶点用instance属性中的矩阵转换到世界空间。</p><p>下面是对两个stream的设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> instancesCount = GetInstancesCount();    <br><span class="hljs-comment">// set up stream source frequency for the first stream  </span><br><span class="hljs-comment">// to render instancesCount instances  </span><br><span class="hljs-comment">// D3DSTREAMSOURCE_INDEXEDDATA tells Direct3D we&#x27;ll use  </span><br><span class="hljs-comment">// indexed geometry for instancing  </span><br>lpDevice-&gt;SetStreamSourceFreq(    <span class="hljs-number">0</span>,    D3DSTREAMSOURCE_INDEXEDDATA | instancesCount);      <br><span class="hljs-comment">// set up first stream source with the vertex buffer  </span><br><span class="hljs-comment">// containing geometry for the geometry packet  </span><br>lpDevice-&gt;SetStreamSource(    <span class="hljs-number">0</span>,    mGeometryInstancingVB[<span class="hljs-number">0</span>],    <span class="hljs-number">0</span>,    mGeometryPacketDecl);    <br><span class="hljs-comment">// set up stream source frequency for the second stream;  </span><br><span class="hljs-comment">// each set of instance attributes describes one instance  </span><br><span class="hljs-comment">// to be rendered  </span><br>lpDevice-&gt;SetStreamSourceFreq(    <span class="hljs-number">1</span>,    D3DSTREAMSOURCE_INSTANCEDATA | <span class="hljs-number">1</span>);    <span class="hljs-comment">// set up second stream source with the vertex buffer    </span><br><span class="hljs-comment">// containing all instances&#x27; attributes  </span><br>pd3dDevice-&gt;SetStreamSource(    <span class="hljs-number">1</span>,    mGeometryInstancingVB[<span class="hljs-number">0</span>],    <span class="hljs-number">0</span>,    mInstancesDataVertexDecl); <br></code></pre></td></tr></table></figure><p>vertex shader的代码如图所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">// vertex input declaration  </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vsInput</span>  </span><br><span class="hljs-class">&#123;</span>    <br>    <span class="hljs-comment">// stream 0    </span><br>    float4 position : POSITION;    <br>    float3 normal   : NORMAL;      <br>    <span class="hljs-comment">// stream 1      </span><br>    float4 model_matrix0 : TEXCOORD0;    <br>    float4 model_matrix1 : TEXCOORD1;    <br>    float4 model_matrix2 : TEXCOORD2;    <br>    float4 model_matrix3 : TEXCOORD3;      <br>    float4 instance_color : D3DCOLOR;  <br>&#125;;      <br>vsOutput <span class="hljs-title function_">GeometryInstancingVS</span><span class="hljs-params">(    in vsInput input)</span>  <br>&#123;    <br>    <span class="hljs-comment">// construct the model matrix    </span><br>    float4x4 modelMatrix =    &#123;      <br>        input.model_matrix0,      <br>        input.model_matrix1,      <br>        input.model_matrix2,      <br>        input.model_matrix3    <br>    &#125;;      <br>    <span class="hljs-comment">// transform input position and normal to world space    </span><br>    <span class="hljs-comment">// with the instance model matrix      </span><br>    float4 worldPosition = mul(input.position, modelMatrix);    <br>    float3 worldNormal = mul(input.normal, modelMatrix);      <br>    <span class="hljs-comment">// output position, normal, and color    </span><br>    output.position = mul(worldPosition, ViewProjectionMatrix);    <br>    output.normal = mul(worldNormal, ViewProjectionMatrix);    <br>    output.color = input.instance_color;      <br>    <span class="hljs-comment">// output other vertex data    </span><br>&#125; <br></code></pre></td></tr></table></figure><p>伴随着最小的cpu开销和内存，这个技术能够高效的绘制大量的同种几何体，并且是很多场景的理想使用方式。唯一的缺点就是需要硬件支持并且不能简单的支持蒙皮。</p><p>为了实现蒙皮，可能需要为所有的instance把蒙皮骨骼信息保存在贴图上，需要为正确的instance获取正确的骨骼，并且要保证texture fectch技术可用（Geometry instancing API需要，ShaderModel 3.0支持）。这个方案看起来很有吸引力，但是性能有待测试。</p>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gamma矫正</title>
      <link href="/2022/07/09/RTR/Gamma%E7%9F%AB%E6%AD%A3/"/>
      <url>/2022/07/09/RTR/Gamma%E7%9F%AB%E6%AD%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Gamma矫正"><a href="#Gamma矫正" class="headerlink" title="Gamma矫正"></a>Gamma矫正</h1><p>之前总结了UnityGamma矫正相关的内容。</p><p>这里进行更加详细的解释。</p><p>主要的参考资料：</p><p>线性空间：<a href="https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch24.html">GPU Gems:Chapter 24. The Importance of Being Linear</a></p><p>HDR：<a href="https://www.eizo.com.cn/global/library/management/ins-and-outs-of-hdr/index1.html">HDR标准</a></p><h2 id="Gamma存在的原因"><a href="#Gamma存在的原因" class="headerlink" title="Gamma存在的原因"></a>Gamma存在的原因</h2><p><strong>一切的起因：CRT显示器对于颜色值得的响应并不是线性的</strong> + <strong>人眼对暗部更明显</strong>。</p><ol><li>阴极射线管在将电压转换成光强的过程中并不表现出线性关系，也就是说，计算机当中保存的0.5的颜色值，输出到CRT显示器上会变成0.25左右，整个颜色会变暗。即使在后来使用了LCD显示器，也需要进行Gamma矫正。Gamma矫正会将图像亮。$$ C_{Gamma} &#x3D; C^{1&#x2F;2.2}$$.</li><li>Gamma矫正会将图像变亮的同时，还会让数值的更大的范围来描述颜色的暗部。恰巧人眼对暗部更加敏感，所以我会直接将Gamma矫正后的图像进行保存。再到后来就是，拍摄设备+存储+显示全部都是用Gamma矫正的图像。</li></ol><h2 id="显示器与Gamma"><a href="#显示器与Gamma" class="headerlink" title="显示器与Gamma"></a>显示器与Gamma</h2><p><strong>根据上面提到的，一般的CRT显示器和LCD显示器都会需要一个Gamma矫正才能正常显示。</strong></p><p><strong>在使用HDR显示器上，同样会有一条Gamma曲线（与CRT不同的是他的分布在整个亮度区间，而不是0到1），这个是为了能够配合人类的视觉。</strong></p><p>人类眼睛所能感知的最暗和最亮物体之间的差异范围（动态范围）通常为  $$ 10^{12} $$ ，传统的SDR范围是 $$  10^{3} $$ ,HDR的范围 $$ 10^{6} $$ . </p><p>为了正确显示HDR图像，仅仅提高亮度是不够的 - 以与人类视力相匹配的方式显示色彩和色调至关重要。 色彩和色调受每个输入和输出设备具有的称为伽玛的输入 - 输出特性的影响。</p><h2 id="渲染与Gamma"><a href="#渲染与Gamma" class="headerlink" title="渲染与Gamma"></a>渲染与Gamma</h2><p>渲染过程中，涉及到两个问题：</p><ol><li>如何使用sRGB图像。</li><li>如何输出正确的图像格式。</li></ol><p>上面两个问题是独立的，互相之间没有关系，下面进行分别讨论。</p><h3 id="sRGB图像的使用"><a href="#sRGB图像的使用" class="headerlink" title="sRGB图像的使用"></a>sRGB图像的使用</h3><p>一般图像都保存在sRGB空间，我们计算光照必定要在线性空间下。</p><p>有两种方式得到：</p><ol><li>一种是通过图像API支持，例如：opengl在设置纹理是可以吧纹理标记，这样Shader在采样的时候就会自动获取到一个线性空间的颜色。这部分需要API的支持，对于手机来说一个Opengl ES 3.0 和Vulken 都支持。</li><li>另一种方式是采样之后计算平方。</li></ol><p>在Gems里面提到，对于手动计算，可能在mipmap和filtering步骤有一些问题。</p><h3 id="输出正确的图像"><a href="#输出正确的图像" class="headerlink" title="输出正确的图像"></a>输出正确的图像</h3><p>这部分就需要判断设备类型：</p><p>如果支持FrameBuffer设置成sRGB那么就可以直接输出线性颜色。任何被Shader返回的值都会在保存之间进行Gamma矫正。如果开启了线性混合，那么已经保存的值会被返回到线性空间进行混合，然后在进行Gamma矫正之后保存。Alpha的值不会参与上面的操作操作。</p><p>如果不支持sRGB类型的Frame Buffer。就需要进行手动矫正。但是这个时候Blend操作我们是无法控制的，所以Blend的结果是用Gamma空间直接混合的错误结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 finalCol = do_all_lighting_and_shading();<br><span class="hljs-type">float</span> pixelAlpha = compute_pixel_alpha();<br><span class="hljs-keyword">return</span> float4(<span class="hljs-built_in">pow</span>(finalCol, <span class="hljs-number">1.0</span> / <span class="hljs-number">2.2</span>), pixelAlpha);<br><span class="hljs-comment">// Or (cheaper, but assuming gamma of 2.0 rather than 2.2)</span><br><span class="hljs-keyword">return</span> float4( <span class="hljs-built_in">sqrt</span>( finalCol ), pixelAlpha );<br></code></pre></td></tr></table></figure><p>如果使用了HDR显示器，那么可以不做这个操作。</p><h3 id="中间结果"><a href="#中间结果" class="headerlink" title="中间结果"></a>中间结果</h3><p>只要记住如果用了sRGB的FrameBuffer，会自动编码解码，计算时统一即可。</p><h3 id="HDR"><a href="#HDR" class="headerlink" title="HDR"></a>HDR</h3><p>如果使用了HDR，那么可以参考Unity的制作方案。</p><p>如果没有开启HDR，原本颜色的叠加都会使用Gamma矫正。这是因为精确度低，经过Gamma编码可以让更大的区间保存暗部。在大部分8bit的颜色格式中，大部分图形API都提供了sRGB版本，就是为了尽可能提升分辨率。</p><p>开启HDR表示可以使用超过255的颜色，此时所有的帧缓存会变成ARGB32.或者ARGBHalf。此时分辨率足够高，所有的线性颜色进行不断的叠加，不在需要特殊编码，而是在这一帧完全处理完成之后，在进行下面的处理。</p><p>当所有的混合和或处理计算结束，Gamma矫正才会再次执行。</p>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Early Z</title>
      <link href="/2022/07/09/RTR/EarlyZ/"/>
      <url>/2022/07/09/RTR/EarlyZ/</url>
      
        <content type="html"><![CDATA[<h1 id="Early-Z"><a href="#Early-Z" class="headerlink" title="Early Z"></a>Early Z</h1><h2 id="优化原理"><a href="#优化原理" class="headerlink" title="优化原理"></a>优化原理</h2><p><a href="https://www.khronos.org/opengl/wiki/Early_Fragment_Test">OpenGL官方文档对EarlyZ的解释</a></p><p>原本的深度测试是在Fragment Shader计算之后的，如果不通过深度测试，这部分Pixel计算就是浪费的。</p><p>优化方式就是在Fragment Shader处理之前，先进行深度测试，可以避免过多的Pixel计算。</p><p>使用深度检测是方便的（硬件直接支持），这个优化，假设你的Pixel计算没有对深度进行任何修改，也就是说在Fragment Shader之前和之后进行深度检测的结果是一样的。（Therefore, an implementation is free to apply early fragment tests if the <a href="https://www.khronos.org/opengl/wiki/Fragment_Shader">Fragment Shader</a> being used does not do anything that would impact the results of those tests. ）</p><h2 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h2><ol><li><p>这个是硬件支持的功能，图形API无法决定是否进行。（原文：Because this is a hardware-based optimization, OpenGL has no direct controls that will tell you if early depth testing will happen.）</p></li><li><p>如果进行了Alpha Clip或者深度写入，会造成EarlyZ失效。（原文：Similarly, if the <a href="https://www.khronos.org/opengl/wiki/Fragment_Shader#Special_operations">fragment shader discards the fragment with the discard keyword</a>, this will almost always turn off early depth tests on some hardware. Note that even <em>conditional</em> use of discard will mean that the FS will turn off early depth tests.）</p></li></ol><h2 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h2><h3 id="Z-Pre-Pass"><a href="#Z-Pre-Pass" class="headerlink" title="Z-Pre-Pass"></a>Z-Pre-Pass</h3><p>Early-Z的实现，主要是通过一个Z-pre-pass实现。简单来说：对不透明物体：</p><ol><li>首先用简单shader进行渲染，这个shader<strong>不写颜色缓冲区，只写深度缓冲区</strong>。</li><li><strong>关闭深度写入，开启深度测试</strong>，用正常的shader进行渲染。</li></ol><p>The most effective way to use early depth test hardware is to run a depth-only pre-processing pass. This means to render all available geometry, using minimal shaders and a rendering pipeline that <a href="https://www.khronos.org/opengl/wiki/Write_Mask">only writes to the depth buffer</a>. The <a href="https://www.khronos.org/opengl/wiki/Vertex_Shader">Vertex Shader</a> should do nothing more than transform positions, and the <a href="https://www.khronos.org/opengl/wiki/Fragment_Shader#Optional">Fragment Shader does not even need to exist</a>.</p><p>This provides the best performance gain if the fragment shader is expensive, or if you intend to use multiple passes across the geometry.</p><h3 id="类似Unity的渲染排序-Render-Sort"><a href="#类似Unity的渲染排序-Render-Sort" class="headerlink" title="类似Unity的渲染排序 Render Sort"></a>类似Unity的渲染排序 Render Sort</h3><p>我们常用的深度排序（从前往后渲染）渲染不透明物体，就是为了利用Early Z，如果没有Early Z那么深度排序就没有意义（并且还会浪费CPU）。（Unity官方文档原文：Spend lots of CPU cycles to do occlusion culling and better sorting (to take advantage of Early Z-cull).）</p><h2 id="Alpha-Test（Discard）在移动平台消耗较大的原因"><a href="#Alpha-Test（Discard）在移动平台消耗较大的原因" class="headerlink" title="Alpha Test（Discard）在移动平台消耗较大的原因"></a><strong>Alpha Test（Discard）在移动平台消耗较大的原因</strong></h2><p>跟上面讲到的Early-Z有关。</p><ol><li>正常情况下，不管是否是开启深度写入或者深度测试，这个面片的光栅化之后对应的像素的深度值都可以在Early-Z（Z-Cull）的阶段判断出来。</li><li>如果开启了Alpha Test（Discard），导致Early-Z失效。即使被遮挡也一定会进行Pixel计算！ 与之相对的Alpha Blend却可以进行正确的Early计算，所以会有人讨论Alpha Test和Alpha Blend的区别。<a href="https://docs.cryengine.com/display/SDKDOC2/Rendering+Performance+Guidelines">CryEngine官方解释</a>文档指出，使用Alpha Testing会导致跳过对Opaque物体的优化。Alpha Blend会进行Frame Buffer的w&#x2F;o操作，开销也比较到。所以他们性能开销的痛点是不一样的。</li></ol><p>Unity官方文档的描述：</p><p>The fixed-function <a href="https://docs.unity3d.com/Manual//SL-AlphaTest.html">AlphaTest</a> - or its programmable equivalent, <code>clip()</code> - has different performance characteristics on different platforms:</p><ul><li>Generally you gain a small advantage when using it to remove totally transparent pixels on most platforms.</li><li>However, on PowerVR GPUs found in iOS and some Android devices, alpha testing is resource-intensive. Do not try to use it for performance optimization on these platforms, as it causes the game to run slower than usual.</li></ul><h2 id="其他的资料"><a href="#其他的资料" class="headerlink" title="其他的资料"></a>其他的资料</h2><p>这个<a href="https://zhuanlan.zhihu.com/p/33127345">文章</a>提到了像素并行处理的问题，这个问题在使用Unity的Render Sort策略下是有问题的。但是如果使用Z-Pre-Pass策略是没有问题的。</p><p>里面提到的更详细的内容都是猜测不是很准确，需要进一步研究一些手机架构。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>他的核心：Early Z的优化和优化失效的问题。</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HDR 与ToneMapping</title>
      <link href="/2022/07/09/RTR/HDR%E4%B8%8EToneMapping%E7%90%86%E8%AE%BA/"/>
      <url>/2022/07/09/RTR/HDR%E4%B8%8EToneMapping%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="HDR-与ToneMapping"><a href="#HDR-与ToneMapping" class="headerlink" title="HDR 与ToneMapping"></a>HDR 与ToneMapping</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>HDR详细的解释：<a href="https://developer.nvidia.com/rendering-game-hdr-display">Rendering a Game for HDR Display</a></p><p>ToneMapping 讲解的比较详细的：<a href="https://zhuanlan.zhihu.com/p/21983679">Tone mapping进化论</a></p><h2 id="HDR解释"><a href="#HDR解释" class="headerlink" title="HDR解释"></a>HDR解释</h2><h3 id="渲染层的HDR和ToneMapping"><a href="#渲染层的HDR和ToneMapping" class="headerlink" title="渲染层的HDR和ToneMapping"></a>渲染层的HDR和ToneMapping</h3><p>渲染层面的HDR主要是渲染阶段：</p><ol><li><p>由于<strong>系统默认的FrameBuffer只支持0-1数据</strong>，如果存储超过1，硬件会自动执行Clamp操作。</p></li><li><p>支持HDR渲染，实际上就是图形API(OPengl 等)支持自定义RenderBuffer。这个自定义的Renderbuffer可以支持，RGBA16 格式，保存超过1的值。</p></li><li><p>最后一个阶段，需要把RenderBuffer的内容（超过1），通过ToneMapping算法，压缩到系统默认的FrameBuffer中用于显示。</p></li></ol><p>下面是一个基础的HDR渲染阶段的流程</p><p>参考GDC2017 High Dynamic Range color grading and display in Frostbite</p><p><img src="/../../images/HDR%E4%B8%8EToneMapping%E7%90%86%E8%AE%BA/1568966737421.png" alt="1568966737421"></p><p>Tonemap之前的流程包括暗角，Flare Len，DoF，Bloom，自动曝光参数计算（部分参数用于ToneMaping）.</p><p>可以将ToneMap和Grading、Gamma矫正进行合并。</p><h3 id="显示层的HDR：多ToneMapping曲线"><a href="#显示层的HDR：多ToneMapping曲线" class="headerlink" title="显示层的HDR：多ToneMapping曲线"></a>显示层的HDR：多ToneMapping曲线</h3><ol><li><p>在进入显示器时，内容必定是FrameBuffer当中的0-1。</p></li><li><p>如果在LDR和HDR显示器上使用同一个ToneMapping曲线，会导致画面整体变亮。</p></li></ol><p><strong>FrameBuffer始终是0-1</strong>，而1对应的值变成了：100nits  200nits 1000nits.</p><p><img src="/../../images/HDR%E4%B8%8EToneMapping%E7%90%86%E8%AE%BA/1569205929868.png" alt="1569205929868"></p><p><img src="/../../images/HDR%E4%B8%8EToneMapping%E7%90%86%E8%AE%BA/1569205676107.png" alt="1569205676107"></p><p>寒霜策略：</p><p><img src="/../../images/HDR%E4%B8%8EToneMapping%E7%90%86%E8%AE%BA/1569205757913.png" alt="1569205757913"></p>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IBL理论与应用</title>
      <link href="/2022/07/09/RTR/IBL%E5%85%89%E7%85%A7%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2022/07/09/RTR/IBL%E5%85%89%E7%85%A7%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><p>- <a href="#ibl%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8">IBL理论与应用</a></p><p>​    - <a href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">理论基础</a></p><p>​        - <a href="#%E5%85%89%E7%85%A7%E5%87%BD%E6%95%B0">光照函数</a></p><p>​        - <a href="#%E4%BB%A3%E7%A0%81">代码</a></p><p>​    - <a href="#ibl%E4%BC%98%E5%8C%96split-sum-approximation">IBL优化：Split Sum Approximation</a></p><p>​        - <a href="#ibl-mipmap%E6%9E%84%E9%80%A0%E4%B8%8Eprefilter">IBL MipMap构造与Prefilter</a></p><p>​        - <a href="#ibl%E5%85%89%E7%85%A7%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E4%BC%B0%E8%AE%A1">IBL光照函数积分估计</a></p><p>​            - <a href="#%E5%8E%9F%E5%A7%8B%E7%A7%AF%E5%88%86">原始积分</a></p><p>​            - <a href="#%E6%8B%9F%E5%90%88%E7%A7%AF%E5%88%86%E4%BC%98%E5%8C%96">拟合积分优化</a></p><p>​            - <a href="#%E9%A2%84%E7%A7%AF%E5%88%86%E8%B4%B4%E5%9B%BE">预积分贴图</a></p><!-- /TOC --><h1 id="IBL理论与应用"><a href="#IBL理论与应用" class="headerlink" title="IBL理论与应用"></a>IBL理论与应用</h1><p>这部分内容主要参自UE4的论文[Real Shading in Unreal Engine 4]</p><p>IBL主要指的就是环境贴图部分计算的光照。</p><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h3 id="光照函数"><a href="#光照函数" class="headerlink" title="光照函数"></a>光照函数</h3><p>光源就是一个Cubemap，过去也会用到双剖面。实际的积分光照结果是：</p><p><img src="/../../images/IBL%E5%85%89%E7%85%A7%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/1574853586831.png" alt="1574853586831"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>这部分内容对应的代码就是下面的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 根据一个随机Xi值和粗糙度、法线计算需要采样cubemap的方向，</span><br>float3 <span class="hljs-title function_">ImportanceSampleGGX</span><span class="hljs-params">( float2 Xi, <span class="hljs-type">float</span> Roughness, float3 N )</span> &#123; <br>   <span class="hljs-type">float</span> a = Roughness * Roughness;<br>    <span class="hljs-type">float</span> Phi = <span class="hljs-number">2</span> * PI * Xi.x; <br>    <span class="hljs-type">float</span> CosTheta = <span class="hljs-built_in">sqrt</span>( (<span class="hljs-number">1</span> - Xi.y) / ( <span class="hljs-number">1</span> + (a*a - <span class="hljs-number">1</span>) * Xi.y ) ); <br>    <span class="hljs-type">float</span> SinTheta = <span class="hljs-built_in">sqrt</span>( <span class="hljs-number">1</span> - CosTheta * CosTheta );<br>    float3 H; <br>    H.x = SinTheta * <span class="hljs-built_in">cos</span>( Phi ); <br>    H.y = SinTheta * <span class="hljs-built_in">sin</span>( Phi ); <br>    H.z = CosTheta;<br>float3 UpVector = <span class="hljs-built_in">abs</span>(N.z) &lt; <span class="hljs-number">0.999</span> ? float3(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) : float3(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>); <br>    float3 TangentX = normalize( cross( UpVector, N ) ); <br>    float3 TangentY = cross( N, TangentX ); <span class="hljs-comment">// Tangent to world space </span><br>    <span class="hljs-keyword">return</span> TangentX * H.x + TangentY * H.y + N * H.z;<br>&#125;<br><span class="hljs-comment">//N就是NumSamples，是进行采样估计得采样数，决定了积分准确度，可以看到和正常光照一样需要有FDG的计算</span><br>float3 <span class="hljs-title function_">SpecularIBL</span><span class="hljs-params">( float3 SpecularColor, <span class="hljs-type">float</span> Roughness, float3 N, float3 V )</span> <br>&#123; <br>    float3 SpecularLighting = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> uint NumSamples = <span class="hljs-number">1024</span>; <br>    <span class="hljs-keyword">for</span>( uint i = <span class="hljs-number">0</span>; i &lt; NumSamples; i++ ) <br>    &#123; <br>        float2 Xi = Hammersley( i, NumSamples );<br>float3 H = ImportanceSampleGGX( Xi, Roughness, N ); <br>        float3 L = <span class="hljs-number">2</span> * dot( V, H ) * H - V;<br><span class="hljs-type">float</span> NoV = saturate( dot( N, V ) ); <br>        <span class="hljs-type">float</span> NoL = saturate( dot( N, L ) ); <br>        <span class="hljs-type">float</span> NoH = saturate( dot( N, H ) ); <br>        <span class="hljs-type">float</span> VoH = saturate( dot( V, H ) );<br>        <span class="hljs-keyword">if</span>( NoL &gt; <span class="hljs-number">0</span> ) <br>        &#123; <br>            float3 SampleColor = EnvMap.SampleLevel( EnvMapSampler, L, <span class="hljs-number">0</span> ).rgb;<br>        <span class="hljs-type">float</span> G = G_Smith( Roughness, NoV, NoL ); <br>            <span class="hljs-type">float</span> Fc = <span class="hljs-built_in">pow</span>( <span class="hljs-number">1</span> - VoH, <span class="hljs-number">5</span> ); <br>            float3 F = (<span class="hljs-number">1</span> - Fc) * SpecularColor + Fc;<br><span class="hljs-comment">// Incident light = SampleColor * NoL </span><br>            <span class="hljs-comment">// Microfacet specular = D*G*F / (4*NoL*NoV) </span><br>            <span class="hljs-comment">// pdf = D * NoH / (4 * VoH) </span><br>            SpecularLighting += SampleColor * F * G * VoH / (NoH * NoV);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> SpecularLighting / NumSamples;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="IBL优化：Split-Sum-Approximation"><a href="#IBL优化：Split-Sum-Approximation" class="headerlink" title="IBL优化：Split Sum Approximation"></a>IBL优化：Split Sum Approximation</h2><p>由于上面内容如果实时计算的话，开销太高，所以对原始公式进行了一次估计。变成了：</p><p><img src="/../../images/IBL%E5%85%89%E7%85%A7%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/1574853973468.png" alt="1574853973468"></p><p>这个就叫做Split Sum Approximation。</p><p>优化之后的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 <span class="hljs-title function_">ApproximateSpecularIBL</span><span class="hljs-params">( float3 SpecularColor, <span class="hljs-type">float</span> Roughness, float3 N, float3 V )</span> <br>&#123; <br>    <span class="hljs-type">float</span> NoV = saturate( dot( N, V ) ); <br>    float3 R = <span class="hljs-number">2</span> * dot( V, N ) * N - V;<br>    <span class="hljs-comment">// 第一项的优化结果：mipmap某一层</span><br>float3 PrefilteredColor = PrefilterEnvMap( Roughness, R ); <br>    <span class="hljs-comment">// 第二项优化结果：真实的进行采样积分，或者使用估计值。</span><br>    float2 EnvBRDF = IntegrateBRDF( Roughness, NoV );<br><span class="hljs-keyword">return</span> PrefilteredColor * ( SpecularColor * EnvBRDF.x + EnvBRDF.y );<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>得到上面的公式之后进行两个积分项的分别化简。</p><h3 id="IBL-MipMap构造与Prefilter"><a href="#IBL-MipMap构造与Prefilter" class="headerlink" title="IBL MipMap构造与Prefilter"></a>IBL MipMap构造与Prefilter</h3><p>首先是第一项，实际上就是计算一个颜色的平均值。</p><p><img src="/../../images/IBL%E5%85%89%E7%85%A7%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/1574854041330.png" alt="1574854041330"></p><p>根据不同的粗糙度采样的范围有所区别。粗糙度越大，采样越分散，所以通常就使用了mipmap对应于不同的粗糙度（也就是模糊程度不同的平均值）。根据其他的一些数学推导，模糊用的filter有所区别。</p><p>UE4进行Prefilter的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 <span class="hljs-title function_">PrefilterEnvMap</span><span class="hljs-params">( <span class="hljs-type">float</span> Roughness, float3 R )</span> <br>&#123; <br>    float3 N = R; float3 V = R;<br>    float3 PrefilteredColor = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> uint NumSamples = <span class="hljs-number">1024</span>; <br>    <span class="hljs-keyword">for</span>( uint i = <span class="hljs-number">0</span>; i &lt; NumSamples; i++ ) <br>    &#123; <br>        float2 Xi = Hammersley( i, NumSamples ); <br>        float3 H = ImportanceSampleGGX( Xi, Roughness, N ); <br>        float3 L = <span class="hljs-number">2</span> * dot( V, H ) * H - V;<br>        <span class="hljs-type">float</span> NoL = saturate( dot( N, L ) ); <br>        <span class="hljs-keyword">if</span>( NoL &gt; <span class="hljs-number">0</span> ) <br>        &#123; <br>            PrefilteredColor += EnvMap.SampleLevel( EnvMapSampler, L, <span class="hljs-number">0</span> ).rgb * NoL; <br>            TotalWeight += NoL; <br>        &#125;<br>&#125;<br><span class="hljs-keyword">return</span> PrefilteredColor / TotalWeight;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="IBL光照函数积分估计"><a href="#IBL光照函数积分估计" class="headerlink" title="IBL光照函数积分估计"></a>IBL光照函数积分估计</h3><p>然后是第二项：</p><p><img src="/../../images/IBL%E5%85%89%E7%85%A7%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/1574854160210.png" alt="1574854160210"></p><p>这一项的优化方式是:</p><ol><li>先得到一个真实的曲线。然后创造一个函数去拟合这个积分结果。</li><li>或者不拟合直接用原始积分结果。</li><li>把准确的积分结果保存在贴图中：UE4的做法</li></ol><h4 id="原始积分"><a href="#原始积分" class="headerlink" title="原始积分"></a>原始积分</h4><p>真实的积分代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 真实的积分代码：</span><br>float2 <span class="hljs-title function_">IntegrateBRDF</span><span class="hljs-params">( <span class="hljs-type">float</span> Roughness, <span class="hljs-type">float</span> NoV )</span> <br>&#123; <br>    float3 V; V.x = <span class="hljs-built_in">sqrt</span>( <span class="hljs-number">1.0f</span> - NoV * NoV ); <span class="hljs-comment">// sin V.y = 0; V.z = NoV; // cos</span><br><span class="hljs-type">float</span> A = <span class="hljs-number">0</span>; <br>    <span class="hljs-type">float</span> B = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> uint NumSamples = <span class="hljs-number">1024</span>; <br>    <span class="hljs-keyword">for</span>( uint i = <span class="hljs-number">0</span>; i &lt; NumSamples; i++ ) <br>    &#123; <br>        float2 Xi = Hammersley( i, NumSamples ); <br>        float3 H = ImportanceSampleGGX( Xi, Roughness, N ); <br>        float3 L = <span class="hljs-number">2</span> * dot( V, H ) * H - V;<br><span class="hljs-type">float</span> NoL = saturate( L.z ); <span class="hljs-type">float</span> NoH = saturate( H.z ); <br>        <span class="hljs-type">float</span> VoH = saturate( dot( V, H ) );<br><span class="hljs-keyword">if</span>( NoL &gt; <span class="hljs-number">0</span> ) <br>        &#123; <br>            <span class="hljs-type">float</span> G = G_Smith( Roughness, NoV, NoL );<br><span class="hljs-type">float</span> G_Vis = G * VoH / (NoH * NoV); <br>            <span class="hljs-type">float</span> Fc = <span class="hljs-built_in">pow</span>( <span class="hljs-number">1</span> - VoH, <span class="hljs-number">5</span> ); <br>            A += (<span class="hljs-number">1</span> - Fc) * G_Vis; <br>            B += Fc * G_Vis;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> float2( A, B ) / NumSamples;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拟合积分优化"><a href="#拟合积分优化" class="headerlink" title="拟合积分优化"></a>拟合积分优化</h4><p>拟合的方式可以参考文献:</p><p>[Summary of Physically Based Shading in Call of Duty: Black Ops ]</p><p>文献当中提到了真实曲线和如何构造出估计曲线。</p><p>估计拟合的brdf代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 <span class="hljs-title function_">EnvironmentBRDF</span><span class="hljs-params">( <span class="hljs-type">float</span> g, <span class="hljs-type">float</span> NoV, float3 rf0 )</span> <br>&#123; <br>    float4 t = float4( <span class="hljs-number">1</span>/<span class="hljs-number">0.96</span>, <span class="hljs-number">0.475</span>, (<span class="hljs-number">0.0275</span> - <span class="hljs-number">0.25</span> * <span class="hljs-number">0.04</span>)/<span class="hljs-number">0.96</span>, <span class="hljs-number">0.25</span> ); <br>    t *= float4( g, g, g, g );<br>    t += float4( <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (<span class="hljs-number">0.015</span> - <span class="hljs-number">0.75</span> * <span class="hljs-number">0.04</span>)/<span class="hljs-number">0.96</span>, <span class="hljs-number">0.75</span> ); <br>    <span class="hljs-type">float</span> a0 = t.x * min( t.y, exp2( <span class="hljs-number">-9.28</span> * NoV ) ) + t.z; <br>    <span class="hljs-type">float</span> a1 = t.w; <br>    <span class="hljs-keyword">return</span> saturate( a0 + rf0 * ( a1 - a0 ) ); <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="预积分贴图"><a href="#预积分贴图" class="headerlink" title="预积分贴图"></a>预积分贴图</h4><p>UE4Brdf的积分贴图：</p><p><img src="/../../images/IBL%E5%85%89%E7%85%A7%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/1574854766491.png" alt="1574854766491"></p>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LOD策略</title>
      <link href="/2022/07/09/RTR/LOD%E7%AD%96%E7%95%A5/"/>
      <url>/2022/07/09/RTR/LOD%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="LOD策略"><a href="#LOD策略" class="headerlink" title="LOD策略"></a>LOD策略</h1><h2 id="LOD常见策略"><a href="#LOD常见策略" class="headerlink" title="LOD常见策略"></a>LOD常见策略</h2><p>在计算LOD过程中，需要根据不同的策略切换模型的LOD级别，常见的策略：</p><ol><li>根据距离。</li><li>根据屏占比：Sphere和AABB</li></ol><p>根据距离的方式会导致远处的城堡用很低的LOD级别，导致看不清楚。近处的小石头用很高的LOD级别实际上看不到。</p><p>Unity和Unreal都是用了屏占比的策略，他们根据不同的屏占比切换LOD级别，同时屏占比过小就会直接剪裁掉：</p><p><img src="/../../images/LOD%E7%AD%96%E7%95%A5/1577155095470.png" alt="1577155095470"></p><p><img src="/../../images/LOD%E7%AD%96%E7%95%A5/1577155108259.png" alt="1577155108259"></p><h2 id="屏占比算法"><a href="#屏占比算法" class="headerlink" title="屏占比算法"></a>屏占比算法</h2><h3 id="球体屏占比"><a href="#球体屏占比" class="headerlink" title="球体屏占比"></a>球体屏占比</h3><p><a href="http://iquilezles.org/www/articles/sphereproj/sphereproj.htm">http://iquilezles.org/www/articles/sphereproj/sphereproj.htm</a></p><h3 id="AABB屏占比"><a href="#AABB屏占比" class="headerlink" title="AABB屏占比"></a>AABB屏占比</h3><p>参考链接：<a href="http://www.codersnotes.com/notes/projected-area-of-an-aabb/">http://www.codersnotes.com/notes/projected-area-of-an-aabb/</a></p>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Temporal Anti-Aliasing</title>
      <link href="/2022/07/09/RTR/TAA/"/>
      <url>/2022/07/09/RTR/TAA/</url>
      
        <content type="html"><![CDATA[<h1 id="Temporal-Anti-Aliasing"><a href="#Temporal-Anti-Aliasing" class="headerlink" title="Temporal Anti-Aliasing"></a>Temporal Anti-Aliasing</h1><p>这里主要根据论文和Unity HDRP的TAA算法进行简单的分析。</p><p>资料主要参考的是 <strong>2016 Temporal Reprojection AA INSIDE</strong>.</p><p>源代码主要来自Unity的两个shader文件：</p><p>TemporalAntiliasing.hlsl和TemporalAntialising.compute.</p><p>下面是TAA在INSIDE当中的效果比较：</p><p><img src="/../../images/img/TAACompare.jpg" alt="TAACompare"></p><h2 id="基础思路"><a href="#基础思路" class="headerlink" title="基础思路"></a>基础思路</h2><p>下面是TAA依赖的一些基本思路：</p><ol><li>一个表面的局部区域可能在视口当中存在很多帧。</li><li>观察者和物体的位置在变，光栅化结果也在变化。</li><li>如果能够向前获取一段时间的变化，那么可以根据变化调整当前帧的光栅化结果。</li></ol><p>记录之前的变化：</p><ol><li>为了根据之前几帧的结果调整当前帧。</li><li>能够通过reprojection获得之前的变化：依赖于深度，局限在最新写入的几帧。</li><li>有时会获取不到之前的结果（前几帧没有出现过）。</li></ol><h2 id="unity算法步骤"><a href="#unity算法步骤" class="headerlink" title="unity算法步骤"></a>unity算法步骤</h2><h3 id="Step1：Jitter"><a href="#Step1：Jitter" class="headerlink" title="Step1：Jitter"></a>Step1：Jitter</h3><p>在TAA算法当中，Jitter的作用实际上就是<strong>采样屏幕颜色的时候</strong>，对纹理坐标做一个offset。使得：实际采样的位置在目标位置附近伴随时间随机的变化。</p><p>在很多地方Jitter的这个offset使用了：<a href="https://en.wikipedia.org/wiki/Halton_sequence">Halton Sequence</a>。</p><p>下面是一维度Halton Sequence的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> <span class="hljs-title function_">HS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> b)</span> :<br><span class="hljs-type">float</span> f = <span class="hljs-number">1</span><br>    <span class="hljs-type">float</span> r = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">do</span><br>        f = f/b<br>        r = r + f * (i mod b)<br>        i = <span class="hljs-built_in">floor</span>(i/b)<br>    <span class="hljs-keyword">return</span> r<br>    <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">HS(1,2) = 1 / 2  HS(2,2) = 1 / 4  HS(3,2) = 3 / 4  ...</span><br><span class="hljs-comment">HS(1,3) = 1 / 3  HS(2,3) = 2 / 3  HS(3,3) = 1 / 9  ...</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>下面是2维Halton的分布：</p><p><img src="/../../images/img/halton.jpg" alt="halton"></p><p>上面的点集为：</p><p>(HS(1,2), HS(1,3) )   ，(HS(2,2), HS(2,3) )，(HS(3,2), HS(3,3) )，(HS(4,2), HS(4,3) )..</p><p>unity计算jitter的源代码，可以看出jitter如何被使用,TemporalAntialising.compute：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">...   <br>jitter = _TaaJitterStrength.zw;<br>...<br><span class="hljs-comment">// 这里是Unjitter,去掉了jitter，positionNDC是jitter</span><br>uv = posInputs.positionNDC - jitter;<br>color = Fetch(_InputTexture, uv, <span class="hljs-number">0.0</span>, _ScreenToTargetScale.xy);<br>...<br></code></pre></td></tr></table></figure><p>_TaaJitterStrength在C#代码中的设置位置，HDCamera.cs:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>cmd.SetGlobalVector(HDShaderIDs._TaaJitterStrength,         taaJitter);<br>...<br></code></pre></td></tr></table></figure><p>计算方式，HDCamera.cs:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br><span class="hljs-type">float</span> jitterX = HaltonSequence.Get((taaFrameIndex &amp; <span class="hljs-number">1023</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) - <span class="hljs-number">0.5f</span>;<br><span class="hljs-type">float</span> jitterY = HaltonSequence.Get((taaFrameIndex &amp; <span class="hljs-number">1023</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">3</span>) - <span class="hljs-number">0.5f</span>;<br>taaJitter = new Vector4(jitterX, jitterY, jitterX / camera.pixelWidth, jitterY / camera.pixelHeight);<br>...<br></code></pre></td></tr></table></figure><p>上面内容都属于HDCamera当中的一个重要的方法，就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c">Matrix4x4 <span class="hljs-title function_">GetJitteredProjectionMatrix</span><span class="hljs-params">(Matrix4x4 origProj)</span><br>&#123;<br>    <span class="hljs-type">float</span> jitterX = HaltonSequence.Get((taaFrameIndex &amp; <span class="hljs-number">1023</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) - <span class="hljs-number">0.5f</span>;<br>    <span class="hljs-type">float</span> jitterY = HaltonSequence.Get((taaFrameIndex &amp; <span class="hljs-number">1023</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">3</span>) - <span class="hljs-number">0.5f</span>;<br>    taaJitter = new Vector4(jitterX, jitterY, jitterX / camera.pixelWidth, jitterY / camera.pixelHeight);<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> kMaxSampleCount = <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">// taaFrameIndex 只在这里更新，kMaxSampleCount是8.</span><br>    <span class="hljs-keyword">if</span> (++taaFrameIndex &gt;= kMaxSampleCount)<br>        taaFrameIndex = <span class="hljs-number">0</span>;<br><br>    Matrix4x4 proj;<br><br>    <span class="hljs-keyword">if</span> (camera.orthographic)<br>    &#123;<br>        ...<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 得到多个分离的剪裁平面</span><br>        var planes = origProj.decomposeProjection;<br><br>        <span class="hljs-comment">// 计算观察范围</span><br>        <span class="hljs-type">float</span> vertFov = Math.Abs(planes.top) + Math.Abs(planes.bottom);<br>        <span class="hljs-type">float</span> horizFov = Math.Abs(planes.left) + Math.Abs(planes.right);<br><br>        <span class="hljs-comment">// 按比例缩放</span><br>        var planeJitter = new Vector2(jitterX * horizFov / camera.pixelWidth,<br>                                      jitterY * vertFov / camera.pixelHeight);<br><br>        <span class="hljs-comment">// 抖动平移整个视锥体</span><br>        planes.left += planeJitter.x;<br>        planes.right += planeJitter.x;<br>        planes.top += planeJitter.y;<br>        planes.bottom += planeJitter.y;<br><span class="hljs-comment">// 还原成投影矩阵</span><br>        proj = Matrix4x4.Frustum(planes);<br>    &#125;<br>    <span class="hljs-keyword">return</span> proj;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Matrix4x4.Frustum(planes)：</span><br><span class="hljs-comment">下面查看这个函数意义：</span><br><span class="hljs-comment">https://docs.unity3d.com/ScriptReference/Matrix4x4.Frustum.html</span><br><span class="hljs-comment">The coordinate of the near projection plane in view space.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>上面的方法主要是通过抖动近剪裁面来实现对整个视锥体的抖动。</strong></p><p>唯一对他的调用是下面的方法，这个方法主要用来更新摄像机的： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">internal <span class="hljs-type">void</span> <span class="hljs-title function_">UpdateViewConstants</span><span class="hljs-params">(<span class="hljs-type">bool</span> jitterProjectionMatrix)</span><br>&#123;<br>    <span class="hljs-comment">// If TAA is enabled projMatrix will hold a jittered projection matrix. The original,</span><br>    <span class="hljs-comment">// non-jittered projection matrix can be accessed via nonJitteredProjMatrix.</span><br>    var nonJitteredCameraProj = camera.projectionMatrix;<br>    var cameraProj = jitterProjectionMatrix<br>        ? GetJitteredProjectionMatrix(nonJitteredCameraProj)<br>        : nonJitteredCameraProj;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>制作后处理的时候关闭,HDRenderPipeline.cs:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">using (new ProfilingSample(cmd, <span class="hljs-string">&quot;After Post-process&quot;</span>, CustomSamplerId.AfterPostProcessing.GetSampler()))<br>&#123;<br>    <span class="hljs-comment">// Note about AfterPostProcess and TAA:</span><br>    <span class="hljs-comment">// When TAA is enabled rendering is jittered and then resolved during the post processing pass.</span><br>    <span class="hljs-comment">// It means that any rendering done after post processing need to disable jittering. This is what we do with hdCamera.UpdateViewConstants(false);</span><br>    <span class="hljs-comment">// The issue is that the only available depth buffer is jittered so pixels would wobble around depth tested edges.</span><br>    <span class="hljs-comment">// In order to avoid that we decide that objects rendered after Post processes while TAA is active will not benefit from the depth buffer so we disable it.</span><br>    <span class="hljs-type">bool</span> taaEnabled = hdCamera.IsTAAEnabled();<br>    hdCamera.UpdateViewConstants(<span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>绘制物体的时候开启,HDCamera.cs:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Pass all the systems that may want to update per-camera data here.</span><br><span class="hljs-comment">// That way you will never update an HDCamera and forget to update the dependent system.</span><br>public <span class="hljs-type">void</span> <span class="hljs-title function_">Update</span><span class="hljs-params">(FrameSettings currentFrameSettings, VolumetricLightingSystem vlSys, MSAASamples msaaSamples)</span><br>&#123;<br>    UpdateViewConstants(IsTAAEnabled());<br></code></pre></td></tr></table></figure><p>到此为止Jitter步骤结束，总结如下：</p><p><img src="/../../images/img/step1jitter.jpg" alt="step1jitter"></p><h3 id="Step2：-ReProjection"><a href="#Step2：-ReProjection" class="headerlink" title="Step2： ReProjection"></a>Step2： ReProjection</h3><p>Reprojection就是讲当前jitter的点还原到历史点的位置。</p><h4 id="动态场景历史点还原"><a href="#动态场景历史点还原" class="headerlink" title="动态场景历史点还原"></a>动态场景历史点还原</h4><p>示意图如下：</p><p>首先获取到了当前帧当前点的屏幕uv。</p><p><img src="/../../images/img/preprojection1.jpg" alt="preprojection1"></p><p>在视锥体中的示意图：</p><p><img src="/../../images/img/preprojection2.jpg" alt="preprojection2"></p><p>然后通过当前帧当前点的深度图还原其世界坐标：</p><p><img src="/../../images/img/preprojection3.jpg" alt="preprojection3"></p><p>然后通过记录的上一个摄像机机位的变换矩阵，还原当前点在上一帧的所在屏幕位置。</p><p><img src="/../../images/img/preprojection4.jpg" alt="preprojection4"></p><p>然后就可以在上一帧的colorbuffer采样上一帧的颜色：</p><p><img src="/../../images/img/preprojection5.jpg" alt="preprojection5"></p><h4 id="动态场景历史点还原-1"><a href="#动态场景历史点还原-1" class="headerlink" title="动态场景历史点还原"></a>动态场景历史点还原</h4><p>动态物体可以渲染velocity buffer，记录了其在屏幕上移动的向量：</p><p>通过减去速度可以恢复到上一帧的位置：</p><p><img src="/../../images/img/preprojection6.jpg" alt="preprojection6"></p><p><strong>VelocityBuffer一般是先通过摄像机运动计算场景中静态物体的运动速度，然后在上面继续绘制动态物体的运动速度</strong></p><p>Unity读取历史信息的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>float2 motionVector;<br>DecodeMotionVector(LOAD_TEXTURE2D_X(_CameraMotionVectorsTexture, closest), motionVector);<br>float3 history = Fetch(_InputHistoryTexture, posInputs.positionNDC - motionVector, <span class="hljs-number">0.0</span>, _ScreenToTargetScaleHistory.xy);<br>...<br></code></pre></td></tr></table></figure><p><strong>上面可以看出unity的TAA依赖于VelocityBuffer的绘制。</strong></p><h3 id="Step3-Revisiting"><a href="#Step3-Revisiting" class="headerlink" title="Step3:  Revisiting"></a>Step3:  Revisiting</h3><p>上一步当中我们已经读取到了历史信息位置，那么现在就需要在历史纹理当中读取信息并且用于计算。</p><p><img src="/../../images/img/Revisiting1.jpg" alt="Revisiting1"></p><p>首先需要解决的是历史信息不正确的状态。</p><p>通过当前像素来控制历史信息的最大最小值，下面是Unity的做法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">...<br>float2 uv = posInputs.positionNDC - jitter;<br><br> float3 color = Fetch(_InputTexture, uv, 0.0, _ScreenToTargetScale.xy);<br> float3 history = Fetch(_InputHistoryTexture, posInputs.positionNDC - motionVector, 0.0, _ScreenToTargetScaleHistory.xy);<br><br> float3 topLeft = Fetch(_InputTexture, uv, -RADIUS, _ScreenToTargetScale.xy);<br> float3 bottomRight = Fetch(_InputTexture, uv, RADIUS, _ScreenToTargetScale.xy);<br><br> float3 corners = 4.0 * (topLeft + bottomRight) - 2.0 * color;<br><br> // Sharpen output<br> #if SHARPEN<br> float3 topRight = Fetch(_InputTexture, uv, float2(RADIUS, -RADIUS), _ScreenToTargetScale.xy);<br> float3 bottomLeft = Fetch(_InputTexture, uv, float2(-RADIUS, RADIUS), _ScreenToTargetScale.xy);<br> float3 blur = (topLeft + topRight + bottomLeft + bottomRight) * 0.25;<br> color += (color - blur) * SHARPEN_STRENGTH;<br> #endif<br> <br> color = clamp(color, 0.0, CLAMP_MAX);<br><br> float3 average = Map((corners + color) / 7.0);<br><br> topLeft = Map(topLeft);<br> bottomRight = Map(bottomRight);<br> color = Map(color);<br><br> float colorLuma = Luminance(color);<br> float averageLuma = Luminance(average);<br> float nudge = lerp(4.0, 0.25, saturate(motionVecLength * 100.0)) * abs(averageLuma - colorLuma);<br><br> float3 minimum = min(bottomRight, topLeft) - nudge;<br> float3 maximum = max(topLeft, bottomRight) + nudge;<br><br> history = Map(history);<br><br> // Clip history samples<br> #if CLIP_AABB<br> history = ClipToAABB(history, minimum, maximum);<br> #else<br> history = clamp(history, minimum, maximum);<br> #endif<br> ...<br></code></pre></td></tr></table></figure><p>下面进行TAA的核心操作：</p><p><img src="/../../images/img/Revisiting2.jpg" alt="Revisiting2"></p><p>进行颜色混合：<strong>经过约束的历史颜色和没有抖动的当前颜色</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">c_hist = ...<span class="hljs-comment">//constrained history sample</span><br>c_in = sample(buf_color, unjitter_uv);<br>c_feedback = lerp(c_in, c_hist, k_feedback);<br></code></pre></td></tr></table></figure><p>保留当前结果作为历史，并输出当前结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">rt_history = c_feedback<br>rt_output = rt_history<br></code></pre></td></tr></table></figure><p>k_feedback可以调整效果。</p><p>Unity 中的TAA是自动的来计算feedback值，TemporalAntialiasing.compute:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br><span class="hljs-type">float</span> historyLuma = Luminance(history);<br><span class="hljs-type">float</span> diff = <span class="hljs-built_in">abs</span>(colorLuma - historyLuma) / Max3(colorLuma, historyLuma, <span class="hljs-number">0.2</span>);<br><span class="hljs-type">float</span> weight = <span class="hljs-number">1.0</span> - diff;<br><span class="hljs-type">float</span> feedback = lerp(FEEDBACK_MIN, FEEDBACK_MAX, weight * weight);<br>...<br></code></pre></td></tr></table></figure><p>Unity在计算之后，还会再次Clamp颜色：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>color = Unmap(lerp(color, history, feedback));<br>color = clamp(color, <span class="hljs-number">0.0</span>, CLAMP_MAX);<br>...<br></code></pre></td></tr></table></figure><p>然后是结果输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>_OutputTexture[COORD_TEXTURE2D_X(posInputs.positionSS)] = float4(color.xyz, <span class="hljs-number">1.0</span>);<br>_OutputHistoryTexture[COORD_TEXTURE2D_X(posInputs.positionSS)] = float4(color.xyz, <span class="hljs-number">1.0</span>);<br>...<br></code></pre></td></tr></table></figure><p>到此为止TAA就结束了，不过还可以加入MotionBlur，Unity没有加到TAA步骤当中，这个打算之后在研究。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <strong>2016 Temporal Reprojection AA INSIDE</strong>.</p><p>[2] Unity HDRP TAA 源代码：TemporalAntialising.compute.</p>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不同图形API剪裁空间说明</title>
      <link href="/2022/07/09/RTR/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/"/>
      <url>/2022/07/09/RTR/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="不同图形API剪裁空间说明"><a href="#不同图形API剪裁空间说明" class="headerlink" title="不同图形API剪裁空间说明"></a>不同图形API剪裁空间说明</h1><h2 id="D3D剪裁空间"><a href="#D3D剪裁空间" class="headerlink" title="D3D剪裁空间"></a>D3D剪裁空间</h2><p><a href="https://docs.microsoft.com/en-us/windows/win32/dxtecharts/the-direct3d-transformation-pipeline">官方链接</a></p><p>整体流程：</p><p><img src="/../../images/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/d3dxfrm61.gif" alt="model space to screen space transformation"></p><p>剪裁空间的矩阵是将摄像机空间的坐标转换到裁剪空间。剪裁空间矩阵最后一列最好是(0, 0, 1, 0)。</p><p>原文解释：The last column of the projection matrix should be (0, 0, 1, 0), or (0, 0, a, 0) for correct fog and lighting effects; (0, 0, 1, 0) form is preferred.</p><p>剪裁空间的坐标： (Xp, Yp, Zp, Wp)  ，剪裁的原则是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">-Wp &lt; Xp &lt;= Wp <br>  -Wp &lt; Yp &lt;= Wp <br>  <span class="hljs-number">0</span> &lt; Zp &lt;= Wp <br></code></pre></td></tr></table></figure><p>所有不满足上面的点都会被剪裁。</p><p>假设摄像机空间的坐标满足：</p><p>Sw - 近剪裁平面屏幕宽度</p><p>Sh - 近剪裁平面屏幕高度</p><p>Zn - 近剪裁平面距离</p><p>Zf -  远剪裁平面距离</p><p><img src="/../../images/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/1575083272973.png" alt="1575083272973"></p><p>透视投影矩阵如下：</p><p><img src="/../../images/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/d3dxfrm62.gif" alt="perspective projection matrix"></p><p>Direct3D假设投影矩阵满足下面的形式，如果不满足会有一些不自然效果：</p><p><img src="/../../images/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/d3dxfrm64.gif" alt="perspective projection matrix"></p><p>Direct3D允许修改剪裁体以达到更高的精确度，这部分实际上就是对Proj空间进行变换得到Clip空间，实际上Proj就是Clip：</p><p><img src="/../../images/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/d3dxfrm67.gif" alt="mclip matrix"></p><p>默认参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">dvClipWidth = <span class="hljs-number">2</span>   <br>dvClipHeight = <span class="hljs-number">2</span>   <br>dvClipX = <span class="hljs-number">-1</span>   <br>dvClipY = <span class="hljs-number">1</span>   <br>dvMinZ = <span class="hljs-number">0</span>   <br>dvMaxZ = <span class="hljs-number">1</span>   <br></code></pre></td></tr></table></figure><p>从投影到剪裁空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(Xc, Yc, Zc, Wc) = (Xp, Yp, Zp, Wp) * Mclip<br></code></pre></td></tr></table></figure><p>视口缩放矩阵会把坐标缩放到窗口坐标中，并且把Y轴上下翻转。</p><p><img src="/../../images/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/d3dxfrm68.gif" alt="viewport scale matrix mvs"></p><p> dwX, dwY - 视口的像素偏移。</p><p> dwWidth, dwHeight视口的像素宽高。</p><p>最终的屏幕坐标是：</p><p><img src="/../../images/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/d3dxfrm69.gif" alt="screen coordinates computed and passed to the rasterizer"></p><p>注意：在D3D当中PS的输入语义SV_POSITION是屏幕坐标。而输出语义SV_POSITION的投影空间对应Glsl的<strong>gl_FragCoord</strong>。而Unity当中的SV_Position就是VS的输出。</p><h2 id="OpengGL"><a href="#OpengGL" class="headerlink" title="OpengGL"></a>OpengGL</h2><p><a href="https://learnopengl.com/Getting-started/Coordinate-Systems">官方文档</a></p><p>OpenGl是投影空间提供剪裁范围：The projection matrix maps a given frustum range to clip space, but also manipulates the <code>w</code> value of each vertex coordinate in such a way that the further away a vertex coordinate is from the viewer, the higher this <code>w</code> component becomes.</p><p>越远w的值越大。剪裁范围是-w 和w之间,z坐标和D3D是有区别的 :Once the coordinates are transformed to clip space they are in the range <code>-w</code> to <code>w</code> (anything outside this range is clipped). </p><p>OpenGL requires that the visible coordinates fall between the range <code>-1.0</code> and <code>1.0</code> as the final vertex shader output, thus once the coordinates are in clip space, perspective division is applied to the clip space coordinates:</p><p>剪裁之后的结果进行透视除法。</p><p><img src="/../../images/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/1575085853893.png" alt="1575085853893"></p>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>体积云光照部分相关理论</title>
      <link href="/2022/07/09/RTR/%E4%BD%93%E7%A7%AF%E4%BA%91/"/>
      <url>/2022/07/09/RTR/%E4%BD%93%E7%A7%AF%E4%BA%91/</url>
      
        <content type="html"><![CDATA[<h1 id="体积云光照部分相关理论"><a href="#体积云光照部分相关理论" class="headerlink" title="体积云光照部分相关理论"></a>体积云光照部分相关理论</h1><p>阅读GPU Pro6当中的第4章体积云，主要为了记录其中和光相关的理论。《Real-Time Rendering  of Physical Based Clouds Using Precomputed Scattering》</p><p>这篇文章主要提出了一种refrence Particle。通过缩放和旋转同一个粒子得到云。云可以有动画。</p><p>在与计算部分, 计算光学深度已经单个和多个的散射积分，用来描述光在rp当中的传递，描述了所有可能的摄像机位置和观察方向，并且存储在查找表当中。</p><p>原文：</p><p>we precompute optical depth as well as single and multiple scattering integrals describing the light transport in the reference particle for all possible camera positions and<br>view directions and store the results in lookup tables. </p><p>在运行阶段，加载查找表，来估计光线在云当中的传递节省ray marching和slicing的开销。</p><p>主要原理来源于[Yusov 14b] </p><p>改进方案包括：</p><p>1.改进基于与计算查找表的着色模型。</p><p>2.使用3D网格来改进光线在云内部传递的衰减算分。</p><p>3.新的粒子生成算法</p><p>4.性能优化，包括给予GPU的粒子排序。</p><h2 id="Light-Transport-Theory"><a href="#Light-Transport-Theory" class="headerlink" title="Light Transport Theory"></a>Light Transport Theory</h2><p>这里介绍光线在粒子中传递的概念。</p><p>参考：More information can be found in [Riley et al. 04,Bouthors 08] </p><p>光在粒子当中有三个现象：</p><ol><li>散射：改变粒子在介质中传播方向。</li><li>吸收：光子能量转换成了其他形式</li><li>发光：与吸收相反。</li></ol><p>上述过程可以用Sc ，Ab，Em三个系数来描述。吸收散射 都是减少了光在介质中的强度。</p><p>消减系数：$$ Ex &#x3D; Ab + Sc $$。</p><p>在云内部 发散和吸收可以忽略 ： $$Em &#x3D; Ab &#x3D; 0$$, 所以散射和吸收可以用同一个系数描述：$$ Sc  &#x3D; Ex &#x3D; B $$</p><p> 光线在云内部，从A点到B点的衰减系数可以用下方公式描述:</p><p>$$ e^{-\tau(A,B)}$$</p><p>$ -\tau(A,B) $ 表示光学深度，是从A点到B点消散系数B的积分。</p><p>$$ -\tau(A,B) &#x3D;  \sum^A_B{\beta(P)ds}$$</p><p>$$ P&#x3D;A+\frac{B-A}{|{B-A}|}  $$<br>s表示当前积分的点。</p><p>为了知道一个散射光的强度，我们需要沿着视线积累太阳光在每一个点上朝摄像机散射的所有分量。</p><p>参数解释$C$表示摄像机位置，$\vec v$表示视线方向，$P_0$和$P_1$表示视线进入和离开云的位置，$P$表示某个散射位置的点，$Q$是光线到达散射位置的太阳光进入云的点。$L_{sun}$表示太阳光强度，$P(\theta)$表示入射方向到出射方向光损失的百分比。削减一共有两部分P到P0和Q到P.</p><p>上面描述的只是一个点。</p><p>同时P的近似函数：</p><p>$$ P(\theta) &#x3D; \frac{1}{4PI}\frac{3(1-g^2)}{2(2+g^2)}\frac{(1 + cos^2(\theta))}{(1+g^2-2gcos(\theta))^{\frac{3}{2}}} $$</p><p>把所有光线夹起来就是最终结果:</p><p>$$L^n_{In}(C,\vec v)&#x3D;\int_{P0}^{P1}J^{(n)}(P,\vec v)e^{-\tau(P,P0)}ds$$</p><p>其中$J^{(n)}$ 表示各个方向每个点想实现方向散射的强度。</p><h2 id="Precompute-Solutions"><a href="#Precompute-Solutions" class="headerlink" title="Precompute Solutions"></a>Precompute Solutions</h2><p>后面的部分用处不大，以后再研究。</p>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>主机渲染和优化技术概要</title>
      <link href="/2022/07/09/RTR/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/"/>
      <url>/2022/07/09/RTR/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h1 id="主机渲染和优化技术概要"><a href="#主机渲染和优化技术概要" class="headerlink" title="主机渲染和优化技术概要"></a>主机渲染和优化技术概要</h1><!-- TOC --><br/><br/>- [主机渲染和优化技术概要](#主机渲染和优化技术概要)<br/>    - [1. 渲染流程](#1-渲染流程)<br/>        - [1.1. RenderPipeline](#11-renderpipeline)<br/>        - [1.2. 渲染参数](#12-渲染参数)<br/>        - [1.3. 常用光照模型](#13-常用光照模型)<br/>        - [1.4. 基础光照计算](#14-基础光照计算)<br/>            - [1.4.1. D项 ：GGX (Trowbridge-Reitz)](#141-d项-ggx-trowbridge-reitz)<br/>            - [1.4.2. G项：Schlick](#142-g项schlick)<br/>            - [1.4.3. F项：Schlick’s approximation](#143-f项schlicks-approximation)<br/>            - [1.4.4. IBL](#144-ibl)<br/>        - [1.5. 光照技术](#15-光照技术)<br/>            - [1.5.1. multipass forward](#151-multipass-forward)<br/>            - [1.5.2. multipass deferred](#152-multipass-deferred)<br/>            - [1.5.3. singlepass deferred](#153-singlepass-deferred)<br/>            - [1.5.4. Tiled-based  Shading](#154-tiled-based--shading)<br/>            - [1.5.5. Clustered Shading](#155-clustered-shading)<br/>            - [1.5.6. 效果对比](#156-效果对比)<br/>    - [2. 渲染技术](#2-渲染技术)<br/>        - [2.1. 基础材质](#21-基础材质)<br/>        - [2.2. 分层细节材质](#22-分层细节材质)<br/>        - [2.3. 分层材质系统](#23-分层材质系统)<br/>        - [2.4. 材质库系统](#24-材质库系统)<br/>        - [2.5. 特效材质](#25-特效材质)<br/>        - [2.6. 屏幕空间技术](#26-屏幕空间技术)<br/>            - [2.6.1. 主要涉及到屏幕空间的Ray Trace操作。](#261-主要涉及到屏幕空间的ray-trace操作)<br/>            - [2.6.2. Screen Space Contact Shadow](#262-screen-space-contact-shadow)<br/>            - [2.6.3. Screen Space Reflections](#263-screen-space-reflections)<br/>        - [2.7. 毛发](#27-毛发)<br/>            - [2.7.1. hairworks or TressFX：](#271-hairworks-or-tressfx)<br/>        - [2.8. 灯光方案](#28-灯光方案)<br/>        - [2.9. 阴影方案](#29-阴影方案)<br/>            - [2.9.1. 巫师3的CSM](#291-巫师3的csm)<br/>            - [2.9.2. 阴影代理](#292-阴影代理)<br/>        - [2.10. LOD方案](#210-lod方案)<br/>        - [2.11. 后处理：曝光与光照设定](#211-后处理曝光与光照设定)<br/>        - [2.12. 透明物体低分辨率渲染](#212-透明物体低分辨率渲染)<br/>        - [2.13. 后处理：HDR and ToneMapping](#213-后处理hdr-and-tonemapping)<br/>        - [2.14. 后处理：TAA](#214-后处理taa)<br/>    - [3. GPU架构](#3-gpu架构)<br/>        - [3.1. GPU存储架构](#31-gpu存储架构)<br/>        - [3.2. GPU渲染架构](#32-gpu渲染架构)<br/>            - [3.2.1. 存储和计算的关系](#321-存储和计算的关系)<br/>            - [3.2.2. Wrap与Wave Front](#322-wrap与wave-front)<br/>        - [3.3. 手游架构](#33-手游架构)<br/>    - [4. 程序优化性能关注的点](#4-程序优化性能关注的点)<br/>        - [4.1. Draw Call](#41-draw-call)<br/>        - [4.2. Early - z](#42-early---z)<br/>        - [4.3. Over Draw](#43-over-draw)<br/>        - [4.4. Quad OverDraw](#44-quad-overdraw)<br/>        - [4.5. Light](#45-light)<br/>        - [4.6. Vertex Count](#46-vertex-count)<br/>        - [4.7. Texture压缩与内存优化](#47-texture压缩与内存优化)<br/>        - [4.8. Baking](#48-baking)<br/>        - [4.9. MipMap](#49-mipmap)<br/>        - [4.10. Testure Streaming](#410-testure-streaming)<br/>        - [4.11. Shader预加载](#411-shader预加载)<br/>        - [4.12. Shader分支](#412-shader分支)<br/>    - [5. 美术资源可能带来的性能问题](#5-美术资源可能带来的性能问题)<br/>        - [5.1. 游戏性能瓶颈：模型](#51-游戏性能瓶颈模型)<br/>        - [5.2. 游戏性能优化：模型](#52-游戏性能优化模型)<br/>        - [5.3. 游戏性能瓶颈：贴图](#53-游戏性能瓶颈贴图)<br/>        - [5.4. 游戏性能优化：贴图](#54-游戏性能优化贴图)<br/>        - [5.5. 游戏性能瓶颈：材质](#55-游戏性能瓶颈材质)<br/>        - [5.6. 游戏性能优化：材质](#56-游戏性能优化材质)<br/>        - [5.7. 游戏性能瓶颈：Quad OverDraw 、OverDraw](#57-游戏性能瓶颈quad-overdraw-overdraw)<br/>        - [5.8. 游戏性能优化：Quad OverDraw 、OverDraw](#58-游戏性能优化quad-overdraw-overdraw)<br/><br/><!-- /TOC --><h2 id="1-渲染流程"><a href="#1-渲染流程" class="headerlink" title="1. 渲染流程"></a>1. 渲染流程</h2><h3 id="1-1-RenderPipeline"><a href="#1-1-RenderPipeline" class="headerlink" title="1.1. RenderPipeline"></a>1.1. RenderPipeline</h3><p>基础渲染流程。</p><p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961718383.png" alt="1568961718383"></p><p><img src="/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961632451.png" alt="1568961632451"></p><p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961793802.png" alt="1568961793802"></p><p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961811084.png" alt="1568961811084"></p><p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961840796.png" alt="1568961840796"></p><p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961874770.png" alt="1568961874770"></p><p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961884019.png" alt="1568961884019"></p><h3 id="1-2-渲染参数"><a href="#1-2-渲染参数" class="headerlink" title="1.2. 渲染参数"></a>1.2. 渲染参数</h3><p>Unity HDRP Deferred结构</p><table><thead><tr><th>G-Buffer Usage</th><th>Format</th><th>RGB</th><th>A</th></tr></thead><tbody><tr><td>GBuffer0</td><td>RGBA32</td><td>Albedo Color &#x2F;      SSS Color</td><td>Spacular Occlusiion &#x2F; SSS Parameter</td></tr><tr><td>GBuffer1</td><td>RGBA32</td><td>Packed Normal</td><td>Roughness</td></tr><tr><td>GBuffer2</td><td>RGBA32</td><td>BSDF Model Specific Parameters</td><td>Coat Mask + Material ID</td></tr><tr><td>GBuffer3</td><td>R11G11B10</td><td>GI + Emissive</td><td>&#x2F;</td></tr><tr><td>GBuffer4 - Optional</td><td>RGBA32</td><td>R:&#x2F;             G:&#x2F;             B: AO</td><td>Light Layer</td></tr><tr><td>GBuffer5 - Optional</td><td>RGBA32</td><td>shadowmask0 - 2</td><td>shadowmask3</td></tr></tbody></table><h3 id="1-3-常用光照模型"><a href="#1-3-常用光照模型" class="headerlink" title="1.3. 常用光照模型"></a>1.3. 常用光照模型</h3><table><thead><tr><th>Clear Coat</th><th>车漆效果</th></tr></thead><tbody><tr><td>Specular</td><td>这个是和Standard（金属工作流）相对的高光工作流。区别只是金属度变成了高光颜色。其他计算没有区别。指定F0。</td></tr><tr><td>Anisotropy</td><td>计算高光时使用各项异性的高光计算。和Standard区别只在于高光的计算，同时多出了一张各向异性贴图和强度控制。例如：拉丝金属。</td></tr><tr><td>Iridescence</td><td>彩虹色是指：随着光照角度的变化光照颜色发生变化。例如：肥皂泡沫，昆虫翅膀。</td></tr><tr><td>Translucent</td><td>透光效果是指：在背光面可以看到光穿过物体的效果。主要用于半透明材质。例如：树叶。</td></tr><tr><td>Surface Scattering</td><td>SSS效果用来描述光线在表面多次散射的效果。可以用来描述灯光和半透物体的交互过程。可以用来制作：玉、冰、皮肤等物体。</td></tr><tr><td>Displacement</td><td>Unity支持高度图计算。Vertex Displacement:  在Vertex阶段直接移动顶点，高度图作为移动距离。Pixel displacement： 将高度图作为视差贴图。（POM）</td></tr><tr><td>Standard</td><td>标准材质</td></tr></tbody></table><h3 id="1-4-基础光照计算"><a href="#1-4-基础光照计算" class="headerlink" title="1.4. 基础光照计算"></a>1.4. 基础光照计算</h3><p>漫反射：</p><p>$$ f(l,v) &#x3D; \frac{c_{diff}}{\pi} $$</p><p>高光：</p><p>$$ f(l,v) &#x3D; \frac{D(h)G(l,v,h)F(v,h)}{4(nl)(nv)} $$</p><h4 id="1-4-1-D项-：GGX-Trowbridge-Reitz"><a href="#1-4-1-D项-：GGX-Trowbridge-Reitz" class="headerlink" title="1.4.1. D项 ：GGX (Trowbridge-Reitz)"></a>1.4.1. D项 ：GGX (Trowbridge-Reitz)</h4><p>$$ \alpha &#x3D; roughness^2 $$</p><p>$$ D_{GGX}(h)&#x3D;\frac{\alpha^2}{\pi((nh)^2(\alpha^2-1)+1)^2} $$</p><h4 id="1-4-2-G项：Schlick"><a href="#1-4-2-G项：Schlick" class="headerlink" title="1.4.2. G项：Schlick"></a>1.4.2. G项：Schlick</h4><p>Schlick-GGX（用在IBL上）</p><p>$$k &#x3D;\frac{\alpha} {2}$$  </p><p>$$ \alpha &#x3D; roughness^2 $$</p><p>根据Disney文章对其做了修改（这个修改只用在解析光源上，IBL在glancing angles会太暗）：</p><p>$$k &#x3D;\frac{(roughness + 1)^2} {8}$$  </p><p>$$ G_{GGX}(v) &#x3D; \frac{nv}{(nv)(1-k)+k} $$</p><h4 id="1-4-3-F项：Schlick’s-approximation"><a href="#1-4-3-F项：Schlick’s-approximation" class="headerlink" title="1.4.3. F项：Schlick’s approximation"></a>1.4.3. F项：Schlick’s approximation</h4><p>$$ F(v,h)&#x3D;F_0 + (1 - F_0) 2^{-5.55473(vh)-6.98316)(vh)} $$</p><h4 id="1-4-4-IBL"><a href="#1-4-4-IBL" class="headerlink" title="1.4.4. IBL"></a>1.4.4. IBL</h4><p>首先需要解决的是辐射度积分，通常使用重要度采样：</p><p>$$ \int_H L_i(l)f(l,v)cos(\theta_l)dl  &#x3D; \frac{1}{N}\sum^{N}_{k&#x3D;1}\frac{L_i(l_k)f(l_k,v)cos theta _{l_k} }{p(l_k,v)} $$</p><h3 id="1-5-光照技术"><a href="#1-5-光照技术" class="headerlink" title="1.5. 光照技术"></a>1.5. 光照技术</h3><h4 id="1-5-1-multipass-forward"><a href="#1-5-1-multipass-forward" class="headerlink" title="1.5.1. multipass forward"></a>1.5.1. multipass forward</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Shaders:</span><br>Shader simpleShader<br><br><span class="hljs-comment">//Buffers:</span><br>Buffer display<br><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">for</span> light in scene<br>        display += simpleShader(mesh, light)<br></code></pre></td></tr></table></figure><h4 id="1-5-2-multipass-deferred"><a href="#1-5-2-multipass-deferred" class="headerlink" title="1.5.2. multipass deferred"></a>1.5.2. multipass deferred</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Buffers:</span><br>Buffer display<br>Buffer GBuffer <br><br><span class="hljs-comment">//Shaders:</span><br>Shader simpleShader<br>Shader writeShadingAttributes<br><br><span class="hljs-comment">//Visibility &amp; materials</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth &lt; GBuffer.depth<br>       GBuffer = writeShadingAttributes(mesh)<br><br><span class="hljs-comment">//Shading &amp; lighting - Multi-pass</span><br><span class="hljs-keyword">for</span> light in scene<br>    display += simpleShader(GBuffer, light)<br></code></pre></td></tr></table></figure><h4 id="1-5-3-singlepass-deferred"><a href="#1-5-3-singlepass-deferred" class="headerlink" title="1.5.3. singlepass deferred"></a>1.5.3. singlepass deferred</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Buffers:</span><br>Buffer display<br>Buffer GBuffer <br><br><span class="hljs-comment">//Shaders:</span><br>Shader manyLightShader<br>Shader writeShadingAttributes<br><br><span class="hljs-comment">//Visibility &amp; materials</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth &lt; GBuffer.depth<br>       GBuffer = writeShadingAttributes(mesh)<br><br><span class="hljs-comment">//Shading &amp; lighting - Single-pass</span><br>display = manyLightShader(GBuffer, scene.lights)<br></code></pre></td></tr></table></figure><h4 id="1-5-4-Tiled-based-Shading"><a href="#1-5-4-Tiled-based-Shading" class="headerlink" title="1.5.4. Tiled-based  Shading"></a>1.5.4. Tiled-based  Shading</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569236801768.png" alt="1569236801768"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">Buffer display<br>Buffer GBuffer <br>Buffer tileArray<br><br><span class="hljs-comment">//Shaders:</span><br>Shader manyLightShader<br>Shader writeShadingAttributes<br>CompShader lightInTile<br><br><span class="hljs-comment">//Visibility &amp; materials</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth &lt; GBuffer.depth<br>       GBuffer = writeShadingAttributes(mesh)<br><br><span class="hljs-comment">//Light culling</span><br><span class="hljs-keyword">for</span> tile in tileArray<br>   <span class="hljs-keyword">for</span> light in scene<br>      <span class="hljs-keyword">if</span> lightInTile(tile, light)<br>          tile += light<br>      <br><span class="hljs-comment">//Shading</span><br>display = manyLightShader(GBuffer, tileArray)<br></code></pre></td></tr></table></figure><h4 id="1-5-5-Clustered-Shading"><a href="#1-5-5-Clustered-Shading" class="headerlink" title="1.5.5. Clustered Shading"></a>1.5.5. Clustered Shading</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569237072424.png" alt="1569237072424"></p><p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569237086038.png" alt="1569237086038"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Buffers:</span><br>Buffer display<br>Buffer GBuffer<br>Buffer clusterArray<br><br><span class="hljs-comment">//Shaders:</span><br>Shader manyLightShader<br>Shader writeShadingAttributes<br>CompShader lightInCluster <br><br><span class="hljs-comment">//Visibility &amp; materials</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth &lt; GBuffer.depth<br>       GBuffer = writeShadingAttributes(mesh)<br><br><span class="hljs-comment">//Light culling</span><br><span class="hljs-keyword">for</span> cluster in clusterArray<br>   <span class="hljs-keyword">for</span> light in scene<br>      <span class="hljs-keyword">if</span> lightIncluster(cluster, light)<br>          cluster += light<br><br><span class="hljs-comment">//Shading</span><br>display = manyLightShader(GBuffer, clusterArray)<br></code></pre></td></tr></table></figure><h4 id="1-5-6-效果对比"><a href="#1-5-6-效果对比" class="headerlink" title="1.5.6. 效果对比"></a>1.5.6. 效果对比</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569237135439.png" alt="1569237135439"></p><h2 id="2-渲染技术"><a href="#2-渲染技术" class="headerlink" title="2. 渲染技术"></a>2. 渲染技术</h2><h3 id="2-1-基础材质"><a href="#2-1-基础材质" class="headerlink" title="2.1. 基础材质"></a>2.1. 基础材质</h3><table><thead><tr><th align="left"><strong>Property</strong></th><th align="left"><strong>Description</strong></th></tr></thead><tbody><tr><td align="left"><strong>Albedo Map</strong></td><td align="left">表示物体颜色，不应该包含任何明暗、AO、阴影信息。除了基础颜色外，还可以包含一些偏色、或者色相的变化。</td></tr><tr><td align="left"><strong>Mask Map</strong></td><td align="left">Assign a Texture that packs different Material maps into each of its RGBA channels. • <strong>Red</strong>: Stores the metallic map.  • <strong>Green</strong>: Stores the ambient occlusion map. • <strong>Blue</strong>: Stores the detail mask map. • <strong>Alpha</strong>: Stores the smoothness map.</td></tr><tr><td align="left"><strong>Normal  Map</strong></td><td align="left">法线，LitShader支持模型空间和切线空间的法线，使用模型空间法线，可以在LOD当中过度更好，使用切线空间法线，可以压缩纹理空间。</td></tr><tr><td align="left"><strong>Bent Normal</strong></td><td align="left">Bent normal实际上也是一个表面方向和Normal接近，主要用来优化AO效果，只对GI（lightmap&#x2F;lightprobe&#x2F;volume proxy）生效。shaer代码：builtinData.bakeDiffuseLighting &#x3D; SampleBakedGI(posInput.positionWS, bennormalWS, texCoord1.xy, texCoord2.xy);</td></tr><tr><td align="left"><strong>Detial Map</strong></td><td align="left"><strong>Red</strong>:  Smoothness的细节噪声 <strong>Green</strong>+<strong>Blue</strong>: 细节法线. • <strong>Alpha</strong>: Albede的明暗细节噪声.</td></tr></tbody></table><h3 id="2-2-分层细节材质"><a href="#2-2-分层细节材质" class="headerlink" title="2.2. 分层细节材质"></a>2.2. 分层细节材质</h3><p>用于秒回细致的角色。</p><p>1.多加了4&#x2F;8层Detial。</p><p>一次DrawCall 刻画精细的材质。</p><table><thead><tr><th align="left"><strong>Property</strong></th><th align="left"><strong>Description</strong></th></tr></thead><tbody><tr><td align="left"><strong>Albedo Map</strong></td><td align="left">表示物体颜色，不应该包含任何明暗、AO、阴影信息。除了基础颜色外，还可以包含一些偏色、或者色相的变化。</td></tr><tr><td align="left"><strong>Mask Map</strong></td><td align="left">• <strong>Red</strong>: Stores the metallic map.  • <strong>Green</strong>: Stores the ambient occlusion map. • <strong>Blue</strong>: Stores the detail mask map. • <strong>Alpha</strong>: Stores the smoothness map.</td></tr><tr><td align="left"><strong>Normal  Map</strong></td><td align="left">法线，LitShader支持模型空间和切线空间的法线，使用模型空间法线，可以在LOD当中过度更好，使用切线空间法线，可以压缩纹理空间。</td></tr><tr><td align="left"><strong>Bent Normal</strong></td><td align="left">Bent normal实际上也是一个表面方向和Normal接近，主要用来优化AO效果，只对GI（lightmap&#x2F;lightprobe&#x2F;volume proxy）生效。shaer代码：builtinData.bakeDiffuseLighting &#x3D; SampleBakedGI(posInput.positionWS, bennormalWS, texCoord1.xy, texCoord2.xy);</td></tr><tr><td align="left"><strong>Detial Map</strong>0</td><td align="left"><strong>Red</strong>:  Smoothness的细节噪声 <strong>Green</strong>+<strong>Blue</strong>: 细节法线. • <strong>Alpha</strong>: Albede的明暗细节噪声.</td></tr><tr><td align="left"><strong>Detial Map</strong>1</td><td align="left">…</td></tr><tr><td align="left"><strong>Detial Map</strong>2</td><td align="left">…</td></tr><tr><td align="left"><strong>Detial Map</strong>3</td><td align="left">…</td></tr></tbody></table><ol start="2"><li>Mask Map中B通道均分4份，作为4层权重。</li></ol><h3 id="2-3-分层材质系统"><a href="#2-3-分层材质系统" class="headerlink" title="2.3. 分层材质系统"></a>2.3. 分层材质系统</h3><p>用于处理建筑：基础材质+脏（剥落材质）+ 旧（覆盖材质）+ 表面覆盖（雪，苔藓等）</p><p>贴图复用，材质球复用，Mesh合并。</p><p>1.参数变成4组。</p><table><thead><tr><th align="left"><strong>Property</strong></th><th align="left"><strong>Description</strong></th></tr></thead><tbody><tr><td align="left"><strong>Albedo Map1-4</strong></td><td align="left">表示物体颜色，不应该包含任何明暗、AO、阴影信息。除了基础颜色外，还可以包含一些偏色、或者色相的变化。</td></tr><tr><td align="left"><strong>Mask Map1-4</strong></td><td align="left">• <strong>Red</strong>: Stores the metallic map.  • <strong>Green</strong>: Stores the ambient occlusion map. • <strong>Blue</strong>:None. • <strong>Alpha</strong>: Stores the smoothness map.</td></tr><tr><td align="left"><strong>Normal  Map1-4</strong></td><td align="left">法线，LitShader支持模型空间和切线空间的法线，使用模型空间法线，可以在LOD当中过度更好，使用切线空间法线，可以压缩纹理空间。</td></tr><tr><td align="left">Mask</td><td align="left">四个通道对应四层。</td></tr></tbody></table><p>2.混合方式</p><p>从上层到下层的覆盖权重，而不是加权求和。</p><p>顶点色作为混合基调，Mask作为平铺细节。</p><p>材质混合：</p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569313963924.png" alt="1569313963924"></p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569313995548.png" alt="1569313995548"></p><h3 id="2-4-材质库系统"><a href="#2-4-材质库系统" class="headerlink" title="2.4. 材质库系统"></a>2.4. 材质库系统</h3><p>刺客型条 GCD2017 Texturing the World of Assassin’s Creed Odyssey：</p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569314751834.png" alt="1569314751834"></p><p>材质使用：</p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569314652689.png" alt="1569314652689"></p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569314671739.png" alt="1569314671739"></p><h3 id="2-5-特效材质"><a href="#2-5-特效材质" class="headerlink" title="2.5. 特效材质"></a>2.5. 特效材质</h3><p>这里的特效主要指的是附着在模型上的效果：</p><ol><li><p>对模型产生修改的效果，直接通过宏开关加载模型上.</p><p>例如：溶解、顶点动画、透明化、AlphaTest类型的效果。</p></li><li><p>不会修改模型的效果，另外使用Unlit渲染一次：</p><p>例如：身体流光、边缘光、轮廓线、透明特效。</p></li></ol><h3 id="2-6-屏幕空间技术"><a href="#2-6-屏幕空间技术" class="headerlink" title="2.6. 屏幕空间技术"></a>2.6. 屏幕空间技术</h3><h4 id="2-6-1-主要涉及到屏幕空间的Ray-Trace操作。"><a href="#2-6-1-主要涉及到屏幕空间的Ray-Trace操作。" class="headerlink" title="2.6.1. 主要涉及到屏幕空间的Ray Trace操作。"></a>2.6.1. 主要涉及到屏幕空间的Ray Trace操作。</h4><h4 id="2-6-2-Screen-Space-Contact-Shadow"><a href="#2-6-2-Screen-Space-Contact-Shadow" class="headerlink" title="2.6.2. Screen Space Contact Shadow"></a>2.6.2. Screen Space Contact Shadow</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569392407631.png" alt="1569392407631"></p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569392417350.png" alt="1569392417350"></p><h4 id="2-6-3-Screen-Space-Reflections"><a href="#2-6-3-Screen-Space-Reflections" class="headerlink" title="2.6.3. Screen Space Reflections"></a>2.6.3. Screen Space Reflections</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569392453534.png" alt="1569392453534"></p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569392487449.png" alt="1569392487449"></p><h3 id="2-7-毛发"><a href="#2-7-毛发" class="headerlink" title="2.7. 毛发"></a>2.7. 毛发</h3><h4 id="2-7-1-hairworks-or-TressFX："><a href="#2-7-1-hairworks-or-TressFX：" class="headerlink" title="2.7.1. hairworks or TressFX："></a>2.7.1. hairworks or TressFX：</h4><p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569390840595.png" alt="1569390840595"></p><p>神秘海域4头发</p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569144795134.png" alt="1569144795134"></p><p>怪物猎人世界宠物毛发</p><p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569144859044.png" alt="1569144859044"></p><p>Unity异教徒短片衣服毛领子：</p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569144994165.png" alt="1569144994165"></p><p>Shell Model</p><p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569310477528.png" alt="1569310477528"></p><h3 id="2-8-灯光方案"><a href="#2-8-灯光方案" class="headerlink" title="2.8. 灯光方案"></a>2.8. 灯光方案</h3><ol><li>动态物体：</li></ol><p>PBR直接光照 + SH 间接光（Reflection Probe） + IBL环境光（Reflection Probe）</p><p>直接光照：所有实时光照的直接分量。</p><p>SH 间接光（Reflection Probe）：天光 + 实时光的间接分量 + 完整烘焙光直接和间接分量。</p><p>点云：记录了六个方向的光线，简化版的SH。</p><ol start="2"><li>静态物体：</li></ol><p>PBR直接光照 + LightMap间接光计算 + IBL环境光 （Reflection Probe）</p><p>LightMap间接光计算 ：天光 + 实时光的间接分量 + 完整烘焙光直接和间接分量。</p><h3 id="2-9-阴影方案"><a href="#2-9-阴影方案" class="headerlink" title="2.9. 阴影方案"></a>2.9. 阴影方案</h3><p>动态物体：ShadowMap CSM 2(5,20) + 静态物体：ShadowMask</p><p>动态阴影边缘优化：PCF2*2 5*5 7*7 、PCSS</p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569209076734.png" alt="1569209076734"></p><p>远处动态物体：</p><ol><li><p>使用第三级CSM，使用代理体阴影。</p></li><li><p>SDF</p></li></ol><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569220211656.png" alt="1569220211656"></p><h4 id="2-9-1-巫师3的CSM"><a href="#2-9-1-巫师3的CSM" class="headerlink" title="2.9.1. 巫师3的CSM"></a>2.9.1. 巫师3的CSM</h4><p>0级：3米</p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569393594256.png" alt="1569393594256"></p><p>1级：20米</p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569393483587.png" alt="1569393483587"></p><p>2级：200米</p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569393547484.png" alt="1569393547484"></p><p>3级：动态物体无阴影</p><h4 id="2-9-2-阴影代理"><a href="#2-9-2-阴影代理" class="headerlink" title="2.9.2. 阴影代理"></a>2.9.2. 阴影代理</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569407455456.png" alt="1569407455456"></p><h3 id="2-10-LOD方案"><a href="#2-10-LOD方案" class="headerlink" title="2.10. LOD方案"></a>2.10. LOD方案</h3><p>Mesh Lod :LOD0 - N  + HLOD + IMPOSTER</p><p>特效LOD : 削减次要粒子 &gt; 降低粒子数量 &gt; 关闭Alpha Test，简化计算。</p><p>Shading LOD ：简化光照模型。</p><p>阴影LOD：Shadow Mask</p><h3 id="2-11-后处理：曝光与光照设定"><a href="#2-11-后处理：曝光与光照设定" class="headerlink" title="2.11. 后处理：曝光与光照设定"></a>2.11. 后处理：曝光与光照设定</h3><ol><li>白平衡场景和灯光设置：</li></ol><p>基本的资源检查场景，确定ShadingModel、贴图制作、光源方案没有问题。</p><p>包括：展览光源+反射球+反射探针。</p><ol start="2"><li>风格化场景和灯光设置：</li></ol><p>结合后处理的风格化场景：夜晚，白天，洞穴，室内，森林等等，包括少量烘焙、参考资源。</p><p>制作标准亮度的cubemap,标准灯光参数，用于检查外包资源的场景。确定在各种环境下显示正常、</p><p>包括：展览光源+反射球+反射探针+lightmap+后处理。</p><ol start="3"><li>AssetLibrary资源库。</li></ol><p>包括了所有资源的展览场景，游戏当中的各种复用场景资源集中排列摆放：树，石头。</p><p>游戏当中场景材质集中摆放。</p><p>检查所有材质模型合规。检查LOD效果。需要可以切换各个风格化设置。资源之间是否统一。</p><p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569405739260.png" alt="1569405739260"></p><p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569405759431.png" alt="1569405759431"></p><ol start="4"><li>游戏场景。</li></ol><p>地标大型资源的游戏场景，地编从2中选取光照方案，从3中选取资源填充场景。</p><p>最终的游戏场景，进行最终游戏性能测试。</p><h3 id="2-12-透明物体低分辨率渲染"><a href="#2-12-透明物体低分辨率渲染" class="headerlink" title="2.12. 透明物体低分辨率渲染"></a>2.12. 透明物体低分辨率渲染</h3><p>通过在低分辨率上渲染透明物体直接减低overdraw。通常给烟雾使用。</p><h3 id="2-13-后处理：HDR-and-ToneMapping"><a href="#2-13-后处理：HDR-and-ToneMapping" class="headerlink" title="2.13. 后处理：HDR and ToneMapping"></a>2.13. 后处理：HDR and ToneMapping</h3><ol><li>渲染层的HDR: HDR和ToneMapping</li></ol><p>参考GDC2017 High Dynamic Range color grading and display in Frostbite</p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568966737421.png" alt="1568966737421"></p><p>Tonemap之前的流程包括暗角，Flare Len，DoF，Bloom，自动曝光参数计算（部分参数用于ToneMaping）.</p><p>可以将ToneMap和Grading、Gamma矫正进行合并。</p><ol start="2"><li>显示层的HDR：多ToneMapping曲线</li></ol><p>如果在LDR和HDR显示器上使用同一个ToneMapping曲线，会导致画面整体变亮。</p><p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569205929868.png" alt="1569205929868"></p><p><strong>FrameBuffer始终是0-1</strong>，（硬件层面，还会转换为1-65535或者1-255），而1对应的值变成了：100nits  200nits 1000nits,所以需要不同的曲线。</p><p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569204914339.png" alt="1569204914339"></p><p>寒霜策略：</p><p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569205757913.png" alt="1569205757913"></p><h3 id="2-14-后处理：TAA"><a href="#2-14-后处理：TAA" class="headerlink" title="2.14. 后处理：TAA"></a>2.14. 后处理：TAA</h3><p>参考：SIGGRAPH2016 Temporal Reprojection AA INSIDE</p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/TAACompare.jpg" alt="TAACompare"></p><h2 id="3-GPU架构"><a href="#3-GPU架构" class="headerlink" title="3. GPU架构"></a>3. GPU架构</h2><h3 id="3-1-GPU存储架构"><a href="#3-1-GPU存储架构" class="headerlink" title="3.1. GPU存储架构"></a>3.1. GPU存储架构</h3><p>Registers:  [on-chip]5 clocks   </p><p>Shared Memory ： [on-chip]50 clocks</p><p>Local Memory ：  [logic  on-chip] 100 clocks</p><p>Constant Memory ：150 clocks +  conditional Cache.</p><p>Global Memory ：150 clocks</p><p>Texture Memory ：150 clocks  + Cache + Filter etc.</p><p>Host Memory :  Pageable And Pinned. </p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569141565643.png" alt="1569141565643"></p><h3 id="3-2-GPU渲染架构"><a href="#3-2-GPU渲染架构" class="headerlink" title="3.2. GPU渲染架构"></a>3.2. GPU渲染架构</h3><h4 id="3-2-1-存储和计算的关系"><a href="#3-2-1-存储和计算的关系" class="headerlink" title="3.2.1. 存储和计算的关系"></a>3.2.1. 存储和计算的关系</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569140686391.png" alt="1569140686391"></p><h4 id="3-2-2-Wrap与Wave-Front"><a href="#3-2-2-Wrap与Wave-Front" class="headerlink" title="3.2.2. Wrap与Wave Front"></a>3.2.2. Wrap与Wave Front</h4><p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569140550632.png" alt="1569140550632"></p><p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569140555815.png" alt="1569140555815"></p><h3 id="3-3-手游架构"><a href="#3-3-手游架构" class="headerlink" title="3.3. 手游架构"></a>3.3. 手游架构</h3><p>Memory And Tiled Based Rendering</p><p>参考：siggraph2016 Best practice for Mobile</p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/5aa7a8c2a46f3.png" alt="5aa7a8c2a46f3"></p><h2 id="4-程序优化性能关注的点"><a href="#4-程序优化性能关注的点" class="headerlink" title="4. 程序优化性能关注的点"></a>4. 程序优化性能关注的点</h2><h3 id="4-1-Draw-Call"><a href="#4-1-Draw-Call" class="headerlink" title="4.1. Draw Call"></a>4.1. Draw Call</h3><p>略</p><h3 id="4-2-Early-z"><a href="#4-2-Early-z" class="headerlink" title="4.2. Early - z"></a>4.2. Early - z</h3><p>原本的深度测试是在Fragment Shader计算之后的，如果不通过深度测试，这部分Pixel计算就是浪费的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Buffers:</span><br>Buffer display<br>Buffer depthBuffer<br><br><span class="hljs-comment">//Shaders:</span><br>Shader simpleShader<br>Shader writeDepth<br><br><span class="hljs-comment">//Visibility</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth &lt; depthBuffer.depth<br>       depthBuffer = writeDepth(mesh)<br><br><span class="hljs-comment">//Shading and lighting</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth == depthBuffer.depth<br>        <span class="hljs-keyword">for</span> light in scene<br>            display += simpleShader(mesh, light)<br></code></pre></td></tr></table></figure><p>Early-z可以假设PS不修改Depth状态，这样就能将深度测试提前。</p><p>Alpha Test会直接导致Early-z失效。也就是无论这个物体有没有被遮挡，一定会发生全部的PS计算。必定产生OverDraw开销，场景中要少用。</p><p>大部分引擎的优化策略：<strong>Z-Pre-Pass</strong>和Render Queue Sort。</p><p>Unity官方文档的描述：</p><p>The fixed-function <a href="https://docs.unity3d.com/Manual//SL-AlphaTest.html">AlphaTest</a> - or its programmable equivalent, <code>clip()</code> - has different performance characteristics on different platforms:</p><ul><li>Generally you gain a small advantage when using it to remove totally transparent pixels on most platforms.优化了FrameBuffer的读取（Blend）写入，</li><li><strong>However, on PowerVR GPUs found in iOS and some Android devices, alpha testing is resource-intensive. Do not try to use it for performance optimization on these platforms, as it causes the game to run slower than usual.与手机架构有关</strong></li></ul><h3 id="4-3-Over-Draw"><a href="#4-3-Over-Draw" class="headerlink" title="4.3. Over Draw"></a>4.3. Over Draw</h3><p><strong>GPU计算开销主要是<em>warp</em>(或WaveFront或thread，对应一次像素计算（PS）或者一次顶点(VS)计算)的多线程并行计算：需要计算的<em>warp</em>越多开销越高，计算的<em>warp</em>越复杂开销越高。</strong></p><p>透明物体，程序可以通过实现，LowResolutionTransparent技术降低大范围覆盖的透明物体的OverDraw。开销分为两部分PS本身的计算和FrameBuffer的写出。</p><p>可以制作特效LOD策略降低特效和透明物体的OverDraw。</p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569145360889.png" alt="1569145360889"></p><h3 id="4-4-Quad-OverDraw"><a href="#4-4-Quad-OverDraw" class="headerlink" title="4.4. Quad OverDraw"></a>4.4. Quad OverDraw</h3><p>warp以2*2形式提交计算，三角形边界有无效计算，三角形越小，无效计算比例越高。PS当中一般需要每个三角形有10个像素的占用。</p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569145282601.png" alt="1569145282601"></p><h3 id="4-5-Light"><a href="#4-5-Light" class="headerlink" title="4.5. Light"></a>4.5. Light</h3><p>光照需要合理分布，Deferred阶段的灯光影响区域的重叠是变相的OverDraw（非Tiled和Clustered）：</p><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569145437672.png" alt="1569145437672"></p><h3 id="4-6-Vertex-Count"><a href="#4-6-Vertex-Count" class="headerlink" title="4.6. Vertex Count"></a>4.6. Vertex Count</h3><p>同一个模型顶点数过多-&gt;三角面增多-&gt;Quad OverDraw增加。</p><p>曲面细分在顶点带来的开销意外 还有大量的Quad OverDraw的开销。</p><h3 id="4-7-Texture压缩与内存优化"><a href="#4-7-Texture压缩与内存优化" class="headerlink" title="4.7. Texture压缩与内存优化"></a>4.7. Texture压缩与内存优化</h3><p>纹理是内存当中最主要的的资源，需要合理的进行Tiling和Packing策略，提升利用率。</p><h3 id="4-8-Baking"><a href="#4-8-Baking" class="headerlink" title="4.8. Baking"></a>4.8. Baking</h3><p>烘焙唯一的性能影响就是Lighmap的内存占用。必须要合理调节渲染参数。通常需要用一米面积多少个texel的限制。每个模型都需要具体调整。</p><h3 id="4-9-MipMap"><a href="#4-9-MipMap" class="headerlink" title="4.9. MipMap"></a>4.9. MipMap</h3><p>重要的远处物体反走样，提升效果的特性。但是内存占用会升高。</p><h3 id="4-10-Testure-Streaming"><a href="#4-10-Testure-Streaming" class="headerlink" title="4.10. Testure Streaming"></a>4.10. Testure Streaming</h3><p>解决Mipmap内存占用的问题。</p><h3 id="4-11-Shader预加载"><a href="#4-11-Shader预加载" class="headerlink" title="4.11. Shader预加载"></a>4.11. Shader预加载</h3><p>如果场景中Shader变体过多，需要考虑Shader的预加载。</p><h3 id="4-12-Shader分支"><a href="#4-12-Shader分支" class="headerlink" title="4.12. Shader分支"></a>4.12. Shader分支</h3><p>通常需要切换渲染效果：切换方式有3种：</p><ol><li>宏：</li></ol><p>通过#define关键字可以定义Shader的表现。不能游戏时切换，主要用来测试和调试，或者多平台兼容。</p><ol start="2"><li>变体：</li></ol><p>通过Shader的变体宏控制分支开关，缺点是会生成大量变体。</p><ol start="3"><li>if else 分支语句切换：</li></ol><p>如果没有合理使用可能导致性能降低，但是通常可以提升性能并且降低变体数量。</p><h2 id="5-美术资源可能带来的性能问题"><a href="#5-美术资源可能带来的性能问题" class="headerlink" title="5. 美术资源可能带来的性能问题"></a>5. 美术资源可能带来的性能问题</h2><ol><li>游戏内存： 场景当中要绘制的所有东西都需要保存到内存中，其中最重要的就是：<strong>模型、贴图</strong>。</li><li>drawcall：每绘制一种东西（不同的模型：即使是相同的材质球也算不同的模型，除非合并他们的mesh），<strong>内存都需要把相关的渲染参数、模型数据、贴图数据传递到GPU</strong>，这个速度非常慢，所以看到的模型越多，drawcall越多。</li><li>GPU渲染速度：模型的材质越复杂，渲染越慢。这个靠TA来制定标准即可。</li></ol><p>对应的美术资源优化主要有个以下方面：</p><ol><li>模型拆分，模型组件复用：美术制作场景时，复用模型资源进行摆放。<strong>只是为了提升工作效率，拆分之后还是需要尽可能使用相同材质，最终还是要合并。</strong></li><li>贴图Tiling，贴图复用：能够直接降低内存开销。<strong>为了效果可以使用更少、分辨率更高的贴图。</strong></li><li>材质复用：不同的模型使用同一个材质球（必须是同一个材质球，而不是不同的材质球同一个参数。）<strong>材质复用的目的，是最终要合并网格以减少drawcall，如果不合并那么材质复用就没有意义。</strong> <strong>Dynamic Batch</strong> 就是这个原理，但是他会在内存生成一份合并后的mesh，相当于内存占用翻倍，浪费内存。<strong>Static Batch</strong>也是一样，只不过是静态合并好。但是合并的物体覆盖全场景。还会导致遮挡剔除失效，同样占内存。</li><li>Prefab、Model复用（包括组件的Prefab，完整模型的Prefab）：直接提升资源利用率。这种服用就是一模一样的mesh和材质，可以直接合并。</li></ol><h3 id="5-1-游戏性能瓶颈：模型"><a href="#5-1-游戏性能瓶颈：模型" class="headerlink" title="5.1. 游戏性能瓶颈：模型"></a>5.1. 游戏性能瓶颈：模型</h3><p>由于场景资源复杂，可能遇到的性能瓶颈：</p><ol><li>模型数量：模型数量越多（ 一个submesh算一个模型 ）drawcall越多，成正比。</li><li>一个模型的面数：模型越大，越占内存。（不使用static batch的原因）。</li><li>模型属性太多（比如各个uv通道全部使用，normal、tangent全部使用）：属性使用的越多，越占内存。</li></ol><p><strong>模型的内存开销&#x3D;模型数量 * 一个模型的面数 * 模型属性</strong></p><p><strong>模型的drawcall 开销&#x3D; 场景中的模型数量。</strong></p><h3 id="5-2-游戏性能优化：模型"><a href="#5-2-游戏性能优化：模型" class="headerlink" title="5.2. 游戏性能优化：模型"></a>5.2. 游戏性能优化：模型</h3><ol><li>美术在3Dmax当中合并不同的mesh。（相同材质的合并，通过合理分布uv可以让大部分mesh复用同一个材质）。<strong>能够在模型总内存消耗不变的情况下降低drawcall。</strong></li><li>如果材质的属性不使用，就不要输出，例如：第二套uv，顶点色，切线信息。<strong>直接降低内存开销。</strong></li><li>控制模型面数，场景当中看不到的面裁切掉。<strong>直接降低内存开销。</strong></li></ol><h3 id="5-3-游戏性能瓶颈：贴图"><a href="#5-3-游戏性能瓶颈：贴图" class="headerlink" title="5.3. 游戏性能瓶颈：贴图"></a>5.3. 游戏性能瓶颈：贴图</h3><ol><li><strong>场景中涉及到的</strong>贴图数量越多，内存占用越大。（例如：一张1024*1024的三通道贴图，相当于一个100万点的只记录了顶点位置的模型，相当于10万顶点并记录了顶点色的模型），美术需要考虑模型和贴图之间的平衡。</li><li><strong>场景中涉及到的</strong>贴图越大，内存占用越多。</li><li><strong>场景中涉及到的</strong>贴图开启mipmap占用内存越多。</li><li>如果贴图不在场景中，那他就只是占用硬盘而已。</li></ol><p><strong>贴图内存开销&#x3D; 贴图数量 * 贴图大小。</strong></p><p><strong>贴图drawcall开销 &#x3D; 基本只和内存有关。</strong></p><p>*<strong>注：</strong>“场景当中涉及到的”指的是客户端从硬盘加载到内存的场景数据。</p><h3 id="5-4-游戏性能优化：贴图"><a href="#5-4-游戏性能优化：贴图" class="headerlink" title="5.4. 游戏性能优化：贴图"></a>5.4. 游戏性能优化：贴图</h3><p><strong>贴图内存开销&#x3D; 贴图数量 * 贴图大小。</strong></p><ol><li>使用Tiling方式的贴图。<strong>减小贴图大小。</strong></li><li>提高利用率。<strong>减少贴图数量。</strong></li><li>LightMap 一般会很占用内存，需要合理调整大小，和烘焙参数。</li></ol><h3 id="5-5-游戏性能瓶颈：材质"><a href="#5-5-游戏性能瓶颈：材质" class="headerlink" title="5.5. 游戏性能瓶颈：材质"></a>5.5. 游戏性能瓶颈：材质</h3><ol><li><strong>场景中涉及到的材质</strong>数量越多drawcall越多。</li><li><strong>场景中涉及到的材质</strong>使用的贴图越多占用内存越多。</li></ol><p>材质内存开销 &#x3D;  几乎不考虑。</p><p>材质drawcall开销&#x3D; 主要看mesh，因为如果同一个mesh 使用不同的材质，那么drawcall还是两个。</p><p><strong>材质复用的真正目的是为了能够合并场景中使用相同材质的mesh。以直接减少drawcall。</strong></p><h3 id="5-6-游戏性能优化：材质"><a href="#5-6-游戏性能优化：材质" class="headerlink" title="5.6. 游戏性能优化：材质"></a>5.6. 游戏性能优化：材质</h3><p><strong>材质复用的真正目的：为了能够合并场景中使用相同材质的mesh，以直接减少drawcall。</strong></p><ol><li><strong>使用相同的材质 + 不同的mesh</strong> 的策略来实现丰富的表现，方便合并。例如：用刷顶点色，代替mask贴图。</li><li>材质复用优先于mesh复用：如果mesh复用，而使用了不同的材质，那么drawcall不能再减少了。如果复用了材质（同一个材质球），而使用了不同的mesh，那么有很多方法来合并mesh以减少drawcall。</li></ol><h3 id="5-7-游戏性能瓶颈：Quad-OverDraw-、OverDraw"><a href="#5-7-游戏性能瓶颈：Quad-OverDraw-、OverDraw" class="headerlink" title="5.7. 游戏性能瓶颈：Quad OverDraw 、OverDraw"></a>5.7. 游戏性能瓶颈：Quad OverDraw 、OverDraw</h3><p><strong>GPU计算开销主要是<em>warp</em>(或WaveFront或thread，对应一次像素计算（PS）或者一次顶点(VS)计算)的多线程并行计算：需要计算的<em>warp</em>越多开销越高，计算的<em>warp</em>越复杂开销越高。</strong></p><p>在渲染管线当中主要是VS阶段计算（和顶点数相关）和PS阶段的计算（和物体覆盖像素有关）。其中PS开销最高。也就是说物体占用的像素越多，开销越高。</p><p>OverDraw：</p><p>​1.可见透明物体，所有未遮挡像素都会计算。多层透明物体重叠，会导致PS阶段需要计算的Warp数提升。</p><p>​2.Alpha Test物体：无论是否被遮挡，Early-Z完全失效，导致PS阶段计算的Warp数提升。</p><ol start="3"><li>后处理：每一个后处理相当于全屏每个像素计算一次。</li></ol><p>Quad OverDraw：</p><p>​PS阶段Warp实际上以2*2为单位计算，也就是说三角形的渲染边界会有很多无效的像素被计算。</p><ol><li>狭长三角形，对像素利用率过低。</li><li>距离过远的三角形，如果缩成一个像素点，开销为实际需要的4倍，如果占据8个限速点，大概为实际需要的2倍。</li></ol><h3 id="5-8-游戏性能优化：Quad-OverDraw-、OverDraw"><a href="#5-8-游戏性能优化：Quad-OverDraw-、OverDraw" class="headerlink" title="5.8. 游戏性能优化：Quad OverDraw 、OverDraw"></a>5.8. 游戏性能优化：Quad OverDraw 、OverDraw</h3><p>OverDraw：</p><ol><li>用更细化的网格秒回透明物体、或者AlphaTest物体。</li><li>场景中少用AlphaTest ：例如：蜘蛛网用AlphaBlend。铁丝网少用。</li><li>对后处理进行合并计算，去除不必要的后处理。</li></ol><p>Quad OverDarw</p><ol><li>美术布线避免使用狭长三角形。</li><li>使用LOD，保证每一个三角形的像素占用率。</li></ol>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大气散射</title>
      <link href="/2022/07/09/RTR/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/"/>
      <url>/2022/07/09/RTR/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="大气散射"><a href="#大气散射" class="headerlink" title="大气散射"></a>大气散射</h1><p>翻译、摘录自GEMS2中的大气散射：<a href="https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering">GEMS2：Accurate Atmosphere Scaterring</a>.</p><p>这里实现的方法来自于：Nishita et al. 1993。</p><p>我们假设摄像机在地平线上，这样就可以假设在各个角度观察大气的密度是固定的。这样就可以简化大气散射模型。</p><h2 id="求解大气散射模型"><a href="#求解大气散射模型" class="headerlink" title="求解大气散射模型"></a>求解大气散射模型</h2><p>散射模型有嵌套积分，没有解析解。幸运的是，可以用梯形法则计算( trapezoid rule)</p><blockquote><p>  Note:</p><p>  梯形法则计算：将该段分成n个样本段，并在每个样本段的中心点计算被积函数。将每个结果乘以样本段的长度并将它们全部加起来。样本数量越多，计算结果越准确，但也使积分计算成本较高。</p></blockquote><p>如果光线穿过大气层到达顶点，需要计算散射。每条射线都应该有两个确定的点，标记出<strong>射线开始穿过大气层的位置</strong>和<strong>停止穿过大气层的位置</strong>。如下图的A和B点。</p><p><img src="/../../images/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/16_atmospheric_02.jpg" alt="16_atmospheric_02.jpg"></p><p><strong>当相机在大气中，A是相机的位置</strong>。当顶点在大气中，B是顶点的位置。<strong>当任意一点在空间中时，我们执行一个球体交点检查来找出射线与外层大气交点，然后我们做交点A或B。</strong></p><p>当我们得到了两个交点，我们就可以开始计算AB之间的积分。我们在线段中间找到我们的采样点P1..P5。</p><p>每一个点的光线的变化：接受<strong>直接来自于太阳的光线</strong>和<strong>来气其他方向的散射光线</strong>，然后一部分光线向摄像机传递，一部分光线向其他方向散射。</p><h2 id="Rayleigh-Scattering-vs-Mie-Scattering"><a href="#Rayleigh-Scattering-vs-Mie-Scattering" class="headerlink" title="Rayleigh Scattering vs. Mie Scattering."></a>Rayleigh Scattering vs. Mie Scattering.</h2><p>知道了光线如何在一点散射，另一个重要的细节是关于如何模拟P点的光散射。大气中不同的粒子以不同的方式散射光线。大气中最常见的两种散射形式是瑞利散射和密散射。</p><p><strong>Rayleigh 散射</strong>是由空气中的小分子引起的，它在较短的波长(先是蓝色，然后是绿色，然后是红色)上对光线的散射更大。天空是蓝色的，<strong>因为蓝色的光到处反射，最终从各个方向到达你的眼睛</strong>。太阳的光线在日落时会变成黄色&#x2F;橙色&#x2F;红色，这是因为光线穿过大气层时，<strong>几乎所有的蓝光和大部分绿光在到达你面前就被散射掉了</strong>，只剩下红色。</p><p><strong>Mie 散射</strong>是由空气中称为气溶胶的较大粒子(如灰尘和污染)引起的，<strong>它倾向于均匀地散射所有波长的光</strong>。在一个雾蒙蒙的日子，Mie散射导致天空看起来有点灰色，并导致太阳有一个大的白色光晕围绕它Mie散射也可以用来模拟空气中水和冰的小粒子散射的光，以产生彩虹的效果，但这超出了本章的范围。(详情请参阅Brewer 2004。)</p><h2 id="Phase-Function相函数"><a href="#Phase-Function相函数" class="headerlink" title="Phase Function相函数"></a>Phase Function相函数</h2><p>这里主要描述光线在某一个点的散射和传递情况：</p><p><img src="/../../images/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/0256equ01.jpg" alt="0256equ01.jpg"></p><p><strong>相位函数描述了有多少光线散射到了相机方向</strong>，（从太阳方向到摄像机方向），还有常量g对散射量的影响。</p><p>相位函数有很多不同的版本。上面的函数是对Nishita等人1993年使用的Henyey-Greenstein函数的一种改编。</p><p>瑞利散射可<strong>近似地设g为0</strong>，这大大简化了方程，使<strong>其对正角和负角对称。当g为负值时，正向散射的光更多，当g为正值时，向光源反射的光更多</strong>。对于Mie气溶胶散射，g通常设置在**-0.75 ~ -0.999<strong>之间。</strong>永远不要将g设为1或-1，因为这会使等式简化为0。**</p><h2 id="The-Out-Scattering-Equation出散射方程"><a href="#The-Out-Scattering-Equation出散射方程" class="headerlink" title="The Out-Scattering Equation出散射方程"></a>The Out-Scattering Equation出散射方程</h2><p><img src="/../../images/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/0256equ02.jpg" alt="0256equ02.jpg"></p><p>外散射方程是前面提到的内积分：<strong>描述了从点Pa到点Pb的平均大气密度乘以射线的长度（光学深度、光学距离、光学厚度optical depth）。</strong></p><blockquote><p>  Note:</p><p>  可以把它看作是一个基于光线路径上空气粒子数量的加权因子。方程的其余部分由常数组成，它们决定了这些粒子从射线中散射出去的光的多少。</p></blockquote><p>为了计算这个积分的值，从Pa到Pb的射线将被分割成段，指数项将在每个采样点被计算。</p><p>变量h是采样点的高度。<strong>在我的实现中，高度被缩放，0代表海平面（地面），1代表大气的顶部。</strong>理论上，大气没有固定的顶部，但是为了实际的目的，我们必须选择一个高度来渲染天空穹顶。h0是比例尺高度，这是大气平均密度的高度。我的实现使用了0.25，所以从地面到天空穹顶的平均密度是25%。我的实现使用了0.25，所以从地面到天空穹顶的平均密度是25%。</p><p>常数是光的波长(或颜色)和K()是散射常数，它依赖于海平面的大气密度。<strong>瑞利散射和密散射有各自的散射常数，包括尺度高度h0。</strong></p><p>瑞利散射和密散射对波长的依赖也不同。瑞利散射常数通常除以4，在大多数计算机图形模型中，Mie散射常数与波长无关，但至少有一个实现将其除以0.84。</p><p><strong>外散射函数决定了有多少光被沿图的两条绿色射线散射掉了。</strong></p><h2 id="The-In-Scattering-Equation"><a href="#The-In-Scattering-Equation" class="headerlink" title="The In-Scattering Equation"></a>The In-Scattering Equation</h2><p><img src="/../../images/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/0257equ01.jpg" alt="0257equ01.jpg"></p><p>内散射方程描述了多少太阳的光线叠加到了大气当中。</p><p>对于每个从Pa到Pb中的点P，PPc是点到太阳的射线，PPa是点到相机的射线。外散射函数决定了有多少光被沿图的两条绿色射线散射掉了。剩下的光由<strong>相位函数</strong>（一个点一个相位函数–由实现和太阳光线夹角决定）、散射常数和阳光强度缩放。</p><p>阳光强度并不一定依赖于波长，但如果你想创建一个围绕紫色恒星旋转的外星世界，你就应该在这里应用颜色。</p><h2 id="The-Surface-Scattering-Equation"><a href="#The-Surface-Scattering-Equation" class="headerlink" title="The Surface-Scattering Equation"></a>The Surface-Scattering Equation</h2><p>这部分就是反射物体表面的颜色。这部分是渲染的选择不做讨论。</p><h2 id="实时计算"><a href="#实时计算" class="headerlink" title="实时计算"></a>实时计算</h2><p>如果使用上面的计算开销很高，计算点很多，需要进行简化。</p><p>GEMS的方法主要是将Outter Scattering 转换成一张二维LUT，简化计算。</p>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图像动态范围</title>
      <link href="/2022/07/09/RTR/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/"/>
      <url>/2022/07/09/RTR/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><p>- <a href="#%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4">图像动态范围</a></p><p>​    - <a href="#dynamic-range">Dynamic Range</a></p><p>​    - <a href="#%E6%98%BE%E7%A4%BA%E5%99%A8%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4">显示器动态范围</a></p><p>​    - <a href="#%E6%9B%9D%E5%85%89%E6%93%8D%E4%BD%9C%E4%BA%AE%E5%BA%A6%E4%B9%98%E6%B3%95%E5%9C%A8ev-%E7%A9%BA%E9%97%B4%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84">曝光操作（亮度乘法）在EV 空间怎么样的？</a></p><p>​    - <a href="#gamma%E6%93%8D%E4%BD%9C%E6%8C%87%E6%95%B0%E6%93%8D%E4%BD%9C%E5%9C%A8ev%E7%A9%BA%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84">Gamma操作（指数操作）在EV空间是怎么样的？</a></p><p>​    - <a href="#%E5%AF%B9%E6%AF%94%E5%BA%A6contrast">对比度Contrast</a></p><p>​    - <a href="#%E8%BF%99%E4%BA%9B%E5%86%85%E5%AE%B9%E5%A6%82%E4%BD%95%E5%BA%94%E7%94%A8%E5%88%B0%E5%B1%80%E9%83%A8%E6%9B%9D%E5%85%89%E4%B8%8A%E5%8F%AF%E4%BB%A5%E7%95%A5%E8%BF%87">这些内容如何应用到局部曝光上（可以略过）</a></p><p>​    - <a href="#eotf%E5%92%8Coetf">EOTF和OETF</a></p><p>​    - <a href="#%E6%98%BE%E7%A4%BA%E5%99%A8oetf%E5%92%8Cgamma22%E7%BC%96%E7%A0%81">显示器OETF和gamma2.2编码</a></p><p>​    - <a href="#%E8%A7%82%E5%AF%9F%E6%9D%A1%E4%BB%B6">观察条件</a></p><p>​    - <a href="#eotf%E5%92%8Coetf%E7%9A%84%E8%A7%86%E8%A7%89%E6%9D%A1%E4%BB%B6">EOTF和OETF的视觉条件</a></p><p>​    - <a href="#adjust-gamma-until-logo-is-barely-visible">Adjust gamma until logo is barely visible</a></p><p>​    - <a href="#tonemapping%E6%93%8D%E4%BD%9C">ToneMapping操作</a></p><p>​    - <a href="#%E5%8F%82%E8%80%83">参考</a></p><p>​    - <a href="#%E9%87%8D%E8%A6%81%E6%80%BB%E7%BB%93">重要总结</a></p><!-- /TOC --><h1 id="图像动态范围"><a href="#图像动态范围" class="headerlink" title="图像动态范围"></a>图像动态范围</h1><p>​这篇笔记主要为了解释什么是<strong>动态范围</strong>，引出sRGB、ToneMapping等内容的前因后果。</p><p>​笔记摘录自<a href="https://bartwronski.com/2016/09/01/dynamic-range-and-evs/">Image Dynamic Range</a>, <a href="https://en.wikipedia.org/wiki/Dynamic_range">wiki Dynamic range</a>,同时根据自己的理解做了补充和注释说明。</p><h2 id="Dynamic-Range"><a href="#Dynamic-Range" class="headerlink" title="Dynamic Range"></a>Dynamic Range</h2><p>​<strong>动态范围</strong>指的是媒体设备能够表示的最大值和最小值的比例（有人会疑问最小值是0怎么办，而实际上0通常表示没有信号，另外最大值和最小值描述的是<strong>设备能够表示的范围</strong>，和设备的硬件相关）。</p><p>​动态范围通常用来描述<strong>信号</strong>：声音信号（播放器）、亮度信号（显示屏）。</p><p>​它通常是一个比例，或者以10为基数的数(声音：分贝)、或者是用2为基数的对数值表示最小信号值和最大信号值的差值(doublings、bits或<strong>stops</strong>)。</p><pre><code>    &gt; bits:信号理论、计算、数字通信当中的**基本信号单位**。他的名字是**binary digit**的缩写。    &gt;    &gt; doublings:没有搜索到，在这篇笔记中不重要。    &gt;    &gt; stops：在摄影中,设备的曝光范围通常用**stops**来表示，相当于设备或者媒体常量比例（contrast ratio）的 $ \log _&#123;2&#125;(c) $ 表示形式。    &gt;    &gt; 例如：通常的DV机的拍摄的常量比例是45:1，他的曝光约为5.5stops。    &gt;    &gt; 曝光范围可以指几种动态范围中的任何一种:    &gt;    &gt; 1.  感光范围照相胶片、纸或数码相机传感器的感光范围.    &gt; 2.  被拍摄场景的光度范围    &gt; 3.  显影胶片图像的不透明度范围    &gt; 4.  相纸上图像的反射率范围。    &gt;    &gt; 例如：胶片的曝光范围约为14stops。</code></pre><p>​（<strong>本段的扩展阅读有点复杂可以跳过</strong>）在模拟信号（模拟信号是指用连续变化的物理量表示的信息）的媒体设备上，他通常表示为信噪比（signal to noise ratio）。最小值是无法从噪声中区分出来的。在某种程度上，他和数字信号（数字信号指自变量是离散的、因变量也是离散的信号，这种信号的自变量用整数表示，因变量用有限数字中的一个数字来表示。）的媒体设备类似，在数字信号设备上，小于最小可表示数据的内容都是量化噪声（由增量调制原理可知，译码器恢复的信号是阶梯形电压经过低通滤波器平滑后的解调电压。它与编码器输入模拟信号的波形近似，但是存在失真，将这种失真称为<strong>量化噪声</strong>。）。</p><p>​动态范围对<strong>模拟相机</strong>（在高亮度和中等亮度的区域的精度更高，黑暗的区域会显示颗粒噪声）、<strong>数字信号</strong>（白色信号被完全的剪裁、大量的信息被压缩到暗部，并且还掺杂着数字噪声）和<strong>数字信号文件</strong>（除了量化噪声、伪影还有0噪声）有不同的含义。</p><p>​这里我们主要讨论在<strong>显示器上</strong>的<strong>动态范围</strong>（<strong>动态范围是stops的范围，可以理解成bit位数</strong>，也叫做曝光范围，也就是说用EV stops表示dynamic range）。我们使用EV stops &#x3D; exposure value stops.<strong>这是一个以2为底数的对数差值</strong>。</p><blockquote><p>  注意是<strong>对数差值</strong>，例如最大值亮度的曝光值是9，最小亮度的曝光是2，那么动态范围是7.</p></blockquote><h2 id="显示器动态范围"><a href="#显示器动态范围" class="headerlink" title="显示器动态范围"></a>显示器动态范围</h2><p>​首先可以做一个简单的联想：<strong>如果我们的输出图像是8bits的，那么显示器的动态范围就是8 EV stop</strong>。<strong>这是错误的：</strong>因为所有在设备上保存的数据都是考虑了<strong>OETF</strong>（存储格式进行了Gamma之类的变换），为了能够在显示设备上正常显示。典型的OETF是gamma操作，常用的Gamma是2.2指数和sRGB（sRGB比2.2编码更加准确，可以参考wiki）</p><p>​<strong>这里实际上就是提出了一个问题：为什么8bits不是对应8 EV stop的动态范围？这里参见后面的解释：OETF（Gamma操作）带来的什么影响</strong>？</p><p>​首先，对于最简单的情况（没有OETF），直接存储8bit值数据。</p><p>​<strong>因为0表示没有信号，所以使用1&#x2F;256（对数为 $ log_2(\frac{1}{258}) &#x3D; -8 $）表示最小可表示信号（小于这个值的都是噪声），1为最高可表示信号（对数为 $ log_2(1) &#x3D; 0 $）,所以动态范围是8。</strong></p><blockquote><p>  <strong>重要说明，一般来讲图像最大值就是1，关键就是最小值是多少！直接决定了曝光范围</strong></p><p>  对于只有8bit的数据来表示颜色情况下，Gamma空间的颜色值的最小值要比线性空间颜色的最小值要小！</p></blockquote><p>​下面是动态范围的数值输出和亮度的关系：</p><p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/dynrange_linear2.png" alt="dynrange_linear.png"></p><p>​图像说明：动态范围用8bits进行线性编码（没有开了OETF直接保存，即没有Gamma）. 红线 &#x3D; stops:曝光值. 蓝色线 &#x3D; 输出结果（亮度）. 绿色线&#x3D; 曝光值. 点&#x3D; <strong>曝光范围到线性亮度的映射</strong>.</p><p>​线性空间中EV stops的表示显然是指数型的，您可以看到这种编码的问题。很多颜色曝光值压缩在暗部，包括了3&#x2F;4的范围。因此线性编码对于对数信号是极大的浪费。</p><blockquote><p>  <strong>重要：这幅图用来做什么？</strong></p><p>  ​首先注意，他不是针对像素说的：不是指一个像素的亮度值和这个像素的曝光值的映射。</p><p>  ​<strong>这幅图表达的是</strong>：当我确定一个曝光范围的时候，可以<strong>表示哪个线性范围的图像亮度</strong>。例如：曝光值范围是8的时候可以表示[0-1]的亮度。当曝光范围变成4,那么小于-4的值就是噪声了，这个时候我们发现图像的大部分亮度范围（观察线性亮度的范围）还在，只是丢失了很小一部分的颜色。<strong>这幅图要讨论的就是这个：用更少的编码位数（动态范围）表示图像大部分的亮度范围（线性亮度）。</strong></p></blockquote><p>​<strong>重要：我们进行图像的亮度操作通常有两种：Gamma操作（指数操作）和亮度缩放（亮度乘法），下面我们讨论这两种操作在EV stops上会产生什么影响！</strong></p><h2 id="曝光操作（亮度乘法）在EV-空间怎么样的？"><a href="#曝光操作（亮度乘法）在EV-空间怎么样的？" class="headerlink" title="曝光操作（亮度乘法）在EV 空间怎么样的？"></a>曝光操作（亮度乘法）在EV 空间怎么样的？</h2><p>​在EV空间的常见操作是调整曝光值（在我们的游戏开发过程中通常的方法是：<strong>亮度</strong>结果直接<strong>乘一个系数</strong>）。<strong>我们现在讨论这个直接进行亮度乘法会给曝光范围（EV stops）带来什么影响。</strong></p><p>​很显然对数空间（EV空间，就是右上角的值）的加法相当于对应的线性空间（亮度空间）的乘法，亮度空间的乘法：</p><p>$$ 2^{x+y} &#x3D;&#x3D; 2^x * 2^y $$</p><p>​从下图可以看出曝光的操作（亮度乘法）没有修改动态范围（EV的范围）：</p><p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/exposure.gif" alt="exposure.gif"></p><blockquote><p>  ​为什么会是上图的样子呢？</p><p>  ​因为图像在变化的过程中，有效位只有8位，当亮度乘一个系数的时候相当于乘了一个 pow(2,N)，在对数空间相当于做了整体的加法，也可以看做做了左右移位的操作。由于有效位数没有变，所以变化范围只能在这8位以内。也就是动态范围只有8。</p></blockquote><h2 id="Gamma操作（指数操作）在EV空间是怎么样的？"><a href="#Gamma操作（指数操作）在EV空间是怎么样的？" class="headerlink" title="Gamma操作（指数操作）在EV空间是怎么样的？"></a>Gamma操作（指数操作）在EV空间是怎么样的？</h2><p>​这就是事情开始变得有趣的地方。Gamma操作（这里实际上泛指的就是幂函数**exp()**，而不是特指图像Gamma变化）通常被定义为线性空间中的一个简单幂函数。</p><p>​Gamma操作：</p><p>$$ gamma(x,y) &#x3D; x^y $$   </p><p>​<strong>对亮度进行Gamma操作：下面的公式x表示曝光范围，描述的是在亮度空间进行Gamma操作之后转换回EV空间后，看看EV stops(也就是x)发生了什么变化：</strong></p><p>$$ log_2(gamma(2^x,y)) &#x3D;&#x3D; log_2(2^{x*y}) $$  </p><p>​<strong>进一步变化，说明亮度的Gamma操作相当于对动态范围（EV值）的乘法：</strong></p><p>$$ log2(2^{x<em>y}) &#x3D;&#x3D; x</em>y $$</p><p>​Gamma的操作对应了<strong>EV值的乘法</strong>（乘法就是压缩或者拉伸）。这是一个被GPU利用的性质：通过一系列的exp2，madd和log2操作来表示power操作。</p><blockquote><p>  怎么理解？</p><p>  就是说Gamma空间的颜色值进行了指数运算，相当于对曝光空间（EV stop 曝光步长）进行了压缩或者拉长。见下图。</p></blockquote><p>​<strong>因此伽玛操作本质上是动态范围压缩&#x2F;扩展操作!</strong></p><p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/gamma.gif" alt="gamma.gif"></p><p>​<strong>你可以看到它对原来的8位动态范围发生了变化。所以Gamma操作（幂操作或者log操作）可以压缩或者增加动态范围。</strong></p><h2 id="对比度Contrast"><a href="#对比度Contrast" class="headerlink" title="对比度Contrast"></a>对比度Contrast</h2><blockquote><p>  这里的对比度Contrast指的是一种维持颜色明暗的类似Gamma的操作，不是指图像的对比度。</p></blockquote><p>​Gamma操作是一个有用的操作，但是用作增加动态范围的时候，整个图像比原来亮了。压缩动态范围的时候，整个图像的颜色都变暗了。这是因为锚点定在了0，线性空间颜色的最大值不会因为EV空间的动态范围变化而变化。这并不是我们想要的属性。<strong>在调整动态范围的过程中（Gamma操作的时候），我们希望图像保证亮度一致性。我们可以补偿亮度！用到的策略就是修改锚点—-例如使用中间灰度作为中间锚点。</strong></p><p>​对比度和gamma很像，但是希望在调整动态范围的时候，保证其他的某个点的颜色不变而不是亮度为1的点不变（<strong>这里还没有讨论到hdr，所以最亮的位置是1</strong>）。例如中间灰度点0.18。</p><p>​对比度计算公式:</p><p>$$ contrast(x, y, midPoint) &#x3D; \frac{x^y * midPoint }{ midPoint^y} $$</p><h2 id="这些内容如何应用到局部曝光上（可以略过）"><a href="#这些内容如何应用到局部曝光上（可以略过）" class="headerlink" title="这些内容如何应用到局部曝光上（可以略过）"></a>这些内容如何应用到局部曝光上（可以略过）</h2><p>​希望有了这些知识，我们就能明白为什么局部曝光相对于其他对比和Gamma操作能更好地保持局部对比、饱和度。他移动了部分的颜色直方图（颜色过亮或者过暗的区域）但是：</p><ol><li>只应用在了部分图像，没有影响中间调。</li><li>只移动值，没有想Gamma一样压缩或者缩放。</li></ol><p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/gamma_vs_both.gif" alt="gamma_vs_both"></p><h2 id="EOTF和OETF"><a href="#EOTF和OETF" class="headerlink" title="EOTF和OETF"></a>EOTF和OETF</h2><p>​在谈论输出函数的时候，显示设备使用的电信号转换函数（EOTF – Electro Optical Transfer Function）和他的逆转函数（OETF, Opto-Electrical Transfer Function）是很重要的。</p><p>​EOTF已经存在了很长时间， 所有CRT显示器对于电压强度的响应方式在某些条件下被认为是一致的。</p><p>​下图是CRT显示器对于输入电压和输出亮度的函数关系。</p><p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/crt_gamma.gif" alt="crt_gamma.gif"></p><p>​早期的渲染管线完全忽视了Gamma并且直接使用它的感知线性属性，直接输出被显示器进行Gamma Power编码后的值。<strong>当你开始认真对待线性空间时，我们才开始使用它的逆函数-OETF，这也是我们为显示器编码信号的策略，例如： sRGB or Rec709。</strong></p><p>​<strong>重要：当我们不再使用CRT显示器的时候，这种指数编码同样被验证在现代显示器上是有用的，他允许我们能够编码更多的信号</strong>（参考前面的Gamma变化可以压缩动态范围）。现在我们使用BT1886标准（指的是EOTF）<strong>用来模拟老式CRT显示器的gamma电压响应。</strong></p><blockquote><p>  这里讨论的就是我们能够通过Gamma编码<strong>在文件当中保存更大的动态范围</strong>，随后再利用显示器自带的EOTF解码以得到正确的效果。</p></blockquote><p>​<a href="https://kb.portrait.com/help/bt-1886-10-questions-10-answers">BT1886问答</a></p><p>​下面是BT1886标，注意他是在指数空间：</p><p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/1579405297828.png" alt="1579405297828"></p><h2 id="显示器OETF和gamma2-2编码"><a href="#显示器OETF和gamma2-2编码" class="headerlink" title="显示器OETF和gamma2.2编码"></a>显示器OETF和gamma2.2编码</h2><p>​我们现在回顾显示器的2.2 Gamma。因为EOTF是2.2，所以OETF就是1&#x2F;2.2（大概就是0.45），这就是我们的Gamma函数，将颜色从线性空间转换到gamma空间，我们会得到一个2.2*8（&#x3D;17.6）的动态范围。（可以保存在文件中的）。</p><p> $$OETF &#x3D;  gamma(color, \frac{1}{2.2}) $$  </p><p> $$EV stops &#x3D; log_2(gamma(2^x, \frac{1}{2.2}))  &#x3D; 2.2*x$$   </p><p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/dynrange_gamma_2_21.png" alt="dynrange_gamma_2_2.png"></p><blockquote><p>  sRGB标准包括了很多内容，Gamma编码只是其中一部分。</p><p>  下图来源于wiki，sRGB标准中linear空间进入Gamma空间的公式。</p><p>  <img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/1579420987252.png" alt="1579420987252"></p></blockquote><p>​现在有人会问，我以为显示器使用sRGB函数，（它在较小值的位置使用了线性函数，其他位置用了2.4的指数。）</p><p>​为什么我不使用精确的sRGB? 在这篇文章中，<strong>我将直接使用gamma 2.2，为了简化说明。</strong></p><blockquote><p>  对于大部分制作软件，和显示器都依赖sRGB标准。在渲染当中我们通常用2.2进行编码解码。</p></blockquote><p>​<strong>这里值得注意的是，仅仅是伽玛2.2的线性值编码在8位就有了很大的动态范围（翻倍）。那么17.6的曝光级别足够了么？</strong>我们得到了更大的分布，尤其是在y轴上变得更均匀了。但是现在仍然不完美，因为现在把太多的值放在了表示阴影上，更多的变化集中在高亮度区间（而不是中等亮度区间，<strong>也就是说高亮度区间对于数值的变化更敏感</strong>）。我们随后在处理。</p><p>​另一方面，使用gamma2.2的OETF（使用了17.6的曝光级别）意味着我们不需要HDR显示和局部的tonemapping了？并不是！仔细想想在1&#x2F;256和2&#x2F;256之间有多少信息？2.2的 EV对于观察者意味着什么？他们可能根本注意不到，因为范围亮度变化太小了。<strong>不同的显示器有不同的曝光范围，并且依赖于观察环境（就是显示器周围的环境）</strong>。参考<a href="http://gpuopen.com/gdc16-wrapup-presentations/">Presentation by Timothy Lottes</a> 。</p><blockquote><p>  有一个地方值得说明：</p><p>  EOTF 的标准只有一个BT1886</p><p>  但是为了这种显示器编码的OETF标准有各种各样。</p></blockquote><p>​但是在我继续深入分析tonemapping是如何改变它的以及gamma真正做了什么之前，我做了一个关于观察条件的小实验。</p><h2 id="观察条件"><a href="#观察条件" class="headerlink" title="观察条件"></a>观察条件</h2><p>​下面是一张iPhone照片，照片中的笔记本上显示了一张图片。这是对于笔记本来说完美的观察环境（拉上了窗帘），笔记本中的图片细节都看的很清楚。</p><p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/2016-08-21-13-31-05.jpg" alt="2016-08-21 13.31.05.jpg"></p><p>由于手机没有捕获足够的动态范围，但是看着可以，所有的细节都捕获了，大量的细节在阴影当中。</p><p>有趣的是HDR的场景和影子看起来非常暗，但是充满了细节和亮点。在这样的完美观察环境中，我不要任何的调整就能够感觉到图像和显示器就是hdr的。</p><p>第二张图片在平均视觉条件当中：</p><p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/2016-08-21-13-29-59.jpg" alt="2016-08-21 13.29.59.jpg"></p><p>正常图片仍然是清晰可以观察到的，尽管暗处丢失的细节不可见。</p><p>图像看起来有了更强烈的明暗差别，但是Kratos的背部完全看不到了。</p><ul><li><strong>Bartleson–Breneman effect:</strong> 图像对比度(发光显示器的图像，如液晶显示器上的图像)随着周围照明的亮度增加。</li></ul><p>第三张我们在极强的亮度条件下</p><p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/2016-08-21-13-30-31.jpg" alt="2016-08-21 13.30.31.jpg">条</p><p>这个时候超过的屏幕的亮度，屏幕内容已经变得不可见了。</p><p>增强亮度，可以看到屏幕细微的变化：</p><p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/2016-08-21-13-30-31_c.jpg" alt="2016-08-21 13.30.31_c.jpg"></p><p>​图像不但不可见了，而且丢失了大量的细节，并且还被屏幕的反射覆盖了。几乎没有Gamma设置能够改善这样的情况。</p><p>​实验的目的是为了说明：<strong>Timothy Lottes在他的演讲中所展示的——观看条件（看显示器的环境）定义了可感知（人眼的实际感受）的动态范围，和图像的清晰度。</strong></p><p>​从数值上理解就是，由于亮度太高你无法分辨0.25以下的值。这就是这个场景动态范围的结果：</p><p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/poor_viewing_conditions2.png" alt="poor_viewing_conditions.png"></p><p>曝光范围在4.4EV的位置就停止了，所以我们需要做一些局部的tonemapping。</p><h2 id="EOTF和OETF的视觉条件"><a href="#EOTF和OETF的视觉条件" class="headerlink" title="EOTF和OETF的视觉条件"></a>EOTF和OETF的视觉条件</h2><p>​<strong>观察环境</strong>和<strong>感知能力</strong>是存在不同的gamma EOTF曲线和OETF曲线的原因。Rec709 EOTF （给高清电视用的）和sRGB（给显示器和打印机用的）的转换曲线是不同的（<strong>2.4</strong> vs <strong>2.2</strong>），因为高清电视在较暗的观看条件下需要不同的对比度和人眼感知效果（2.4有更大的动态范围）。</p><blockquote><p>  Rec709和sRGB除了Gamma不同之外还有很多特性需要注意，还涉及到文件传输，保存，显示特性，这里不做详细讨论。值得注意的是，Rec. 709和sRGB具有相同的主色性。</p></blockquote><p>​由于Bartleson-Breneman效应（<strong>当周围环境变得更明亮时，我们感知到更多的对比度，更少的动态范围</strong>，因为动态范围由最小可表示精度决定，太亮的地方，看暗处的感受就不明显了。），客厅在晚上和标准办公环境(sRGB)需要不同的EOTF。Rec709 EOTF伽马将意味着输出设备产生更多的对比度。（<strong>Gamma更大，图像亮度更亮</strong>）</p><p>​因此使用，翻转函数，OETF of Rec709能够保存更大的曝光范围，并且TV支持他们的显示并且TV的使用环境我们认为偏暗，所以会足够好。</p><blockquote><p>  在比较暗的环境中，因为人感受到更少的对比度（明暗对比），更大的动态范围（暗处的细节），我们希望提高屏幕亮度，降低对比度，使用比较大的gamma值。（晚上的客厅）</p><p>  在比较亮的环境中，因为人感受到更多的对比度，更x小的动态范围，我们希望降低屏幕亮度，提升对比度，使用比较小的gamma值。（办公环境）</p></blockquote><p>​下面是两个曲线的对比：</p><p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/gamma_2_2vs2_4.gif" alt="gamma_2_2vs2_4.gif"></p><p>​Gamma2.2和2.4并不是唯一的标准，不同的软件和硬件还有不同的标准。你可以找到历史参考苹果Mac gammas 1.8或2.0。Gameboy使用了极限的gammas 3.0或4.0</p><h2 id="Adjust-gamma-until-logo-is-barely-visible"><a href="#Adjust-gamma-until-logo-is-barely-visible" class="headerlink" title="Adjust gamma until logo is barely visible"></a>Adjust gamma until logo is barely visible</h2><p>​由于不同的观察条件（在不同的灯光环境看显示器），是我们看到下面这张图的原因：</p><p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/logo.png" alt="logo.png"></p><p>​<strong>有的时候这个东西没有名字，有时候叫做Slider,有时候叫做Gamma，有时候叫做对比度、亮度，这些都是不对的，但是他们本质的功能是调节不完美的观察条件,以让人能够正确的观察到屏幕效果。</strong></p><p>​在亮度环境范围，会造成一个对比度的降低了的环境，需要动态范围压缩的操作（降低Gamma值，让图像变暗），观察者能够感受到更强的对比度。</p><blockquote><p>  试想一下</p><p>  在特别亮的灯光环境下，应该把它调亮，这个时候相当于增加动态范围，增加Gamma，这个时候对比度降低了。</p><p>  当周围环境变得更明亮时，我们感知到更多的对比度，更少的动态范围。所以我们要增加动态范围降低对比度，以保证观察效果。</p></blockquote><p>这个设置通常是有用的，但是问题在于：</p><ol><li>通常用户值只设置一次，却在不同的环境玩游戏。设置一次但是在白天、晚上、晚上开灯的时候玩游戏。</li><li>这个功能的目的没有合理的表达出来。这个调节结果依赖于室内环境的亮度和内容被观察的环境。</li></ol><p>​假设在一个很糟糕的观察条件下。环境特别亮，这个时候我们如何调整显示器的Gamma值?(在EOTF以外的操作)。</p><p>​这个是时候我们需要提高动态范围，降低对比度。所以在输出之前的OETF编码需要进行修改，使用0.7的改变图像的动态范围（我们对于显示器的EOTF没有做任何事情）:</p><p>$$ (x^{0.7})^{1&#x2F;2.2} &#x3D;&#x3D; x^{0.7&#x2F;2.2} $$</p><p>注意下面的公式是编码到Gamma空间的编码方式，上面的内容就是保存更大的动态范围：</p><p>$$ x^{1&#x2F;2.2} $$</p><p>图示：</p><p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/poor_viewing_conditions1.gif" alt="poor_viewing_conditions.gif"></p><p>​这样我们就增加了1.42左右的曝光范围。然而，在好的观察条件下（从特别明亮的环境，回到晚上），效果有会变的很差。</p><blockquote><p>  这部分需要注意了： 我们没有对显示器本身的EOTF做任何事情，只是单纯的修改了图像编码到Gamma空间的函数，也就是我们提升了这个图像保存时的动态范围。然后在显示出来。</p><p>  这个时候就有一个问题，Gamma的编码和解码不配套，而按照标准资源制作流程都是sRBG。这里需要注意两点：</p><ol><li>我们是在游戏渲染中常常用到这种策略。</li><li>修改原始图像的动态范围，表示我们的图像在动态范围做了伸缩，而显示器本身还有自己的动态范围的伸缩，并没有改变颜色，Gamma空间就是单纯的动态范围伸缩而已！另外，注意动态范围并不是数据精度的bit。</li></ol></blockquote><h2 id="ToneMapping操作"><a href="#ToneMapping操作" class="headerlink" title="ToneMapping操作"></a>ToneMapping操作</h2><p>​从上面的分析来看我们不需要tonemapping的曲线。毕竟在适当的观测条件下，采用直接的线性编码可以获得较大的动态范围。</p><p>这里有两个问题：</p><ol><li><p>其一是非正规分布的数据，较高的曝光区域占据了很大的范围。我们希望更大的动态范围保存中等亮度的值。</p></li><li><p>通常1定义了一个白色点，但是在没有上限的HDR渲染上，曝光之后，我能够保证在中等范围有足够的值，我们也能够在亮度区域有足够的动态分布。这在PBR渲染当中是确实存在的。</p><p>​目前提供的方法还没有为那些非常明亮的对象提供任何解决方案，我们不想降低对比度或改变曝光，我们不想让它们完全失去饱和度;我们仍然希望看到一些细节。</p></li></ol><p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/proper_exp_linear.png" alt="proper_exp_linear"></p><p>​上图的曝光效果完全剪裁掉了亮度区域。</p><p>​这个时候就是tonemapping发挥作用的地方。一些常见的例子： Reinhard。我绝不推荐这条曲线，还有更好的选择。</p><p>可能每个引擎都实现了一个参考曲线： <a href="http://filmicgames.com/archives/75">Hable Uncharted tonemapping curve</a>.</p><p>另一个选择是：<a href="https://github.com/ampas/aces-dev">ACES</a></p><p>或者开销更低的：ACES RRT and ODT， <a href="https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/">Kris Narkowicz proposed</a>.</p><p>最后，我个人认为非常方便的选择是精心设计的：<a href="http://gpuopen.com/gdc16-wrapup-presentations/">generic filmic tonemapping operator from Timothy Lottes</a>.</p><p>我不在这里集中讨论它们，而是尝试用最简单的形式来解释:</p><p>$$  tonemap(x) &#x3D; x&#x2F;(1+x) $$</p><p>这是一条永远不会到达白点的曲线，因此通常使用重新调平校正因子（除以白点值）</p><p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/reinhard.png" alt="reinhard.png"></p><p>上图是白点值定义为128的tonemapping曲线。</p><p>​这看起来很棒——我们不仅获得了超过7个曝光点，在不影响中间色调和暗部的情况下，将它们紧紧地包裹在亮色中，而且在最终编码中EV的分布看起来几乎完美!</p><p>​它还可以(在一定程度上)分辨出比EV 0(曝光后)的原始亮度高得多的物体的细节——比如发射物、发光粒子、火焰、明亮的镜面反射。任何没有比128更“热”的东西都会得到一些区别和表现。</p><p>​最好的方案是 <a href="http://graphicrants.blogspot.com/2013/12/tone-mapping.html">firefly fighting in post effects or general variance reduction</a>. 更好的解决方案，能想要在tonemapping上做更多的事情：在暗部添加一些饱和度和对比度的视觉矫正（filmic曲线的toe部分）等。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://renderwonk.com/publications/s2010-color-course/">http://renderwonk.com/publications/s2010-color-course/ </a>SIGGRAPH 2010 Course: Color Enhancement and Rendering in Film and Game Production</p><p><a href="http://gpuopen.com/gdc16-wrapup-presentations/">http://gpuopen.com/gdc16-wrapup-presentations/</a>  “Advanced Techniques and Optimization of HDR Color Pipelines”, Timothy Lottes.</p><p><a href="http://filmicgames.com/archives/75">http://filmicgames.com/archives/75</a> John Hable “Filmic Tonemapping Operators”</p><p><a href="https://github.com/ampas/aces-dev">https://github.com/ampas/aces-dev</a> Academy Color Encoding Standard</p><p><a href="https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/">https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/</a> ACES filmic tonemapping curve</p><p><a href="http://graphicrants.blogspot.com/2013/12/tone-mapping.html">http://graphicrants.blogspot.com/2013/12/tone-mapping.html</a> Brian Karis “Tone-mapping”</p><h2 id="重要总结"><a href="#重要总结" class="headerlink" title="重要总结"></a>重要总结</h2><ol><li>为什么要讨论动态范围？ 其实和软件无关，这是一个硬件上的内容，是为了描述硬件设备可表示信号的区分度。文中有一段话：</li></ol><p>​<strong>因为0表示没有信号，所以使用1&#x2F;256（对数为 $ log_2(\frac{1}{258}) &#x3D; -8 $）表示最小可表示信号（小于这个值的都是噪声），1为最高可表示信号（对数为 $ log_2(1) &#x3D; 0 $）,所以动态范围是8。</strong></p><p>​<strong>这完全是因为在8bit的数据格式下，我们能表达的最小亮度就是1&#x2F;256，我们无法表达更小的颜色了。</strong>所以亮度的范围就是[1&#x2F;256 ，1]。 在二进制上就是8个级别，就是我们的8 EV stops。</p><p>​通过Gamma编码之后： 这个值变成了  $ {(2^{-8}) }^{\frac{1}{2.2}} $   &#x3D; $ {(2^{-3.6}) } $。</p><p>​**最小值变大了！也就是说我们可以表示更暗的颜色了!**，但是数据还是8bits。我们能表示的亮度级别变成了17.6.也就是我们的sRGB能够表达17.6EV stops。</p><ol start="2"><li><p>一定要记住，Dynamic Range(动态范围，8 EV stops)不是数据格式（8 bits的图像格式）。8bits的通道可以保存17.6 EV stops的动态范围。Gamma的作用就是在固定的数据量下，保存更多的亮度变化范围。</p></li><li><p>整个显示过程中存在两次动态范围的变化，一次是制作软件完成制作，保存到sRBG（17.6 EV stops的动态范围），用了OTEF。显示器显示时，自身的EOTF（CRT是自带的，最新显示器是专门附加的）从17.6 EV stops解码回正确的亮度值。</p></li><li><p>人眼对很高的动态范围感知，但是依赖于环境。嘈杂的环境听不到耳语。强光看不到暗处的细节。所以需要游戏中调节滑块的功能，修改显示器的显示动态范围大小。</p></li><li><p>一般的显示器本身的动态范围有限，过渡的拉伸会导致亮部被剪裁掉。所以HDR显示器就是有更大的动态范围。</p></li><li><p>游戏当中Gamma的编码和解码可能不配套，因为需要Gamma矫正。如果编码用了更大的动态范围（这个时候显示器的动态范围不变），相当于把整个图像变亮了。（提高动态范围会增加图像亮度，这是Gamma本身的特性）这一点很容易体现在数据大小上。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>毛发方案分析</title>
      <link href="/2022/07/09/RTR/%E6%AF%9B%E5%8F%91%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/"/>
      <url>/2022/07/09/RTR/%E6%AF%9B%E5%8F%91%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="怪物猎人世界中宠物的毛发与Fins-amp-Shells模型"><a href="#怪物猎人世界中宠物的毛发与Fins-amp-Shells模型" class="headerlink" title="怪物猎人世界中宠物的毛发与Fins&amp;Shells模型"></a>怪物猎人世界中宠物的毛发与Fins&amp;Shells模型</h1><p>最近策划决定项目中要使用怪物猎人世界中宠物的毛发方案。所以做了简单的分析。</p><p>目前发现怪物猎人当中的宠物，使用的是MotionBlur的方式来生成浓密毛发的。</p><p>经过实验大致实现步骤如下：</p><ol><li>有毛发部位需要一张<strong>毛发流向图</strong>或者<strong>将毛发流向写入顶点色</strong>来描述毛发走向。这个阶段需要在绘制毛发Gbuffer的过程中，<strong>将毛发走向填充到一张走向buffer当中</strong>或者<strong>单独进行一次流向渲染</strong>。</li><li>使用屏幕空间的毛发走向图，进行一次运动模糊。</li></ol><h2 id="毛发基础材质制作"><a href="#毛发基础材质制作" class="headerlink" title="毛发基础材质制作"></a>毛发基础材质制作</h2><p>毛发的基础材质就是基础的PBR材质即可。</p><p>包括diffuse、metallic、smoothness、normal。主要用来表述整个毛发的材质。</p><h2 id="毛发噪声纹理制作"><a href="#毛发噪声纹理制作" class="headerlink" title="毛发噪声纹理制作"></a>毛发噪声纹理制作</h2><p>毛发噪声直接作为一个噪声乘上diffuse，作为最终的diffuse。</p><p>下面是一张可用的噪声，</p><p><img src="/../../images/img/furnosie.png" alt="furnosie"></p><p>让后直接进行模糊即可。</p><p><strong>TODO：</strong></p><h1 id="Fins-amp-Shells模型"><a href="#Fins-amp-Shells模型" class="headerlink" title="Fins&amp;Shells模型"></a>Fins&amp;Shells模型</h1><p>标准的壳模型，</p>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>法线空间变换推导</title>
      <link href="/2022/07/09/RTR/%E6%B3%95%E7%BA%BF%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/"/>
      <url>/2022/07/09/RTR/%E6%B3%95%E7%BA%BF%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="法线空间变换推导"><a href="#法线空间变换推导" class="headerlink" title="法线空间变换推导"></a>法线空间变换推导</h1><p>问题：法线在遇到非统一的缩放时会出现问题。</p><p>解决方案：使用变化矩阵的逆转矩阵进行变换。</p><p>推导：$ M ​$ 为变换矩阵。$ t ​$ 切线。$ n ​$ 为法线。$ p $ 为模型坐标。</p><p>​         正常的模型变换为：  $$ p’ &#x3D; M * p ​$$</p><p>​ 这个变换对切线也适用：$$ t’ &#x3D; M * t ​$$</p><p>​ 而法线不行$ n’  \neq  M * n $。对于法线我们通过 $$ dot(n, t) &#x3D;  n^{T}  * t &#x3D;  0 $$  这个条件来推到用于法线变换的矩阵$ S $。</p><p>*注：上面没有用$ dot ​$操作的$n​$和$t​$ 当做 $1 * 3​$的矩阵看待。</p><p>​ $$ 0 &#x3D; (n’)^T * t’  &#x3D; (Sn)^T * (Mt) &#x3D; n^T * S^T * M * t &#x3D; n^T * (S*M)*t$$ </p><p>所以$I &#x3D; SM$ ,所以$S$是$M$的逆转矩阵.</p><p>​操作 $$n’ &#x3D; (M^T )^{-1}  * n  ​$$  </p><p>​                       $$(n’)^t &#x3D; n^T * M^{-1}​$$ </p><p>在Unity当中$mul$操作结束以后$ n’  $ 和 $(n’)^t$都是$float3$ </p><p>所以：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">n_WorldSpace = mul(n_ObjectSpace, unity_WorldToObejct) ;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>手机Tiled-BasedRender和GPU带宽</title>
      <link href="/2022/07/09/RTR/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/"/>
      <url>/2022/07/09/RTR/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="手机Tiled-BasedRender和GPU带宽"><a href="#手机Tiled-BasedRender和GPU带宽" class="headerlink" title="手机Tiled-BasedRender和GPU带宽"></a>手机Tiled-BasedRender和GPU带宽</h1><h2 id="带宽的概念"><a href="#带宽的概念" class="headerlink" title="带宽的概念"></a>带宽的概念</h2><p>参考资料:</p><p><a href="https://developer.apple.com/documentation/metal/gpu_selection_in_macos/understanding_gpu_bandwidth">Apple官方文档</a></p><p><em>Bandwidth</em> refers to the external bandwidth between a GPU and its associated system. It’s a measure of the data transfer speed across the bus that connects the two (for example, PCIe or Thunderbolt). Bandwidth doesn’t refer to the internal bandwidth of a GPU, which is a measure of the data transfer speed between components within the GPU.</p><p>内存一共有两种，设备内存和系统内存：</p><p>资源使用方式：</p><p>1.所有数据都放在系统内存</p><p><img src="/../../images/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/d1b485f2-df04-403f-b665-44e91c8bec0b.png" alt="A system diagram showing two shared resources in the same system memory that can be accessed by a discrete GPU via a PCIe bus and by an external GPU via a Thunderbolt 3 bus."></p><p>2.所有数据放到设备内存</p><p><img src="/../../images/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/dd271bd5-dfd5-479a-80bb-67eb01405346.png" alt="A system diagram showing two private resources in separate video memory that can be accessed directly by a discrete GPU and an external GPU."></p><p>3.同时放到设备系统内存</p><p><img src="/../../images/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/f3cf8929-b6e6-47de-8cf3-307313202472.png" alt="A system diagram showing two managed resources with one copy in the same system memory and another copy in separate video memory. The resource copies in system memory can be accessed by a discrete GPU via a PCIe bus and by an external GPU via a Thunderbolt 3 bus. The resource copies in video memory can be accessed directly by a discrete GPU and an external GPU."></p><p>可以看到，经过PCIe访问的数据就会产生带宽。</p><p><a href="https://developer.samsung.com/game/gpu-framebuffer">三星文档</a></p><h2 id="渲染模式的推导"><a href="#渲染模式的推导" class="headerlink" title="渲染模式的推导"></a>渲染模式的推导</h2><p>带宽和Cache导致了手机不得不使用Tiled Based Rendering。</p><h3 id="立即模式的渲染Immediate-Mode-Renderer-“IMR”"><a href="#立即模式的渲染Immediate-Mode-Renderer-“IMR”" class="headerlink" title="立即模式的渲染Immediate-Mode Renderer (“IMR”)"></a>立即模式的渲染Immediate-Mode Renderer (“IMR”)</h3><p>如下图所示可以看到，每次读取数据，写出数据，都占用大量带宽。</p><p><img src="/../../images/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/tech_GPUFramebuffer_03.svg" alt="Pipeline of an &#39;immediate-mode&#39; renderer"></p><p>IMR模式的渲染每次会有大量的栅格化写出，这部分内容是没有规律的。所以像素会反复写出。</p><p>这种状态下有一个Cache，是行级别的。</p><p><img src="/../../images/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/1569317001543.png" alt="1569317001543"></p><p>这里有一个极大的前提就是，Cache是有限的！！！</p><h3 id="Tiled-memory"><a href="#Tiled-memory" class="headerlink" title="Tiled memory"></a>Tiled memory</h3><p>第一个策略是把屏幕分块Cache，这样内存功能更加有规律。内存的传输不是太频繁了。</p><p><img src="/../../images/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/1569317024532.png" alt="1569317024532"></p><h3 id="Rasterizing-within-tiles"><a href="#Rasterizing-within-tiles" class="headerlink" title="Rasterizing within tiles"></a>Rasterizing within tiles</h3><p>上面的问题是，如果一个三角跨越整个屏幕的三角形会打破Cache。</p><p>进一步的优化，是基于Tiled进行光栅化：we can draw all the pixels that the triangle covers within one tile before moving on to the next tile.</p><h3 id="Binning"><a href="#Binning" class="headerlink" title="Binning"></a>Binning</h3><p>进一步优化，我们现在不只是基于Cache去光栅化，而是直接基于Tiled计算所有的三角形。</p><ol><li>第一步就是计算每个tile中的所有三角形。</li></ol><p> Note that this process involves vertex shading, since this affects the location of triangles, but not fragment shading.</p><p><img src="/../../images/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/1569318032142.png" alt="1569318032142"></p><h3 id="Tile-based-rasterization"><a href="#Tile-based-rasterization" class="headerlink" title="Tile-based rasterization"></a>Tile-based rasterization</h3><p>第二步就是基于Tile的栅格化。</p><p>Once the geometry has been sorted into bins, the rasterizer can process the scene one bin at a time, writing only to local tile memory until processing of the tile is finished.</p><p>由于一个一个处理所以Cache被压缩成了一个Tile,而不再需要多个Cache进行缓存了。</p><p>Since each tile is processed only once, the “cache” is now reduced to a single tile. </p><p>新的流程:</p><p><img src="/../../images/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/tech_GPUFramebuffer_16.svg" alt="Pipeline of a tiled renderer"></p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>Frame buffer memory bandwidth is greatly reduced, reducing power and increasing speed.<ul><li>Mobile memory is typically slower and lower power than desktop systems, and bandwidth is shared with the CPU, so access is very costly.</li></ul></li><li>With API support, off-chip memory requirements may also be reduced (it may not be necessary to allocate an off-chip Z buffer at all, for example).</li><li>Texture cache performance can be improved (textures covering multiple primitives may be accessed more coherently one tile at a time than one primitive at a time.</li><li>Much less on-chip space is needed for good performance compared with a general-purpose frame buffer cache.<ul><li>This means that more space can be dedicated to texture cache, further reducing bandwidth.</li></ul></li></ul><h3 id="Limitations-of-tile-based-rendering"><a href="#Limitations-of-tile-based-rendering" class="headerlink" title="Limitations of tile-based rendering"></a>Limitations of tile-based rendering</h3><p>While there are many performance advantages to tile-based rendering, there are some restrictions imposed by the technique:</p><ul><li>The two-stage binning and fragment passes introduce latency<ul><li>This latency should be hidden by pipelining and improved performance, but makes some operations relatively more costly</li><li>In pipelined tiled rendering, framebuffer and textures required for rendering should be double-buffered so as to avoid stalling the pipeline。</li></ul></li><li><strong>Framebuffer reads that might fall outside the current fragment are relatively more costly</strong><ul><li><strong>Operations such as screen-space ray tracing require writing all the framebuffer data - removing the ability to discard full-resolution images and depth values after use</strong></li></ul></li><li>There is a cost to traversing the geometry repeatedly<ul><li>Scenes that are vertex-shader bound may have increased overhead in a tiler</li></ul></li><li>The binning pass may have limitations<ul><li>Some implementations may run out of space for binning primitives in very complex scenes, or may have optimizations that are bypassed by unusual input (such as highly irregular geometry)</li></ul></li><li>Switching to a different render target and back involves flushing all working data to memory and later reading it back<ul><li>For a tiler, it is especially important that shadow and environment maps be generated before the main frame buffer, not “on demand” during final rendering (though this is good advice for most GPUs)</li></ul></li><li>Graphics state (such as shaders) may change more frequently and less predictably<ul><li>Geometry that is “skipped” means that states do not necessarily follow in turn, making incremental state updates hard to implement</li></ul></li></ul><p>In most cases, the behavior of a tile-based GPU should not be appreciably worse than for an immediate-mode renderer using similarly limited hardware (indeed, some hardware can choose whether or not to run in a tiled mode), but it is possible to remove the performance benefits of tile-based rendering with the wrong use pattern.</p>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>蒙特卡洛方法</title>
      <link href="/2022/07/09/RTR/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%96%B9%E6%B3%95/"/>
      <url>/2022/07/09/RTR/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="蒙特卡洛方法"><a href="#蒙特卡洛方法" class="headerlink" title="蒙特卡洛方法"></a>蒙特卡洛方法</h1><p>wiki解释:<a href="https://zh.wikipedia.org/wiki/%E8%92%99%E5%9C%B0%E5%8D%A1%E7%BE%85%E6%96%B9%E6%B3%95">蒙特卡洛</a></p><p>重点在于：蒙特卡罗方法在数学中的应用，下面摘要了关键的部分。</p><h2 id="蒙特卡洛积分"><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a>蒙特卡洛积分</h2><p>非权重蒙特卡罗积分，也称<strong>确定性抽样</strong>，是对被积函数<strong>变量区间</strong>进行<strong>随机均匀抽样</strong>，然后对抽样点的<strong>函数值求平均</strong>，从而可以得到<strong>函数积分的近似值</strong>。</p><p>此种方法的正确性是基于<strong>概率论</strong>和<strong>中心极限定理</strong>)。</p><p>当抽样点数为m时，使用此种方法所得近似解的统计误差只与m有关（与 $$\frac{1}{\sqrt m}$$正相关），不随积分维数的改变而改变。因此当积分维度较高时，蒙特卡罗方法相对于其他数值解法更优。</p><h2 id="蒙脱卡洛方法推导"><a href="#蒙脱卡洛方法推导" class="headerlink" title="蒙脱卡洛方法推导"></a>蒙脱卡洛方法推导</h2><p>首先，有<strong>一组</strong>独立同分布的随机变量 $ { X_i } $ 。注意这是独立同分布的集合包括了多个随机变量。</p><p>每一个随机变量 $ X_i $ 在 $ [a,b] $ 上服从分布 $  f_x $ （概率密度函数PDF，积分为1）。  </p><p>我们构造一个新的函数 $ g^*(x) &#x3D; \frac{g(x)}{f_x{(x)}} $ ， 然后 $ g^*(X_i) $ 也是一个随机变量。</p><p><em><em>关键： $ g^</em>(X_i ) $  的概率为 $ f_x(X_i) $ !!!</em>*</p><p>我们现在计算这个新的随机变量的<strong>期望</strong>：</p><p> $$ E[g^*(X_i)] &#x3D; \int _a^b g^*(x)f_x(x) dx  &#x3D; \int _a^b  g(x) d x &#x3D; I $$ </p><p>根据<strong>强大数定理</strong>：</p><p>$$ Pr(\lim_{N \to \infty } \frac {1}{N} \sum_{i&#x3D;1}^{N} g^*(X_i) &#x3D; I )&#x3D; 1 $$</p><p>我们项构造一个平均值 $ \hat I  $ ，则 $ \hat I  $ 依1概率收敛到 $ I $ ：</p><p>$$ \hat I &#x3D; \frac {1}{N} \sum_{i&#x3D;1}^{N} g^*(X_i)  $$</p><p>在完成以上的准备条件之后，我们进行实际推导：</p><p><strong>问题：</strong> 我们希望求解积分：</p><p>$$  I &#x3D; \int_a^b g(x) dx $$</p><p><strong>求解：</strong></p><ol><li><p>假设函数 $ g(x) $ 分布在 $ [a,b] $ 内可积。</p></li><li><p>构造任意一个概率密度函数 $ f_x (x) $. 满足：</p><p>a.  当 $  g(x)  \neq 0 $ 时， $ f_x(x) \neq 0  $ , $ (a &lt; x &lt; b) $ .</p><p>b.  $ \int_a^b f_x(x) dx &#x3D; 1 $.</p></li></ol><p>引入上面条件,原积分（<strong>期望</strong>）可以写成：</p><p>$ I &#x3D; \int_a^b g^*(x)f_x(x) dx $</p><p>根据强大数定理得到的平均值（<strong>期望估计</strong>）变为：</p><p>$ \hat I &#x3D; \frac {1}{N} \sum_{i&#x3D;1}^{N} g^*(X_i)  $</p><p>根据之前的说明：随着采样次数增多 $ \hat I  $ 依概率1收敛到 $ I $ ：</p><p><strong>所以 $ \hat I  $  可以作为 $ I $ 的一个估计。</strong></p><p>如果 $ f_x $ 是 $ [a , b ] $ 上的一个<strong>均匀分布</strong>的话，那么积分就变成了:</p><p>$ I &#x3D; (b - a) \int_a^b g(x) \frac{1}{b - a} dx $</p><p>均值就变成了 （ $ f_x $ 消失了）：</p><p>$$ \hat I &#x3D; \frac {b - a}{N} \sum_{i&#x3D;1}^{N} g(X_i)  $$</p><p> $ \hat I  $ 就是 $ I $ 的估计，蒙特卡洛积分就是用<br> $$ \frac {b - a}{N} \sum_{i&#x3D;1}^{N} g(X_i) $$<br> 估计<br> $$  \int _a^b  g(x) d x  $$</p><h2 id="蒙特卡洛在渲染当中的应用"><a href="#蒙特卡洛在渲染当中的应用" class="headerlink" title="蒙特卡洛在渲染当中的应用"></a>蒙特卡洛在渲染当中的应用</h2><p>这里主要来自一本书：</p><p>《Monte Carlo Methods in Global Illumination - Photo-realistic Rendering with Randomization》</p><p>主要用来用随机采样的方法解决全局光照渲染的问题。</p><p>因为，全局光照的积分是一个难以求和的积分，刚好符合蒙特卡洛积分的思路。</p>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渲染管线</title>
      <link href="/2022/07/09/RTR/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
      <url>/2022/07/09/RTR/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h1><p>最近回顾了一下基础的图形学内容，发现很多都忘记了，现在认真的总结一下。主要内容都来自<a href="https://docs.microsoft.com/en-us/windows/desktop/direct3d11/overviews-direct3d-11-graphics-pipeline">d3d的官方文档当中提取的图形管线</a>当中。</p><p>下图是一个总览的流程，这个流程主要是针对D3D API可配置的阶段：</p><p><img src="/img/renderpipeline-d3d11-pipeline-stages.jpg" alt="d3d11-pipeline-stages"></p><h2 id="渲染管线总览"><a href="#渲染管线总览" class="headerlink" title="渲染管线总览"></a>渲染管线总览</h2><p>D3D 10和更高级的API支持将渲染管线 划分成不同的功能阶段，下面是每一个阶段的主要描述：</p><table><thead><tr><th align="left">Topic</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">Input-Assembler Stage 输入装配阶段</td><td align="left">the first stage in the pipeline is the input-assembler (IA) stage.第一个阶段是输入装配阶段。</td></tr><tr><td align="left">Vertex Shader Stage</td><td align="left">The vertex-shader (VS) stage processes vertices from the input assembler, performing per-vertex operations such as transformations, skinning, morphing, and per-vertex lighting. （vertexShder阶段主要处理逐顶点操作，包括：transformation，顶点光照，变形，蒙皮等，他的数据来源于IA阶段。）Vertex shaders always operate on a single input vertex and produce a single output vertex（输入输出都是单独顶点）.</td></tr><tr><td align="left">Tessellation Stages</td><td align="left">曲面细分，处理的是表面：三角形。</td></tr><tr><td align="left">Geometry Shader Stage</td><td align="left">处理一系列顶点输入，产生一系列顶点输出。</td></tr><tr><td align="left">Stream-Output Stage</td><td align="left">The purpose of the stream-output stage is to continuously output (or stream) vertex data from the geometry-shader stage (or the vertex-shader stage if the geometry-shader stage is inactive) to one or more buffers in memory (see <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3d11/d3d10-graphics-programming-guide-output-stream-stage-getting-started">Getting Started with the Stream-Output Stage</a>).  将顶点处理的数据传送到一个或者多个内存？</td></tr><tr><td align="left">Rasterizer Stage</td><td align="left">The rasterization stage converts vector information (composed of shapes or primitives) into a raster image (composed of pixels) for the purpose of displaying real-time 3D graphics.  从顶点到图像。</td></tr><tr><td align="left">Pixel Shader Stage</td><td align="left">The pixel-shader stage (PS) enables rich shading techniques such as per-pixel lighting and post-processing. <strong>A pixel shader is a program that combines constant variables, texture data, interpolated per-vertex values, and other data to produce per-pixel outputs.</strong> （pixel Shader主要将常量、纹理数据、逐顶点插值数据等内容来生成像素输出）The rasterizer stage invokes a pixel shader once for each pixel covered by a primitive, however, it is possible to specify a <strong>NULL</strong> shader to avoid running a shader. （光栅化阶段会为每一个被图元覆盖的像素执行一次pixelShader）</td></tr><tr><td align="left">Output-Merger Stage</td><td align="left">The output-merger (OM) stage generates the final rendered pixel color using a combination of pipeline state（OM阶段会根据渲染状态的组合生成最终的颜色：pixel Shader输出，渲染目标，深度&#x2F;stencil buffer内容）, the pixel data generated by the pixel shaders, the contents of the render targets, and the contents of the depth&#x2F;stencil buffers. The OM stage is the final step for determining which pixels are visible (with depth-stencil testing) and blending the final pixel colors**.(OM阶段决定哪个像素可见，深度和stencil测试和blend。）**</td></tr></tbody></table><h2 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h2><h3 id="Input-Assembler-Stage-IA-（未补全）"><a href="#Input-Assembler-Stage-IA-（未补全）" class="headerlink" title="Input-Assembler Stage(IA) （未补全）"></a>Input-Assembler Stage(IA) （未补全）</h3><p>简介：IA阶段的目的主要是从user-filled buffer当中读取图元数据（points, lines and&#x2F;or triangles），然后组合成在之后阶段需要使用的新的结构的图元数据。 AI阶段能够将顶点组合成不同的图元类型，组合过程需要读取相邻的数据，这部分数据只在Geometry Stage阶段可以。例如：如果一个几何着色器在三角形上被调用，那么他的输入就包括他自身的三个顶点，和相邻三角形的顶点数据。</p><h4 id="IA阶段步骤总结"><a href="#IA阶段步骤总结" class="headerlink" title="IA阶段步骤总结"></a>IA阶段步骤总结</h4><ol><li><a href="https://docs.microsoft.com/en-us/windows/desktop/direct3d11/d3d10-graphics-programming-guide-input-assembler-stage-getting-started#create-input-buffers">Create Input Buffers</a>：使用输入的vertex data初始化input buffer。</li><li><a href="https://docs.microsoft.com/en-us/windows/desktop/direct3d11/d3d10-graphics-programming-guide-input-assembler-stage-getting-started#create-the-input-layout-object">Create the Input-Layout Object</a>：使用input layout object描述vertex buffer中的数据类型。</li><li><a href="https://docs.microsoft.com/en-us/windows/desktop/direct3d11/d3d10-graphics-programming-guide-input-assembler-stage-getting-started#bind-objects-to-the-input-assembler-stage">Bind Objects to the Input-Assembler Stage</a>：将vertex data buffer和layout object 绑定到IA阶段。</li><li><a href="https://docs.microsoft.com/en-us/windows/desktop/direct3d11/d3d10-graphics-programming-guide-input-assembler-stage-getting-started#specify-the-primitive-type">Specify the Primitive Type</a>：定义顶点数据如何组成图元。</li><li><a href="https://docs.microsoft.com/en-us/windows/desktop/direct3d11/d3d10-graphics-programming-guide-input-assembler-stage-getting-started#call-draw-methods">Call Draw Methods</a>：调用绘制方法，将绑定到IA的数据传送到pipeline。</li></ol><h4 id="Create-Input-Buffers"><a href="#Create-Input-Buffers" class="headerlink" title="Create Input Buffers"></a>Create Input Buffers</h4><p>inpute buffer有两种：vertex buffer和index buffer。vertex buffer提供数据，index buffer提供数据索引，可以创建多个vertex buffer。可以创建一个index buffer。</p><h3 id="Vertex-Shader-Stage"><a href="#Vertex-Shader-Stage" class="headerlink" title="Vertex Shader Stage"></a>Vertex Shader Stage</h3><p>vertex Shader的输入最多为16 个 32-bit的4维向量，输出也是一样。一个vertex shader必须至少有一个输入和一个输出（一个标量）。</p><p>vertex Shader能够处理两个来自IA阶段的系统生成值：VertexID and InstanceID，他们只提供给vertex shader stage。</p><p>vertex Shader在所有顶点上运行，包括有邻接拓扑关系的图元的相邻顶点。</p><p>顶点着色器可以在不需要屏幕空间导数的情况下执行加载和纹理采样操作。（应该指的是类似Unity的Sample2D_Load操作）</p><h3 id="Tessellation-Stages（未补全）"><a href="#Tessellation-Stages（未补全）" class="headerlink" title="Tessellation Stages（未补全）"></a>Tessellation Stages（未补全）</h3><h3 id="Geometry-Shader-Stage"><a href="#Geometry-Shader-Stage" class="headerlink" title="Geometry Shader Stage"></a>Geometry Shader Stage</h3><p>这部分没有太多特殊的内容，见<a href="https://docs.microsoft.com/en-us/windows/desktop/direct3d11/geometry-shader-stage">官方文档</a>。</p><h3 id="Stream-Output-Stage"><a href="#Stream-Output-Stage" class="headerlink" title="Stream-Output Stage"></a>Stream-Output Stage</h3><p>连续的将顶点数据输出到内存的buffer当中。</p><p><img src="/../../images/img/renderpipeline-d3d10-depth-stencil-test.png" alt="renderpipeline-d3d10-depth-stencil-test"></p><p>When a triangle or line strip is bound to the input-assembler stage, each strip is converted into a list before they are streamed out。（<strong>所有的数据在输出之前，都是一个链表</strong>）The amount of data streamed out can vary（<strong>数据可以变化，例如：几何着色器会向链表插入数据</strong>，<em>几何、纹理、常量数据在整个渲染流程中如何存储需要研究一下</em>）。</p><h3 id="Rasterizer-Stage"><a href="#Rasterizer-Stage" class="headerlink" title="Rasterizer Stage"></a>Rasterizer Stage</h3><p>将图元数据转化成光栅图像（像素），每个像素根据顶点进行插值。</p><p>光栅化阶段包括：视椎体剪裁、透视变化（<strong>剪裁空间坐标除z（这里说的不是z分量，而是深度值，对应的是剪裁空间坐标中的w分量）</strong>）等。（Rasterization includes clipping vertices to the view frustum, performing a divide by z to provide perspective, mapping primitives to a 2D viewport, and determining how to invoke the pixel shader. ）</p><p><strong>重点：为什么不一步变换到NDC呢？因为，视椎体剪裁需要在Clip-Space进行。当完成视椎体剪裁之后，才会进行透视变化，这个时候才会进行透视除法。以上两步都在光栅化阶段进行。所以Unity在Vertex Shader阶段输出的是Clip-Space坐标，是提供给这个阶段使用的。</strong></p><p>进入光栅化阶段的顶点，被认为是在齐次坐标的剪裁空间的（x，y，z ，w），x正方向向右，Y正方向向上，Z正方向是摄像机前方。(Vertices (x,y,z,w), coming into the rasterizer stage are assumed to be in homogeneous clip-space. In this coordinate space the X axis points right, Y points up and Z points away from camera.)</p><p>齐次坐标和NDC：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"> [x y z w]   →   [x/w y/w z/w]<br>homogeneous     normalized device<br>clip space      <span class="hljs-title function_">coordinates</span> <span class="hljs-params">(NDC)</span><br></code></pre></td></tr></table></figure><p>Zbuffer优化：On hardware that implements <strong>hierarchical Z-buffer optimizations</strong>, you may enable preloading the z-buffer by setting the pixel shader stage to <strong>NULL</strong> while enabling depth and stencil testing.</p><h3 id="Pixel-Shader-Stage"><a href="#Pixel-Shader-Stage" class="headerlink" title="Pixel Shader Stage"></a>Pixel Shader Stage</h3><p>在这个阶段进行丰富的着色、光照和后处理计算。这个阶段使用常量、纹理数据、插值数据和其他顶点程序输出的数据。光栅化阶段会为每一个被图元覆盖的区域执行一次Pixel Shader。</p><p>Use the depth-write-enable state (in the output-merger stage) to control whether depth data gets written to a depth buffer (or use the discard instruction to discard data for that pixel). A pixel shader can also output an optional 32-bit, 1-component, floating-point, depth value for depth testing (using the SV_Depth semantic). The depth value is output in the oDepth register, and replaces the interpolated depth value for depth testing (assuming depth testing is enabled). There is no way to dynamically change between using fixed-function depth or shader oDepth。<strong>比较重要的部分是可以通过SV_Depth 语义来直接输出深度到深度贴图当中，这样可以直接代替来自Vertex Data的深度插值数据。不过这两种方式不能动态变化。目前没有在Unity当中尝试过。</strong></p><h3 id="Output-Merger-Stage"><a href="#Output-Merger-Stage" class="headerlink" title="Output-Merger Stage"></a>Output-Merger Stage</h3><p>OM阶段会根据渲染状态的组合生成最终的颜色：pixel Shader输出，渲染目标，深度&#x2F;stencil buffer内容。</p><h4 id="Depth-Stencil"><a href="#Depth-Stencil" class="headerlink" title="Depth-Stencil"></a>Depth-Stencil</h4><p>OM阶段的第一步就是Depth-Stencil Testing，这步骤依赖于一张Depth-Stencil buffer。Depth-Stencil是作为纹理资源创建的，他包括了深度信息和Stencil信息。</p><p>深度信息用来决定哪些像素距离摄像机更近，Stencil数据用来当做Mask使用。他们在这个阶段使用用来决定这个像素是否被绘制。下图描述了Depth-Stencil是如何被使用的。</p><p><img src="/../../images/img/renderpipeline-d3d10-depth-stencil-test.png" alt="renderpipeline-d3d10-depth-stencil-test"></p><p>Depth-Stencil的状态如果没有被配置，那么久会使用默认参数。<strong>如果没有开启multisampling那么混合操作逐像素进行，如果开启，混合就在多个采样结果上进行。（这个内容我理解的是MSAA之类的操作）。</strong></p><p>使用深度缓冲区来确定应该绘制哪个像素的过程称为depth-buffer，有时也称为z-buffer。</p><h4 id="Blending"><a href="#Blending" class="headerlink" title="Blending"></a>Blending</h4><p>Blending的作用就是将一个或者多个像素颜色值混合作为最终的颜色输出。</p><p><img src="/../../images/img/renderpipeline-d3d10-blend-state.png" alt="renderpipeline-d3d10-blend-state"></p><p><strong>D3D文档里面说：Blend values (including BlendFactor) are always clamped to the range of the render-target format before blending. 。就是说所有混合的值会再blending阶段进行Clamp，但是我发现Unity如果使用负数的Alpha(Blend Factor)时并没有被Clamp</strong></p><p><strong>另一个要点：When you use sRGB render targets, the runtime converts the render target color into linear space before it performs blending. The runtime converts the final blended value back into sRGB space before it saves the value back to the render target. 当使用sRGB的render targets的时候，在混合之前会转换到线性空间，混合结束之后再返回sRGB的render target。Unity当中的做法是只使用Linear的render targets。全部渲染完成之后再一次性转换会原始的sRGB。</strong></p><h4 id="Multiple-RenderTargets"><a href="#Multiple-RenderTargets" class="headerlink" title="Multiple RenderTargets"></a>Multiple RenderTargets</h4><p>多个渲染目标。一个Pixel Shader能够同时渲染8个render target。所有的render target需要是同一种类型(buffer, Texture1D, Texture1DArray, and so on)，同一种尺寸 (width, height, depth, array size, sample counts)。但是可以有不同的数据格式（Each render target may have a different data format.）。例如：多个G-buffer在一个Pass完成，但根据存储数据的不同，使用了不同的数据格式。</p><h4 id="Output-Write-Mask"><a href="#Output-Write-Mask" class="headerlink" title="Output-Write Mask"></a>Output-Write Mask</h4><p>Use an output-write mask to control (per component) what data can be written to a render target.</p><p>这个没有在Unity当中找到对应物。</p><h4 id="Sample-Mask"><a href="#Sample-Mask" class="headerlink" title="Sample Mask"></a>Sample Mask</h4><p>这个没有在Unity当中找到对应物。</p>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>球面谐波的理论与实践</title>
      <link href="/2022/07/09/RTR/%E7%90%83%E9%9D%A2%E8%B0%90%E6%B3%A2%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2022/07/09/RTR/%E7%90%83%E9%9D%A2%E8%B0%90%E6%B3%A2%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="球面谐波的理论与实践"><a href="#球面谐波的理论与实践" class="headerlink" title="球面谐波的理论与实践"></a>球面谐波的理论与实践</h1><p>球谐光照就是用N个多项式拟合一个位置的低频光照函数。主要用到的就是球面谐波。</p><p>下面详细分析球谐函数的推导。</p><h2 id="球谐函数"><a href="#球谐函数" class="headerlink" title="球谐函数"></a>球谐函数</h2><p>下面先介绍几个和球谐相关的数学理论。</p><h3 id="期望："><a href="#期望：" class="headerlink" title="期望："></a>期望：</h3><h3 id="蒙特卡洛："><a href="#蒙特卡洛：" class="headerlink" title="蒙特卡洛："></a>蒙特卡洛：</h3><h3 id="大数定理："><a href="#大数定理：" class="headerlink" title="大数定理："></a>大数定理：</h3><h3 id="随机数与球面坐标："><a href="#随机数与球面坐标：" class="headerlink" title="随机数与球面坐标："></a>随机数与球面坐标：</h3><h3 id="正交基函数："><a href="#正交基函数：" class="headerlink" title="正交基函数："></a>正交基函数：</h3><h3 id="正交多项式："><a href="#正交多项式：" class="headerlink" title="正交多项式："></a>正交多项式：</h3><h3 id="球谐："><a href="#球谐：" class="headerlink" title="球谐："></a>球谐：</h3><h3 id="球谐函数："><a href="#球谐函数：" class="headerlink" title="球谐函数："></a>球谐函数：</h3><h3 id="球谐投影："><a href="#球谐投影：" class="headerlink" title="球谐投影："></a>球谐投影：</h3><h3 id="球谐光照："><a href="#球谐光照：" class="headerlink" title="球谐光照："></a>球谐光照：</h3><h3 id="采样与计算"><a href="#采样与计算" class="headerlink" title="采样与计算:"></a>采样与计算:</h3>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>表面反射模型基础推到</title>
      <link href="/2022/07/09/RTR/%E8%A1%A8%E9%9D%A2%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/07/09/RTR/%E8%A1%A8%E9%9D%A2%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="表面反射模型基础推到"><a href="#表面反射模型基础推到" class="headerlink" title="表面反射模型基础推到"></a>表面反射模型基础推到</h1><p>这篇文章主要用来推导、描述表面反射模型：包括PBR的BRDF、BSSRDF、BSDF以及风格化渲染的反射模型、二次元渲染的反射模型等等内容。</p><p>光线照射到物体表面，发生反射，之后反射光线进入人眼，最终形成人眼对物体的感觉。</p><p><strong>所以最重要的就是光线如何在不同的材质上进行反射，也就是我们现在要研究的反射模型。</strong></p><h2 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h2><p><strong>双向反射分布函数（BRDF）</strong>就是最常用的对表面反射的定义。</p><p>BRDF描述的问题：当沿着$w_i$方向入射辐射度为$$ L_{(p,w_i)} $$时，朝向观察者且方向为$$ w_o $$的离开当前表面的辐射度。</p><p>假设$ w_i $为微分方向视椎体，$$ p $$为入射点，则p处的微分入射辐射度为：</p><p>$$ dE(p,w_i) &#x3D; L_i(p,w_i)cos(\theta_i)dw_i $$</p><p>$ L_i(p,w_i) $ 单位辐射角入射光强度，$ cos(\theta_i) $法线和入射角夹角，$ dw_i $为微分方向视椎体</p><p>我们很容易想到，反射光线和入射光线强度是成正比的：</p><p>$$ dE(p,w_i) \propto dL_o(p,w_o) $$ </p><p>所以当给定一对如何方向和反射方向，BDRF函数可以写作：</p><p>$$ f_r(p,w_o,w_i) &#x3D; \frac{dL_o(p,w_o)}{dE(p,w_i)} &#x3D; \frac{dL_o(p,w_o)}{L_i(p,w_i)cos(\theta_i)dw_i} $$</p><p>上面是BRDF函数，而物理的BRDF函数同时还需要满足：</p><ul><li><p>互易性：$$ f_r(p,w_o,w_i) &#x3D; f_r(p,w_i,w_o) $$</p></li><li><p>能量守恒。</p></li></ul><p>最终的反射光为：</p><p>$$ L_o{(p,w_o)} &#x3D; \int_{\cal H(n)} f_r(p,w_o,w_i)L_i(p,w_i)cos(\theta_i)dw_i $$</p><p>上面的$$ w_o $$只局限在反射方向，就是法线方向的上半球$$ \cal H(n) $$。</p><h2 id="BTDF"><a href="#BTDF" class="headerlink" title="BTDF"></a>BTDF</h2><p>而表面还可能有透视光线，即穿透到法线放线下半球的光线，我们用<strong>双向透射分布函数表述（BTDF）</strong>。$$ w_o $$和$$ w_i $$分布于法线两边。</p><ul><li>BTDF不需要满足互易性：从物理意义上来说就是，透射两边的折射率不同。</li></ul><p>最终的透射光为：</p><p>​$$ L_o{(p,w_o)} &#x3D; \int_{\Theta(n)} f_t(p,w_o,w_i)L_i(p,w_i)|cos(\theta_i)|dw_i $$</p><p>上面的$$w_o$$只局限在透射方向，就是法线方向的下半球$$ \Theta(n) $$。</p><h2 id="BSSRDF"><a href="#BSSRDF" class="headerlink" title="BSSRDF"></a>BSSRDF</h2><p>很多材质还会表现出<strong>下表面的光线传输</strong>。<strong>双向散射表面反射分布函数（BSSRDF）</strong>。</p><p>与反射分布函数和透射分布函数不同的是：<strong>散射的能量还需要考虑从其他附近入射点传递来的能量</strong>。</p><p>此时，$$ f_r(p,w_o,w_i) &#x3D; \frac{dL_o(p,w_o)}{dE(p,w_i)}  $$  只考虑了当前点的入射，还需要考虑附近点的积累$$ S(p_o,w_o,p_i,w_i) &#x3D; \frac{dL_o(p_o,w_o)}{dE(p_i,w_i)}  $$。</p><p>也就是说，在附近某一点$ p_i $ 处入射的能量与他最终离开$ p_o $点时能量的比例就是$$ S(p_o,w_o,p_i,w_i) $$。</p><p>所以这个时候的积分需要考虑的不再是一个点，还需要考虑一片区域：</p><p>​$$  L_o{(p_o,w_o)} &#x3D; \int_A  \int_{\Theta(n)} S(p_o,w_o,p_i,w_i) L_i(p_i,w_i)|cos(\theta_i)|dw_i dA $$</p><p>这个公式有如下特点：</p><ul><li>随着$p_o$和$ p_i$的距离增加S的值会变小</li><li>通常算法会通过一个卷积（基于几何空间或者基于图片空间）来表述，周围表面受光对当前点的影响。</li></ul><h1 id="辐射度理论"><a href="#辐射度理论" class="headerlink" title="辐射度理论"></a>辐射度理论</h1><p>为什么将辐射度理论，<strong>就是为了更好的理解光线的发射与吸收的多少。</strong></p><p>辐射通量（$$ \Phi $$，也叫作功率）：单位时间内，穿过某一表面或空间的全部能量。</p><p>辐射度（$$ W&#x2F;m^2 $$）：表示穿过某一表面的<strong>通量面密度</strong>（可以理解成穿过单位面积的光线数量，<strong>可以理解亮度、光照强度</strong>）。</p><p>一个点光源发射光线，在具体他为r的位置，出辐射度为：</p><p>$$ E &#x3D; \Phi &#x2F; 4\pi r^2 $$</p><p>所以<strong>光照强度</strong>（就是单位面积光线数量，也就是<strong>通量面密度</strong>）按照距离的平方进行衰减的。</p><h2 id="Lambertian定理"><a href="#Lambertian定理" class="headerlink" title="Lambertian定理"></a>Lambertian定理</h2><h3 id="入射辐射度"><a href="#入射辐射度" class="headerlink" title="入射辐射度"></a>入射辐射度</h3><p><strong>Lambertian定理：到达表面的光线数量正比与光线方向和法线方向夹角的余弦。</strong></p><p>如下图，一个<strong>面光源</strong>以$\theta$角度照射表面，面光源面积为$ A $,辐射通量为$ \Phi $，对应接受光照的表面面积为$ A1 $。<strong>如果A足够的小</strong>（这一点非常重要），那么对于A1内的点，入辐射度<strong>约</strong>为 $$ E &#x3D; \frac{\Phi\cos(\theta)}{A} $$ 。</p><p><img src="/../../images/img/brdf_inlight.jpg" alt="brdf_inlight"></p><h3 id="出射辐射度"><a href="#出射辐射度" class="headerlink" title="出射辐射度"></a>出射辐射度</h3><p><strong>Lambertian反射</strong>：反射方向的单位<strong>辐射度</strong>均匀分布&#x3D; $$ \frac{接收的光线强度}{\pi} $$ </p><p>如下图，假如A处的<strong>光线是按照各个方向平均反射</strong>的，那么A1和A2接收到的<strong>光线总数</strong>是一样多的。但是，由于A1和A2的<strong>面积不一样</strong>，所以他们的<strong>辐射度</strong>（<strong>光照强度</strong>，<strong>亮度</strong>）是不一样的！！！</p><p><strong>而Lambertian反射要求的是辐射度一样</strong>，<strong>所以光线的反射数量与反射方向和法线方向夹角的余弦成正比。</strong></p><p><img src="/../../images/img/brdf_outlight.jpg" alt="brdf_outlight"></p><h1 id="表面反射函数实践"><a href="#表面反射函数实践" class="headerlink" title="表面反射函数实践"></a>表面反射函数实践</h1><p>首先BDRF的积分可以简化为求和，因为游戏引擎中光照都是通过有限个光源计算的，不在需要<strong>微分方向视椎体</strong>：</p><p>$$ L_o{(p,w_o)} &#x3D; \int_{\cal H(n)} f_r(p,w_o,w_i)L_i(p,w_i)cos(\theta_i)dw_i $$</p><p>变成：</p><p>$$ L_o{(p,w_o)} &#x3D; \sum_{w_i} f_r(p,w_o,w_i)L_i(p,w_i)cos(\theta_i) $$</p><p>$$ w_i $$ :为某个入射光方向。</p><p>$$ L_i(p,w_i) $$  :  一般就是经过<strong>距离衰减</strong>和<strong>阴影遮挡</strong>计算之后的光亮度。</p><p>$$ cos(\theta_i) $$ : 就是$$ dot(w_i,w_o) $$</p><p>另一点需要注意的是，RGB通道的每个分量的颜色都是独立计算的。</p><p>下面我们将讨论具体的$$  f_r(p,w_o,w_i) $$都是怎么计算的。</p><h2 id="Lambertian反射"><a href="#Lambertian反射" class="headerlink" title="Lambertian反射"></a>Lambertian反射</h2><p>Lambertian模型可以作为最简单的BRDF模型，他是能量守恒的。</p><p>$$ f_{Lambertian}(p,w_o,w_i) &#x3D; \frac{R}{\pi} $$</p><p>$$ R $$  :表示的是表面反射率（Albedo\Diffuse），在实际中就是RGB通道的颜色值。</p><h3 id="Lambertian为什么除-pi"><a href="#Lambertian为什么除-pi" class="headerlink" title="Lambertian为什么除$ \pi $"></a>Lambertian为什么除$ \pi $</h3><p>首先分析一种错误的理解：反射半球的表面积应该是$$ 2\pi r^2 $$，反射射光照总能量比例为$$R$$，各个方向平均反射，所以最终lambertian反射强度应该是:</p><p>$$ \frac{R}{2\pi} $$</p><p>这种理解错误的原因是：Lambertian考虑的是反射辐通量（光照强度）各个方向恒定，而不是反射总辐通量R被平均分。</p><p>那么这个$$ \frac{R}{\pi} $$是怎么来的？</p><p>对<strong>幅通量</strong>根据Lambertian定律（反射幅通量和$ cos(\theta) $成正比）进行半球积分得到表面接收的<strong>辐通量</strong>。</p><p><img src="/../../images/img/Lamberts-cosine-law.png" alt="Lamberts-cosine-law"></p><p>对所有方向的辐通量进行积分就可以得到反射全部的总辐射度：</p><p>$$ L_o&#x3D; \int  f_{Lambertian}(p,w_o,w_i) cos\theta dw_o $$</p><p><strong>有一个需要理解的地方：因某个方向的出辐射度为X（面积小），那么对其贡献辐射度的表面上的辐射度为$Xcos\theta$（面积大所以贡献的辐射度少）。</strong></p><p>因为，Lambertian的brdf($$ f_{Lambertian}(p,w_o,w_i) $$ )是常数：</p><p>$$ L_o&#x3D; \int  f_{Lambertian}(p,w_o,w_i)  cos\theta dw_o $$</p><p>进行移项：</p><p>$$ \frac{L_o}{f_{Lambertian}(p,w_o,w_i) } &#x3D; \int cos \theta dw_o $$</p><p>下面对：反射半球半球积分$$ \int cos \theta dw_o $$ 进行拆解和仔细计算：</p><p>$$ \int_0^{2\pi} \int_0^{\frac{\pi}{2} } cos \theta \ sin \theta d \theta d \phi   $$</p><p>$$ &#x3D; 4  \int_0^{\frac{\pi}{2}}  \int_0^{\frac{\pi}{2} }  cos \theta  sin\theta d \theta d \phi $$</p><p>$$ &#x3D;   \int_0^{\frac{\pi}{2}}  \int_0^{\frac{\pi}{2} }  sin 2\theta d 2\theta d \phi $$</p><p>$$ &#x3D; \int_0^{\frac{\pi}{2}}  \int_0^{\frac{\pi}{2} }  d(-cos 2\theta  )d \phi $$</p><p>$$ &#x3D;(-cos \pi + cos 0) *\frac{\pi}{2} $$</p><p>$$ &#x3D;\pi $$</p><p>所以：</p><p>$$ \frac{L_o}{f_{Lambertian}(p,w_o,w_i)} &#x3D; \pi $$</p><p>$$f_{Lambertian}(p,w_o,w_i)  &#x3D;  \frac{L_o}{ \pi} $$</p><p>假设入射辐通量为1，表面反射率为R（入射光被反射的比例），则反射辐通量（反射之后分布到各个方向后的比例）为：</p><p>$$f_{Lambertian}(p,w_o,w_i) &#x3D;  \frac{R}{ \pi} $$</p><p>至此，推导完毕。</p><h2 id="菲涅尔方程"><a href="#菲涅尔方程" class="headerlink" title="菲涅尔方程"></a>菲涅尔方程</h2><p>菲涅尔等式主要用来求解反射和透射系数。</p><p>首先需要，两种材质的折射率$$ \eta_i $$和$$ \eta_t $$ ,一般情况下随着光的波长折射率会有变化。</p><p>菲涅尔定律：</p><p>$$ \eta_i \sin(\theta_i) &#x3D; \eta_t \sin(\theta_t) $$</p><p>反射定律：</p><p>$$\theta_i &#x3D; \theta_o$$</p><h3 id="Unity-Fresnel"><a href="#Unity-Fresnel" class="headerlink" title="Unity Fresnel"></a>Unity Fresnel</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">real3 <span class="hljs-title function_">F_Schlick</span><span class="hljs-params">(real3 f0, real f90, real u)</span><br>&#123;<br>    real x = <span class="hljs-number">1.0</span> - u;<br>    real x2 = x * x;<br>    real x5 = x * x2 * x2;<br>    <span class="hljs-keyword">return</span> f0 * (<span class="hljs-number">1.0</span> - x5) + (f90 * x5);        <span class="hljs-comment">// sub mul mul mul sub mul mad*3</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="微表面模型-TODO"><a href="#微表面模型-TODO" class="headerlink" title="微表面模型 TODO"></a>微表面模型 TODO</h2><p>整体BRDF模型：</p><p>$$f &#x3D; \frac{D()G()F()}{4cos\theta_o cos\theta_i}$$</p><p>下面描述整体推到过程:</p><h3 id="通量-Phi"><a href="#通量-Phi" class="headerlink" title="通量$ \Phi $"></a>通量$ \Phi $</h3><p>第一个概念是通量，单位时间穿过一个表面上光线的<strong>总量</strong>。（也就是功率）。</p><h3 id="入射辐射度-L-i-和反射辐射度-L-o"><a href="#入射辐射度-L-i-和反射辐射度-L-o" class="headerlink" title="入射辐射度$ L_i $和反射辐射度$ L_o $"></a>入射辐射度$ L_i $和反射辐射度$ L_o $</h3><p>表示<strong>单位时间单位面积</strong>入射（反射）表面接受（反射）的光线量。</p><p>如果入射表面面积为$$ A $$， 则：$$ L_i &#x3D; \frac{\Phi}{A} $$</p><p>写成微分形式：$$ L_i &#x3D; \frac{d \Phi}{d A} $$</p><h3 id="立体角-w-和光强"><a href="#立体角-w-和光强" class="headerlink" title="立体角$ w $和光强"></a>立体角$ w $和光强</h3><p>光线传过单位立体角的数量。就是光强。$$ E &#x3D; \frac{\Phi}{w} $$微分形式：$$ E &#x3D; \frac{d \Phi}{d w} $$</p><h3 id="辐射度-L"><a href="#辐射度-L" class="headerlink" title="辐射度$ L $"></a>辐射度$ L $</h3><p>单位时间内传过单位立体角单位面积的光线量。</p><p>$$ L &#x3D;\frac{d\Phi }{dw dA_{w} } $$         </p><p>$$ d\Phi_i&#x3D;  L(w_i)dw_i cos \theta_i dA $$ </p><p>$$ d\Phi_o&#x3D;  L(w_o)dw_o cos \theta_o dA $$ </p><h3 id="菲涅尔公式F"><a href="#菲涅尔公式F" class="headerlink" title="菲涅尔公式F"></a>菲涅尔公式F</h3><p>表示某一角度下光线被反射、折射的比例。 $$ \Phi_i $$为入射通量，$$ \Phi_o $$反射通量。则：</p><p>$$ \Phi_o &#x3D; F\Phi_i $$</p><h3 id="BDRF公式"><a href="#BDRF公式" class="headerlink" title="BDRF公式"></a>BDRF公式</h3><p>​$$ f_r(p,w_o,w_i) &#x3D; \frac{L_o(p,w_o)}{dE(p,w_i)} &#x3D; \frac{L_o(p,w_o)}{L_i(p,w_i)cos(\theta_i)dw_i} $$</p><p>这里的$ L_o $ 没有积分符号，是因为我们现在计算的是某一条线如何光线与某一条反射光线。</p><h3 id="BDRF推导"><a href="#BDRF推导" class="headerlink" title="BDRF推导"></a>BDRF推导</h3><p>在微面元理论中，我们的$ dA $由很多微面元组成，并且这些面元只有<strong>全镜面反射</strong>，只有满足$$ w_h &#x3D; w_n $$的表面才能被反射出去。我们<strong>用统计模型$$D(w_h) $$来描述某个角度的面片比例</strong>。 那么入射的辐通量就需要考虑面片分布。则：</p><p>$$ d\Phi_i&#x3D;  L(w_i)dw_i D(w_h) dw_hcos \theta_o dA $$ </p><p>半角向量和出射角向量微分的对应关系:</p><p>$$dw_h &#x3D; \frac{dw_o}{4cos(\theta_o)}$$</p><p><strong>1. 菲涅尔公式+BRDF公式：</strong></p><p>$$ L(w_o)dw_o cos \theta_o dA &#x3D;  F L(w_i)dw_i D(w_h) dw_hcos \theta_o dA $$</p><p><strong>2. 半角向量和出射角向量微分的对应关系:</strong></p><p>$$ 4 cos \theta_o L(w_o) cos \theta_o &#x3D;  F L(w_i)dw_i D(w_h)cos \theta_h $$</p><p><strong>3. 通过移项、约分构造brdf</strong></p><p>$$ \frac{L_o(p,w_o)}{L_i(p,w_i)cos(\theta_i)dw_i}  &#x3D; \frac{ F D(w_h)  }{4  cos \theta_o cos \theta_i} $$</p><p><strong>4.除了上面的F、D之外，由于几何结构，还有一些光线由于几何结构被：masking 和 shadowing。所以这个比例为G项。</strong></p><p><strong>5.所以最终结果为：</strong></p><p>$$ brdf &#x3D;  \frac{L_o(p,w_o)}{L_i(p,w_i)cos(\theta_i)dw_i}  &#x3D; \frac{ F D(w_h)  G}{4  cos \theta_o cos \theta_i} $$</p><h3 id="法线分布函数：normal-distribution-function"><a href="#法线分布函数：normal-distribution-function" class="headerlink" title="法线分布函数：normal distribution function"></a>法线分布函数：normal distribution function</h3><p>D项：法线分布函数用来描述，法线方向在表面上的分布情况，积分结果为1。</p><h3 id="几何衰减：Evaluate-shadowing-x2F-masking-term"><a href="#几何衰减：Evaluate-shadowing-x2F-masking-term" class="headerlink" title="几何衰减：Evaluate shadowing&#x2F;masking term"></a>几何衰减：Evaluate shadowing&#x2F;masking <strong>term</strong></h3><p>G项：用来描述Shadow和masking项。用来描述不同的几何结构有多少光线被遮挡。</p><h3 id="菲涅尔项：Fresnel"><a href="#菲涅尔项：Fresnel" class="headerlink" title="菲涅尔项：Fresnel"></a>菲涅尔项：Fresnel</h3><p>F项：用来描述在不同材质，不同角度上，反射光线所占的比例。</p><h2 id="unity中的实现"><a href="#unity中的实现" class="headerlink" title="unity中的实现"></a>unity中的实现</h2><h3 id="Unity-Specular-Term"><a href="#Unity-Specular-Term" class="headerlink" title="Unity Specular Term"></a>Unity Specular Term</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: specularTerm = ComputeWard(H, LdotH, NdotL, NdotV, positionWS, preLightData, bsdfData); <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: specularTerm = ComputeBlinnPhong(H, LdotH, NdotL, NdotV, positionWS, preLightData, bsdfData); <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: specularTerm = ComputeCookTorrance(H, LdotH, NdotL, NdotV, positionWS, preLightData, bsdfData); <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: specularTerm = ComputeGGX(H, LdotH, NdotL, NdotV, positionWS, preLightData, bsdfData); <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: specularTerm = ComputePhong(H, LdotH, NdotL, NdotV, positionWS, preLightData, bsdfData); <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><h3 id="Unity-Specular-Term-1"><a href="#Unity-Specular-Term-1" class="headerlink" title="Unity Specular Term"></a>Unity Specular Term</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">Lambert<br>OrenNayar<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>重要度采样</title>
      <link href="/2022/07/09/RTR/%E9%87%8D%E8%A6%81%E5%BA%A6%E9%87%87%E6%A0%B7/"/>
      <url>/2022/07/09/RTR/%E9%87%8D%E8%A6%81%E5%BA%A6%E9%87%87%E6%A0%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="重要度采样"><a href="#重要度采样" class="headerlink" title="重要度采样"></a>重要度采样</h1><p>wiki解释：<a href="https://zh.wikipedia.org/wiki/%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7">重要度采样</a></p><p>主要：该方法从与原分布不同的另一个分布中采样，而对原先分布的性质进行估计</p><h2 id="重要度采样的推导"><a href="#重要度采样的推导" class="headerlink" title="重要度采样的推导"></a>重要度采样的推导</h2><p>首先利用**一个随机变量$$X$$**的多个样本值$${x_i}$$，构造期望值估计：</p><p>$$ \hat E[X,P] &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^n  x_i $$</p><p>$$ X $$:随机变量</p><p>$$ x_i $$：$$X $$ 样本值。</p><p>$$P$$:  $$X$$的分布。</p><p>这个期望的<strong>精确度和$$X$$的方差</strong>有关：</p><p>$$var [\hat E ; P] &#x3D; var [X;P]&#x2F;n $$</p><p>为了降低方差，我们引入一个新的随机变量$$ L $$，保证$$ E[L;P]&#x3D;1$$得到：</p><p>$$\hat E [X; P] &#x3D; \hat E [\frac{X}{L} ; P^{(L)}] $$</p><p>$$L$$的作用就是降低对$$X$$的方差，来达到降低$$\hat E$$的误差的目的。</p><p>最优的$$ L $$为 $$ L^* &#x3D; \frac{X}{E[X;P]}$$,也就是说，$$L$$把$$X$$变成了一个常量。</p><p>此时，要求的期望值变为：</p><p> $$E[X;P] &#x3D; \frac{X}{ L^*}$$</p><p>但是理论上无法求得$$L*$$，所以需要进行估计，在很小的一段区间($$[a; a + da]$$)上$$L^*$$的概率为:</p><p>$$P^{(L^*)}(X \in [a; a+ da]) &#x3D; \int_{w \in { X \in a;a+da } } \frac{X_w}{E[x;P]} dP(w)  $$</p><p>实际过程我们无法的到最优化的 $$ L* $$，可以用如下方式逼近</p><p>$$ &#x3D;  \frac{1}{E[X;P]} aP(X \in [a; a+ da]) $$ </p><p>上式的意思是一段区间里面$$L^*$$的积分值。</p><p>由于$$L^*$$的期望等于1：</p><p>$$1  &#x3D; \int_{a &#x3D; -\infty}^{\infty}  \frac{1}{E[X;P]} aP(X \in [a; a+ da]) $$ </p><p>此时期望变为：</p><p> $$E[X;P]  &#x3D; \int_{a &#x3D; -\infty}^{\infty} aP(X \in [a; a+ da]) $$  </p>]]></content>
      
      
      <categories>
          
          <category> RTR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HDRP ShaderPass说明</title>
      <link href="/2022/07/09/HDRPsource/2.ShaderPass%E8%AF%B4%E6%98%8E/"/>
      <url>/2022/07/09/HDRPsource/2.ShaderPass%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="HDRP-ShaderPass说明"><a href="#HDRP-ShaderPass说明" class="headerlink" title="HDRP ShaderPass说明"></a>HDRP ShaderPass说明</h1><h2 id="所有PassName"><a href="#所有PassName" class="headerlink" title="所有PassName"></a>所有PassName</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HDShaderPassNames</span><br>&#123;<br>  <span class="hljs-comment">// ShaderPass string - use to have consistent name through the code</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> s_EmptyStr = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> s_ForwardStr = <span class="hljs-string">&quot;Forward&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> s_DepthOnlyStr = <span class="hljs-string">&quot;DepthOnly&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> s_DepthForwardOnlyStr = <span class="hljs-string">&quot;DepthForwardOnly&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> s_ForwardOnlyStr = <span class="hljs-string">&quot;ForwardOnly&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> s_GBufferStr = <span class="hljs-string">&quot;GBuffer&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> s_GBufferWithPrepassStr = <span class="hljs-string">&quot;GBufferWithPrepass&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> s_SRPDefaultUnlitStr = <span class="hljs-string">&quot;SRPDefaultUnlit&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> s_MotionVectorsStr = <span class="hljs-string">&quot;MotionVectors&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> s_DistortionVectorsStr = <span class="hljs-string">&quot;DistortionVectors&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> s_TransparentDepthPrepassStr = <span class="hljs-string">&quot;TransparentDepthPrepass&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> s_TransparentBackfaceStr = <span class="hljs-string">&quot;TransparentBackface&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> s_TransparentDepthPostpassStr = <span class="hljs-string">&quot;TransparentDepthPostpass&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> s_MetaStr = <span class="hljs-string">&quot;Meta&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> s_ShadowCasterStr = <span class="hljs-string">&quot;ShadowCaster&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> s_MeshDecalsStr = <span class="hljs-string">&quot;DBufferMesh&quot;</span>;<br><br>  <span class="hljs-comment">// ShaderPass name</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_EmptyName = <span class="hljs-keyword">new</span> ShaderPassName(s_EmptyStr);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_ForwardName = <span class="hljs-keyword">new</span> ShaderPassName(s_ForwardStr);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_DepthOnlyName = <span class="hljs-keyword">new</span> ShaderPassName(s_DepthOnlyStr);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_DepthForwardOnlyName = <span class="hljs-keyword">new</span> ShaderPassName(s_DepthForwardOnlyStr);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_ForwardOnlyName = <span class="hljs-keyword">new</span> ShaderPassName(s_ForwardOnlyStr);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_GBufferName = <span class="hljs-keyword">new</span> ShaderPassName(s_GBufferStr);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_GBufferWithPrepassName = <span class="hljs-keyword">new</span> ShaderPassName(s_GBufferWithPrepassStr);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_SRPDefaultUnlitName = <span class="hljs-keyword">new</span> ShaderPassName(s_SRPDefaultUnlitStr);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_MotionVectorsName = <span class="hljs-keyword">new</span> ShaderPassName(s_MotionVectorsStr);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_DistortionVectorsName = <span class="hljs-keyword">new</span> ShaderPassName(s_DistortionVectorsStr);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_TransparentDepthPrepassName = <span class="hljs-keyword">new</span> ShaderPassName(s_TransparentDepthPrepassStr);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_TransparentBackfaceName = <span class="hljs-keyword">new</span> ShaderPassName(s_TransparentBackfaceStr);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_TransparentDepthPostpassName = <span class="hljs-keyword">new</span> ShaderPassName(s_TransparentDepthPostpassStr);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_MeshDecalsName = <span class="hljs-keyword">new</span> ShaderPassName(s_MeshDecalsStr);<br><br>  <span class="hljs-comment">// Legacy name 这部分的Pass都会作为ErrorPass渲染</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_AlwaysName = <span class="hljs-keyword">new</span> ShaderPassName(<span class="hljs-string">&quot;Always&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_ForwardBaseName = <span class="hljs-keyword">new</span> ShaderPassName(<span class="hljs-string">&quot;ForwardBase&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_DeferredName = <span class="hljs-keyword">new</span> ShaderPassName(<span class="hljs-string">&quot;Deferred&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_PrepassBaseName = <span class="hljs-keyword">new</span> ShaderPassName(<span class="hljs-string">&quot;PrepassBase&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_VertexName = <span class="hljs-keyword">new</span> ShaderPassName(<span class="hljs-string">&quot;Vertex&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_VertexLMRGBMName = <span class="hljs-keyword">new</span> ShaderPassName(<span class="hljs-string">&quot;VertexLMRGBM&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ShaderPassName s_VertexLMName = <span class="hljs-keyword">new</span> ShaderPassName(<span class="hljs-string">&quot;VertexLM&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h2><p>所有在前向渲染物体使用这个Pass，正常情况下使用Deferred时，所有不透明物体都需要在DeferredPass 完成渲染，这里只渲染透明物体。</p><h2 id="ForwardOnly"><a href="#ForwardOnly" class="headerlink" title="ForwardOnly"></a>ForwardOnly</h2><p>通过ForwardOnly可以强制在Forward 阶段渲染不透明物体</p><p>无光照物体使用这个Pass，并且不输出法线</p><h2 id="DepthForwardOnly"><a href="#DepthForwardOnly" class="headerlink" title="DepthForwardOnly"></a>DepthForwardOnly</h2><p>和ForwardOnly对应使用</p><h2 id="DepthOnly"><a href="#DepthOnly" class="headerlink" title="DepthOnly"></a>DepthOnly</h2><p>渲染深度，Forward和Deferred必须有一个深度</p><h2 id="TransparentDepthPrepass"><a href="#TransparentDepthPrepass" class="headerlink" title="TransparentDepthPrepass"></a>TransparentDepthPrepass</h2><p>透明物体Prepass深度</p>]]></content>
      
      
      <categories>
          
          <category> HDRPSource </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>光照设置</title>
      <link href="/2022/07/09/HDRPsource/10.Lighting%E8%AE%BE%E7%BD%AE/"/>
      <url>/2022/07/09/HDRPsource/10.Lighting%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="光照设置"><a href="#光照设置" class="headerlink" title="光照设置"></a>光照设置</h1><p>这里主要讲解GI的设置方式。</p><p>同时解释一下Shader是如何在<strong>光照探针</strong>、<strong>静态光照贴图</strong>，<strong>动态光照贴图</strong>，<strong>直接光照</strong>之间产生作用的。</p><p>首先看一下我们能设置的选项：</p><p>对于光源：</p><ol><li>realtime.</li><li>mix.</li><li>bake.</li></ol><p>对于emission（HDRP）：</p><ol><li>realtime.</li><li>bake.</li></ol><p>对于物体：</p><ol><li>lightmap static.</li><li>lightprobe.</li></ol><p>对于工程选项，在Windows&#x2F;Rendering&#x2F;Lighting Setting中的设置三部分：</p><ol><li>Realtime Lighting.</li><li>Mixed Lighting.</li><li>Lightmapping Setting.</li></ol><p>##测试场景</p><p>下面是测试场景：</p><p><img src="/../../images/10.%E5%85%89%E6%BA%90%E9%85%8D%E7%BD%AE.PNG" alt="光源配置"></p><p>测试场景当中有三个光源：红色点光源，绿色物体自发光，蓝色点光源，同时场景当中布满了光照探针。两个黑色模型，用于观察受光表现。（目前全部都是realtime光源，同时，物体是Lightmap static, realtime GI 和baked GI全部开启）。</p><p>从反面可以看到，红框内部就是间接光照。</p><p><img src="/../../images/10.%E5%85%89%E6%BA%90%E9%85%8D%E7%BD%AE%E5%8F%8D%E9%9D%A2.PNG" alt="光源配置"></p><p>接下来的内容会不断修改光源类型，物体类型设置和光照设置，来观察GI情况。</p><h2 id="光源类型"><a href="#光源类型" class="headerlink" title="光源类型"></a>光源类型</h2><p>光源有三种类型：realtime、mix、bake，如下图：</p><p><img src="/../../images/10.%E5%85%89%E6%BA%90%E7%B1%BB%E5%9E%8B.png"></p><p>每种类型的光都可以假设成由两部分组成：</p><p><strong>直接光照</strong>（直接照在某个物体上）</p><p><strong>间接光照</strong>。（经过物体反弹之后照在其他物体上）</p><h2 id="自发光"><a href="#自发光" class="headerlink" title="自发光"></a>自发光</h2><p>自发光也是一种光源：但是只有两种：realtime和bake。</p><p>这里有不同：</p><p>1.realtime：对应的是realtime类型光源的间接成分。</p><p>2.bake：对应的是bake类型的光源。</p><p><img src="/../../images/10.%E8%87%AA%E5%8F%91%E5%85%89%E7%B1%BB%E5%9E%8B.png"></p><h2 id="物体受光"><a href="#物体受光" class="headerlink" title="物体受光"></a>物体受光</h2><p>物体上和受光相关的有两个设置：</p><ol><li>lightmap static是否打开。</li><li>lightprobe 是否打开。</li></ol><p>选项位置见下图：</p><p><img src="/../../images/10.%E7%89%A9%E4%BD%93%E5%85%89%E7%85%A7%E7%B1%BB%E5%9E%8B.png"></p><p>下面讨论每个情况。</p><p>###LightMap Static物体</p><p>​LightMap Static打开时受光来源：Realtime GI贴图 + Baked GI贴图 + realtime 光的直接光照 + mix 光的直接光照。(贴图内容和探针内容在后面解释)</p><p>当前场景两个物体都是lightMap Static。我们把测试场景中蓝色光改成bake，这个时候两个lightmap static物体的光照贴图如下。</p><p><img src="/../../images/10.%E7%89%A9%E4%BD%93%E5%8F%97%E5%85%89%E6%83%85%E5%86%B5.png"></p><p>​从上图可以看到，蓝色光源被bake到baked lightmap中，realtime光源和realtime自发光被bake到realtimeGI当中。同时，下图是物体背面的受光情况，可以看到，间接光都存在。</p><p><img src="/../../images/10.%E7%89%A9%E4%BD%93%E5%8F%97%E5%85%89%E6%83%85%E5%86%B5%E8%83%8C%E9%9D%A2.PNG"></p><p>接下来我们在做一个实验，在运行模式下修改三个光源的颜色，</p><p>​红色realtime点光源-&gt;蓝色realtime点光源， 绿色realtime自发光-&gt;黄色realtime自发光， 蓝色baked点光源-&gt;红色baked自发光</p><p>下图为修改后的结果，可以发现。两个点光源的变化是合理的。但是realtime GI贴图上的realtime自发光并没有变化（就是说在Play模式下并不是realtime的）。同时我发现，在编辑模式下，我修改自发光颜色realtimeGI贴图不用重新烘焙就会马上变（就是说在Editor模式下是realtime的），这个可能是bug。</p><p><img src="/../../images/10.%E4%BF%AE%E6%94%B9%E5%85%89%E6%BA%90%E9%A2%9C%E8%89%B2.PNG"></p><p>###Lightprobe物体</p><p>打开时受光来源： realtime光的直接光照 + mix光的直接光照 + 光照探针。</p><p>​我们把下方平面取消掉lightmap static，这样这个物体就会使用LightProbe作为间接光。同时保持左侧为realtime红色光，右侧为bake蓝色光，中间为realtime自发光。</p><p><img src="/../../images/10.LightProbe%E7%BB%93%E6%9E%9C.PNG"></p><p>​从上图可以看到，光照探针烘焙了所有的间接光（红绿蓝）。同时下方平面不再接受GI贴图，而间接光是通过光照探针插值来的（有个很重要的地方是：realtime的自发光和baked点光源表现居然是一样的的效果），选择平面后可以看到插值用到的光照探针。可以看到光照效果很差，所以大物体不适合使用探针。</p><p>###特殊说明</p><ol><li>如果为一个物体烘焙了光照贴图，那么即使取消了lightmap static，lightprobe也不会生效（灰色状态），必须手动清除光照贴图。</li></ol><p><img src="/../../images/10.%E9%94%99%E8%AF%AF%E5%85%89%E7%85%A7%E7%8A%B6%E6%80%811.PNG"></p><ol start="2"><li>如果一个物体还没有烘焙光照贴图，那么即使LightMap Static打开，Lightprobe也可以打开（正常情况他们是互斥的）。</li></ol><p><img src="/../../images/10.%E9%94%99%E8%AF%AF%E5%85%89%E7%85%A7%E7%8A%B6%E6%80%812.PNG"></p><p>上面两种情况就是光照信息错误的状态。</p><p>物体受光可以参考一下Shader当中的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 <span class="hljs-title function_">SampleBakedGI</span><span class="hljs-params">(float3 positionRWS, float3 normalWS, float2 uvStaticLightmap, float2 uvDynamicLightmap)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)</span><br><span class="hljs-comment">// If there is no lightmap, it assume lightprobe</span><br>  ...<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br>    float3 bakeDiffuseLighting = float3(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LIGHTMAP_ON</span><br>        bakeDiffuseLighting += SampleDirectionalLightmap();<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DYNAMICLIGHTMAP_ON</span><br>        bakeDiffuseLighting += SampleSingleLightmap()<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> bakeDiffuseLighting;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="光源烘焙"><a href="#光源烘焙" class="headerlink" title="光源烘焙"></a>光源烘焙</h2><p>三种光源（每种光源的两个部分）和两种emission通过光照烘焙之后会通过不同的方式对物体产生影响。</p><ol><li>Realtime GI贴图： Realtime Light的间接部分  + realtime emission。</li><li>Baked GI贴图：Mix Light的间接部分 + Baked Light的全部 + baked emission。</li><li>实时光照计算： Realtime的直接部分 + MixLight的直接部分。</li><li>光头照探针里面：Mix Light的间接部分 + Baked Light的全部 + baked emission+ Realtime Light的间接部分</li></ol><p>这里特殊说明mix 光源类型我们关掉自发光，将红光变成mix点光源，蓝光还是bake。</p><p><img src="/../../images/10.mix%E5%85%89%E6%BA%90.PNG"></p><p>此时法线，realtime的间接光烘焙到了bakelightmap当中。此时如果在Play模式下变化mix点光源，只有直接光会变化，而Baked lilghtmap不会变化，如果在运行过程中，把红色点光源变化realtime，则Realtime lightmap中也不计算间接光，因为没有预先烘焙的信息。</p><p>​<strong>结合上一部分的特殊说明：所有GI内容和物体类型，必须在设置好之后统一bake一次。在修改了物体类型和光照类型之后，也必须重新bake，场景光照才会正确。</strong></p><h2 id="光照设置-1"><a href="#光照设置-1" class="headerlink" title="光照设置"></a>光照设置</h2><p>光照设置有下面三块：</p><ol><li>Realtime Lighting.</li><li>Mixed Lighting.</li><li>Lightmapping Setting.</li></ol><p>###Realtime Lighting</p><p>这个下面只有一个开关。Realtime Global Illumination，用于控制是否生成Realtime GI贴图。</p><p>如果不选择。那么对于LightMap Static打开的物体受光就会发生改变：</p><p>从   :</p><p><strong>Realtime GI贴图 + Baked GI贴图 + realtime 光的直接光照 + mix 光的直接光照。</strong> </p><p>变成 :</p><p>​                                   <strong>Baked GI贴图 + realtime 光的直接光照 + mix 光的直接光照</strong>。</p><h3 id="Mixed-Lighting"><a href="#Mixed-Lighting" class="headerlink" title="Mixed Lighting"></a>Mixed Lighting</h3><p>这个下面有一个开关，Baked  Global Illumination用于控制是否生成Baked GI贴图。</p><p>效果和上面的Realtime Global Illumination一致。</p><p>还有一个选项Lighting Mode。这个用于控制MixLight对于ShadowMask之类的类容有所影响，对于前面的内容没有影响。</p><p>下面是三种设置情况对应的物体接受光照贴图的情况：</p><p>1.Realtime GI开Baked GI开</p><p><img src="/../../images/10.%E5%85%89%E7%85%A7%E8%AE%BE%E7%BD%AE1.PNG"></p><p>2.Realtime GI关Baked GI开</p><p><img src="/../../images/10.%E5%85%89%E7%85%A7%E8%AE%BE%E7%BD%AE2.PNG"></p><p>3.Realtime GI开Baked GI关</p><p><img src="/../../images/10.%E5%85%89%E7%85%A7%E8%AE%BE%E7%BD%AE3.PNG"></p><h3 id="Lightmapping-Setting"><a href="#Lightmapping-Setting" class="headerlink" title="Lightmapping Setting"></a>Lightmapping Setting</h3><p>这个主要用来控制 <strong>Baked GI贴图</strong>如何生成。</p><p>Directional Mode 开始 对于<strong>Baked GI贴图</strong>和<strong>Realtime GI贴图</strong>同时生效。</p>]]></content>
      
      
      <categories>
          
          <category> HDRPSource </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码结构</title>
      <link href="/2022/07/09/HDRPsource/1.%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"/>
      <url>/2022/07/09/HDRPsource/1.%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><p>hdrp的所有渲染过程描述在HDRenderPipeline类的Render方法当中：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">UnityEngine.Experimental.Rendering.HDPipeline</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HDRenderPipeline</span> &#123;<br>...<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Render</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function"> ScriptableRenderContext renderContext, Camera[] cameras</span></span><br><span class="hljs-params"><span class="hljs-function"> </span>)</span><br><span class="hljs-function">...</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="Render方法"><a href="#Render方法" class="headerlink" title="Render方法"></a>Render方法</h1><p>render方法当中的主要输入的ScriptableRenderContext和Camera列表：</p><p>ScriptableRenderContext：定义状态、收集渲染命令。</p><p>摄像机列表</p><h2 id="render主要过程"><a href="#render主要过程" class="headerlink" title="render主要过程"></a>render主要过程</h2><p>收件进行物体剪裁</p><p>然后调用一系列DrawRenderers和CommandBuffer</p><p>最终提交</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Render</span>(<span class="hljs-params">ScriptableRenderContext renderContext, Camera[] cameras</span>)</span><br>&#123;<br>  <span class="hljs-comment">//调用父类方法</span><br>  <span class="hljs-keyword">base</span>.Render(renderContext, cameras);<br>  <br>  <span class="hljs-comment">//渲染时间控制</span><br>    &#123;<br><br>    &#125;<br>  <br>  <span class="hljs-comment">// 渲染平面反射 ：统计需要渲染的反射类型：反射探针 和 平面反射</span><br>  <span class="hljs-comment">// 通过深层调用可以发现最终调用的是 renderCamera.Render();</span><br>    ReflectionSystem.RenderAllRealtimeProbes(probeTypeToRender);<br>  <br>  <span class="hljs-comment">// 更新HDRP assets 设置</span><br>    m_Asset.UpdateDirtyFrameSettings();<br>  <br>    <span class="hljs-comment">// 为每个摄像机循环渲染</span><br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> camera <span class="hljs-keyword">in</span> cameras)<br>    &#123;<br>      RenderPipeline.BeginCameraRendering(camera);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="为每个摄像机循环渲染"><a href="#为每个摄像机循环渲染" class="headerlink" title="为每个摄像机循环渲染"></a>为每个摄像机循环渲染</h2><h3 id="准备设置参数"><a href="#准备设置参数" class="headerlink" title="准备设置参数"></a>准备设置参数</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (camera == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">// 首先从摄像机上获取摄像机设置。</span><br><span class="hljs-keyword">var</span> additionalCameraData = camera.GetComponent&lt;HDAdditionalCameraData&gt;();<br>FrameSettings srcFrameSettings;<br><span class="hljs-comment">// 如果有这个组件则从组件当中获取最新设置FrameSettings。</span><br><span class="hljs-keyword">if</span> (additionalCameraData)<br>&#123;                additionalCameraData.UpdateDirtyFrameSettings(assetFrameSettingsIsDirty, m_Asset.GetFrameSettings());<br> srcFrameSettings = additionalCameraData.GetFrameSettings();<br> &#125;<br><span class="hljs-comment">// 如果没有则从HDRenderPipelineAsset中获取设置</span><br><span class="hljs-keyword">else</span><br>&#123;<br>    srcFrameSettings = m_Asset.GetFrameSettings();<br>&#125;<br><br><span class="hljs-comment">//  根据各方面内容初始化帧设置。</span><br>   FrameSettings currentFrameSettings = <span class="hljs-keyword">new</span> FrameSettings();<br> FrameSettings.InitializeFrameSettings(camera, m_Asset.GetRenderPipelineSettings(), srcFrameSettings, <span class="hljs-keyword">ref</span> currentFrameSettings);<br><br><br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//初始化commandbuffer来提交主要的渲染命令</span><br><span class="hljs-keyword">var</span> cmd = CommandBufferPool.Get(<span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-comment">// 完全自定义内容的摄像机，不进入渲染过程</span><br><span class="hljs-keyword">if</span> (additionalCameraData <br>&amp;&amp; additionalCameraData.renderingPath == HDAdditionalCameraData.RenderingPath.FullscreenPassthrough)<br>&#123;<br>  <span class="hljs-comment">// 直接提交一个空的command buffer执行</span><br>  <span class="hljs-comment">// 这里思考一下我们的Command在哪里起作用</span><br>  renderContext.ExecuteCommandBuffer(cmd);<br>  CommandBufferPool.Release(cmd);<br>  renderContext.Submit();<br>  <span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">// 渲染反射：如果注意就可以发现，上面也有一个RenderAllRealtimeViewerDependentProbes区别在于上面的没有提供摄像机，一个是静态的、一个是为当前摄像机渲染的动态的。</span><br><span class="hljs-keyword">if</span> (camera.cameraType != CameraType.Reflection &amp;&amp; camera.cameraType != CameraType.Preview &amp;&amp; !camera.orthographic) ReflectionSystem.RenderAllRealtimeViewerDependentProbesFor(ReflectionProbeType.PlanarReflection, camera);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">可以查看反射探针和镜面反射探针，都保存在下面的数组中</span><br><span class="hljs-comment">m_PlanarReflectionProbe_PerCamera_RealtimeUpdate</span><br><span class="hljs-comment">m_PlanarReflectionProbe_RealtimeUpdate_WorkArray</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 初始化材质资源，材质列表中每个材质需要的资源初始化。用cmd来申请</span><br><span class="hljs-comment">// m_MaterialList如何填充的？</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> material <span class="hljs-keyword">in</span> m_MaterialList)<br>   material.RenderInit(cmd);<br><br><span class="hljs-comment">// 使用ProfilingSamplig采样渲染</span><br><span class="hljs-comment">// 填充CommandBuffer来指定渲染过程</span><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;HDRenderPipeline::Render&quot;</span>, CustomSamplerId.HDRenderPipelineRender.GetSampler()))<br>&#123;<br>   <br>&#125;<br><br><span class="hljs-comment">// 执行组装好的CommandBuffer</span><br>renderContext.ExecuteCommandBuffer(cmd);<br><span class="hljs-comment">// 释放</span><br>CommandBufferPool.Release(cmd);<br><span class="hljs-comment">// 提交</span><br>renderContext.Submit();<br><br><span class="hljs-comment">// 和调试相关的内容暂时忽略</span><br><span class="hljs-keyword">if</span> (m_CurrentDebugDisplaySettings.fullScreenDebugMode == FullScreenDebugMode.ScreenSpaceTracing)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="填充CommandBuffer来指定渲染过程"><a href="#填充CommandBuffer来指定渲染过程" class="headerlink" title="填充CommandBuffer来指定渲染过程"></a>填充CommandBuffer来指定渲染过程</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-comment">// 初始化设置  @@</span><br>m_LightLoop.NewFrame(currentFrameSettings);<br><br><span class="hljs-comment">// 根据摄像机类型设置m_CurrentDebugDisplaySettings</span><br><span class="hljs-keyword">if</span> (camera.cameraType == CameraType.Reflection || camera.cameraType == CameraType.Preview)<br>&#123;<br>  m_CurrentDebugDisplaySettings = s_NeutralDebugDisplaySettings;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>  m_CurrentDebugDisplaySettings = m_DebugDisplaySettings;<br>&#125;<br><br><span class="hljs-comment">// Volume相关的处理</span><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;Volume Update&quot;</span>, CustomSamplerId.VolumeUpdate.GetSampler()))<br>&#123;<br>&#125;<br><br><span class="hljs-comment">// 或处理判断</span><br><span class="hljs-keyword">var</span> postProcessLayer = camera.GetComponent&lt;PostProcessLayer&gt;();<br><span class="hljs-comment">// Disable post process if we enable debug mode or if the post process layer is disabled</span><br><span class="hljs-keyword">if</span> (m_CurrentDebugDisplaySettings.IsDebugDisplayRemovePostprocess() || !HDUtils.IsPostProcessingActive(postProcessLayer))<br>&#123;<br>  currentFrameSettings.enablePostprocess = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// 摄像机HDCamera设置，体积光系统？</span><br><span class="hljs-keyword">var</span> hdCamera = HDCamera.Get(camera);<br><span class="hljs-keyword">if</span> (hdCamera == <span class="hljs-literal">null</span>)<br>&#123;<br>  hdCamera = HDCamera.Create(camera, m_VolumetricLightingSystem);<br>&#125;<br>hdCamera.Update(currentFrameSettings, postProcessLayer, m_VolumetricLightingSystem);<br>Resize(hdCamera);<br>ApplyDebugDisplaySettings(hdCamera, cmd);<br>UpdateShadowSettings(hdCamera);<br>m_SkyManager.UpdateCurrentSkySettings(hdCamera);<br></code></pre></td></tr></table></figure><h4 id="剪裁"><a href="#剪裁" class="headerlink" title="剪裁"></a>剪裁</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">ScriptableCullingParameters cullingParams;<br><span class="hljs-keyword">if</span> (!CullResults.GetCullingParameters(camera, hdCamera.frameSettings.enableStereo, <span class="hljs-keyword">out</span> cullingParams))<br>&#123;<br>  renderContext.Submit();<br>  <span class="hljs-keyword">continue</span>;<br>&#125;<br>m_LightLoop.UpdateCullingParameters(<span class="hljs-keyword">ref</span> cullingParams);<br>hdCamera.UpdateStereoDependentState(<span class="hljs-keyword">ref</span> cullingParams);<br></code></pre></td></tr></table></figure><p>####一堆看不懂的设置</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableDBuffer)<br>&#123;<br>  <span class="hljs-comment">// decal system needs to be updated with current camera, it needs it to set up culling and light list generation parameters</span><br>  DecalSystem.instance.CurrentCamera = camera;<br>  DecalSystem.instance.BeginCull();<br>&#125;<br><br>ReflectionSystem.PrepareCull(camera, m_ReflectionProbeCullResults);<br><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;CullResults.Cull&quot;</span>, CustomSamplerId.CullResultsCull.GetSampler()))<br>&#123;<br>  CullResults.Cull(<span class="hljs-keyword">ref</span> cullingParams, renderContext, <span class="hljs-keyword">ref</span> m_CullResults);<br>&#125;<br><br>m_ReflectionProbeCullResults.Cull();<br><br>m_DbufferManager.EnableDBUffer = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;DBufferPrepareDrawData&quot;</span>, CustomSamplerId.DBufferPrepareDrawData.GetSampler()))<br>&#123;<br>  <span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableDBuffer)<br>  &#123;<br>    DecalSystem.instance.EndCull();<br>    m_DbufferManager.EnableDBUffer = <span class="hljs-literal">true</span>;              <span class="hljs-comment">// mesh decals are renderers managed by c++ runtime and we have no way to query if any are visible, so set to true</span><br>    DecalSystem.instance.UpdateCachedMaterialData();    <span class="hljs-comment">// textures, alpha or fade distances could&#x27;ve changed</span><br>    DecalSystem.instance.CreateDrawData();              <span class="hljs-comment">// prepare data is separate from draw</span><br>    DecalSystem.instance.UpdateTextureAtlas(cmd);       <span class="hljs-comment">// as this is only used for transparent pass, would&#x27;ve been nice not to have to do this if no transparent renderers are visible, needs to happen after CreateDrawData</span><br>  &#125;<br>&#125;<br>renderContext.SetupCameraProperties(camera, hdCamera.frameSettings.enableStereo);<br><br>PushGlobalParams(hdCamera, cmd, diffusionProfileSettings);<br><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Find a correct place to bind these material textures</span><br><span class="hljs-comment">// We have to bind the material specific global parameters in this mode</span><br>m_MaterialList.ForEach(material =&gt; material.Bind());<br><br><span class="hljs-comment">// Frustum cull density volumes on the CPU. Can be performed as soon as the camera is set up.</span><br>DensityVolumeList densityVolumes = m_VolumetricLightingSystem.PrepareVisibleDensityVolumeList(hdCamera, cmd, m_Time);<br><br><span class="hljs-comment">// Note: Legacy Unity behave like this for ShadowMask</span><br><span class="hljs-comment">// When you select ShadowMask in Lighting panel it recompile shaders on the fly with the SHADOW_MASK keyword.</span><br><span class="hljs-comment">// However there is no C# function that we can query to know what mode have been select in Lighting Panel and it will be wrong anyway. Lighting Panel setup what will be the next bake mode. But until light is bake, it is wrong.</span><br><span class="hljs-comment">// Currently to know if you need shadow mask you need to go through all visible lights (of CullResult), check the LightBakingOutput struct and look at lightmapBakeType/mixedLightingMode. If one light have shadow mask bake mode, then you need shadow mask features (i.e extra Gbuffer).</span><br><span class="hljs-comment">// It mean that when we build a standalone player, if we detect a light with bake shadow mask, we generate all shader variant (with and without shadow mask) and at runtime, when a bake shadow mask light is visible, we dynamically allocate an extra GBuffer and switch the shader.</span><br><span class="hljs-comment">// So the first thing to do is to go through all the light: PrepareLightsForGPU</span><br><span class="hljs-built_in">bool</span> enableBakeShadowMask;<br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;TP_PrepareLightsForGPU&quot;</span>, CustomSamplerId.TPPrepareLightsForGPU.GetSampler()))<br>&#123;<br>  enableBakeShadowMask = m_LightLoop.PrepareLightsForGPU(cmd, hdCamera, m_ShadowSettings, m_CullResults, m_ReflectionProbeCullResults, densityVolumes);<br>&#125;<br>ConfigureForShadowMask(enableBakeShadowMask, cmd);<br><br></code></pre></td></tr></table></figure><h4 id="正式开始渲染-必要部分1"><a href="#正式开始渲染-必要部分1" class="headerlink" title="正式开始渲染:必要部分1"></a>正式开始渲染:必要部分1</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#">StartStereoRendering(renderContext, hdCamera);<br>ClearBuffers(hdCamera, cmd);<br><br><span class="hljs-comment">// 预先深度</span><br>RenderDepthPrepass(m_CullResults, hdCamera, renderContext, cmd);<br><br><span class="hljs-comment">// 渲染深度给Decal使用</span><br>RenderDBuffer(hdCamera, cmd, renderContext, m_CullResults);<br><br><span class="hljs-comment">// 渲染Gbuffer</span><br>RenderGBuffer(m_CullResults, hdCamera, enableBakeShadowMask, renderContext, cmd);<br><br><span class="hljs-comment">// 绑定NormalBuffer到某个外部纹理？？</span><br>m_NormalBufferManager.BindNormalBuffers(cmd);<br><br><span class="hljs-comment">// 渲染深度和深度金字塔</span><br>CopyDepthBufferIfNeeded(cmd);<br>RenderDepthPyramid(hdCamera, cmd, renderContext, FullScreenDebugMode.DepthPyramid);<br><br><span class="hljs-comment">// 渲染MotionVector？？</span><br>RenderObjectsVelocity(m_CullResults, hdCamera, renderContext, cmd);<br>RenderCameraVelocity(m_CullResults, hdCamera, renderContext, cmd);<br><br><span class="hljs-comment">// 设置全局的深度纹理</span><br>cmd.SetGlobalTexture(HDShaderIDs._CameraDepthTexture, GetDepthTexture());<br><br><span class="hljs-comment">// 天空盒更新</span><br>UpdateSkyEnvironment(hdCamera, cmd);<br><br>StopStereoRendering(renderContext, hdCamera);<br><br><span class="hljs-keyword">if</span> (m_CurrentDebugDisplaySettings.IsDebugMaterialDisplayEnabled())<br>&#123;<br>  RenderDebugViewMaterial(m_CullResults, hdCamera, renderContext, cmd);<br><br>  PushColorPickerDebugTexture(cmd, m_CameraColorBuffer, hdCamera);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>  <span class="hljs-comment">//正式开始渲染:必要部分2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>####正式开始渲染:必要部分2 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#">StartStereoRendering(renderContext, hdCamera);<br><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;Render SSAO&quot;</span>, CustomSamplerId.RenderSSAO.GetSampler()))<br>&#123;<br><span class="hljs-comment">//渲染SSAO，屏幕空间环境光，这里需要PostProcessing？？？</span><br>  RenderSSAO(cmd, hdCamera, renderContext, postProcessLayer);<br>&#125;<br><br><br><span class="hljs-comment">// FeatureVariamts ??? 和Stencil相关</span><br><span class="hljs-keyword">if</span> (m_LightLoop.GetFeatureVariantsEnabled())<br>&#123;<br>  <span class="hljs-comment">// For material classification we use compute shader and so can&#x27;t read into the stencil, so prepare it.</span><br>  <span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;Clear and copy stencil texture&quot;</span>, CustomSamplerId.ClearAndCopyStencilTexture.GetSampler()))<br>  &#123;<br>    HDUtils.SetRenderTarget(cmd, hdCamera, m_CameraStencilBufferCopy, ClearFlag.Color, CoreUtils.clearColorAllBlack);<br><br>    <span class="hljs-comment">// In the material classification shader we will simply test is we are no lighting</span><br>    <span class="hljs-comment">// Use ShaderPassID 1 =&gt; &quot;Pass 1 - Write 1 if value different from stencilRef to output&quot;</span><br>    HDUtils.DrawFullScreen(cmd, hdCamera, m_CopyStencilForNoLighting, m_CameraStencilBufferCopy, m_CameraDepthStencilBuffer, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><br>StopStereoRendering(renderContext, hdCamera);<br><br><span class="hljs-comment">// 异步计算阴影？？</span><br>GPUFence buildGPULightListsCompleteFence = <span class="hljs-keyword">new</span> GPUFence();<br><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableAsyncCompute)<br>&#123;<br>  GPUFence startFence = cmd.CreateGPUFence();<br>  renderContext.ExecuteCommandBuffer(cmd);<br>  cmd.Clear();<br><br>  buildGPULightListsCompleteFence = m_LightLoop.BuildGPULightListsAsyncBegin(hdCamera, renderContext, m_CameraDepthStencilBuffer, m_CameraStencilBufferCopy, startFence, m_SkyManager.IsLightingSkyValid());<br>&#125;<br><br><span class="hljs-comment">//正式开始渲染:必要部分3 </span><br></code></pre></td></tr></table></figure><p>####正式开始渲染:必要部分3 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs c#"> <span class="hljs-comment">// 渲染阴影</span><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;Render shadows&quot;</span>, CustomSamplerId.RenderShadows.GetSampler()))<br>&#123;<br>  m_LightLoop.RenderShadows(renderContext, cmd, m_CullResults);<br><br>  <span class="hljs-comment">// Overwrite camera properties set during the shadow pass with the original camera properties.</span><br>  renderContext.SetupCameraProperties(camera, hdCamera.frameSettings.enableStereo);<br>  hdCamera.SetupGlobalParams(cmd, m_Time, m_LastTime, m_FrameCount);<br>  <span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableStereo)<br>    hdCamera.SetupGlobalStereoParams(cmd);<br>&#125;<br><br><span class="hljs-comment">// 渲染deffered直接阴影</span><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;Deferred directional shadows&quot;</span>, CustomSamplerId.RenderDeferredDirectionalShadow.GetSampler()))<br>&#123;<br>    <span class="hljs-comment">// When debug is enabled we need to clear otherwise we may see non-shadows areas with stale values.</span><br>    <span class="hljs-keyword">if</span> (m_CurrentDebugDisplaySettings.fullScreenDebugMode == FullScreenDebugMode.DeferredShadows)<br>    &#123;<br>      HDUtils.SetRenderTarget(cmd, hdCamera, m_DeferredShadowBuffer, ClearFlag.Color, CoreUtils.clearColorAllBlack);<br>    &#125;<br><br>    m_LightLoop.RenderDeferredDirectionalShadow(hdCamera, m_DeferredShadowBuffer, GetDepthTexture(), cmd);<br>    PushFullScreenDebugTexture(hdCamera, cmd, m_DeferredShadowBuffer, FullScreenDebugMode.DeferredShadows);<br>&#125;<br><br><span class="hljs-comment">// 异步计算阴影结束？</span><br><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableAsyncCompute)<br>&#123;<br>  m_LightLoop.BuildGPULightListAsyncEnd(hdCamera, cmd, buildGPULightListsCompleteFence);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>  <span class="hljs-comment">// 配置光照列表</span><br>  <span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;Build Light list&quot;</span>, CustomSamplerId.BuildLightList.GetSampler()))<br>  &#123;<br>    m_LightLoop.BuildGPULightLists(hdCamera, cmd, m_CameraDepthStencilBuffer, m_CameraStencilBufferCopy, m_SkyManager.IsLightingSkyValid());<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 和体积光相关的雾参数</span><br>&#123;<br>  <span class="hljs-comment">// Set fog parameters for volumetric lighting.</span><br>  <span class="hljs-keyword">var</span> visualEnv = VolumeManager.instance.stack.GetComponent&lt;VisualEnvironment&gt;();<br>  visualEnv.PushFogShaderParameters(hdCamera, cmd);<br>&#125;<br><br><span class="hljs-comment">// 体素化阶段</span><br>m_VolumetricLightingSystem.VolumeVoxelizationPass(hdCamera, cmd, m_FrameCount, densityVolumes);<br><br><span class="hljs-comment">// 渲染体积光</span><br>m_VolumetricLightingSystem.VolumetricLightingPass(hdCamera, cmd, m_FrameCount);<br><br><span class="hljs-comment">// 渲染延迟光照</span><br>RenderDeferredLighting(hdCamera, cmd);<br><br><span class="hljs-comment">// Might float this higher if we enable stereo w/ deferred</span><br>StartStereoRendering(renderContext, hdCamera);<br><br><span class="hljs-comment">// 渲染前向物体</span><br>RenderForward(m_CullResults, hdCamera, renderContext, cmd, ForwardPass.Opaque);<br><br><span class="hljs-comment">// SSS pass here handle both SSS material from deferred and forward</span><br>m_SSSBufferManager.SubsurfaceScatteringPass(hdCamera, cmd, diffusionProfileSettings,m_CameraColorBuffer, m_CameraSssDiffuseLightingBuffer, m_CameraDepthStencilBuffer, GetDepthTexture());<br><br><span class="hljs-comment">// 渲染天空</span><br>RenderSky(hdCamera, cmd);<br><br><span class="hljs-comment">// 渲染每一个反射物体</span><br>RenderForward(m_CullResults, hdCamera, renderContext, cmd, ForwardPass.PreRefraction);<br><br><span class="hljs-comment">// 渲染颜色金字塔</span><br>RenderColorPyramid(hdCamera, cmd, renderContext, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 渲染前向物体</span><br><span class="hljs-comment">// Render all type of transparent forward (unlit, lit, complex (hair...)) to keep the sorting between transparent objects.</span><br>RenderForward(m_CullResults, hdCamera, renderContext, cmd, ForwardPass.Transparent);<br><br><span class="hljs-comment">// 渲染错误</span><br><span class="hljs-comment">// Render All forward error</span><br>RenderForwardError(m_CullResults, hdCamera, renderContext, cmd);<br><br><span class="hljs-comment">// Fill depth buffer to reduce artifact for transparent object during postprocess</span><br><span class="hljs-comment">// 给后处理渲染透明物体的深度</span><br>RenderTransparentDepthPostpass(m_CullResults, hdCamera, renderContext, cmd, ForwardPass.Transparent);<br><br><span class="hljs-comment">// 渲染颜色金字塔2</span><br>RenderColorPyramid(hdCamera, cmd, renderContext, <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// ？？</span><br>AccumulateDistortion(m_CullResults, hdCamera, renderContext, cmd);<br>RenderDistortion(hdCamera, cmd, m_Asset.renderPipelineResources);<br><br>StopStereoRendering(renderContext, hdCamera);<br><br><span class="hljs-comment">// 测设相关</span><br>PushFullScreenDebugTexture(hdCamera, cmd, m_CameraColorBuffer, FullScreenDebugMode.NanTracker);<br>PushColorPickerDebugTexture(hdCamera, cmd, m_CameraColorBuffer);<br><br>StartStereoRendering(renderContext, hdCamera);<br><br><span class="hljs-comment">// 后处理</span><br><span class="hljs-comment">// Final blit</span><br><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enablePostprocess)<br>&#123;<br>  RenderPostProcess(hdCamera, cmd, postProcessLayer);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>  <span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;Blit to final RT&quot;</span>, CustomSamplerId.BlitToFinalRT.GetSampler()))<br>  &#123;<br>    <span class="hljs-comment">// This Blit will flip the screen on anything other than openGL</span><br>    HDUtils.BlitCameraTexture(cmd, hdCamera, m_CameraColorBuffer, BuiltinRenderTextureType.CameraTarget);<br>  &#125;<br>&#125;<br><br>StopStereoRendering(renderContext, hdCamera);<br><span class="hljs-comment">// Pushes to XR headset and/or display mirror</span><br><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableStereo)<br>  renderContext.StereoEndRender(hdCamera.camera);<br></code></pre></td></tr></table></figure><h1 id="具体渲染方法"><a href="#具体渲染方法" class="headerlink" title="具体渲染方法"></a>具体渲染方法</h1><h2 id="RenderDepthPrepass"><a href="#RenderDepthPrepass" class="headerlink" title="RenderDepthPrepass"></a>RenderDepthPrepass</h2><p>渲染内容：根据渲染设置提前渲染深度。</p><p><strong>在Deferred渲染过程中，我们可以使用Forward不透明材质，这些材质需要渲染深度，来得到正确的灯光列表</strong></p><p><strong>之后再Deferred光照阶段（deferred lighting pass），不去渲染这些forward的不透明材质。</strong></p><p>在deferred模式下，默认是没有forward不透明物体的。但是如果有了，就需要ForwardOnly强行渲染不透明物体。这时候Forward没用，只有FOrwardOnly有用。同时也需要有DepthForwardOnly。</p><p>如果forward材质没有深度，则光照可能不正确。</p><p>  &#x2F;&#x2F; Forward material always output normal buffer (unless they don’t participate to shading)</p><p>&#x2F;&#x2F; Deferred material never output normal buffer</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Asset当中开启了Forward Only，则只会渲染前向物体。则depthonly 和depthforwardonly都会渲染。</span><br><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableForwardRenderingOnly)<br>&#123;<br>  HDUtils.SetRenderTarget 设置渲染目标<br>  <span class="hljs-comment">// Full forward: Output normal buffer for both forward and forwardOnly</span><br> RenderOpaqueRenderList(cull, <span class="hljs-comment">// 剪裁结果保存了所有Render</span><br>                        hdCamera, <span class="hljs-comment">//摄像机参数</span><br>                        renderContext,  <span class="hljs-comment">// 渲染上下文</span><br>                        cmd, <br>                        <span class="hljs-comment">// 需要渲染的pass ，所有深度pass都会渲染</span><br>                        m_DepthOnlyAndDepthForwardOnlyPassNames,<br>                        <span class="hljs-number">0</span>, <br>                        <span class="hljs-comment">// 渲染队列</span><br>                        HDRenderQueue.k_RenderQueue_AllOpaque);<br>&#125;<br><span class="hljs-comment">// 如果是deferred render的物体（也就是没有开启Forward Only设置）开启了DepthPrepass,或者开启了深度DBuffer，就会给Deferred渲染的物体也进行prepass深度渲染，一般主需要渲染forward的深度就可以。</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableDepthPrepassWithDeferredRendering || m_DbufferManager.EnableDBUffer)<br>&#123;<br>  HDUtils.SetRenderTarget(cmd, hdCamera, m_CameraDepthStencilBuffer);<br>  <span class="hljs-comment">// 用DepthOnly写入deferred的深度</span><br>  RenderOpaqueRenderList(cull, hdCamera, renderContext, cmd, m_DepthOnlyPassNames, <span class="hljs-number">0</span>, HDRenderQueue.k_RenderQueue_AllOpaque);<br><br>  <span class="hljs-comment">//与上面不同的是颜色缓存使用了法线 RTI（rendertexture index）也就是forward物体需要填充法线纹理。</span><br>  HDUtils.SetRenderTarget(cmd, hdCamera, <br>                          m_NormalBufferManager.GetBuffersRTI(),<br>                          m_CameraDepthStencilBuffer);<br><br>  <span class="hljs-comment">// 用DepthForwardOnly写入Forward物体的深度</span><br>  RenderOpaqueRenderList(cull, hdCamera, renderContext, cmd, m_DepthForwardOnlyPassNames, <span class="hljs-number">0</span>, HDRenderQueue.k_RenderQueue_AllOpaque);<br><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">// Deferred with partial depth prepass</span><br>&#123;<br>  cmd.DisableShaderKeyword(<span class="hljs-string">&quot;WRITE_NORMAL_BUFFER&quot;</span>);<br><span class="hljs-comment">// 给Deferred alpha tested materials必须渲染prepass。</span><br>  HDUtils.SetRenderTarget(cmd, hdCamera, m_CameraDepthStencilBuffer);<br>  <span class="hljs-keyword">var</span> renderQueueRange = <span class="hljs-keyword">new</span> RenderQueueRange &#123; min = (<span class="hljs-built_in">int</span>)RenderQueue.AlphaTest, max = (<span class="hljs-built_in">int</span>)RenderQueue.GeometryLast - <span class="hljs-number">1</span> &#125;;<br>  RenderOpaqueRenderList(cull, hdCamera, renderContext, cmd, m_DepthOnlyPassNames, <span class="hljs-number">0</span>, renderQueueRange);<br><br>  HDUtils.SetRenderTarget(cmd, hdCamera, m_NormalBufferManager.GetBuffersRTI(), m_CameraDepthStencilBuffer);<br><span class="hljs-comment">// 在deferred 模式下强行渲染Forward不透明物体，需要有DepthForwardonlyPath，否则光照错误。</span><br>  RenderOpaqueRenderList(cull, hdCamera, renderContext, cmd, m_DepthForwardOnlyPassNames, <span class="hljs-number">0</span>, HDRenderQueue.k_RenderQueue_AllOpaque);<br><br>&#125;<br><br><span class="hljs-comment">// 透明物体的Prepass</span><br><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableTransparentPrepass)<br>&#123;<br>RenderTransparentRenderList(cull, hdCamera, <br>                                renderContext, <br>                                cmd, <br>                                m_TransparentDepthPrepassNames);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RenderDBuffer"><a href="#RenderDBuffer" class="headerlink" title="RenderDBuffer"></a>RenderDBuffer</h2><p>如果需要深度贴图则绑定一个DBuffer，需要接受Decal的也在这里渲染</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//如果开启Dbuffer</span><br><span class="hljs-keyword">if</span> (!hdCamera.frameSettings.enableDBuffer)<br>  <span class="hljs-keyword">return</span>;<br><br><br>  <span class="hljs-comment">// We need to copy depth buffer texture if we want to bind it at this stage</span><br><span class="hljs-comment">// 复制了一份CameraDepthStencil</span><br>  CopyDepthBufferIfNeeded(cmd);<br><br>  <span class="hljs-comment">// Depth texture is now ready, bind it. 把复制得到的深度设置成全局深度</span><br><span class="hljs-comment">// _CameraDepthTexture在这里生产</span><br>  cmd.SetGlobalTexture(HDShaderIDs._CameraDepthTexture, GetDepthTexture());<br>  m_DbufferManager.ClearTargets(cmd, hdCamera);<br>  HDUtils.SetRenderTarget(cmd, hdCamera, m_DbufferManager.GetBuffersRTI(), m_CameraDepthStencilBuffer); <span class="hljs-comment">// do not clear anymore</span><br>  m_DbufferManager.SetHTile(m_DbufferManager.bufferCount, cmd);<br>  renderContext.ExecuteCommandBuffer(cmd);<br>  cmd.Clear();<br><br><span class="hljs-comment">// 渲染空pass  绘制DBufferMesh Pass decal？</span><br><span class="hljs-comment">// 使用——MeshDecalsPass 渲染一个_DecalHTileTexture纹理</span><br>  DrawRendererSettings drawSettings = <span class="hljs-keyword">new</span> DrawRendererSettings(hdCamera.camera, HDShaderPassNames.s_EmptyName)<br>  &#123;<br>    rendererConfiguration = <span class="hljs-number">0</span>,<br>    sorting = &#123; flags = SortFlags.CommonOpaque &#125;<br>  &#125;;<br>  drawSettings.SetShaderPassName(<span class="hljs-number">0</span>, HDShaderPassNames.s_MeshDecalsName);<br>  FilterRenderersSettings filterRenderersSettings = <span class="hljs-keyword">new</span> FilterRenderersSettings(<span class="hljs-literal">true</span>)<br>  &#123;<br>    renderQueueRange = HDRenderQueue.k_RenderQueue_AllOpaque<br>  &#125;;<br><span class="hljs-comment">// 渲染需要接受decal的物体</span><br>  renderContext.DrawRenderers(cullResults.visibleRenderers, <span class="hljs-keyword">ref</span> drawSettings, filterRenderersSettings);<br><br><span class="hljs-comment">// 渲染Decal到Dbuffer  HtileDepth？</span><br>  DecalSystem.instance.RenderIntoDBuffer(cmd);<br>  m_DbufferManager.UnSetHTile(cmd);<br>  m_DbufferManager.SetHTileTexture(cmd);  <span class="hljs-comment">// mask per 8x8 tile used for optimization when looking up dbuffer values</span><br><br></code></pre></td></tr></table></figure><h2 id="RenderGBuffer"><a href="#RenderGBuffer" class="headerlink" title="RenderGBuffer"></a>RenderGBuffer</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 只渲染前向物体</span><br><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableForwardRenderingOnly)<br>  <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 设置Gbuffer目标，和深度</span><br>HDUtils.SetRenderTarget(cmd, hdCamera, m_GbufferManager.GetBuffersRTI(enableShadowMask), m_CameraDepthStencilBuffer);<br><span class="hljs-comment">// 进行渲染，渲染的过程填充深度</span><br>RenderOpaqueRenderList(cull, hdCamera, renderContext, cmd, HDShaderPassNames.s_GBufferName, m_currentRendererConfigurationBakedLighting, HDRenderQueue.k_RenderQueue_AllOpaque);<br><span class="hljs-comment">// 设置Gbuffer _GBufferTexture0 - 4</span><br>m_GbufferManager.BindBufferAsTextures(cmd);<br></code></pre></td></tr></table></figure><h2 id="RenderDepthPyramid"><a href="#RenderDepthPyramid" class="headerlink" title="RenderDepthPyramid"></a>RenderDepthPyramid</h2><p>computeShader计算深度金字塔</p><h2 id="RenderObjectsVelocity"><a href="#RenderObjectsVelocity" class="headerlink" title="RenderObjectsVelocity"></a>RenderObjectsVelocity</h2><p>渲染物体速度</p><h2 id="RenderCameraVelocity"><a href="#RenderCameraVelocity" class="headerlink" title="RenderCameraVelocity"></a>RenderCameraVelocity</h2><p>渲染摄像机速度</p><p>##cmd.SetGlobalTexture();</p><p>设置全局深度贴图</p><h2 id="RenderSSAO"><a href="#RenderSSAO" class="headerlink" title="RenderSSAO"></a>RenderSSAO</h2><p>SSAO, Shadow, Build light list, deferred shadow, material and light classification can be parallelize with Async compute</p><p>同时计算各种效果</p><h2 id="m-VolumetricLightingSystem"><a href="#m-VolumetricLightingSystem" class="headerlink" title="m_VolumetricLightingSystem"></a>m_VolumetricLightingSystem</h2><p>和体积光相关的操作</p><h2 id="m-LightLoop-RenderShadows"><a href="#m-LightLoop-RenderShadows" class="headerlink" title="m_LightLoop.RenderShadows"></a>m_LightLoop.RenderShadows</h2><p>渲染阴影</p><h2 id="m-LightLoop-RenderDeferredDirectionalShadow"><a href="#m-LightLoop-RenderDeferredDirectionalShadow" class="headerlink" title="m_LightLoop.RenderDeferredDirectionalShadow"></a>m_LightLoop.RenderDeferredDirectionalShadow</h2><h2 id="RenderDeferredLighting"><a href="#RenderDeferredLighting" class="headerlink" title="RenderDeferredLighting"></a>RenderDeferredLighting</h2><p>计算deferred物体光照 </p><p>实现了ComputeShader和Shader两个版本的Deferred计算。</p><h2 id="RenderForward"><a href="#RenderForward" class="headerlink" title="RenderForward"></a>RenderForward</h2><p>ForwardPass.Opaque Pass</p><p>在不同模式下的渲染：</p><p>在RenderForward的过程中，渲染那个pass会根据设置不同发生改变。</p><p>如果启用ForwardOnly Rnedering，那么Forward和ForwardOnly就都会渲染，无论是不透明物体还是透明物体。</p><p>如果是Deferred模式，那么对于transparent Forward和ForwardOnly就都会渲染，对于opaque就只会渲染ForwardOnly。</p><p>所以ForwardOnly 和Forward是互斥的。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// Debug相关内容</span><br><span class="hljs-built_in">string</span> profileName;<br><span class="hljs-keyword">if</span> (m_CurrentDebugDisplaySettings.IsDebugDisplayEnabled())<br>&#123;<br>  profileName = k_ForwardPassDebugName[(<span class="hljs-built_in">int</span>)pass];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>  profileName = k_ForwardPassName[(<span class="hljs-built_in">int</span>)pass];<br>&#125;<br><br><br><span class="hljs-comment">// 获取摄像机</span><br><span class="hljs-keyword">var</span> camera = hdCamera.camera;<br><br><span class="hljs-comment">// ???????</span><br>m_LightLoop.RenderForward(camera, cmd, pass == ForwardPass.Opaque);<br><br><span class="hljs-comment">// 屏幕空间Tracing</span><br><span class="hljs-keyword">var</span> debugScreenSpaceTracing = m_CurrentDebugDisplaySettings.fullScreenDebugMode == FullScreenDebugMode.ScreenSpaceTracing;<br><br><span class="hljs-comment">// 不透明物体</span><br><span class="hljs-keyword">if</span> (pass == ForwardPass.Opaque)<br>&#123;<br>  <span class="hljs-comment">// 使用SSS效果</span><br>  <span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableSubsurfaceScattering)<br>  &#123;<br>    RenderTargetIdentifier[] m_MRTWithSSS = <span class="hljs-keyword">new</span> RenderTargetIdentifier[<span class="hljs-number">2</span> + m_SSSBufferManager.sssBufferCount];<br>    <span class="hljs-comment">// 准备所有的SSS需要的buffer</span><br>    m_MRTWithSSS[<span class="hljs-number">0</span>] = m_CameraColorBuffer; <span class="hljs-comment">// Store the specular color</span><br>    m_MRTWithSSS[<span class="hljs-number">1</span>] = m_CameraSssDiffuseLightingBuffer;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; m_SSSBufferManager.sssBufferCount; ++i)<br>    &#123;<br>      m_MRTWithSSS[i + <span class="hljs-number">2</span>] = m_SSSBufferManager.GetSSSBuffer(i);<br>    &#125;<br><br>    HDUtils.SetRenderTarget(cmd, hdCamera, m_MRTWithSSS, m_CameraDepthStencilBuffer);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br><span class="hljs-comment">//不使用SSS效果，则就是用一般的Depth和COlorbuffer</span><br>    HDUtils.SetRenderTarget(cmd, hdCamera, m_CameraColorBuffer, m_CameraDepthStencilBuffer);<br>  &#125;<br><br>  <span class="hljs-comment">//根据渲染设置使用不同的Forwardpass  ： ForwardOnly Or Forward</span><br>  <span class="hljs-keyword">var</span> passNames = hdCamera.frameSettings.enableForwardRenderingOnly<br>    ? m_ForwardAndForwardOnlyPassNames<br>    : m_ForwardOnlyPassNames;<br>  <span class="hljs-comment">// 调试模式</span><br>  <span class="hljs-keyword">var</span> debugSSTThisPass = debugScreenSpaceTracing &amp;&amp; (m_CurrentDebugDisplaySettings.lightingDebugSettings.debugLightingMode == DebugLightingMode.ScreenSpaceTracingReflection);<br><br>  <span class="hljs-keyword">if</span> (debugSSTThisPass)<br>    cmd.SetRandomWriteTarget(<span class="hljs-number">7</span>, m_DebugScreenSpaceTracingData);<br>  <br>  <span class="hljs-comment">// 渲染不透明物体</span><br>  RenderOpaqueRenderList(cullResults, hdCamera, renderContext, cmd, passNames, m_currentRendererConfigurationBakedLighting);<br>  <br>  <span class="hljs-keyword">if</span> (debugSSTThisPass)<br>    cmd.ClearRandomWriteTargets();<br>&#125;<br><span class="hljs-comment">//渲染透明物体</span><br><span class="hljs-keyword">else</span><br>&#123;<br>  <span class="hljs-comment">// 设置透明物体渲染目标</span><br>  HDUtils.SetRenderTarget(cmd, hdCamera, m_CameraColorBuffer, m_CameraDepthStencilBuffer);<br>  <span class="hljs-comment">// 使用dbuffer 并且有Decal 则SetAtlas？？？？</span><br>  <span class="hljs-keyword">if</span> ((hdCamera.frameSettings.enableDBuffer) &amp;&amp; (DecalSystem.m_DecalDatasCount &gt; <span class="hljs-number">0</span>)) <br>  &#123;<br>    DecalSystem.instance.SetAtlas(cmd); <span class="hljs-comment">// for clustered decals</span><br>  &#125;<br><br>  <span class="hljs-keyword">var</span> debugSSTThisPass = debugScreenSpaceTracing &amp;&amp; (m_CurrentDebugDisplaySettings.lightingDebugSettings.debugLightingMode == DebugLightingMode.ScreenSpaceTracingRefraction);<br>  <span class="hljs-keyword">if</span> (debugSSTThisPass)<br>    cmd.SetRandomWriteTarget(<span class="hljs-number">7</span>, m_DebugScreenSpaceTracingData);<br>  <br>  <span class="hljs-comment">// 渲染透明物体</span><br>  RenderTransparentRenderList(cullResults, hdCamera, renderContext, cmd, m_AllTransparentPassNames, m_currentRendererConfigurationBakedLighting, pass == ForwardPass.PreRefraction ? HDRenderQueue.k_RenderQueue_PreRefraction : HDRenderQueue.k_RenderQueue_Transparent);<br>  <br>  <span class="hljs-keyword">if</span> (debugSSTThisPass)<br>    cmd.ClearRandomWriteTargets();<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//渲染的ShaderPass</span><br>   var passNames = hdCamera.frameSettings.enableForwardRenderingOnly<br>                        ? m_ForwardAndForwardOnlyPassNames<br>                        : m_ForwardOnlyPassNames;<br><br><span class="hljs-comment">// HDShaderPassNames.s_SRPDefaultUnlitName  是一个FallBack</span><br>ShaderPassName[] m_ForwardAndForwardOnlyPassNames = &#123; HDShaderPassNames.s_ForwardOnlyName, <br>                                                     HDShaderPassNames.s_ForwardName, <br>                                                     HDShaderPassNames.s_SRPDefaultUnlitName &#125;;<br>ShaderPassName[] m_ForwardOnlyPassNames = &#123; HDShaderPassNames.s_ForwardOnlyName, <br>                                           HDShaderPassNames.s_SRPDefaultUnlitName &#125;;<br><br><span class="hljs-comment">// 渲染队列</span><br>RenderQueueRange k_RenderQueue_AllOpaque = new RenderQueueRange &#123; <br>  min = (<span class="hljs-type">int</span>)Priority.Opaque,    <span class="hljs-number">2000</span><br>  max = (<span class="hljs-type">int</span>)Priority.OpaqueLast &#125;; <span class="hljs-number">2500</span><br></code></pre></td></tr></table></figure><h2 id="RenderSky"><a href="#RenderSky" class="headerlink" title="RenderSky"></a>RenderSky</h2><h2 id="RenderForward-1"><a href="#RenderForward-1" class="headerlink" title="RenderForward"></a>RenderForward</h2><p>forwardPass.PreRefraction Pass</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//渲染的pass</span><br>ShaderPassName[] m_AllTransparentPassNames = &#123;  HDShaderPassNames.s_TransparentBackfaceName,<br>                                                        HDShaderPassNames.s_ForwardOnlyName,<br>                                                        HDShaderPassNames.s_ForwardName,<br>                                                        HDShaderPassNames.s_SRPDefaultUnlitName &#125;;<br><span class="hljs-comment">// 渲染队列</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> RenderQueueRange k_RenderQueue_Transparent = <span class="hljs-keyword">new</span> RenderQueueRange &#123; <br>   min = (<span class="hljs-built_in">int</span>)Priority.PreRefractionFirst,  <span class="hljs-number">2750</span> - <span class="hljs-number">100</span><br>   max = (<span class="hljs-built_in">int</span>)Priority.PreRefractionLast &#125;; <span class="hljs-number">2750</span> + <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h2 id="RenderColorPyramid"><a href="#RenderColorPyramid" class="headerlink" title="RenderColorPyramid"></a>RenderColorPyramid</h2><p>Gpu计算,会根据是否需要Bloom，Distortion，SSR等内容来判断是否使用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">RenderColorPyramid(hdCamera, cmd, renderContext, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h2 id="RenderForward-2"><a href="#RenderForward-2" class="headerlink" title="RenderForward"></a>RenderForward</h2><p>ForwardPass.Transparent Pass</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">ShaderPassName[] m_AllTransparentPassNames = &#123;  HDShaderPassNames.s_TransparentBackfaceName,<br>                                                        HDShaderPassNames.s_ForwardOnlyName,<br>                                                        HDShaderPassNames.s_ForwardName,<br>                                                        HDShaderPassNames.s_SRPDefaultUnlitName &#125;;<br><br><span class="hljs-comment">//渲染队列</span><br> public <span class="hljs-type">static</span> readonly RenderQueueRange k_RenderQueue_PreRefraction = new RenderQueueRange &#123; min = (<span class="hljs-type">int</span>)Priority.TransparentFirst,     <span class="hljs-number">3000</span> - <span class="hljs-number">100</span><br>max = (<span class="hljs-type">int</span>)Priority. TransparentLast&#125;;    <span class="hljs-number">3000</span> + <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>##RednerTransparentDepthPostpass</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (!hdCamera.frameSettings.enableTransparentPostpass)<br><span class="hljs-keyword">return</span>;<br><br><br>HDUtils.SetRenderTarget(cmd, hdCamera, m_CameraDepthStencilBuffer);<br>RenderTransparentRenderList(cullResults, hdCamera, renderContext, cmd, m_TransparentDepthPostpassNames);<br><br><span class="hljs-comment">//使用Pass</span><br>TransparentDepthPostpass<br></code></pre></td></tr></table></figure><p>##RenderColorPyramid</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">RenderColorPyramid(hdCamera, cmd, renderContext, <span class="hljs-literal">false</span>); <br></code></pre></td></tr></table></figure><h2 id="渲染错误的Pass"><a href="#渲染错误的Pass" class="headerlink" title="渲染错误的Pass"></a>渲染错误的Pass</h2><p>都是之前遗留的PassName</p><pre><code>    public static readonly ShaderPassName s_AlwaysName = new ShaderPassName(&quot;Always&quot;);    public static readonly ShaderPassName s_ForwardBaseName = new ShaderPassName(&quot;ForwardBase&quot;);    public static readonly ShaderPassName s_DeferredName = new ShaderPassName(&quot;Deferred&quot;);    public static readonly ShaderPassName s_PrepassBaseName = new ShaderPassName(&quot;PrepassBase&quot;);    public static readonly ShaderPassName s_VertexName = new ShaderPassName(&quot;Vertex&quot;);    public static readonly ShaderPassName s_VertexLMRGBMName = new ShaderPassName(&quot;VertexLMRGBM&quot;);    public static readonly ShaderPassName s_VertexLMName = new ShaderPassName(&quot;VertexLM&quot;);</code></pre><h2 id="AccumulateDistortion-amp-RenderDistortion"><a href="#AccumulateDistortion-amp-RenderDistortion" class="headerlink" title="AccumulateDistortion &amp; RenderDistortion"></a>AccumulateDistortion &amp; RenderDistortion</h2><p>失真计算？</p><h2 id="RenderPostProcess"><a href="#RenderPostProcess" class="headerlink" title="RenderPostProcess"></a>RenderPostProcess</h2><p>后处理</p><h2 id="进一步调用"><a href="#进一步调用" class="headerlink" title="进一步调用"></a>进一步调用</h2><h3 id="RenderOpaqueRenderList"><a href="#RenderOpaqueRenderList" class="headerlink" title="RenderOpaqueRenderList"></a>RenderOpaqueRenderList</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderTransparentRenderList</span>(<span class="hljs-params">CullResults cull,</span></span><br><span class="hljs-params"><span class="hljs-function">            HDCamera hdCamera,</span></span><br><span class="hljs-params"><span class="hljs-function">            ScriptableRenderContext renderContext,</span></span><br><span class="hljs-params"><span class="hljs-function">            CommandBuffer cmd,</span></span><br><span class="hljs-params"><span class="hljs-function">            ShaderPassName passName,</span></span><br><span class="hljs-params"><span class="hljs-function">            RendererConfiguration rendererConfiguration = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            RenderQueueRange? inRenderQueueRange = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            RenderStateBlock? stateBlock = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            Material overrideMaterial = <span class="hljs-literal">null</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                 </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">void</span> RenderTransparentRenderList(CullResults cull,</span></span><br><span class="hljs-params"><span class="hljs-function">            HDCamera hdCamera,</span></span><br><span class="hljs-params"><span class="hljs-function">            ScriptableRenderContext renderContext,</span></span><br><span class="hljs-params"><span class="hljs-function">            CommandBuffer cmd, </span></span><br><span class="hljs-params"><span class="hljs-function">            ShaderPassName[] passName,   //  多个pass</span></span><br><span class="hljs-params"><span class="hljs-function">            RendererConfiguration rendererConfiguration = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            RenderQueueRange? inRenderQueueRange = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            RenderStateBlock? stateBlock = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            Material overrideMaterial = <span class="hljs-literal">null</span></span></span><br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 想要渲染不都名物体 </span><br><span class="hljs-keyword">if</span> (!hdCamera.frameSettings.enableOpaqueObjects)<br>     <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// DrawRender 不再Command当中渲染，所以想把之前的做完。</span><br>renderContext.ExecuteCommandBuffer(cmd);<br>cmd.Clear();<br><br><span class="hljs-comment">// 设置绘制参数，排序方式</span><br><span class="hljs-keyword">var</span> drawSettings = <span class="hljs-keyword">new</span> DrawRendererSettings(hdCamera.camera, HDShaderPassNames.s_EmptyName)<br>&#123;<br>  rendererConfiguration = rendererConfiguration,<br>  sorting = &#123; flags = SortFlags.CommonOpaque &#125;<br>&#125;;<br><br><span class="hljs-comment">// 收集需要渲染的pass Name</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; passNames.Length; ++i)<br>&#123;<br>  drawSettings.SetShaderPassName(i, passNames[i]);<br>&#125;<br><br><span class="hljs-comment">// 设置全局材质，渲染某些通用效果的时候使用</span><br><span class="hljs-keyword">if</span> (overrideMaterial != <span class="hljs-literal">null</span>)<br>  drawSettings.SetOverrideMaterial(overrideMaterial, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 渲染队列，指定还是范围</span><br><span class="hljs-keyword">var</span> filterSettings = <span class="hljs-keyword">new</span> FilterRenderersSettings(<span class="hljs-literal">true</span>)<br>&#123;<br>  renderQueueRange = inRenderQueueRange == <span class="hljs-literal">null</span> ? <br>    HDRenderQueue.k_RenderQueue_AllOpaque : inRenderQueueRange.Value<br>      <span class="hljs-comment">//2000 -  2500</span><br>&#125;;<br><br><span class="hljs-keyword">if</span> (stateBlock == <span class="hljs-literal">null</span>)<br>  renderContext.DrawRenderers(cull.visibleRenderers, <span class="hljs-keyword">ref</span> drawSettings, filterSettings);<br><span class="hljs-keyword">else</span><br>  renderContext.DrawRenderers(cull.visibleRenderers, <span class="hljs-keyword">ref</span> drawSettings, filterSettings, stateBlock.Value);<br></code></pre></td></tr></table></figure><p>###RenderTransparentRenderList</p><h1 id="初始化与HDRenderPipelineAsset"><a href="#初始化与HDRenderPipelineAsset" class="headerlink" title="初始化与HDRenderPipelineAsset"></a>初始化与HDRenderPipelineAsset</h1>]]></content>
      
      
      <categories>
          
          <category> HDRPSource </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渲染队列</title>
      <link href="/2022/07/09/HDRPsource/3.%E6%B8%B2%E6%9F%93%E5%8F%82%E6%95%B0/"/>
      <url>/2022/07/09/HDRPsource/3.%E6%B8%B2%E6%9F%93%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>#.渲染队列</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HDRenderQueue</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> k_TransparentPriorityQueueRange = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Priority<br>&#123;<br>Background = UnityEngine.Rendering.RenderQueue.Background,<br>Opaque = UnityEngine.Rendering.RenderQueue.Geometry,<br>OpaqueAlphaTest = UnityEngine.Rendering.RenderQueue.AlphaTest,<br><span class="hljs-comment">// Warning: we must not change Geometry last value to stay compatible with occlusion</span><br>OpaqueLast = UnityEngine.Rendering.RenderQueue.GeometryLast,<br><span class="hljs-comment">// For transparent pass we define a range of 200 value to define the priority</span><br><span class="hljs-comment">// Warning: Be sure no range are overlapping</span><br>PreRefractionFirst = <span class="hljs-number">2750</span> - k_TransparentPriorityQueueRange,<br>PreRefraction = <span class="hljs-number">2750</span>,<br>PreRefractionLast = <span class="hljs-number">2750</span> + k_TransparentPriorityQueueRange,<br>TransparentFirst = UnityEngine.Rendering.RenderQueue.Transparent - k_TransparentPriorityQueueRange,<br>Transparent = UnityEngine.Rendering.RenderQueue.Transparent,<br>TransparentLast = UnityEngine.Rendering.RenderQueue.Transparent + k_TransparentPriorityQueueRange,<br>Overlay = UnityEngine.Rendering.RenderQueue.Overlay<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> RenderQueueRange k_RenderQueue_OpaqueNoAlphaTest = <span class="hljs-keyword">new</span> RenderQueueRange &#123; min = (<span class="hljs-built_in">int</span>)Priority.Opaque, max = (<span class="hljs-built_in">int</span>)Priority.OpaqueAlphaTest - <span class="hljs-number">1</span> &#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> RenderQueueRange k_RenderQueue_OpaqueAlphaTest = <span class="hljs-keyword">new</span> RenderQueueRange &#123; min = (<span class="hljs-built_in">int</span>)Priority.OpaqueAlphaTest, max = (<span class="hljs-built_in">int</span>)Priority.OpaqueLast &#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> RenderQueueRange k_RenderQueue_AllOpaque = <span class="hljs-keyword">new</span> RenderQueueRange &#123; min = (<span class="hljs-built_in">int</span>)Priority.Opaque, max = (<span class="hljs-built_in">int</span>)Priority.OpaqueLast &#125;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> RenderQueueRange k_RenderQueue_PreRefraction = <span class="hljs-keyword">new</span> RenderQueueRange &#123; min = (<span class="hljs-built_in">int</span>)Priority.PreRefractionFirst, max = (<span class="hljs-built_in">int</span>)Priority.PreRefractionLast &#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> RenderQueueRange k_RenderQueue_Transparent = <span class="hljs-keyword">new</span> RenderQueueRange &#123; min = (<span class="hljs-built_in">int</span>)Priority.TransparentFirst, max = (<span class="hljs-built_in">int</span>)Priority.TransparentLast &#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> RenderQueueRange k_RenderQueue_AllTransparent = <span class="hljs-keyword">new</span> RenderQueueRange &#123; min = (<span class="hljs-built_in">int</span>)Priority.PreRefractionFirst, max = (<span class="hljs-built_in">int</span>)Priority.TransparentLast &#125;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> RenderQueueRange k_RenderQueue_All = <span class="hljs-keyword">new</span> RenderQueueRange &#123; min = <span class="hljs-number">0</span>, max = <span class="hljs-number">5000</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>2内置纹理</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HDShaderIDs</span><br>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ShadowDatasExp = Shader.PropertyToID(<span class="hljs-string">&quot;_ShadowDatasExp&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ShadowPayloads = Shader.PropertyToID(<span class="hljs-string">&quot;_ShadowPayloads&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ShadowmapExp_VSM_0 = Shader.PropertyToID(<span class="hljs-string">&quot;_ShadowmapExp_VSM_0&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ShadowmapExp_VSM_1 = Shader.PropertyToID(<span class="hljs-string">&quot;_ShadowmapExp_VSM_1&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ShadowmapExp_VSM_2 = Shader.PropertyToID(<span class="hljs-string">&quot;_ShadowmapExp_VSM_2&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ShadowmapExp_PCF = Shader.PropertyToID(<span class="hljs-string">&quot;_ShadowmapExp_PCF&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_LayeredSingleIdxBuffer = Shader.PropertyToID(<span class="hljs-string">&quot;g_LayeredSingleIdxBuffer&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _EnvLightIndexShift = Shader.PropertyToID(<span class="hljs-string">&quot;_EnvLightIndexShift&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DensityVolumeIndexShift = Shader.PropertyToID(<span class="hljs-string">&quot;_DensityVolumeIndexShift&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_isOrthographic = Shader.PropertyToID(<span class="hljs-string">&quot;g_isOrthographic&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_iNrVisibLights = Shader.PropertyToID(<span class="hljs-string">&quot;g_iNrVisibLights&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_mScrProjection = Shader.PropertyToID(<span class="hljs-string">&quot;g_mScrProjection&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_mInvScrProjection = Shader.PropertyToID(<span class="hljs-string">&quot;g_mInvScrProjection&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_mScrProjectionArr = Shader.PropertyToID(<span class="hljs-string">&quot;g_mScrProjectionArr&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_mInvScrProjectionArr = Shader.PropertyToID(<span class="hljs-string">&quot;g_mInvScrProjectionArr&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_iLog2NumClusters = Shader.PropertyToID(<span class="hljs-string">&quot;g_iLog2NumClusters&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_screenSize = Shader.PropertyToID(<span class="hljs-string">&quot;g_screenSize&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_iNumSamplesMSAA = Shader.PropertyToID(<span class="hljs-string">&quot;g_iNumSamplesMSAA&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_fNearPlane = Shader.PropertyToID(<span class="hljs-string">&quot;g_fNearPlane&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_fFarPlane = Shader.PropertyToID(<span class="hljs-string">&quot;g_fFarPlane&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_fClustScale = Shader.PropertyToID(<span class="hljs-string">&quot;g_fClustScale&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_fClustBase = Shader.PropertyToID(<span class="hljs-string">&quot;g_fClustBase&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_depth_tex = Shader.PropertyToID(<span class="hljs-string">&quot;g_depth_tex&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_vLayeredLightList = Shader.PropertyToID(<span class="hljs-string">&quot;g_vLayeredLightList&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_LayeredOffset = Shader.PropertyToID(<span class="hljs-string">&quot;g_LayeredOffset&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_vBigTileLightList = Shader.PropertyToID(<span class="hljs-string">&quot;g_vBigTileLightList&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_logBaseBuffer = Shader.PropertyToID(<span class="hljs-string">&quot;g_logBaseBuffer&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_vBoundsBuffer = Shader.PropertyToID(<span class="hljs-string">&quot;g_vBoundsBuffer&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _LightVolumeData = Shader.PropertyToID(<span class="hljs-string">&quot;_LightVolumeData&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_data = Shader.PropertyToID(<span class="hljs-string">&quot;g_data&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_mProjectionArr = Shader.PropertyToID(<span class="hljs-string">&quot;g_mProjectionArr&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_mInvProjectionArr = Shader.PropertyToID(<span class="hljs-string">&quot;g_mInvProjectionArr&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_viDimensions = Shader.PropertyToID(<span class="hljs-string">&quot;g_viDimensions&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_vLightList = Shader.PropertyToID(<span class="hljs-string">&quot;g_vLightList&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_BaseFeatureFlags = Shader.PropertyToID(<span class="hljs-string">&quot;g_BaseFeatureFlags&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_TileFeatureFlags = Shader.PropertyToID(<span class="hljs-string">&quot;g_TileFeatureFlags&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_DispatchIndirectBuffer = Shader.PropertyToID(<span class="hljs-string">&quot;g_DispatchIndirectBuffer&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_TileList = Shader.PropertyToID(<span class="hljs-string">&quot;g_TileList&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_NumTiles = Shader.PropertyToID(<span class="hljs-string">&quot;g_NumTiles&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_NumTilesX = Shader.PropertyToID(<span class="hljs-string">&quot;g_NumTilesX&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _NumTiles = Shader.PropertyToID(<span class="hljs-string">&quot;_NumTiles&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _CookieTextures = Shader.PropertyToID(<span class="hljs-string">&quot;_CookieTextures&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _CookieCubeTextures = Shader.PropertyToID(<span class="hljs-string">&quot;_CookieCubeTextures&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _EnvCubemapTextures = Shader.PropertyToID(<span class="hljs-string">&quot;_EnvCubemapTextures&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _Env2DTextures = Shader.PropertyToID(<span class="hljs-string">&quot;_Env2DTextures&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _Env2DCaptureVP = Shader.PropertyToID(<span class="hljs-string">&quot;_Env2DCaptureVP&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DirectionalLightDatas = Shader.PropertyToID(<span class="hljs-string">&quot;_DirectionalLightDatas&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DirectionalLightCount = Shader.PropertyToID(<span class="hljs-string">&quot;_DirectionalLightCount&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _LightDatas = Shader.PropertyToID(<span class="hljs-string">&quot;_LightDatas&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _PunctualLightCount = Shader.PropertyToID(<span class="hljs-string">&quot;_PunctualLightCount&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _AreaLightCount = Shader.PropertyToID(<span class="hljs-string">&quot;_AreaLightCount&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_vLightListGlobal = Shader.PropertyToID(<span class="hljs-string">&quot;g_vLightListGlobal&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _EnvLightDatas = Shader.PropertyToID(<span class="hljs-string">&quot;_EnvLightDatas&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _EnvLightCount = Shader.PropertyToID(<span class="hljs-string">&quot;_EnvLightCount&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _EnvProxyCount = Shader.PropertyToID(<span class="hljs-string">&quot;_EnvProxyCount&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ShadowDatas = Shader.PropertyToID(<span class="hljs-string">&quot;_ShadowDatas&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _NumTileFtplX = Shader.PropertyToID(<span class="hljs-string">&quot;_NumTileFtplX&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _NumTileFtplY = Shader.PropertyToID(<span class="hljs-string">&quot;_NumTileFtplY&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _NumTileClusteredX = Shader.PropertyToID(<span class="hljs-string">&quot;_NumTileClusteredX&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _NumTileClusteredY = Shader.PropertyToID(<span class="hljs-string">&quot;_NumTileClusteredY&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_isLogBaseBufferEnabled = Shader.PropertyToID(<span class="hljs-string">&quot;g_isLogBaseBufferEnabled&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_vLayeredOffsetsBuffer = Shader.PropertyToID(<span class="hljs-string">&quot;g_vLayeredOffsetsBuffer&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ViewTilesFlags = Shader.PropertyToID(<span class="hljs-string">&quot;_ViewTilesFlags&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _MousePixelCoord = Shader.PropertyToID(<span class="hljs-string">&quot;_MousePixelCoord&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _MouseClickPixelCoord = Shader.PropertyToID(<span class="hljs-string">&quot;_MouseClickPixelCoord&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DebugStep = Shader.PropertyToID(<span class="hljs-string">&quot;_DebugStep&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DebugFont = Shader.PropertyToID(<span class="hljs-string">&quot;_DebugFont&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DebugExposure = Shader.PropertyToID(<span class="hljs-string">&quot;_DebugExposure&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DebugScreenSpaceTracingData = Shader.PropertyToID(<span class="hljs-string">&quot;_DebugScreenSpaceTracingData&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ShowGrid = Shader.PropertyToID(<span class="hljs-string">&quot;_ShowGrid&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ShowSSRaySampledColor = Shader.PropertyToID(<span class="hljs-string">&quot;_ShowSSRaySampledColor&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ShowDepthPyramidDebug = Shader.PropertyToID(<span class="hljs-string">&quot;_ShowDepthPyramidDebug&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DebugViewMaterial = Shader.PropertyToID(<span class="hljs-string">&quot;_DebugViewMaterial&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DebugLightingMode = Shader.PropertyToID(<span class="hljs-string">&quot;_DebugLightingMode&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DebugLightingSubMode = Shader.PropertyToID(<span class="hljs-string">&quot;_DebugLightingSubMode&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DebugLightingAlbedo = Shader.PropertyToID(<span class="hljs-string">&quot;_DebugLightingAlbedo&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DebugLightingSmoothness = Shader.PropertyToID(<span class="hljs-string">&quot;_DebugLightingSmoothness&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DebugLightingNormal = Shader.PropertyToID(<span class="hljs-string">&quot;_DebugLightingNormal&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DebugLightingSpecularColor = Shader.PropertyToID(<span class="hljs-string">&quot;_DebugLightingSpecularColor&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _AmbientOcclusionTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_AmbientOcclusionTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DebugMipMapMode = Shader.PropertyToID(<span class="hljs-string">&quot;_DebugMipMapMode&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _UseTileLightList = Shader.PropertyToID(<span class="hljs-string">&quot;_UseTileLightList&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _FrameCount     = Shader.PropertyToID(<span class="hljs-string">&quot;_FrameCount&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _Time           = Shader.PropertyToID(<span class="hljs-string">&quot;_Time&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _LastTime       = Shader.PropertyToID(<span class="hljs-string">&quot;_LastTime&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SinTime        = Shader.PropertyToID(<span class="hljs-string">&quot;_SinTime&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _CosTime        = Shader.PropertyToID(<span class="hljs-string">&quot;_CosTime&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> unity_DeltaTime = Shader.PropertyToID(<span class="hljs-string">&quot;unity_DeltaTime&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _EnvLightSkyEnabled = Shader.PropertyToID(<span class="hljs-string">&quot;_EnvLightSkyEnabled&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _AmbientOcclusionParam = Shader.PropertyToID(<span class="hljs-string">&quot;_AmbientOcclusionParam&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SkyTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_SkyTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SkyTextureMipCount = Shader.PropertyToID(<span class="hljs-string">&quot;_SkyTextureMipCount&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _EnableSubsurfaceScattering = Shader.PropertyToID(<span class="hljs-string">&quot;_EnableSubsurfaceScattering&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _TransmittanceMultiplier = Shader.PropertyToID(<span class="hljs-string">&quot;_TransmittanceMultiplier&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _TexturingModeFlags = Shader.PropertyToID(<span class="hljs-string">&quot;_TexturingModeFlags&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _TransmissionFlags = Shader.PropertyToID(<span class="hljs-string">&quot;_TransmissionFlags&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ThicknessRemaps = Shader.PropertyToID(<span class="hljs-string">&quot;_ThicknessRemaps&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ShapeParams = Shader.PropertyToID(<span class="hljs-string">&quot;_ShapeParams&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _HalfRcpVariancesAndWeights = Shader.PropertyToID(<span class="hljs-string">&quot;_HalfRcpVariancesAndWeights&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _TransmissionTintsAndFresnel0 = Shader.PropertyToID(<span class="hljs-string">&quot;_TransmissionTintsAndFresnel0&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> specularLightingUAV = Shader.PropertyToID(<span class="hljs-string">&quot;specularLightingUAV&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> diffuseLightingUAV = Shader.PropertyToID(<span class="hljs-string">&quot;diffuseLightingUAV&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> g_TileListOffset = Shader.PropertyToID(<span class="hljs-string">&quot;g_TileListOffset&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _LtcData = Shader.PropertyToID(<span class="hljs-string">&quot;_LtcData&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _LtcGGXMatrix = Shader.PropertyToID(<span class="hljs-string">&quot;_LtcGGXMatrix&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _LtcDisneyDiffuseMatrix = Shader.PropertyToID(<span class="hljs-string">&quot;_LtcDisneyDiffuseMatrix&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _LtcMultiGGXFresnelDisneyDiffuse = Shader.PropertyToID(<span class="hljs-string">&quot;_LtcMultiGGXFresnelDisneyDiffuse&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DeferredShadowTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_DeferredShadowTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DeferredShadowTextureUAV = Shader.PropertyToID(<span class="hljs-string">&quot;_DeferredShadowTextureUAV&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DirectionalShadowIndex = Shader.PropertyToID(<span class="hljs-string">&quot;_DirectionalShadowIndex&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DirectionalContactShadowParams = Shader.PropertyToID(<span class="hljs-string">&quot;_ScreenSpaceShadowsParameters&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DirectionalContactShadowSampleCount = Shader.PropertyToID(<span class="hljs-string">&quot;_SampleCount&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DirectionalLightDirection = Shader.PropertyToID(<span class="hljs-string">&quot;_DirectionalLightDirection&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _PunctualLightPosition = Shader.PropertyToID(<span class="hljs-string">&quot;_PunctualLightPosition&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _StencilMask = Shader.PropertyToID(<span class="hljs-string">&quot;_StencilMask&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _StencilRef = Shader.PropertyToID(<span class="hljs-string">&quot;_StencilRef&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _StencilCmp = Shader.PropertyToID(<span class="hljs-string">&quot;_StencilCmp&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _InputDepth = Shader.PropertyToID(<span class="hljs-string">&quot;_InputDepthTexture&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SrcBlend = Shader.PropertyToID(<span class="hljs-string">&quot;_SrcBlend&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DstBlend = Shader.PropertyToID(<span class="hljs-string">&quot;_DstBlend&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSSHTile = Shader.PropertyToID(<span class="hljs-string">&quot;_SSSHTile&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _StencilTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_StencilTexture&quot;</span>);<br><br>  <span class="hljs-comment">// all decal properties</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _NormalToWorldID = Shader.PropertyToID(<span class="hljs-string">&quot;_NormalToWorld&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DecalAtlas2DID = Shader.PropertyToID(<span class="hljs-string">&quot;_DecalAtlas2D&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DecalAtlasID = Shader.PropertyToID(<span class="hljs-string">&quot;_DecalAtlas&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DecalHTileTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_DecalHTileTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DecalIndexShift = Shader.PropertyToID(<span class="hljs-string">&quot;_DecalIndexShift&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DecalCount = Shader.PropertyToID(<span class="hljs-string">&quot;_DecalCount&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DecalDatas = Shader.PropertyToID(<span class="hljs-string">&quot;_DecalDatas&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _WorldSpaceCameraPos = Shader.PropertyToID(<span class="hljs-string">&quot;_WorldSpaceCameraPos&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ViewMatrix = Shader.PropertyToID(<span class="hljs-string">&quot;_ViewMatrix&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _InvViewMatrix = Shader.PropertyToID(<span class="hljs-string">&quot;_InvViewMatrix&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ProjMatrix = Shader.PropertyToID(<span class="hljs-string">&quot;_ProjMatrix&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _InvProjMatrix = Shader.PropertyToID(<span class="hljs-string">&quot;_InvProjMatrix&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _NonJitteredViewProjMatrix = Shader.PropertyToID(<span class="hljs-string">&quot;_NonJitteredViewProjMatrix&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ViewProjMatrix = Shader.PropertyToID(<span class="hljs-string">&quot;_ViewProjMatrix&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _InvViewProjMatrix = Shader.PropertyToID(<span class="hljs-string">&quot;_InvViewProjMatrix&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DetViewMatrix = Shader.PropertyToID(<span class="hljs-string">&quot;_DetViewMatrix&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ZBufferParams = Shader.PropertyToID(<span class="hljs-string">&quot;_ZBufferParams&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ProjectionParams = Shader.PropertyToID(<span class="hljs-string">&quot;_ProjectionParams&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> unity_OrthoParams = Shader.PropertyToID(<span class="hljs-string">&quot;unity_OrthoParams&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _InvProjParam = Shader.PropertyToID(<span class="hljs-string">&quot;_InvProjParam&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ScreenSize = Shader.PropertyToID(<span class="hljs-string">&quot;_ScreenSize&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ScreenParams = Shader.PropertyToID(<span class="hljs-string">&quot;_ScreenParams&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ScreenToTargetScale = Shader.PropertyToID(<span class="hljs-string">&quot;_ScreenToTargetScale&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _PrevViewProjMatrix = Shader.PropertyToID(<span class="hljs-string">&quot;_PrevViewProjMatrix&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _FrustumPlanes = Shader.PropertyToID(<span class="hljs-string">&quot;_FrustumPlanes&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _TaaFrameRotation = Shader.PropertyToID(<span class="hljs-string">&quot;_TaaFrameRotation&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ViewMatrixStereo = Shader.PropertyToID(<span class="hljs-string">&quot;_ViewMatrixStereo&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ViewProjMatrixStereo = Shader.PropertyToID(<span class="hljs-string">&quot;_ViewProjMatrixStereo&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _InvViewMatrixStereo = Shader.PropertyToID(<span class="hljs-string">&quot;_InvViewMatrixStereo&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _InvProjMatrixStereo = Shader.PropertyToID(<span class="hljs-string">&quot;_InvProjMatrixStereo&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _InvViewProjMatrixStereo = Shader.PropertyToID(<span class="hljs-string">&quot;_InvViewProjMatrixStereo&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DepthTexture                   = Shader.PropertyToID(<span class="hljs-string">&quot;_DepthTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _CameraColorTexture             = Shader.PropertyToID(<span class="hljs-string">&quot;_CameraColorTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _CameraSssDiffuseLightingBuffer = Shader.PropertyToID(<span class="hljs-string">&quot;_CameraSssDiffuseLightingTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _CameraFilteringBuffer          = Shader.PropertyToID(<span class="hljs-string">&quot;_CameraFilteringTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _IrradianceSource               = Shader.PropertyToID(<span class="hljs-string">&quot;_IrradianceSource&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _EnableDBuffer = Shader.PropertyToID(<span class="hljs-string">&quot;_EnableDBuffer&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DecalAtlasResolution = Shader.PropertyToID(<span class="hljs-string">&quot;_DecalAtlasResolution&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span>[] _GBufferTexture =<br>  &#123;<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_GBufferTexture0&quot;</span>),<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_GBufferTexture1&quot;</span>),<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_GBufferTexture2&quot;</span>),<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_GBufferTexture3&quot;</span>),<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_GBufferTexture4&quot;</span>),<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_GBufferTexture5&quot;</span>),<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_GBufferTexture6&quot;</span>),<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_GBufferTexture7&quot;</span>)<br>  &#125;;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span>[] _DBufferTexture =<br>  &#123;<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_DBufferTexture0&quot;</span>),<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_DBufferTexture1&quot;</span>),<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_DBufferTexture2&quot;</span>),<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_DBufferTexture3&quot;</span>)<br>  &#125;;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span>[] _SSSBufferTexture =<br>  &#123;<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_SSSBufferTexture0&quot;</span>),<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_SSSBufferTexture1&quot;</span>),<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_SSSBufferTexture2&quot;</span>),<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_SSSBufferTexture3&quot;</span>),<br>  &#125;;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span>[] _NormalBufferTexture =<br>  &#123;<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_NormalBufferTexture0&quot;</span>),<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_NormalBufferTexture1&quot;</span>),<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_NormalBufferTexture2&quot;</span>),<br>    Shader.PropertyToID(<span class="hljs-string">&quot;_NormalBufferTexture3&quot;</span>),<br>  &#125;;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSRefractionRayMarchBehindObjects = Shader.PropertyToID(<span class="hljs-string">&quot;_SSRefractionRayMarchBehindObjects&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSRefractionRayMaxScreenDistance = Shader.PropertyToID(<span class="hljs-string">&quot;_SSRefractionRayMaxScreenDistance&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSRefractionRayBlendScreenDistance = Shader.PropertyToID(<span class="hljs-string">&quot;_SSRefractionRayBlendScreenDistance&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSRefractionRayLevel = Shader.PropertyToID(<span class="hljs-string">&quot;_SSRefractionRayLevel&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSRefractionRayMinLevel = Shader.PropertyToID(<span class="hljs-string">&quot;_SSRefractionRayMinLevel&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSRefractionRayMaxLevel = Shader.PropertyToID(<span class="hljs-string">&quot;_SSRefractionRayMaxLevel&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSRefractionRayMaxIterations = Shader.PropertyToID(<span class="hljs-string">&quot;_SSRefractionRayMaxIterations&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSRefractionDepthBufferThickness = Shader.PropertyToID(<span class="hljs-string">&quot;_SSRefractionDepthBufferThickness&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSRefractionInvScreenWeightDistance = Shader.PropertyToID(<span class="hljs-string">&quot;_SSRefractionInvScreenWeightDistance&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSReflectionRayMarchBehindObjects = Shader.PropertyToID(<span class="hljs-string">&quot;_SSReflectionRayMarchBehindObjects&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSReflectionRayMaxScreenDistance = Shader.PropertyToID(<span class="hljs-string">&quot;_SSReflectionRayMaxScreenDistance&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSReflectionRayBlendScreenDistance = Shader.PropertyToID(<span class="hljs-string">&quot;_SSReflectionRayBlendScreenDistance&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSReflectionRayLevel = Shader.PropertyToID(<span class="hljs-string">&quot;_SSReflectionRayLevel&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSReflectionRayMinLevel = Shader.PropertyToID(<span class="hljs-string">&quot;_SSReflectionRayMinLevel&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSReflectionRayMaxLevel = Shader.PropertyToID(<span class="hljs-string">&quot;_SSReflectionRayMaxLevel&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSReflectionRayMaxIterations = Shader.PropertyToID(<span class="hljs-string">&quot;_SSReflectionRayMaxIterations&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSReflectionDepthBufferThickness = Shader.PropertyToID(<span class="hljs-string">&quot;_SSReflectionDepthBufferThickness&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSReflectionInvScreenWeightDistance = Shader.PropertyToID(<span class="hljs-string">&quot;_SSReflectionInvScreenWeightDistance&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSReflectionProjectionModel = Shader.PropertyToID(<span class="hljs-string">&quot;_SSReflectionProjectionModel&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SSReflectionEnabled = Shader.PropertyToID(<span class="hljs-string">&quot;_SSReflectionEnabled&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VelocityTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_VelocityTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ShadowMaskTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_ShadowMaskTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DistortionTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_DistortionTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ColorPyramidTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_ColorPyramidTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DepthPyramidTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_DepthPyramidTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ColorPyramidSize = Shader.PropertyToID(<span class="hljs-string">&quot;_ColorPyramidSize&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ColorPyramidScale = Shader.PropertyToID(<span class="hljs-string">&quot;_ColorPyramidScale&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DepthPyramidSize = Shader.PropertyToID(<span class="hljs-string">&quot;_DepthPyramidSize&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DepthPyramidScale = Shader.PropertyToID(<span class="hljs-string">&quot;_DepthPyramidScale&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DebugColorPickerTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_DebugColorPickerTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ColorPickerMode = Shader.PropertyToID(<span class="hljs-string">&quot;_ColorPickerMode&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ApplyLinearToSRGB = Shader.PropertyToID(<span class="hljs-string">&quot;_ApplyLinearToSRGB&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ColorPickerFontColor = Shader.PropertyToID(<span class="hljs-string">&quot;_ColorPickerFontColor&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _RequireToFlipInputTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_RequireToFlipInputTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _FalseColorEnabled = Shader.PropertyToID(<span class="hljs-string">&quot;_FalseColor&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _FalseColorThresholds = Shader.PropertyToID(<span class="hljs-string">&quot;_FalseColorThresholds&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DebugFullScreenTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_DebugFullScreenTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _BlitTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_BlitTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _BlitScaleBias = Shader.PropertyToID(<span class="hljs-string">&quot;_BlitScaleBias&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _BlitMipLevel = Shader.PropertyToID(<span class="hljs-string">&quot;_BlitMipLevel&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _BlitScaleBiasRt = Shader.PropertyToID(<span class="hljs-string">&quot;_BlitScaleBiasRt&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _WorldScales = Shader.PropertyToID(<span class="hljs-string">&quot;_WorldScales&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _FilterKernels = Shader.PropertyToID(<span class="hljs-string">&quot;_FilterKernels&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _FilterKernelsBasic = Shader.PropertyToID(<span class="hljs-string">&quot;_FilterKernelsBasic&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _HalfRcpWeightedVariances = Shader.PropertyToID(<span class="hljs-string">&quot;_HalfRcpWeightedVariances&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _CameraDepthTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_CameraDepthTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _CameraMotionVectorsTexture = Shader.PropertyToID(<span class="hljs-string">&quot;_CameraMotionVectorsTexture&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _CameraMotionVectorsSize = Shader.PropertyToID(<span class="hljs-string">&quot;_CameraMotionVectorsSize&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _CameraMotionVectorsScale = Shader.PropertyToID(<span class="hljs-string">&quot;_CameraMotionVectorsScale&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _FullScreenDebugMode = Shader.PropertyToID(<span class="hljs-string">&quot;_FullScreenDebugMode&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _InputCubemap = Shader.PropertyToID(<span class="hljs-string">&quot;_InputCubemap&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _Mipmap = Shader.PropertyToID(<span class="hljs-string">&quot;_Mipmap&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _DiffusionProfile = Shader.PropertyToID(<span class="hljs-string">&quot;_DiffusionProfile&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _MaxRadius = Shader.PropertyToID(<span class="hljs-string">&quot;_MaxRadius&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ShapeParam = Shader.PropertyToID(<span class="hljs-string">&quot;_ShapeParam&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _StdDev1 = Shader.PropertyToID(<span class="hljs-string">&quot;_StdDev1&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _StdDev2 = Shader.PropertyToID(<span class="hljs-string">&quot;_StdDev2&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _LerpWeight = Shader.PropertyToID(<span class="hljs-string">&quot;_LerpWeight&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _HalfRcpVarianceAndWeight1 = Shader.PropertyToID(<span class="hljs-string">&quot;_HalfRcpVarianceAndWeight1&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _HalfRcpVarianceAndWeight2 = Shader.PropertyToID(<span class="hljs-string">&quot;_HalfRcpVarianceAndWeight2&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _TransmissionTint = Shader.PropertyToID(<span class="hljs-string">&quot;_TransmissionTint&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _ThicknessRemap = Shader.PropertyToID(<span class="hljs-string">&quot;_ThicknessRemap&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _Cubemap = Shader.PropertyToID(<span class="hljs-string">&quot;_Cubemap&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _SkyParam = Shader.PropertyToID(<span class="hljs-string">&quot;_SkyParam&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _PixelCoordToViewDirWS = Shader.PropertyToID(<span class="hljs-string">&quot;_PixelCoordToViewDirWS&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _Size = Shader.PropertyToID(<span class="hljs-string">&quot;_Size&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _Source4 = Shader.PropertyToID(<span class="hljs-string">&quot;_Source4&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _Result1 = Shader.PropertyToID(<span class="hljs-string">&quot;_Result1&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _AtmosphericScatteringType      = Shader.PropertyToID(<span class="hljs-string">&quot;_AtmosphericScatteringType&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _AmbientProbeCoeffs             = Shader.PropertyToID(<span class="hljs-string">&quot;_AmbientProbeCoeffs&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _GlobalExtinction               = Shader.PropertyToID(<span class="hljs-string">&quot;_GlobalExtinction&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _GlobalScattering               = Shader.PropertyToID(<span class="hljs-string">&quot;_GlobalScattering&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _GlobalAnisotropy               = Shader.PropertyToID(<span class="hljs-string">&quot;_GlobalAnisotropy&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _CornetteShanksConstant         = Shader.PropertyToID(<span class="hljs-string">&quot;_CornetteShanksConstant&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VBufferResolution              = Shader.PropertyToID(<span class="hljs-string">&quot;_VBufferResolution&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VBufferSliceCount              = Shader.PropertyToID(<span class="hljs-string">&quot;_VBufferSliceCount&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VBufferUvScaleAndLimit         = Shader.PropertyToID(<span class="hljs-string">&quot;_VBufferUvScaleAndLimit&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VBufferDepthEncodingParams     = Shader.PropertyToID(<span class="hljs-string">&quot;_VBufferDepthEncodingParams&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VBufferDepthDecodingParams     = Shader.PropertyToID(<span class="hljs-string">&quot;_VBufferDepthDecodingParams&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VBufferPrevResolution          = Shader.PropertyToID(<span class="hljs-string">&quot;_VBufferPrevResolution&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VBufferPrevSliceCount          = Shader.PropertyToID(<span class="hljs-string">&quot;_VBufferPrevSliceCount&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VBufferPrevUvScaleAndLimit     = Shader.PropertyToID(<span class="hljs-string">&quot;_VBufferPrevUvScaleAndLimit&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VBufferPrevDepthEncodingParams = Shader.PropertyToID(<span class="hljs-string">&quot;_VBufferPrevDepthEncodingParams&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VBufferPrevDepthDecodingParams = Shader.PropertyToID(<span class="hljs-string">&quot;_VBufferPrevDepthDecodingParams&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VBufferCoordToViewDirWS        = Shader.PropertyToID(<span class="hljs-string">&quot;_VBufferCoordToViewDirWS&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VBufferDensity                 = Shader.PropertyToID(<span class="hljs-string">&quot;_VBufferDensity&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VBufferLighting                = Shader.PropertyToID(<span class="hljs-string">&quot;_VBufferLighting&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VBufferLightingIntegral        = Shader.PropertyToID(<span class="hljs-string">&quot;_VBufferLightingIntegral&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VBufferLightingHistory         = Shader.PropertyToID(<span class="hljs-string">&quot;_VBufferLightingHistory&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VBufferLightingFeedback        = Shader.PropertyToID(<span class="hljs-string">&quot;_VBufferLightingFeedback&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VBufferSampleOffset            = Shader.PropertyToID(<span class="hljs-string">&quot;_VBufferSampleOffset&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VolumeBounds                   = Shader.PropertyToID(<span class="hljs-string">&quot;_VolumeBounds&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VolumeData                     = Shader.PropertyToID(<span class="hljs-string">&quot;_VolumeData&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _NumVisibleDensityVolumes       = Shader.PropertyToID(<span class="hljs-string">&quot;_NumVisibleDensityVolumes&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VolumeMaskAtlas                = Shader.PropertyToID(<span class="hljs-string">&quot;_VolumeMaskAtlas&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _VolumeMaskDimensions           = Shader.PropertyToID(<span class="hljs-string">&quot;_VolumeMaskDimensions&quot;</span>);<br><br>  <span class="hljs-comment">// Preintegrated texture name</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _PreIntegratedFGD_GGXDisneyDiffuse = Shader.PropertyToID(<span class="hljs-string">&quot;_PreIntegratedFGD_GGXDisneyDiffuse&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _PreIntegratedFGD_CharlieAndCloth = Shader.PropertyToID(<span class="hljs-string">&quot;_PreIntegratedFGD_CharlieAndCloth&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HDRPSource </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shader代码分析</title>
      <link href="/2022/07/09/HDRPsource/4.LitShader%E5%88%86%E6%9E%90/"/>
      <url>/2022/07/09/HDRPsource/4.LitShader%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Shader代码分析"><a href="#Shader代码分析" class="headerlink" title="Shader代码分析"></a>Shader代码分析</h1><p>unity HDRP的所有shader的内容都集中在了Lit Shader当中。Shader Graph等内容都是使用的相同的底层结构。</p><p>现在我对Lit的整个过程、内部结构和Shader参数进行分析，了解一下新的Shader是如何运作的。</p><p>在文档2当中我们看到了目前包括的所有的Shader Pass</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs hlsl">public static readonly string s_EmptyStr = &quot;&quot;;<br>public static readonly string s_ForwardStr = &quot;Forward&quot;;<br>public static readonly string s_DepthOnlyStr = &quot;DepthOnly&quot;;<br>public static readonly string s_DepthForwardOnlyStr = &quot;DepthForwardOnly&quot;;<br>public static readonly string s_ForwardOnlyStr = &quot;ForwardOnly&quot;;<br>public static readonly string s_GBufferStr = &quot;GBuffer&quot;;<br>public static readonly string s_GBufferWithPrepassStr = &quot;GBufferWithPrepass&quot;;<br>public static readonly string s_SRPDefaultUnlitStr = &quot;SRPDefaultUnlit&quot;;<br>public static readonly string s_MotionVectorsStr = &quot;MotionVectors&quot;;<br>public static readonly string s_DistortionVectorsStr = &quot;DistortionVectors&quot;;<br>public static readonly string s_TransparentDepthPrepassStr = &quot;TransparentDepthPrepass&quot;;<br>public static readonly string s_TransparentBackfaceStr = &quot;TransparentBackface&quot;;<br>public static readonly string s_TransparentDepthPostpassStr = &quot;TransparentDepthPostpass&quot;;<br>public static readonly string s_MetaStr = &quot;Meta&quot;;<br>public static readonly string s_ShadowCasterStr = &quot;ShadowCaster&quot;;<br>public static readonly string s_MeshDecalsStr = &quot;DBufferMesh&quot;;<br></code></pre></td></tr></table></figure><p>其中主要的包括GBuffer、Forward、DepthOnly、ShadowCaster。现在我们依次对着几个Pass进行分析。</p><p>上面每一个Pass的具体代码都在下面的目录中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">\Packages\hrdp\Runtime\RenderPipeline\ShaderPass<br></code></pre></td></tr></table></figure><p>具体的代码结构基本一致，下面以GbufferPass 进行说明</p><h2 id="GBuffer-Pass"><a href="#GBuffer-Pass" class="headerlink" title="GBuffer Pass"></a>GBuffer Pass</h2><p>Gbuffer在Lit当中的完整内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">Pass<br>&#123;<br>    Name <span class="hljs-string">&quot;GBuffer&quot;</span>  <span class="hljs-comment">// Name is not used</span><br>    Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;GBuffer&quot;</span> &#125;<br>    <span class="hljs-comment">// 剪裁模式和深度测试可以进行设置</span><br>    <span class="hljs-comment">// 深入写入必然开启</span><br>    Cull [_CullMode]<br>    ZTest [_ZTestGBuffer]<br>    Stencil<br>    &#123;<br>        WriteMask [_StencilWriteMask]<br>        Ref  [_StencilRef]<br>        Comp Always<br>        Pass Replace<br>    &#125;<br><br>    HLSLPROGRAM<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ DEBUG_DISPLAY</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ LIGHTMAP_ON</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ DIRLIGHTMAP_COMBINED</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ DYNAMICLIGHTMAP_ON</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ SHADOWS_SHADOWMASK</span><br>    <span class="hljs-comment">// Setup DECALS_OFF so the shader stripper can remove variants</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile DECALS_OFF DECALS_3RT DECALS_4RT</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ LIGHT_LAYERS</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _ALPHATEST_ON</span><br>    <span class="hljs-comment">// When we have alpha test, we will force a depth prepass so we always bypass the clip instruction in the GBuffer</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> SHADERPASS SHADERPASS_GBUFFER</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl&quot;</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/ShaderPass/LitSharePass.hlsl&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitData.hlsl&quot;</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassGBuffer.hlsl&quot;</span></span><br><br>    ENDHLSL<br>&#125;<br></code></pre></td></tr></table></figure><p>上面Include的文件当中包括大量的函数和工具。其中和Gbuffer相关的主要Vert和Frag函数在<strong>ShaderPassGBuffer.hlsl</strong>文件当中。</p><p>这部分主要定义了<strong>Vert</strong>和<strong>Frag</strong>函数，以及<strong>曲面细分</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> SHADERPASS != SHADERPASS_GBUFFER</span><br><span class="hljs-meta">#<span class="hljs-keyword">error</span> SHADERPASS_is_not_correctly_define</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// 这个Include文件当中包括了顶点数据格式的转换。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/VertMesh.hlsl&quot;</span></span><br><br>PackedVaryingsType <span class="hljs-title function_">Vert</span><span class="hljs-params">(AttributesMesh inputMesh)</span><br>&#123;<br>    VaryingsType varyingsType;<br>  <span class="hljs-comment">//这里包括了坐标空间的转换。和一些必要的参数计算。世界坐标法线、世界坐标位置等等</span><br>    varyingsType.vmesh = VertMesh(inputMesh);<br>  <span class="hljs-comment">// 调整传递用的结构体，节省空间</span><br>    <span class="hljs-keyword">return</span> PackVaryingsType(varyingsType);<br>&#125;<br><span class="hljs-comment">// 这部分主要是曲面细分</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> TESSELLATION_ON</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Frag</span><span class="hljs-params">(  PackedVaryingsToPS packedInput,</span><br><span class="hljs-params">            OUTPUT_GBUFFER(outGBuffer)</span><br><span class="hljs-params">            #ifdef _DEPTHOFFSET_ON</span><br><span class="hljs-params">            , out <span class="hljs-type">float</span> outputDepth : SV_Depth</span><br><span class="hljs-params">            #endif</span><br><span class="hljs-params">            )</span><br>&#123;<br><span class="hljs-comment">// 解析出数据</span><br>    FragInputs input = UnpackVaryingsMeshToFragInputs(packedInput.vmesh);<br><br>    <span class="hljs-comment">// input.positionSS is SV_Position</span><br>    PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> VARYINGS_NEED_POSITION_WS</span><br>    float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-comment">// Unused</span><br>    float3 V = float3(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// Avoid the division by 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    SurfaceData surfaceData;<br>    BuiltinData builtinData;<br>    GetSurfaceAndBuiltinData(input, V, posInput, surfaceData, builtinData);<br><br>    ENCODE_INTO_GBUFFER(surfaceData, builtinData, posInput.positionSS, outGBuffer);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _DEPTHOFFSET_ON</span><br>    outputDepth = posInput.deviceDepth;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>###VertMesh.hlsl</p><p>比较重要的内容为<strong>VertMesh.hlsl</strong>这个文件：主要定义了顶点片段着色器的输入输出和输入输出的拆包和解包。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">PackVaryingsType 、UnpackVaryingsMeshToFragInputs：<span class="hljs-comment">//输出的拆包和解包函数</span><br>VertMesh：设置顶点参数  包括：法线、切线、世界坐标、纹理坐标、剪裁空间坐标等<br></code></pre></td></tr></table></figure><h3 id="GetSurfaceAndBuiltinData"><a href="#GetSurfaceAndBuiltinData" class="headerlink" title="GetSurfaceAndBuiltinData"></a>GetSurfaceAndBuiltinData</h3><p>这个是对纹理的采样和计算。通过不同的宏，控制了纹理采样、顶点混合、视差、Lod等等内容。</p><p>##LitData.hlsl与LayeredLitData.hlsl</p><p>这两个文件中包括了纹理采样计算的主要内容：<strong>GetSurfaceAndBuiltinData函数</strong></p><p>重要的数据结构,根据宏来判断使用那种数据结构，记录了所有和纹理坐标相关的信息，包括Planar&#x2F;Triplanar&#x2F;Uv和多层UV，细节纹理等信息，每一层具体内容记录在：UVMapping结构中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LayerTexCoord</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LAYERED_LIT_SHADER</span><br>    UVMapping base;<br>    UVMapping details;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    UVMapping base0;<br>...<br>    UVMapping details0;<br>...<br>    UVMapping blendMask;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    float3 vertexNormalWS; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> store also object normal map for object triplanar</span><br>    float3 triplanarWeights;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SURFACE_GRADIENT</span><br>    float3 vertexTangentWS0, vertexBitangentWS0;.<br>    ...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="GetSurfaceAndBuiltinData-1"><a href="#GetSurfaceAndBuiltinData-1" class="headerlink" title="GetSurfaceAndBuiltinData"></a>GetSurfaceAndBuiltinData</h3><p>这个函数主要作用是通过Frag的输入信息，计算纹理坐标。输出纹理采样和混合结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">GetSurfaceAndBuiltinData</span><span class="hljs-params">(FragInputs input, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData)</span><br>&#123;<br><span class="hljs-comment">// Lod CrossFade</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LOD_FADE_CROSSFADE </span><br>    uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); /<br>    LODDitheringTransition(fadeMaskSeed, unity_LODFade.x);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">//双面处理</span><br>    ApplyDoubleSidedFlipOrMirror(input); <span class="hljs-comment">// Apply double sided flip on the vertex normal</span><br><span class="hljs-comment">// 根据配置计算纹理坐标：Planer、Triplanar、Tiling\offset等内容。</span><br>    LayerTexCoord layerTexCoord;<br>    ZERO_INITIALIZE(LayerTexCoord, layerTexCoord);<br>    GetLayerTexCoord(input, layerTexCoord);<br>  <br><span class="hljs-comment">// 这里是视差贴图，计算纹理偏移</span><br>    <span class="hljs-type">float</span> depthOffset = ApplyPerPixelDisplacement(input, V, layerTexCoord);<br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _DEPTHOFFSET_ON</span><br>    ApplyDepthOffsetPositionInput(V, depthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">// 根据计算出的纹理坐标和视差编译对纹理进行采样。</span><br>    float3 normalTS;<br>    float3 bentNormalTS;<br>    float3 bentNormalWS;<br>    <span class="hljs-type">float</span> alpha = GetSurfaceData(input, layerTexCoord, surfaceData, normalTS, bentNormalTS);<br>    GetNormalWS(input, normalTS, surfaceData.normalWS);<br><br>    <span class="hljs-comment">// Use bent normal to sample GI if available</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _BENTNORMALMAP</span><br>    GetNormalWS(input, bentNormalTS, bentNormalWS);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    bentNormalWS = surfaceData.normalWS;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    surfaceData.geomNormalWS = input.worldToTangent[<span class="hljs-number">2</span>];<br><br><span class="hljs-comment">// 从采样的结果到处高光等内容的</span><br>...<br>  <br>  <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Caution: surfaceData must be fully initialize before calling GetBuiltinData</span><br>    GetBuiltinData(input, V, posInput, surfaceData, alpha, bentNormalWS, depthOffset, builtinData);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="GetSurfaceData"><a href="#GetSurfaceData" class="headerlink" title="GetSurfaceData"></a>GetSurfaceData</h3><h3 id="GetBuiltinData"><a href="#GetBuiltinData" class="headerlink" title="GetBuiltinData"></a>GetBuiltinData</h3>]]></content>
      
      
      <categories>
          
          <category> HDRPSource </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity光源配置：Tiled And Cluster</title>
      <link href="/2022/07/09/HDRPsource/5.UnityHDRP%E5%85%89%E6%BA%90%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/07/09/HDRPsource/5.UnityHDRP%E5%85%89%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity光源配置：Tiled-And-Cluster"><a href="#Unity光源配置：Tiled-And-Cluster" class="headerlink" title="Unity光源配置：Tiled And Cluster"></a>Unity光源配置：Tiled And Cluster</h1><p>unity最新的HDRP中采用了Cluster和Tiled的光源配置，这里主要记录光源是如何从Unity当中的Light配置设置到最终Shader的对应Pass当中的。</p><p>Cluster是把视锥体看做三维体素，每个体素当中计算影响这个体素的光线，就和Volumetric Fog一样的原理。</p><p>Tiled是把屏幕分成格子，对每个格子计算影响这个格子的光源。</p><p>Tiled光照列表的计算总共分为三步：</p><ol><li>计算光照列表的所有凸包</li><li>使用凸包，计算bigtile的光照列表的大致计算。</li><li>使用fplt进行更精细的光照列表计算。</li></ol><p>##Tile光照列表计算</p><p>下面是光源计算,为每一个Tile生成光照列表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-type">void</span> <span class="hljs-title function_">BuildGPULightListsCommon</span><span class="hljs-params">(HDCamera hdCamera, CommandBuffer cmd, RenderTargetIdentifier cameraDepthBufferRT, RenderTargetIdentifier stencilTextureRT, <span class="hljs-type">bool</span> skyEnabled)</span><br>&#123;<br>  var camera = hdCamera.camera;<br>  <span class="hljs-comment">// 计算光照列表开始</span><br>  cmd.BeginSample(<span class="hljs-string">&quot;Build Light List&quot;</span>);<br><br>  var w = (<span class="hljs-type">int</span>)hdCamera.screenSize.x;<br>  var h = (<span class="hljs-type">int</span>)hdCamera.screenSize.y;<br>  s_TempScreenDimArray[<span class="hljs-number">0</span>] = w;<br>  s_TempScreenDimArray[<span class="hljs-number">1</span>] = h;<br>  <span class="hljs-comment">//首先设置Tile的大小  64,64</span><br>  var numBigTilesX = (w + <span class="hljs-number">63</span>) / <span class="hljs-number">64</span>;<br>  var numBigTilesY = (h + <span class="hljs-number">63</span>) / <span class="hljs-number">64</span>;<br><br>  <br>  <span class="hljs-comment">// 计算各种矩阵：</span><br>  m_LightListProjMatrices[<span class="hljs-number">0</span>] = <br>  m_LightListProjscrMatrices[<span class="hljs-number">0</span>] = <br>  m_LightListInvProjscrMatrices[<span class="hljs-number">0</span>] =<br>  m_LightListProjHMatrices[<span class="hljs-number">0</span>] = ;<br>  m_LightListInvProjHMatrices[<span class="hljs-number">0</span>] = ；<br>     <br>  <span class="hljs-comment">// 如果有光源 ，计算所有光源的AABB包围盒 ：见shader：lightlistbuild-bigtile.compute</span><br>   <span class="hljs-keyword">if</span> (m_lightCount != <span class="hljs-number">0</span>)<br>   &#123;<br><span class="hljs-comment">//第一步计算AABB</span><br>     var genAABBKernel = isProjectionOblique ? s_GenAABBKernel_Oblique : s_GenAABBKernel;<br><br>     <span class="hljs-comment">// 是否正交</span><br>     cmd.SetComputeIntParam(buildScreenAABBShader, HDShaderIDs.g_isOrthographic, isOrthographic ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br> <span class="hljs-comment">// 光源数量</span><br>     cmd.SetComputeIntParam(buildScreenAABBShader, HDShaderIDs.g_iNrVisibLights, m_lightCount);<br>     <span class="hljs-comment">// 光源凸包数据</span><br>     cmd.SetComputeBufferParam(buildScreenAABBShader, genAABBKernel, HDShaderIDs.g_data, s_ConvexBoundsBuffer);<br><span class="hljs-comment">// 矩阵数组</span><br>     cmd.SetComputeMatrixArrayParam(buildScreenAABBShader, HDShaderIDs.g_mProjectionArr, m_LightListProjHMatrices);<br>     cmd.SetComputeMatrixArrayParam(buildScreenAABBShader, HDShaderIDs.g_mInvProjectionArr, m_LightListInvProjHMatrices);<br><br>     <span class="hljs-comment">// AABB结果</span><br>     cmd.SetComputeBufferParam(buildScreenAABBShader, genAABBKernel, HDShaderIDs.g_vBoundsBuffer, s_AABBBoundsBuffer);<br><br>     <span class="hljs-type">int</span> tgY = (<span class="hljs-type">int</span>)hdCamera.numEyes;<br>     <br>     <span class="hljs-comment">// 提交计算</span><br>     cmd.DispatchCompute(buildScreenAABBShader, genAABBKernel, (m_lightCount + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>, tgY, <span class="hljs-number">1</span>);<br>   &#125;<br>  <br>  <br>  <span class="hljs-comment">// 粗糙的Tile计算。</span><br>  <span class="hljs-comment">// enable coarse 2D pass on 64x64 tiles (used for both fptl and clustered).</span><br>  <span class="hljs-keyword">if</span> (m_FrameSettings.lightLoopSettings.enableBigTilePrepass)<br>  &#123;<br>    cmd.SetComputeIntParam(buildPerBigTileLightListShader, HDShaderIDs.g_iNrVisibLights, m_lightCount);<br>    cmd.SetComputeIntParam(buildPerBigTileLightListShader, HDShaderIDs.g_isOrthographic, isOrthographic ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>    cmd.SetComputeIntParams(buildPerBigTileLightListShader, HDShaderIDs.g_viDimensions, s_TempScreenDimArray);<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> These two aren&#x27;t actually used...</span><br>    cmd.SetComputeIntParam(buildPerBigTileLightListShader, HDShaderIDs._EnvLightIndexShift, m_lightList.lights.Count);<br>    cmd.SetComputeIntParam(buildPerBigTileLightListShader, HDShaderIDs._DecalIndexShift, m_lightList.lights.Count + m_lightList.envLights.Count);<br><br>    cmd.SetComputeMatrixArrayParam(buildPerBigTileLightListShader, HDShaderIDs.g_mScrProjectionArr, m_LightListProjscrMatrices);<br>    cmd.SetComputeMatrixArrayParam(buildPerBigTileLightListShader, HDShaderIDs.g_mInvScrProjectionArr, m_LightListInvProjscrMatrices);<br><br>    cmd.SetComputeFloatParam(buildPerBigTileLightListShader, HDShaderIDs.g_fNearPlane, camera.nearClipPlane);<br>    cmd.SetComputeFloatParam(buildPerBigTileLightListShader, HDShaderIDs.g_fFarPlane, camera.farClipPlane);<br>    cmd.SetComputeBufferParam(buildPerBigTileLightListShader, s_GenListPerBigTileKernel, HDShaderIDs.g_vLightList, s_BigTileLightList);<br>    cmd.SetComputeBufferParam(buildPerBigTileLightListShader, s_GenListPerBigTileKernel, HDShaderIDs.g_vBoundsBuffer, s_AABBBoundsBuffer);<br>    cmd.SetComputeBufferParam(buildPerBigTileLightListShader, s_GenListPerBigTileKernel, HDShaderIDs._LightVolumeData, s_LightVolumeDataBuffer);<br>    cmd.SetComputeBufferParam(buildPerBigTileLightListShader, s_GenListPerBigTileKernel, HDShaderIDs.g_data, s_ConvexBoundsBuffer);<br><br>    <span class="hljs-type">int</span> tgZ = (<span class="hljs-type">int</span>)hdCamera.numEyes;<br>    cmd.DispatchCompute(buildPerBigTileLightListShader, s_GenListPerBigTileKernel, numBigTilesX, numBigTilesY, tgZ);<br>  &#125;<br>  <br>  <br>  <span class="hljs-comment">// fplt计算</span><br>  <span class="hljs-comment">// optimized for opaques only</span><br>    <span class="hljs-keyword">if</span> (m_FrameSettings.lightLoopSettings.isFptlEnabled)<br>    &#123;<br>      var genListPerTileKernel = isProjectionOblique ? s_GenListPerTileKernel_Oblique : s_GenListPerTileKernel;<br><br>      cmd.SetComputeIntParam(buildPerTileLightListShader, HDShaderIDs.g_isOrthographic, isOrthographic ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>      cmd.SetComputeIntParams(buildPerTileLightListShader, HDShaderIDs.g_viDimensions, s_TempScreenDimArray);<br>      cmd.SetComputeIntParam(buildPerTileLightListShader, HDShaderIDs._EnvLightIndexShift, m_lightList.lights.Count);<br>      cmd.SetComputeIntParam(buildPerTileLightListShader, HDShaderIDs._DecalIndexShift, m_lightList.lights.Count + m_lightList.envLights.Count);<br>      cmd.SetComputeIntParam(buildPerTileLightListShader, HDShaderIDs.g_iNrVisibLights, m_lightCount);<br><br>      cmd.SetComputeBufferParam(buildPerTileLightListShader, genListPerTileKernel, HDShaderIDs.g_vBoundsBuffer, s_AABBBoundsBuffer);<br>      cmd.SetComputeBufferParam(buildPerTileLightListShader, genListPerTileKernel, HDShaderIDs._LightVolumeData, s_LightVolumeDataBuffer);<br>      cmd.SetComputeBufferParam(buildPerTileLightListShader, genListPerTileKernel, HDShaderIDs.g_data, s_ConvexBoundsBuffer);<br><br>      cmd.SetComputeMatrixParam(buildPerTileLightListShader, HDShaderIDs.g_mScrProjection, m_LightListProjscrMatrices[<span class="hljs-number">0</span>]);<br>      cmd.SetComputeMatrixParam(buildPerTileLightListShader, HDShaderIDs.g_mInvScrProjection, m_LightListInvProjscrMatrices[<span class="hljs-number">0</span>]);<br><br>      cmd.SetComputeTextureParam(buildPerTileLightListShader, genListPerTileKernel, HDShaderIDs.g_depth_tex, cameraDepthBufferRT);<br>      cmd.SetComputeBufferParam(buildPerTileLightListShader, genListPerTileKernel, HDShaderIDs.g_vLightList, s_LightList);<br>      <span class="hljs-keyword">if</span> (m_FrameSettings.lightLoopSettings.enableBigTilePrepass)<br>        cmd.SetComputeBufferParam(buildPerTileLightListShader, genListPerTileKernel, HDShaderIDs.g_vBigTileLightList, s_BigTileLightList);<br><br>      <span class="hljs-keyword">if</span> (enableFeatureVariants)<br>      &#123;<br>        uint baseFeatureFlags = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (m_lightList.directionalLights.Count &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>          baseFeatureFlags |= (uint)LightFeatureFlags.Directional;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (skyEnabled)<br>        &#123;<br>          baseFeatureFlags |= (uint)LightFeatureFlags.Sky;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!m_FrameSettings.lightLoopSettings.enableComputeMaterialVariants)<br>        &#123;<br>          baseFeatureFlags |= LightDefinitions.s_MaterialFeatureMaskFlags;<br>        &#125;<br>        cmd.SetComputeIntParam(buildPerTileLightListShader, HDShaderIDs.g_BaseFeatureFlags, (<span class="hljs-type">int</span>)baseFeatureFlags);<br>        cmd.SetComputeBufferParam(buildPerTileLightListShader, genListPerTileKernel, HDShaderIDs.g_TileFeatureFlags, s_TileFeatureFlags);<br>      &#125;<br><br>      cmd.DispatchCompute(buildPerTileLightListShader, genListPerTileKernel, numTilesX, numTilesY, <span class="hljs-number">1</span>);<br>    &#125;<br>  <br>  <span class="hljs-comment">// Cluster 计算</span><br>  VoxelLightListGeneration(cmd, hdCamera, m_LightListProjscrMatrices, m_LightListInvProjscrMatrices, cameraDepthBufferRT);<br><br>  <span class="hljs-comment">// 计算光照列表结束</span><br>  cmd.EndSample(<span class="hljs-string">&quot;Build Light List&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="光源包围盒计算"><a href="#光源包围盒计算" class="headerlink" title="光源包围盒计算"></a>光源包围盒计算</h3><p>计算屏幕空间光源包围盒的shader：scrbound.compute</p><p>原始代码中记录的包围盒的类型，中心和几个扩展方向</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SFiniteLightBound</span></span><br><span class="hljs-class">&#123;</span><br>    public Vector3 boxAxisX;<br>    public Vector3 boxAxisY;<br>    public Vector3 boxAxisZ;<br>    public Vector3 center;        <span class="hljs-comment">// a center in camera space inside the bounding volume of the light source.</span><br>    public Vector2 scaleXY;<br>    public <span class="hljs-type">float</span> radius;<br>&#125;;<br></code></pre></td></tr></table></figure><p>每个光源都有一个上面的结构体，从一个统一的结构体转换到屏幕对齐的AABB包围盒。</p><p>###BigTile光照列表计算</p><p>计算BigTile光照列表的compute shader：</p><p>使用了三种方法：</p><ol><li>包围盒相交。</li><li>球形相交。</li><li>CullByExactEdgeTests：这个还没有看。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 根据NR_THREADS作为不同线程的采样间隔，计算互斥的光源信息</span><br>[numthreads(NR_THREADS, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-type">void</span> <span class="hljs-title function_">BigTileLightListGen</span><span class="hljs-params">(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID)</span><br>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  这里的计算是每个Tile一次提交，每个提交，多个Thread并行。，每个Thread处理不想交的一组灯光。</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-comment">// 这个是Tile的ID</span><br>    uint eyeIndex = u3GroupID.z;<br>    uint2 tileIDX = u3GroupID.xy;<br>  <span class="hljs-comment">//  这个是每个Tile当中的threadID</span><br>    uint t=threadID;<br>  <br><span class="hljs-comment">// 计算每个Tile的实际大小。</span><br>    uint iWidth = g_viDimensions.x;<br>    uint iHeight = g_viDimensions.y;<br>    uint nrBigTilesX = (iWidth+<span class="hljs-number">63</span>)/<span class="hljs-number">64</span>;<br>    uint nrBigTilesY = (iHeight+<span class="hljs-number">63</span>)/<span class="hljs-number">64</span>;<br><br>  <span class="hljs-comment">// 线程共享，只让第一个线程进行初始化操作。</span><br>    <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>) lightOffs = <span class="hljs-number">0</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(SHADER_API_XBOXONE) &amp;&amp; !defined(SHADER_API_PSSL)</span><br>    GroupMemoryBarrierWithGroupSync();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// Raw pixel coordinates of tile</span><br>    uint2 viTilLL = <span class="hljs-number">64</span>*tileIDX;<br>    uint2 viTilUR = min( viTilLL+uint2(<span class="hljs-number">64</span>,<span class="hljs-number">64</span>), uint2(iWidth, iHeight) );            <span class="hljs-comment">// not width and height minus 1 since viTilUR represents the end of the tile corner.</span><br><br>    <span class="hljs-comment">// 每个tile的包围盒</span><br>    float2 vTileLL = float2(viTilLL.x/(<span class="hljs-type">float</span>) iWidth, viTilLL.y/(<span class="hljs-type">float</span>) iHeight);<br>    float2 vTileUR = float2(viTilUR.x/(<span class="hljs-type">float</span>) iWidth, viTilUR.y/(<span class="hljs-type">float</span>) iHeight);<br><br>    <span class="hljs-comment">// build coarse list using AABB</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=(<span class="hljs-type">int</span>) t; l&lt;(<span class="hljs-type">int</span>) g_iNrVisibLights; l += NR_THREADS)<br>    &#123;<br>      <span class="hljs-comment">// 获取灯光包围盒信息</span><br>        <span class="hljs-type">const</span> ScreenSpaceBoundsIndices boundsIndices = GenerateScreenSpaceBoundsIndices(l, g_iNrVisibLights, eyeIndex);<br>      <span class="hljs-comment">// 灯光的包围盒信息</span><br>        <span class="hljs-type">const</span> float2 vMi = g_vBoundsBuffer[boundsIndices.min].xy;<br>        <span class="hljs-type">const</span> float2 vMa = g_vBoundsBuffer[boundsIndices.max].xy;<br><br>      <span class="hljs-comment">// 灯光的包围盒和tile的包围盒是否相交</span><br>        <span class="hljs-keyword">if</span>( all(vMa&gt;vTileLL) &amp;&amp; all(vMi&lt;vTileUR))<br>        &#123;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> uInc = <span class="hljs-number">1</span>;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> uIndex;<br>          <span class="hljs-comment">// 原子求和操作，让lightOffs加1.</span><br>            InterlockedAdd(lightOffs, uInc, uIndex);<br><span class="hljs-comment">// 通过加到当前Tile的灯光列表，uIndex是组间不同的。</span><br>            <span class="hljs-keyword">if</span>(uIndex&lt;MAX_NR_BIGTILE_LIGHTS) lightsListLDS[uIndex] = l;    <br>        &#125;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> <span class="hljs-comment">/*!defined(SHADER_API_XBOXONE) &amp;&amp; */</span>!defined(SHADER_API_PSSL)</span><br>    GroupMemoryBarrierWithGroupSync();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-comment">// 计算实际的光照数。</span><br>    <span class="hljs-type">int</span> iNrCoarseLights = min(lightOffs,MAX_NR_BIGTILE_LIGHTS);<br><br>  <span class="hljs-comment">// 球形相交计算，如果球形没有相交， 则把lightlist中记录原来相交的id变成uint_max</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PERFORM_SPHERICAL_INTERSECTION_TESTS</span><br>    SphericalIntersectionTests( t, iNrCoarseLights, float2(min(viTilLL.xy+uint2(<span class="hljs-number">64</span>/<span class="hljs-number">2</span>,<span class="hljs-number">64</span>/<span class="hljs-number">2</span>), uint2(iWidth<span class="hljs-number">-1</span>, iHeight<span class="hljs-number">-1</span>))), eyeIndex );<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> EXACT_EDGE_TESTS</span><br>    CullByExactEdgeTests(t, iNrCoarseLights, viTilLL.xy, viTilUR.xy, eyeIndex);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 灯光按类型排序</span><br>    SORTLIST(lightsListLDS, iNrCoarseLights, MAX_NR_BIG_TILE_LIGHTS_PLUS_ONE, t, NR_THREADS);<br><br>    <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>) lightOffs = <span class="hljs-number">0</span>;<br>    GroupMemoryBarrierWithGroupSync();<br>  <span class="hljs-comment">// 重新计算光照数量</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=t; i&lt;iNrCoarseLights; i+=NR_THREADS) <br>      <span class="hljs-keyword">if</span>(lightsListLDS[i]&lt;(uint)g_iNrVisibLights) <br>        InterlockedAdd(lightOffs, <span class="hljs-number">1</span>);<br>    GroupMemoryBarrierWithGroupSync();<br>    iNrCoarseLights = lightOffs;<br><span class="hljs-comment">// 计算当前tile的索引</span><br>    <span class="hljs-type">int</span> offs = tileIDX.y*nrBigTilesX + tileIDX.x + (eyeIndex * nrBigTilesX * nrBigTilesY);<br><span class="hljs-comment">//最终的光照列表，放到记录光照的列表当中，所有的tile的光照列表存在一个大的tile当中。</span><br>    <span class="hljs-keyword">for</span>(i=t; i&lt;(iNrCoarseLights+<span class="hljs-number">1</span>); i+=NR_THREADS)<br>        g_vLightList[MAX_NR_BIG_TILE_LIGHTS_PLUS_ONE*offs + i] = i==<span class="hljs-number">0</span> ? iNrCoarseLights : lightsListLDS[max(i<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>)];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FPTL"><a href="#FPTL" class="headerlink" title="FPTL"></a>FPTL</h3><p>精准的判断每个tile当中的光照列表,这里使用了更加精细的tile划分（16*16），相对于bigtile还会对Z值进行比较。原本的Bigtile 只是用了屏幕方向的xy。</p><p>同时加入了光源类型相关的操作。</p><p>shader使用:lightlistbuild.compute</p><p>compute Shader使用的kernel确定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (GetFeatureVariantsEnabled())<br>&#123;<br>  s_GenListPerTileKernel = buildPerTileLightListShader.FindKernel(m_FrameSettings.lightLoopSettings.enableBigTilePrepass ? <span class="hljs-string">&quot;TileLightListGen_SrcBigTile_FeatureFlags&quot;</span> : <span class="hljs-string">&quot;TileLightListGen_FeatureFlags&quot;</span>);<br>  s_GenListPerTileKernel_Oblique = buildPerTileLightListShader.FindKernel(m_FrameSettings.lightLoopSettings.enableBigTilePrepass ? <span class="hljs-string">&quot;TileLightListGen_SrcBigTile_FeatureFlags_Oblique&quot;</span> : <span class="hljs-string">&quot;TileLightListGen_FeatureFlags_Oblique&quot;</span>);<br><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>  s_GenListPerTileKernel = buildPerTileLightListShader.FindKernel(m_FrameSettings.lightLoopSettings.enableBigTilePrepass ? <span class="hljs-string">&quot;TileLightListGen_SrcBigTile&quot;</span> : <span class="hljs-string">&quot;TileLightListGen&quot;</span>);<br>  s_GenListPerTileKernel_Oblique = buildPerTileLightListShader.FindKernel(m_FrameSettings.lightLoopSettings.enableBigTilePrepass ? <span class="hljs-string">&quot;TileLightListGen_SrcBigTile_Oblique&quot;</span> : <span class="hljs-string">&quot;TileLightListGen_Oblique&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>FPTLshader</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><code class="hljs c">[numthreads(NR_THREADS, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-type">void</span> <span class="hljs-title function_">LIGHTLISTGEN</span><span class="hljs-params">(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID)</span><br>&#123;<br>    uint2 tileIDX = u3GroupID.xy;<br>    uint t=threadID;<br><br>    <span class="hljs-keyword">if</span>(t&lt;MAX_NR_COARSE_ENTRIES)<br>        prunedList[t]=<span class="hljs-number">0</span>;<br><br>    uint iWidth = g_viDimensions.x;<br>    uint iHeight = g_viDimensions.y;<br>    uint nrTilesX = (iWidth+<span class="hljs-number">15</span>)/<span class="hljs-number">16</span>;<br>    uint nrTilesY = (iHeight+<span class="hljs-number">15</span>)/<span class="hljs-number">16</span>;<br>    uint nrTiles = nrTilesX * nrTilesY; <span class="hljs-comment">// Precompute?</span><br><br>    <span class="hljs-comment">// build tile scr boundary</span><br>    <span class="hljs-type">const</span> uint uFltMax = <span class="hljs-number">0x7f7fffff</span>;  <span class="hljs-comment">// FLT_MAX as a uint</span><br>    <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>)<br>    &#123;<br>        ldsZMin = uFltMax;<br>        ldsZMax = <span class="hljs-number">0</span>;<br>        lightOffs = <span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(SHADER_API_XBOXONE) &amp;&amp; !defined(SHADER_API_PSSL)</span><br>    GroupMemoryBarrierWithGroupSync();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    uint2 viTilLL = <span class="hljs-number">16</span>*tileIDX;<br><br>    <span class="hljs-comment">// establish min and max depth first</span><br>    <span class="hljs-type">float</span> dpt_mi=asfloat(uFltMax), dpt_ma=<span class="hljs-number">0.0</span>;<br><span class="hljs-comment">// 计算包含深度的包围盒。</span><br>    float4 vLinDepths;<br>    &#123;<br>        <span class="hljs-comment">// Fetch depths and calculate min/max</span><br>        UNITY_UNROLL<br>        <span class="hljs-title function_">for</span><span class="hljs-params">(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)</span><br>        &#123;<br>            <span class="hljs-type">int</span> idx = i * NR_THREADS + t;<br>            uint2 uCrd = min( uint2(viTilLL.x+(idx&amp;<span class="hljs-number">0xf</span>), viTilLL.y+(idx&gt;&gt;<span class="hljs-number">4</span>)), uint2(iWidth<span class="hljs-number">-1</span>, iHeight<span class="hljs-number">-1</span>) );<br>            <span class="hljs-type">const</span> <span class="hljs-type">float</span> fDepth = FetchDepth(g_depth_tex, uCrd);<br>            vLinDepths[i] = GetLinearDepth(uCrd+float2(<span class="hljs-number">0.5</span>,<span class="hljs-number">0.5</span>), fDepth);<br>            <span class="hljs-keyword">if</span>(fDepth&lt;VIEWPORT_SCALE_Z)     <span class="hljs-comment">// if not skydome</span><br>            &#123;<br>                dpt_mi = min(fDepth, dpt_mi);<br>                dpt_ma = max(fDepth, dpt_ma);<br>            &#125;<br>        &#125;<br><br>        InterlockedMax(ldsZMax, asuint(dpt_ma));<br>        InterlockedMin(ldsZMin, asuint(dpt_mi));<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(SHADER_API_XBOXONE) &amp;&amp; !defined(SHADER_API_PSSL)</span><br>        GroupMemoryBarrierWithGroupSync();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br><br><br>    float3 vTileLL = float3(viTilLL.x/(<span class="hljs-type">float</span>) iWidth, viTilLL.y/(<span class="hljs-type">float</span>) iHeight, asfloat(ldsZMin));<br>    float3 vTileUR = float3((viTilLL.x+<span class="hljs-number">16</span>)/(<span class="hljs-type">float</span>) iWidth, (viTilLL.y+<span class="hljs-number">16</span>)/(<span class="hljs-type">float</span>) iHeight, asfloat(ldsZMax));<br>    vTileUR.xy = min(vTileUR.xy,float2(<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>)).xy;<br><br><span class="hljs-comment">// 使用aabb计算粗糙的光照列表。</span><br>    <span class="hljs-comment">// build coarse list using AABB</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_TWO_PASS_TILED_LIGHTING</span><br>    <span class="hljs-type">const</span> uint log2BigTileToTileRatio = firstbithigh(<span class="hljs-number">64</span>) - firstbithigh(<span class="hljs-number">16</span>);<br><br>    <span class="hljs-type">int</span> NrBigTilesX = (nrTilesX+((<span class="hljs-number">1</span>&lt;&lt;log2BigTileToTileRatio)<span class="hljs-number">-1</span>))&gt;&gt;log2BigTileToTileRatio;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> bigTileIdx = (tileIDX.y&gt;&gt;log2BigTileToTileRatio)*NrBigTilesX + (tileIDX.x&gt;&gt;log2BigTileToTileRatio);       <span class="hljs-comment">// map the idx to 64x64 tiles</span><br>    <span class="hljs-type">int</span> nrBigTileLights = g_vBigTileLightList[MAX_NR_BIG_TILE_LIGHTS_PLUS_ONE*bigTileIdx+<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l0=(<span class="hljs-type">int</span>) t; l0&lt;(<span class="hljs-type">int</span>) nrBigTileLights; l0 += NR_THREADS)<br>    &#123;<br>        <span class="hljs-type">int</span> l = g_vBigTileLightList[MAX_NR_BIG_TILE_LIGHTS_PLUS_ONE*bigTileIdx+l0+<span class="hljs-number">1</span>];<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=(<span class="hljs-type">int</span>) t; l&lt;(<span class="hljs-type">int</span>) g_iNrVisibLights; l += NR_THREADS)<br>    &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-comment">// Skip density volumes (lights are sorted by category). <span class="hljs-doctag">TODO:</span> improve data locality</span><br>        <span class="hljs-keyword">if</span> (_LightVolumeData[l].lightCategory == LIGHTCATEGORY_DENSITY_VOLUME) &#123; <span class="hljs-keyword">break</span>; &#125;<br><br>        <span class="hljs-type">const</span> float3 vMi = g_vBoundsBuffer[l].xyz;<br>        <span class="hljs-type">const</span> float3 vMa = g_vBoundsBuffer[l+g_iNrVisibLights].xyz;<br><span class="hljs-comment">// 包围盒在xyz方向上同时判断相交。</span><br>        <span class="hljs-keyword">if</span>( all(vMa&gt;vTileLL) &amp;&amp; all(vMi&lt;vTileUR))<br>        &#123;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> uInc = <span class="hljs-number">1</span>;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> uIndex;<br>            InterlockedAdd(lightOffs, uInc, uIndex);<br>            <span class="hljs-keyword">if</span>(uIndex&lt;MAX_NR_COARSE_ENTRIES) coarseList[uIndex] = l;        <span class="hljs-comment">// add to light list</span><br>        &#125;<br>    &#125;<br>      <span class="hljs-comment">// 粗糙的光照列表计算结束</span><br><br>      <span class="hljs-comment">// FPTL进行精细调整。</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FINE_PRUNING_ENABLED</span><br>    <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">2</span>) ldsDoesLightIntersect[t] = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(SHADER_API_XBOXONE) &amp;&amp; !defined(SHADER_API_PSSL)</span><br>    GroupMemoryBarrierWithGroupSync();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-type">int</span> iNrCoarseLights = min(lightOffs,MAX_NR_COARSE_ENTRIES);<br><br>      <span class="hljs-comment">// 球形相交和 bigtile类似</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PERFORM_SPHERICAL_INTERSECTION_TESTS</span><br>    iNrCoarseLights = SphericalIntersectionTests( t, iNrCoarseLights, float2(min(viTilLL.xy+uint2(<span class="hljs-number">16</span>/<span class="hljs-number">2</span>,<span class="hljs-number">16</span>/<span class="hljs-number">2</span>), uint2(iWidth<span class="hljs-number">-1</span>, iHeight<span class="hljs-number">-1</span>))) );<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> FINE_PRUNING_ENABLED</span><br>    &#123;<br>      <span class="hljs-comment">// 修改保存位置</span><br>        <span class="hljs-keyword">if</span>((<span class="hljs-type">int</span>)t&lt;iNrCoarseLights) prunedList[t] = coarseList[t];<br>        <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>) ldsNrLightsFinal=iNrCoarseLights;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    &#123;<br>        <span class="hljs-comment">// initializes ldsNrLightsFinal with the number of accepted lights.</span><br>        <span class="hljs-comment">// all accepted entries delivered in prunedList[].</span><br>        FinePruneLights(t, iNrCoarseLights, viTilLL, vLinDepths);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">// 光照类型相关，t是线程号。每个线程对应一个类型。</span><br>    <span class="hljs-keyword">if</span>(t&lt;CATEGORY_LIST_SIZE) ldsCategoryListCount[t]=<span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_FEATURE_FLAGS</span><br>    <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>) ldsFeatureFlags=<span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(SHADER_API_XBOXONE) &amp;&amp; !defined(SHADER_API_PSSL)</span><br>    GroupMemoryBarrierWithGroupSync();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br>     <span class="hljs-comment">// 统计每种类型光源的数量</span><br>    <span class="hljs-type">int</span> nrLightsCombinedList = min(ldsNrLightsFinal,MAX_NR_COARSE_ENTRIES);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=t; i&lt;nrLightsCombinedList; i+=NR_THREADS)<br>    &#123;<br>        InterlockedAdd(ldsCategoryListCount[_LightVolumeData[prunedList[i]].lightCategory], <span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_FEATURE_FLAGS</span><br>        InterlockedOr(ldsFeatureFlags, _LightVolumeData[prunedList[i]].featureFlags);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br><br>      <span class="hljs-comment">// 光照排序，减少在计算光照过程中分支的情况</span><br>    <span class="hljs-comment">// sort lights (gives a more efficient execution in both deferred and tiled forward lighting).</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(SHADER_API_XBOXONE) &amp;&amp; !defined(SHADER_API_PSSL)</span><br>    SORTLIST(prunedList, nrLightsCombinedList, MAX_NR_COARSE_ENTRIES, t, NR_THREADS);<br>    <span class="hljs-comment">//MERGESORTLIST(prunedList, coarseList, nrLightsCombinedList, t, NR_THREADS);</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_FEATURE_FLAGS</span><br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-number">0</span>)<br>    &#123;<br>        uint featureFlags = ldsFeatureFlags | g_BaseFeatureFlags;<br>        <span class="hljs-comment">// In case of back</span><br>        <span class="hljs-keyword">if</span>(ldsZMax &lt; ldsZMin)   <span class="hljs-comment">// is background pixel</span><br>        &#123;<br>            <span class="hljs-comment">// There is no stencil usage with compute path, featureFlags set to 0 is use to have fast rejection of tile in this case. It will still execute but will do nothing</span><br>            featureFlags = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        g_TileFeatureFlags[tileIDX.y * nrTilesX + tileIDX.x] = featureFlags;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// write lights to global buffers</span><br>    <span class="hljs-type">int</span> localOffs=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> offs = tileIDX.y*nrTilesX + tileIDX.x;<br><br>    <span class="hljs-comment">// All our cull data are in the same list, but at render time envLights are separated so we need to shift the index</span><br>    <span class="hljs-comment">// to make it work correctly</span><br>    <span class="hljs-type">int</span> shiftIndex[CATEGORY_LIST_SIZE];<br>    ZERO_INITIALIZE_ARRAY(<span class="hljs-type">int</span>, shiftIndex, CATEGORY_LIST_SIZE);<br>    shiftIndex[CATEGORY_LIST_SIZE - <span class="hljs-number">2</span>] = _EnvLightIndexShift;<br>    shiftIndex[CATEGORY_LIST_SIZE - <span class="hljs-number">1</span>] = _DecalIndexShift;<br><br>      <span class="hljs-comment">//将光源按照类型顺序写入到全局结果中。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> category=<span class="hljs-number">0</span>; category&lt;CATEGORY_LIST_SIZE; category++)<br>    &#123;<br>        <span class="hljs-type">int</span> nrLightsFinal = ldsCategoryListCount[category];<br>        <span class="hljs-type">int</span> nrLightsFinalClamped = nrLightsFinal&lt;MAX_NR_PRUNED_ENTRIES ? nrLightsFinal : MAX_NR_PRUNED_ENTRIES;<br><br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> nrDWords = ((nrLightsFinalClamped+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=(<span class="hljs-type">int</span>) t; l&lt;(<span class="hljs-type">int</span>) nrDWords; l += NR_THREADS)<br>        &#123;<br>            <span class="hljs-comment">// We remap the prunedList index to the original LightData / EnvLightData indices</span><br>            uint uLow = l==<span class="hljs-number">0</span> ? nrLightsFinalClamped : prunedList[max(<span class="hljs-number">0</span>,<span class="hljs-number">2</span> * l - <span class="hljs-number">1</span> + localOffs)] - shiftIndex[category];<br>            uint uHigh = prunedList[<span class="hljs-number">2</span> * l + <span class="hljs-number">0</span> + localOffs] - shiftIndex[category];<br><br>            g_vLightList[<span class="hljs-number">16</span>*offs + l] = (uLow&amp;<span class="hljs-number">0xffff</span>) | (uHigh&lt;&lt;<span class="hljs-number">16</span>);<br>        &#125;<br><br>        localOffs += nrLightsFinal;<br>        offs += (nrTilesX*nrTilesY);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HDRPSource </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HDRP Decal</title>
      <link href="/2022/07/09/HDRPsource/6.HDRPDecal/"/>
      <url>/2022/07/09/HDRPsource/6.HDRPDecal/</url>
      
        <content type="html"><![CDATA[<p>#HDRP Decal</p><p>Unity提供了贴花功能，现在能够控制Decal具体要投射到哪些物体上。。</p><p>Decal 渲染最开始需要一个深度图：</p><p>需要透视Decal的物体会渲染</p><p>m_DepthOnlyPassNames ：渲染深度</p><p>m_DepthForwardOnlyPassNames：渲染法线</p><p>Decal需要进行可以进行异步剪裁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableDecals)<br>&#123;<br>  <span class="hljs-comment">// decal system needs to be updated with current camera, it needs it to set up culling and light list generation parameters</span><br>  DecalSystem.instance.CurrentCamera = camera;<br>  DecalSystem.instance.BeginCull();<br>&#125;<br><br><span class="hljs-comment">// 其他计算。</span><br><br>m_DbufferManager.enableDecals = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableDecals)<br>&#123;<br>  using (new ProfilingSample(cmd, <span class="hljs-string">&quot;DBufferPrepareDrawData&quot;</span>, CustomSamplerId.DBufferPrepareDrawData.GetSampler()))<br>  &#123;<br>    DecalSystem.instance.EndCull();<br>    m_DbufferManager.enableDecals = <span class="hljs-literal">true</span>;              <span class="hljs-comment">// mesh decals are renderers managed by c++ runtime and we have no way to query if any are visible, so set to true</span><br>    DecalSystem.instance.UpdateCachedMaterialData();    <span class="hljs-comment">// textures, alpha or fade distances could&#x27;ve changed</span><br>    DecalSystem.instance.CreateDrawData();              <span class="hljs-comment">// prepare data is separate from draw</span><br>    DecalSystem.instance.UpdateTextureAtlas(cmd);       <span class="hljs-comment">// as this is only used for transparent pass, would&#x27;ve been nice not to have to do this if no transparent renderers are visible, needs to happen after CreateDrawData</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关于Dbuffer"><a href="#关于Dbuffer" class="headerlink" title="关于Dbuffer"></a>关于Dbuffer</h2><p>如果没有Decals 则不需要Dbuffer，Decal是需要渲染到Dbuffer当中的，Dbuffer的结构类似Gbuffer.</p><p>下面是Dbuffer渲染代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">RenderDBuffer</span><span class="hljs-params">(HDCamera hdCamera, CommandBuffer cmd, ScriptableRenderContext renderContext, CullResults cullResults)</span><br>&#123;<br>  <span class="hljs-comment">// 不需要Decals 则不需要Dbuffer</span><br>  <span class="hljs-keyword">if</span> (!hdCamera.frameSettings.enableDecals)<br>    <span class="hljs-keyword">return</span>;<br><br><br><span class="hljs-comment">// 深度信息 放入Depth Buffer（从 m_SharedRTManager.GetDepthStencilBuffer() =&gt; m_SharedRTManager.GetDepthTexture()）</span><br>    CopyDepthBufferIfNeeded(cmd);<br><br>    <span class="hljs-type">bool</span> rtCount4 = m_Asset.GetRenderPipelineSettings().decalSettings.perChannelMask;<br>    <span class="hljs-comment">// Depth texture is now ready, bind it.</span><br>  <span class="hljs-comment">// 设置全局纹理</span><br>    cmd.SetGlobalTexture(HDShaderIDs._CameraDepthTexture, m_SharedRTManager.GetDepthTexture());<br>  <span class="hljs-comment">// 清理纹理设置成渲染目标，内部这只了多个渲染目标，m_SharedRTManager.GetDepthStencilBuffer()只是指定了深度用哪一个。</span><br>    m_DbufferManager.ClearAndSetTargets(cmd, hdCamera, rtCount4, m_SharedRTManager.GetDepthStencilBuffer());<br>    renderContext.ExecuteCommandBuffer(cmd);<br>  <br>  <span class="hljs-comment">// 这里cmd重置了</span><br>    cmd.Clear();<br><br>    DrawRendererSettings drawSettings = new DrawRendererSettings(hdCamera.camera, HDShaderPassNames.s_EmptyName)<br>    &#123;<br>      rendererConfiguration = <span class="hljs-number">0</span>,<br>      sorting = &#123; flags = SortFlags.CommonOpaque &#125;<br>    &#125;;<br><br>  <span class="hljs-comment">// 渲染目标数量 决定渲染方式，即需要绘制的pass名字</span><br>    <span class="hljs-keyword">if</span> (rtCount4)<br>    &#123;<br>      drawSettings.SetShaderPassName(<span class="hljs-number">0</span>, HDShaderPassNames.s_MeshDecalsMName);<br>      drawSettings.SetShaderPassName(<span class="hljs-number">1</span>, HDShaderPassNames.s_MeshDecalsAOName);<br>      drawSettings.SetShaderPassName(<span class="hljs-number">2</span>, HDShaderPassNames.s_MeshDecalsMAOName);<br>      drawSettings.SetShaderPassName(<span class="hljs-number">3</span>, HDShaderPassNames.s_MeshDecalsSName);<br>      drawSettings.SetShaderPassName(<span class="hljs-number">4</span>, HDShaderPassNames.s_MeshDecalsMSName);<br>      drawSettings.SetShaderPassName(<span class="hljs-number">5</span>, HDShaderPassNames.s_MeshDecalsAOSName);<br>      drawSettings.SetShaderPassName(<span class="hljs-number">6</span>, HDShaderPassNames.s_MeshDecalsMAOSName);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      drawSettings.SetShaderPassName(<span class="hljs-number">0</span>, HDShaderPassNames.s_MeshDecals3RTName);<br>    &#125;<br><br>  <span class="hljs-comment">// 所有不透明物体</span><br>    FilterRenderersSettings filterRenderersSettings = new FilterRenderersSettings(<span class="hljs-literal">true</span>)<br>    &#123;<br>      renderQueueRange = HDRenderQueue.k_RenderQueue_AllOpaque<br>    &#125;;<br><br>  <span class="hljs-comment">// 先绘制一次可见物体的decallpass，这个是说不用DecalProjector的方式的Decal？ 经过测试这句话即使注释掉也没反应。</span><br>    renderContext.DrawRenderers(cullResults.visibleRenderers, ref drawSettings, filterRenderersSettings);<br>  <br>  <span class="hljs-comment">// 这里再用cmd绘制是直接绘制到屏幕上了，收集相同材质的Decal，使用Instance绘制Decal，Shader是Decal，Dbuffer 有多个渲染目标和深度</span><br>    DecalSystem.instance.RenderIntoDBuffer(cmd);<br>    m_DbufferManager.UnSetHTile(cmd);<br>    m_DbufferManager.SetHTileTexture(cmd);  <span class="hljs-comment">// mask per 8x8 tile used for optimization when looking up dbuffer values</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HDRPSource </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LitShader参数</title>
      <link href="/2022/07/09/HDRPsource/8.LitShader/"/>
      <url>/2022/07/09/HDRPsource/8.LitShader/</url>
      
        <content type="html"><![CDATA[<h1 id="LitShader参数"><a href="#LitShader参数" class="headerlink" title="LitShader参数"></a>LitShader参数</h1><p><strong>特殊设置：</strong></p><p>Alpha CutOff  ：  透明阈值， Alpha值使用BaseColor,a通道，小于这个Alpha值得的位置完全透明。</p><p>Use Alpha Test :  是否使用Alpha Test。</p><p>Use PIXEL DisPlacement: 是否使用高度图。</p><p>Height Min&#x2F;Max Samples  :  高度图最小&#x2F;大采样次数。（决定了效果）</p><p>Height Lod Threshold：高度图 Lod，决定效果。</p><p><strong>纹理设置：</strong></p><p>BaseColor ：基础颜色默认白色，会和BaseColorMap的颜色相乘。</p><p>BaseColorMap ：就是漫反射贴图，对应Albedo。</p><p>Tiling&#x2F;Offset :决定了所有贴图的便偏移和混合。</p><p>NormalMap：切线空间法线贴图。</p><p>HeightMAp：当Use PIXEL DisPlacement勾选的时候，这个高度贴图才会生效。使用r通道。</p><p>Height Amplitude：高度的强弱。和HeightMap的结果相乘。</p><p>MaskMap：分为四个通道，R(Metalness)G(AO)B(Detial)A(Smoothness).</p><p>Metallic : 和金属度相乘。</p><p>Smothness : 这个值目前无效。（在HDRP中如果使用MaskMap则Smothness无效，这里为了兼容HDRP）</p><p>SmoothnessRemapMin ：金属度映射下限</p><p>SmoothnessRemapMax ： 金属度映射上限</p><p>AORemapMin ：AO映射下限</p><p>AORemapMax：AO映射上限</p><h1 id="LayeredLit参数"><a href="#LayeredLit参数" class="headerlink" title="LayeredLit参数"></a>LayeredLit参数</h1><p><strong>特殊设置</strong></p><p>LayerMaskMap ：混合贴图。</p><p>Alpha CutOff：见LitShader，使用的Alpha值来自于所有BaseColor，a通道的混合结果。</p><p>Use Alpha Test :  是否使用Alpha Test。</p><p>Use PIXEL DisPlacement: 是否使用高度图。高度来自于高度图r通道混合的结果。</p><p>Use Mul VERTEX Color Blend： 使用乘法顶点色混合。权重&#x3D;顶点色和LayerMaskMap相乘</p><p>Use Add VERTEX Color Blend： 使用加法顶点色混合。权重&#x3D;（顶点色 - 0.5）和和LayerMaskMap相加</p><p><strong>注：权重a表示0层，rgb分别表示123层。</strong></p><p><strong>Use Mul VERTEX Color Blend&#x2F;Use Add VERTEX Color Blend:选择一个就可以，或者都不选。如果都选则第一个生效。</strong></p><p><strong>纹理设置</strong></p><p>这部分内容同LitShader一致，只不过最终的值是通过<strong>Mask和顶点色的权重</strong>混合的结果。</p><p><strong>纹理层设置</strong></p><p>Layer Number Three：使用三层。</p><p>Layer Number Four：使用四层。</p><p><strong>Layer Number Four&#x2F;Layer Number Three:选择一个就可以</strong></p><h1 id="TiledLayeredLit"><a href="#TiledLayeredLit" class="headerlink" title="TiledLayeredLit"></a>TiledLayeredLit</h1><p>和LayeredLit全部一致。只是多了一张纹理和两个参数：</p><p>Normal（RG）AO（B) Alpaha(A)：RG通道表示法线的两个通道，B表示AO，A是alpha通道。</p><p>注：这个纹理的alpha通道和各层的混合结果的aplpha同时生效。</p><p>Main Normal Fractor：各层纹理和这个主纹理的混合程度，0表示完全使用主纹理，1表示完全混合主纹理和细节纹理。</p><p>AOFractor：表示主纹理AO所占最终AO比例。0表示不适用主纹理AO。</p>]]></content>
      
      
      <categories>
          
          <category> HDRPSource </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>光源配置设置</title>
      <link href="/2022/07/09/HDRPsource/7.%E5%85%89%E6%BA%90%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/"/>
      <url>/2022/07/09/HDRPsource/7.%E5%85%89%E6%BA%90%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="光源配置设置"><a href="#光源配置设置" class="headerlink" title="光源配置设置"></a>光源配置设置</h1><p>由于HDRP使用了新的光源配置方式，所以一些设置会影响性能，这里介绍一下主要的设置。</p><p>主要的设置主要在HDRenderPipelineAsset</p><p>和光源配置相关的参数，主要三个：</p><p>Asumc Compute &#x2F; Build Light List in Async  光照列表和阴影同步计算。</p><p>Light Loop Settings &#x2F; FPTL For Forward Opaque 光照列表与Deferred相同,提供给前向物体 </p><p>BigTile Prepass  在FPTL(16<em>16)之前进行粗糙Tile计算 64</em>64。</p>]]></content>
      
      
      <categories>
          
          <category> HDRPSource </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Occlusion Probe Shader部分</title>
      <link href="/2022/07/09/HDRPsource/9.OcclusionProbe/"/>
      <url>/2022/07/09/HDRPsource/9.OcclusionProbe/</url>
      
        <content type="html"><![CDATA[<h1 id="Occlusion-Probe-Shader部分"><a href="#Occlusion-Probe-Shader部分" class="headerlink" title="Occlusion Probe Shader部分"></a>Occlusion Probe Shader部分</h1><p>OcclusionProbe主要是用来计算环境光遮挡的探针，基本的原理是生成一个体素划分的块区域，在体素中填充阴影遮挡情况。在后在Shader当中提取计算的体素信息。</p><p>有两个步骤需要实现：</p><p>1.需要使用Unity自带的Progressive烘焙工具，<strong>手动</strong>烘焙环境贴图。</p><p>2.需要保证产生遮挡的物体，开启lightmap static</p><p>3.需要保证Baked Global Illumination是选择的。</p><p>4.烘焙完成，需要修改Shader读取这些体素信息。</p><h2 id="Shader中SurfaceData的区别"><a href="#Shader中SurfaceData的区别" class="headerlink" title="Shader中SurfaceData的区别"></a>Shader中SurfaceData的区别</h2><p>HDRP中SurfaceData数据保存了遮挡信息</p><p>主要的区别是三个Occlusion值</p><ol><li>skyOcclusion </li><li>treeOcclusion</li><li>grassOcclusion</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">struct SurfaceData<br>&#123;<br>    uint materialFeatures;<br>    float3 baseColor;<br>    float specularOcclusion;<br>    float3 normalWS;<br>    float perceptualSmoothness;<br>    float ambientOcclusion;<br>    float metallic;<br>    float coatMask;<br>    float3 specularColor;<br>    uint diffusionProfile;<br>    float subsurfaceMask;<br>    float thickness;<br>    float3 tangentWS;<br>    float anisotropy;<br>    float iridescenceThickness;<br>    float iridescenceMask;<br>    float ior;<br>    float3 transmittanceColor;<br>    float atDistance;<br>    float transmittanceMask;<br>    // (BofD)中的内容<br>    float skyOcclusion; // Occlusion Prode的遮挡信息<br>    float treeOcclusion;  // Occlusion Prode2的遮挡信息<br>    // 还有一个grassOcclusion 是一个临时变量没有出现<br>&#125;;<br>================================<br>struct SurfaceData<br>&#123;<br>    uint materialFeatures;<br>    float3 baseColor;<br>    float specularOcclusion;<br>    float3 normalWS;<br>    float perceptualSmoothness;<br>    float ambientOcclusion;<br>    float metallic;<br>    float coatMask;<br>    float3 specularColor;<br>    uint diffusionProfile;<br>    float subsurfaceMask;<br>    float thickness;<br>    float3 tangentWS;<br>    float anisotropy;<br>    float iridescenceThickness;<br>    float iridescenceMask;<br>    float3 geomNormalWS;<br>    float ior;<br>    float3 transmittanceColor;<br>    float atDistance;<br>    float transmittanceMask;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Occlusion遮挡信息的读取"><a href="#Occlusion遮挡信息的读取" class="headerlink" title="Occlusion遮挡信息的读取"></a>Occlusion遮挡信息的读取</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">主要获取到SurfaceData的位置是LitDaysIndividualLayer.  (BofD)<br>  ...<br><span class="hljs-comment">//forest-begin: sky occlusion</span><br>    <span class="hljs-type">float</span> grassOcclusion;<br>    surfaceData.skyOcclusion = SampleSkyOcclusion(input.positionRWS, grassOcclusion);<br><span class="hljs-comment">//forest-end</span><br><span class="hljs-comment">//forest-begin: Tree Occlusion</span><br>    float4 treeOcclusionInput = float4(input.texCoord2.xy, input.texCoord3.xy);<br>    surfaceData.treeOcclusion = GetTreeOcclusion(input.positionRWS, treeOcclusionInput);<br><span class="hljs-comment">//forest-end:</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">// #if !defined(LAYERED_LIT_SHADER)</span></span><br> ...<br></code></pre></td></tr></table></figure><p>上面涉及到的具体的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 _AtmosphericScatteringSunVector;<br><span class="hljs-comment">// 通过树的参数计算得到。</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">GetTreeOcclusion</span><span class="hljs-params">(float3 positionRWS, float4 treeOcclusionInput)</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_ANIM_SINGLE_PIVOT_COLOR) || defined(_ANIM_HIERARCHY_PIVOT)</span><br><span class="hljs-keyword">if</span>(_UseTreeOcclusion) &#123;<br>float3 positionWS = GetAbsolutePositionWS(positionRWS);<br><span class="hljs-type">float</span> treeWidth = _Tree12Width == <span class="hljs-number">0</span> ? <span class="hljs-number">1.f</span> : saturate((positionWS.y - UNITY_MATRIX_M._m13) / _Tree12Width);<br><span class="hljs-type">float</span> treeDO = lerp(_TreeDO, _TreeDO2, treeWidth);<br><span class="hljs-type">float</span> treeAO = lerp(_TreeAO, _TreeAO2, treeWidth);<br>float4 lightDir = float4(-_AtmosphericScatteringSunVector * treeDO, treeAO);<br><span class="hljs-type">float</span> treeDOBias = lerp(_TreeDOBias, _TreeDOBias2, treeWidth);<br><span class="hljs-type">float</span> treeAOBias = lerp(_TreeAOBias, _TreeAOBias2, treeWidth);<br><span class="hljs-keyword">return</span> saturate(dot(saturate(treeOcclusionInput + float4(treeDOBias.rrr, treeAOBias)), lightDir));<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1.f</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">SampleOcclusionProbes</span><span class="hljs-params">(float3 positionWS)</span><br>&#123;<br>    <span class="hljs-type">float</span> occlusionProbes = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 世界坐标转换到探针坐标</span><br>    float3 pos = mul(_OcclusionProbesWorldToLocalDetail, float4(positionWS, <span class="hljs-number">1</span>)).xyz;<br><br>  <span class="hljs-comment">// 这里有两个三维纹理。一个细节一个全局</span><br>    UNITY_BRANCH<br><span class="hljs-title function_">if</span><span class="hljs-params">(all(pos &gt; <span class="hljs-number">0</span>) &amp;&amp; all(pos &lt; <span class="hljs-number">1</span>))</span><br>    &#123;<br>      <span class="hljs-comment">// 采样三维纹理</span><br>occlusionProbes = tex3D(_OcclusionProbesDetail, pos).a;<br>&#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>pos = mul(_OcclusionProbesWorldToLocal, float4(positionWS, <span class="hljs-number">1</span>)).xyz;<br>occlusionProbes = tex3D(_OcclusionProbes, pos).a;<br>&#125;<br><br>    <span class="hljs-keyword">return</span> occlusionProbes;<br>&#125;<br><br><span class="hljs-comment">// 草的环境光遮挡，这是二维纹理。</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">SampleGrassOcclusion</span><span class="hljs-params">(float2 terrainUV)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> lerp(<span class="hljs-number">1.0</span>, tex2D(_GrassOcclusion, terrainUV).a, _GrassOcclusionAmountTerrain);<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">SampleGrassOcclusion</span><span class="hljs-params">(float3 positionWS)</span><br>&#123;<br>    float3 pos = mul(_GrassOcclusionWorldToLocal, float4(positionWS, <span class="hljs-number">1</span>)).xyz;<br>    <span class="hljs-type">float</span> terrainHeight = tex2D(_GrassOcclusionHeightmap, pos.xz).a;<br>    <span class="hljs-type">float</span> height = pos.y - terrainHeight * _GrassOcclusionHeightRange;<br><br>    UNITY_BRANCH<br>    <span class="hljs-title function_">if</span><span class="hljs-params">(height &lt; _GrassOcclusionCullHeight)</span><br>    &#123;<br>        <span class="hljs-type">float</span> xz = lerp(<span class="hljs-number">1.0</span>, tex2D(_GrassOcclusion, pos.xz).a, _GrassOcclusionAmountGrass);<br>        <span class="hljs-keyword">return</span> saturate(xz + smoothstep(_GrassOcclusionHeightFadeBottom, _GrassOcclusionHeightFadeTop, height));<br><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 这里会返回grassOcclusion和SkyOcclusion两个内容</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">SampleSkyOcclusion</span><span class="hljs-params">(float3 positionRWS, out <span class="hljs-type">float</span> grassOcclusion)</span><br>&#123;<br>  <span class="hljs-comment">// 获取世界坐标</span><br>    float3 positionWS = GetAbsolutePositionWS(positionRWS);<br>  <span class="hljs-comment">// 从世界坐标采样体素块</span><br>    grassOcclusion = SampleGrassOcclusion(positionWS);<br>  <br>    <span class="hljs-keyword">return</span> grassOcclusion * SampleOcclusionProbes(positionWS);<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">SampleSkyOcclusion</span><span class="hljs-params">(float3 positionRWS, float2 terrainUV, out <span class="hljs-type">float</span> grassOcclusion)</span><br>&#123;<br>    float3 positionWS = GetAbsolutePositionWS(positionRWS);<br>    grassOcclusion = SampleGrassOcclusion(terrainUV);<br>    <span class="hljs-keyword">return</span> grassOcclusion * SampleOcclusionProbes(positionWS);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在可以知道三个信息的来源：</p><ol><li>skyOcclusion  来自三维纹理</li><li>treeOcclusion  通过树的参数计算得到</li><li>grassOcclusion 来自二维纹理</li></ol><h2 id="Occlusion遮挡信息的使用"><a href="#Occlusion遮挡信息的使用" class="headerlink" title="Occlusion遮挡信息的使用"></a>Occlusion遮挡信息的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//BuildinData中获取环境烘焙信息是使用了上面的采样结果。</span><br>SampleBakedGI函数出现了区别<br><span class="hljs-comment">// 所有的基础烘焙信息：</span><br><span class="hljs-comment">// LightMap：fully baked lightmap (static lightmap) + enlighten realtime lightmap (dynamic lightmap) 可以组合使用</span><br><span class="hljs-comment">// for each case we can have directional lightmap or not.</span><br><span class="hljs-comment">// lightprobe for dynamic/moving entity：</span><br><span class="hljs-comment">//探针类型：Either SH9 per object lightprobe or SH4 per pixel per object volume probe</span><br>float3 <span class="hljs-title function_">SampleBakedGI</span><span class="hljs-params">(float3 positionRWS, float3 normalWS, float2 uvStaticLightmap, float2 uvDynamicLightmap)</span><br>&#123;<br><span class="hljs-comment">// If there is no lightmap, it assume lightprobe</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)</span><br><br>    <span class="hljs-keyword">if</span> (unity_ProbeVolumeParams.x == <span class="hljs-number">0.0</span>)<br>    &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> pass a tab of coefficient instead!</span><br>        real4 SHCoefficients[<span class="hljs-number">7</span>];<br>        SHCoefficients[<span class="hljs-number">0</span>] = unity_SHAr;<br>        SHCoefficients[<span class="hljs-number">1</span>] = unity_SHAg;<br>        SHCoefficients[<span class="hljs-number">2</span>] = unity_SHAb;<br>        SHCoefficients[<span class="hljs-number">3</span>] = unity_SHBr;<br>        SHCoefficients[<span class="hljs-number">4</span>] = unity_SHBg;<br>        SHCoefficients[<span class="hljs-number">5</span>] = unity_SHBb;<br>        SHCoefficients[<span class="hljs-number">6</span>] = unity_SHC;<br><br>        <span class="hljs-keyword">return</span> SampleSH9(SHCoefficients, normalWS);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> SampleProbeVolumeSH4(TEXTURE3D_PARAM(unity_ProbeVolumeSH, samplerunity_ProbeVolumeSH), positionRWS, normalWS, GetProbeVolumeWorldToObject(),<br>        unity_ProbeVolumeParams.y, unity_ProbeVolumeParams.z, unity_ProbeVolumeMin.xyz, unity_ProbeVolumeSizeInv.xyz);<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-comment">//定义了光照贴图，进行贴图内容的读取</span><br>    float3 bakeDiffuseLighting = float3(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UNITY_LIGHTMAP_FULL_HDR</span><br>    <span class="hljs-type">bool</span> useRGBMLightmap = <span class="hljs-literal">false</span>;<br>    float4 decodeInstructions = float4(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); <span class="hljs-comment">// Never used but needed for the interface since it supports gamma lightmaps</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">bool</span> useRGBMLightmap = <span class="hljs-literal">true</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(UNITY_LIGHTMAP_RGBM_ENCODING)</span><br>        float4 decodeInstructions = float4(<span class="hljs-number">34.493242</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); <span class="hljs-comment">// range^2.2 = 5^2.2, gamma = 2.2</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        float4 decodeInstructions = float4(<span class="hljs-number">2.0</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); <span class="hljs-comment">// range = 2.0^2.2 = 4.59</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">// 每一种Light都可以分成方向烘焙和单一烘焙两种</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LIGHTMAP_ON</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DIRLIGHTMAP_COMBINED</span><br>        bakeDiffuseLighting += SampleDirectionalLightmap(TEXTURE2D_PARAM(unity_Lightmap, samplerunity_Lightmap),<br>                                                        TEXTURE2D_PARAM(unity_LightmapInd, samplerunity_Lightmap),<br>                                                        uvStaticLightmap, unity_LightmapST, normalWS, useRGBMLightmap, decodeInstructions);<br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        bakeDiffuseLighting += SampleSingleLightmap(TEXTURE2D_PARAM(unity_Lightmap, samplerunity_Lightmap), uvStaticLightmap, unity_LightmapST, useRGBMLightmap, decodeInstructions);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DYNAMICLIGHTMAP_ON</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DIRLIGHTMAP_COMBINED</span><br>        bakeDiffuseLighting += SampleDirectionalLightmap(TEXTURE2D_PARAM(unity_DynamicLightmap, samplerunity_DynamicLightmap),<br>                                                        TEXTURE2D_PARAM(unity_DynamicDirectionality, samplerunity_DynamicLightmap),<br>                                                        uvDynamicLightmap, unity_DynamicLightmapST, normalWS, <span class="hljs-literal">false</span>, decodeInstructions);<br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        bakeDiffuseLighting += SampleSingleLightmap(TEXTURE2D_PARAM(unity_DynamicLightmap, samplerunity_DynamicLightmap), uvDynamicLightmap, unity_DynamicLightmapST, <span class="hljs-literal">false</span>, decodeInstructions);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-comment">// 俩个lightmap是相加的关系</span><br>    <span class="hljs-keyword">return</span> bakeDiffuseLighting;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><br><span class="hljs-comment">// 修改后的烘焙信息获取。</span><br>float3 <span class="hljs-title function_">SampleBakedGI</span><span class="hljs-params">(float3 positionRWS, float3 normalWS, float2 uvStaticLightmap, float2 uvDynamicLightmap, <span class="hljs-type">float</span> skyOcclusion, <span class="hljs-type">float</span> grassOcclusion, <span class="hljs-type">float</span> treeOcclusion)</span><br><span class="hljs-comment">//forest-end</span><br>&#123;<br>    <span class="hljs-comment">// If there is no lightmap, it assume lightprobe</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)</span><br>    <span class="hljs-keyword">if</span> (unity_ProbeVolumeParams.x == <span class="hljs-number">0.0</span>)<br>    &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> pass a tab of coefficient instead!</span><br>        real4 SHCoefficients[<span class="hljs-number">7</span>];<br>        SHCoefficients[<span class="hljs-number">0</span>] = unity_SHAr;<br>        SHCoefficients[<span class="hljs-number">1</span>] = unity_SHAg;<br>        SHCoefficients[<span class="hljs-number">2</span>] = unity_SHAb;<br>        SHCoefficients[<span class="hljs-number">3</span>] = unity_SHBr;<br>        SHCoefficients[<span class="hljs-number">4</span>] = unity_SHBg;<br>        SHCoefficients[<span class="hljs-number">5</span>] = unity_SHBb;<br>        SHCoefficients[<span class="hljs-number">6</span>] = unity_SHC;<br><br>      <span class="hljs-comment">// 这个累加计算了一个环境光的探针。</span><br><span class="hljs-comment">//forest-begin: sky occlusion</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> SKY_OCCLUSION</span><br>SHCoefficients[<span class="hljs-number">0</span>] += _AmbientProbeSH[<span class="hljs-number">0</span>] * skyOcclusion;<br>SHCoefficients[<span class="hljs-number">1</span>] += _AmbientProbeSH[<span class="hljs-number">1</span>] * skyOcclusion;<br>SHCoefficients[<span class="hljs-number">2</span>] += _AmbientProbeSH[<span class="hljs-number">2</span>] * skyOcclusion;<br>SHCoefficients[<span class="hljs-number">3</span>] += _AmbientProbeSH[<span class="hljs-number">3</span>] * skyOcclusion;<br>SHCoefficients[<span class="hljs-number">4</span>] += _AmbientProbeSH[<span class="hljs-number">4</span>] * skyOcclusion;<br>SHCoefficients[<span class="hljs-number">5</span>] += _AmbientProbeSH[<span class="hljs-number">5</span>] * skyOcclusion;<br>SHCoefficients[<span class="hljs-number">6</span>] += _AmbientProbeSH[<span class="hljs-number">6</span>] * skyOcclusion;<br>       <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">//forest-end</span><br><br><span class="hljs-comment">// 同时还积累的树的环境光遮挡</span><br><span class="hljs-comment">//forest-begin: Tree occlusion</span><br>        <span class="hljs-keyword">return</span> SampleSH9(SHCoefficients, normalWS) * treeOcclusion;<br><span class="hljs-comment">//forest-end</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-comment">//这里只是多了一个树木的遮挡</span><br>        <span class="hljs-keyword">return</span> SampleProbeVolumeSH4(TEXTURE3D_PARAM(unity_ProbeVolumeSH, samplerunity_ProbeVolumeSH), positionRWS, normalWS, GetProbeVolumeWorldToObject(),<br><span class="hljs-comment">//forest-begin: Tree occlusion</span><br>            unity_ProbeVolumeParams.y, unity_ProbeVolumeParams.z, unity_ProbeVolumeMin, unity_ProbeVolumeSizeInv) * treeOcclusion;<br><span class="hljs-comment">//forest-end</span><br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br>    float3 bakeDiffuseLighting = float3(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UNITY_LIGHTMAP_FULL_HDR</span><br>    <span class="hljs-type">bool</span> useRGBMLightmap = <span class="hljs-literal">false</span>;<br>    float4 decodeInstructions = float4(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); <span class="hljs-comment">// Never used but needed for the interface since it supports gamma lightmaps</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">bool</span> useRGBMLightmap = <span class="hljs-literal">true</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(UNITY_LIGHTMAP_RGBM_ENCODING)</span><br>        float4 decodeInstructions = float4(<span class="hljs-number">34.493242</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); <span class="hljs-comment">// range^2.2 = 5^2.2, gamma = 2.2</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        float4 decodeInstructions = float4(<span class="hljs-number">2.0</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); <span class="hljs-comment">// range = 2.0^2.2 = 4.59</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LIGHTMAP_ON</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DIRLIGHTMAP_COMBINED</span><br>        bakeDiffuseLighting += SampleDirectionalLightmap(TEXTURE2D_PARAM(unity_Lightmap, samplerunity_Lightmap),<br>                                                        TEXTURE2D_PARAM(unity_LightmapInd, samplerunity_Lightmap),<br>                                                        uvStaticLightmap, unity_LightmapST, normalWS, useRGBMLightmap, decodeInstructions);<br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        bakeDiffuseLighting += SampleSingleLightmap(TEXTURE2D_PARAM(unity_Lightmap, samplerunity_Lightmap), uvStaticLightmap, unity_LightmapST, useRGBMLightmap, decodeInstructions);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DYNAMICLIGHTMAP_ON</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DIRLIGHTMAP_COMBINED</span><br>        bakeDiffuseLighting += SampleDirectionalLightmap(TEXTURE2D_PARAM(unity_DynamicLightmap, samplerunity_DynamicLightmap),<br>                                                        TEXTURE2D_PARAM(unity_DynamicDirectionality, samplerunity_DynamicLightmap),<br>                                                        uvDynamicLightmap, unity_DynamicLightmapST, normalWS, <span class="hljs-literal">false</span>, decodeInstructions);<br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        bakeDiffuseLighting += SampleSingleLightmap(TEXTURE2D_PARAM(unity_DynamicLightmap, samplerunity_DynamicLightmap), uvDynamicLightmap, unity_DynamicLightmapST, <span class="hljs-literal">false</span>, decodeInstructions);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-comment">// 这里只是多积累了一个草的环境光遮挡，也就是说LightProbe是给动态物体使用的</span><br><span class="hljs-comment">//forest-begin: sky occlusion</span><br>    <span class="hljs-keyword">return</span> bakeDiffuseLighting * grassOcclusion;<br><span class="hljs-comment">//forest-end</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>从上面的代码中我发现skyOcclusion只在lightprobe计算的时候生效，也就是他是给动态物体使用的!!!!</strong></p><p>现在三个Occlusion的作用就清楚了</p><ol><li>grassOcclusion 用于乘到每一个烘焙信息上</li><li>treeOcclusion 用于乘到每一个光照探针结果上</li><li>skyOcclusion  用于乘到动态光照探针SH9上</li></ol><h2 id="Shader部分总结"><a href="#Shader部分总结" class="headerlink" title="Shader部分总结"></a>Shader部分总结</h2><p>上面的内容只是Book of Death的使用方式，而我们可以自己修改应用位置，计算方法。</p><p>下面需要讨论这些Occlusion的参数是如何传递到Shader当中的。</p><h1 id="Occlusion-Prob-Script部分"><a href="#Occlusion-Prob-Script部分" class="headerlink" title="Occlusion Prob Script部分"></a>Occlusion Prob Script部分</h1><p>上面介绍了如何在Shader当中使用prob三维纹理内容，现在看一下脚本当中如何生成这些。</p><p>在BofD当中主要的脚本就是OcclusionProbes以及他对应的Editor代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">首先最终要的内容就是传递到unity当中参数。<br>    static class Uniforms<br>    &#123;<br>        internal static readonly int _AmbientProbeSH = Shader.PropertyToID(&quot;_AmbientProbeSH&quot;);<br>        internal static readonly int _OcclusionProbes = Shader.PropertyToID(&quot;_OcclusionProbes&quot;);<br>        internal static readonly int _OcclusionProbesWorldToLocal = Shader.PropertyToID(&quot;_OcclusionProbesWorldToLocal&quot;);<br>        internal static readonly int _OcclusionProbesDetail = Shader.PropertyToID(&quot;_OcclusionProbesDetail&quot;);<br>        internal static readonly int _OcclusionProbesWorldToLocalDetail = Shader.PropertyToID(&quot;_OcclusionProbesWorldToLocalDetail&quot;);<br>        internal static readonly int _OcclusionProbesReflectionOcclusionAmount = Shader.PropertyToID(&quot;_OcclusionProbesReflectionOcclusionAmount&quot;);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>这些数据是通过Progressive烘焙lightmapping引擎烘焙出来的内容，相当于使用了引擎的特性。</strong></p><p><strong>要使用引擎的特性需要自己写一部分回调函数。BofD的代码在OcclusionProbes.Editor.cs文件中。</strong></p><h2 id="OcclusionProbes生成设置"><a href="#OcclusionProbes生成设置" class="headerlink" title="OcclusionProbes生成设置"></a>OcclusionProbes生成设置</h2><p>主要有两部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">Lightmapping.started += Started;<br>Lightmapping.completed += Completed;<br></code></pre></td></tr></table></figure><h3 id="Started"><a href="#Started" class="headerlink" title="Started"></a>Started</h3><p>在光照贴图开始烘焙之前调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Started</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 计算探针的数量：这里使用的是体素形式，我们也可以定义自己的形状。</span><br>    <span class="hljs-type">int</span> probeCount = m_XCount * m_YCount * m_ZCount;<br>    <span class="hljs-keyword">if</span> (probeCount == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 细节Probe数量统计</span><br>    <span class="hljs-type">int</span> detailSetCount = <span class="hljs-number">0</span>;<br>    foreach(OcclusionProbesDetail detail in m_OcclusionProbesDetail)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (detail == null || !detail.gameObject.activeSelf)<br>        <span class="hljs-keyword">continue</span>;<br><br>      probeCount += detail.m_XCount * detail.m_YCount * detail.m_ZCount;<br>      detailSetCount++;<br>    &#125;<br><br>  <span class="hljs-comment">// 声明主探针位置数组,坐标矩阵等等</span><br>    Vector4[] positions = new Vector4[probeCount];<br><br>        <span class="hljs-comment">// Main</span><br>        Vector3 size = transform.localScale;<br>        Matrix4x4 localToWorld = Matrix4x4.TRS(transform.position - size * <span class="hljs-number">0.5f</span>, transform.rotation, size);<br>        m_WorldToLocal = localToWorld.inverse;<br>        m_CountBaked = new Vector3i(m_XCount, m_YCount, m_ZCount);<br><br>        <span class="hljs-type">int</span> indexOffset = <span class="hljs-number">0</span>;<br>        GenerateProbePositions(ref positions, ref indexOffset, m_CountBaked, localToWorld, CalculateRayOffset(m_RayOffset, size, m_CountBaked));<br><br>        <span class="hljs-comment">// Detail</span><br>        m_CountBakedDetail = new Vector3i[detailSetCount];<br>        m_WorldToLocalDetail = new Matrix4x4[detailSetCount];<br><br>  <span class="hljs-comment">// 声明细节探针的位置，矩阵转化，大小等等</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        foreach(OcclusionProbesDetail detail in m_OcclusionProbesDetail)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (detail == null || !detail.gameObject.activeSelf)<br>                <span class="hljs-keyword">continue</span>;<br>            <br>            Transform t = detail.transform;<br>            Vector3 sizeDetail = t.localScale;<br>            Matrix4x4 localToWorldDetail = Matrix4x4.TRS(t.position - sizeDetail * <span class="hljs-number">0.5f</span>, t.rotation, sizeDetail);<br>            m_WorldToLocalDetail[i] = localToWorldDetail.inverse;<br>            m_CountBakedDetail[i] = new Vector3i(detail.m_XCount, detail.m_YCount, detail.m_ZCount);<br>            GenerateProbePositions(ref positions, ref indexOffset, m_CountBakedDetail[i], localToWorldDetail, CalculateRayOffset(detail.m_RayOffset, sizeDetail, m_CountBakedDetail[i]));<br>            i++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> sampleCount = <span class="hljs-number">1024</span>;<br><br>  <br>  <span class="hljs-comment">//这两句话才是核心内容，传入顶点数量和顶点位置，上面的内容实际上都是逻辑层的东西。</span><br>  UnityEditor.Experimental.Lightmapping.SetCustomBakeInputs(positions, sampleCount);<br>        m_SampleCountBaked = sampleCount;<br><br>        UnityEditor.Experimental.Lightmapping.probesIgnoreDirectEnvironment = <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="Completed"><a href="#Completed" class="headerlink" title="Completed"></a>Completed</h3><p>光照烘焙计算之后保存数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-type">void</span> <span class="hljs-title function_">Completed</span><span class="hljs-params">()</span><br>  &#123;<br><span class="hljs-comment">// 从烘焙管线当中提取所有的探针生成三维纹理。</span><br>    <span class="hljs-comment">// 同样也可以生成别的list之类的结构</span><br>    <span class="hljs-comment">// ...</span><br><br>      <span class="hljs-comment">// Ambient probe</span><br>      <span class="hljs-comment">// 这个只是一个SH9 用于记录全局的光线                              </span><br>      BakeAmbientProbe();<br><span class="hljs-comment">// 把所有资源保存</span><br>      AssetDatabase.SaveAssets();<br><br>      m_CountBaked = new Vector3i(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><p>经过上面两步的计算所有的内容都会保存在和Lightmap相同的目录当中，需要自己通过代码设置到Shader当中来使用。</p><p>剩下的工作就是把这些点传递到Shader当中就可以了，主要代码在OcclusionProbes当中。</p><p>注：在BofD当中OcclusionProbes主要用来削减BakeAmbientProbe，然后削减的值叠加到原始的光照探针上。</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>1.在场景中新建一个Occlusion Probes，设置大小，体素纹理分辨率，细节纹理个数及其分辨率。</p><p>2.将烘焙方式设置为<strong>手动</strong>，烘焙引擎设置为Progressive。</p><p>3.点击烘焙，就会生成资源了。</p><p>4.通过Occlusion Probes脚本，设置全局的Shader参数。</p><p>5.在所有Shader当中就可以读取多个三维纹理，根据矩阵等位置的计算，就可以提去出各个点的环境光明暗情况。</p>]]></content>
      
      
      <categories>
          
          <category> HDRPSource </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HDRP当中设置矩阵的代码</title>
      <link href="/2022/07/09/HDRPsource/HDRPShader%E5%86%85%E7%BD%AE%E7%9F%A9%E9%98%B5%E5%A4%87%E6%9F%A5/"/>
      <url>/2022/07/09/HDRPsource/HDRPShader%E5%86%85%E7%BD%AE%E7%9F%A9%E9%98%B5%E5%A4%87%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="HDRP当中设置矩阵的代码："><a href="#HDRP当中设置矩阵的代码：" class="headerlink" title="HDRP当中设置矩阵的代码："></a>HDRP当中设置矩阵的代码：</h1><p>HDCamera.cs</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123;<br>    <span class="hljs-type">bool</span> taaEnabled = m_frameSettings.IsEnabled(FrameSettingsField.Postprocess)<br>        &amp;&amp; antialiasing == AntialiasingMode.TemporalAntialiasing<br>        &amp;&amp; camera.cameraType == CameraType.Game;<br><br>    cmd.SetGlobalMatrix(HDShaderIDs._ViewMatrix,                viewMatrix);<br>    cmd.SetGlobalMatrix(HDShaderIDs._InvViewMatrix,             viewMatrix.inverse);<br>    cmd.SetGlobalMatrix(HDShaderIDs._ProjMatrix,                projMatrix);<br>    cmd.SetGlobalMatrix(HDShaderIDs._InvProjMatrix,             projMatrix.inverse);<br>    cmd.SetGlobalMatrix(HDShaderIDs._ViewProjMatrix,            viewProjMatrix);<br>    cmd.SetGlobalMatrix(HDShaderIDs._InvViewProjMatrix,         viewProjMatrix.inverse);<br>    cmd.SetGlobalMatrix(HDShaderIDs._NonJitteredViewProjMatrix, nonJitteredViewProjMatrix);<br>    cmd.SetGlobalMatrix(HDShaderIDs._PrevViewProjMatrix,        prevViewProjMatrix);<br>    cmd.SetGlobalMatrix(HDShaderIDs._CameraViewProjMatrix,      viewProjMatrix);<br>    cmd.SetGlobalVector(HDShaderIDs._WorldSpaceCameraPos,       worldSpaceCameraPos);<br>    cmd.SetGlobalVector(HDShaderIDs._PrevCamPosRWS,             prevWorldSpaceCameraPos);<br>    cmd.SetGlobalVector(HDShaderIDs._ScreenSize,                screenSize);<br>    cmd.SetGlobalVector(HDShaderIDs._ScreenToTargetScale,       doubleBufferedViewportScale);<br>    cmd.SetGlobalVector(HDShaderIDs._ScreenToTargetScaleHistory, doubleBufferedViewportScaleHistory);<br>    cmd.SetGlobalVector(HDShaderIDs._ZBufferParams,             zBufferParams);<br>    cmd.SetGlobalVector(HDShaderIDs._ProjectionParams,          projectionParams);<br>    cmd.SetGlobalVector(HDShaderIDs.unity_OrthoParams,          unity_OrthoParams);<br>    cmd.SetGlobalVector(HDShaderIDs._ScreenParams,              screenParams);<br>    cmd.SetGlobalVector(HDShaderIDs._TaaFrameInfo,              new Vector4(taaFrameRotation.x, taaFrameRotation.y, taaFrameIndex, taaEnabled ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>));<br>    cmd.SetGlobalVector(HDShaderIDs._TaaJitterStrength,         taaJitter);<br>    cmd.SetGlobalVectorArray(HDShaderIDs._FrustumPlanes,        frustumPlaneEquations);<br></code></pre></td></tr></table></figure><p>矩阵在Shader当中的代码:</p><p>ShaderVariables.hlsl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// Define that before including all the sub systems ShaderVariablesXXX.hlsl files in order to include constant buffer properties.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHADER_VARIABLES_INCLUDE_CB</span><br><br><span class="hljs-comment">// Important: please use macros or functions to access the CBuffer data.</span><br><span class="hljs-comment">// The member names and data layout can (and will) change!</span><br>CBUFFER_START(UnityGlobal)<br>    <span class="hljs-comment">// ================================</span><br>    <span class="hljs-comment">//     PER VIEW CONSTANTS</span><br>    <span class="hljs-comment">// ================================</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> all affine matrices should be 3x4.</span><br>    float4x4 _ViewMatrix;<br>float4x4 _InvViewMatrix;<br>float4x4 _ProjMatrix;<br>float4x4 _InvProjMatrix;<br>float4x4 _ViewProjMatrix;<br>float4x4 _CameraViewProjMatrix;<br>float4x4 _InvViewProjMatrix;<br>float4x4 _NonJitteredViewProjMatrix;<br>float4x4 _PrevViewProjMatrix;       <span class="hljs-comment">// non-jittered</span><br><br>float4 _TextureWidthScaling; <span class="hljs-comment">// 0.5 for SinglePassDoubleWide (stereo) and 1.0 otherwise</span><br><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> put commonly used vars together (below), and then sort them by the frequency of use (descending).</span><br><span class="hljs-comment">// Note: a matrix is 4 * 4 * 4 = 64 bytes (1x cache line), so no need to sort those.</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> USING_STEREO_MATRICES</span><br>float3 _WorldSpaceCameraPos;<br><span class="hljs-type">float</span>  _Pad0;<br>float3 _PrevCamPosRWS;<br><span class="hljs-type">float</span>  _Pad1;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>float4 _ScreenSize;                 <span class="hljs-comment">// &#123; w, h, 1 / w, 1 / h &#125;</span><br><br><span class="hljs-comment">// Those two uniforms are specific to the RTHandle system</span><br>float4 _ScreenToTargetScale;        <span class="hljs-comment">// &#123; w / RTHandle.maxWidth, h / RTHandle.maxHeight &#125; : xy = currFrame, zw = prevFrame</span><br>float4 _ScreenToTargetScaleHistory; <span class="hljs-comment">// Same as above but the RTHandle handle size is that of the history buffer</span><br><br></code></pre></td></tr></table></figure><p>上面矩阵的宏定义:</p><p>ShaderVariablesMatrixDefsHDCamera.hlsl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UNITY_SHADER_VARIABLES_MATRIX_DEFS_LEGACY_UNITY_INCLUDED</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">error</span> Mixing HDCamera and legacy Unity matrix definitions</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> UNITY_SHADER_VARIABLES_MATRIX_DEFS_HDCAMERA_INCLUDED</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_SHADER_VARIABLES_MATRIX_DEFS_HDCAMERA_INCLUDED</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(USING_STEREO_MATRICES)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_V     _ViewMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_V   _InvViewMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_P     OptimizeProjectionMatrix(_ProjMatrixStereo[unity_StereoEyeIndex])</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_P   _InvProjMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_VP    _ViewProjMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_VP  _InvViewProjMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_UNJITTERED_VP _ViewProjMatrixStereo[unity_StereoEyeIndex] <span class="hljs-comment">// Since VR doesn&#x27;t need to add jitter, just use normal VP matrix</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_PREV_VP _PrevViewProjMatrixStereo[unity_StereoEyeIndex]</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_V     _ViewMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_V   _InvViewMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_P     OptimizeProjectionMatrix(_ProjMatrix)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_P   _InvProjMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_VP    _ViewProjMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_VP  _InvViewProjMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_UNJITTERED_VP _NonJitteredViewProjMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_PREV_VP _PrevViewProjMatrix</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// USING_STEREO_MATRICES</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// UNITY_SHADER_VARIABLES_MATRIX_DEFS_HDCAMERA_INCLUDED</span></span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HDRPSource </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shader开发说明</title>
      <link href="/2022/07/09/HDRPsource/new2.HDRPShader%E5%BC%80%E5%8F%91%E8%AF%B4%E6%98%8E/"/>
      <url>/2022/07/09/HDRPsource/new2.HDRPShader%E5%BC%80%E5%8F%91%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="Shader开发说明"><a href="#Shader开发说明" class="headerlink" title="Shader开发说明"></a>Shader开发说明</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p><strong>CoreRPLibrary&#x2F;ShaderLibrary:</strong></p><p>保存了大量的工具函数：光照计算工具函数，随机数计算，矩阵工具，坐标转换工具，风场，ParallaxOcclusionMapping等。</p><p><strong>CoreRPLibrary&#x2F;ShaderLibrary&#x2F;API:</strong></p><p>保存了跨平台函数的定义。</p><p><strong>HDRP&#x2F;Runtime&#x2F;Material:</strong></p><p>保存了HDRP中默认支持的材质Shader：Lit，LayeredLit，Stacklit等，都是和各自材质相关的计算。不同的材质中包含了不同的BSDF函数的实现、不同的BuiltinData的组织方式。</p><p><strong>HDRP&#x2F;Runtime&#x2F;PostProcessing&#x2F;Shaders:</strong></p><p>后处理的Shader，HDRP中后处理全部使用ComputeShader。</p><p><strong>HDRP&#x2F;Runtime&#x2F;RenderPipeline&#x2F;ShaderPass:</strong></p><p>ShaderPass的定义：包括了Vertex和Fragment程序的定义。</p><p><strong>HDRP&#x2F;Runtime&#x2F;RenderPipeline&#x2F;ShaderLibrary:</strong></p><p>从C#当中设置的Shader参数，包括：各种变换矩阵、获取矩阵的函数、摄像机参数、场景参数、全部buffer、全局纹理、shader控制参数等。</p><h3 id="Shader-Pass"><a href="#Shader-Pass" class="headerlink" title="Shader Pass"></a>Shader Pass</h3><p>RenderPiple的代码中，在不同的时机会渲染不同的ShaderPass（通过lightmode区分）。<strong>如果要看更详细的Pass绘制时机，以及Pass之间如何组合成正确的Shader，需要看Pipeline的代码，如果随意组合会得到无法预知的结果</strong>，主要的Pass如下：</p><h4 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h4><p>前向渲染物体使用这个Pass，正常情况下使用Deferred。透明物体可以使用Forward Pass， StackLit也是Forward Pass。</p><h4 id="ForwardOnly"><a href="#ForwardOnly" class="headerlink" title="ForwardOnly"></a>ForwardOnly</h4><p>ForwardOnly的用处是：渲染透明物体或<strong>在Deferred模式下强制使用Forward模式渲染不透明物体</strong>。 例如：StackLit就是使用了{ForwardOnly和DepthForwardOnly}组合的Shader。</p><h4 id="DepthForwardOnly"><a href="#DepthForwardOnly" class="headerlink" title="DepthForwardOnly"></a>DepthForwardOnly</h4><p>和ForwardOnly对应使用。</p><h4 id="DepthOnly"><a href="#DepthOnly" class="headerlink" title="DepthOnly"></a>DepthOnly</h4><p>渲染深度，Forward和Deferred必须有一个深度，使用这个Pass。</p><h4 id="TransparentDepthPrepass"><a href="#TransparentDepthPrepass" class="headerlink" title="TransparentDepthPrepass"></a>TransparentDepthPrepass</h4><p>透明物体Prepass深度</p><h4 id="TransparentDepthPostpass"><a href="#TransparentDepthPostpass" class="headerlink" title="TransparentDepthPostpass"></a>TransparentDepthPostpass</h4><p>透明物体Postpass深度</p><p><strong>注意：</strong>上面所有的Pass需要正确的组合在一个Shader当中，不然会出错。例如：自己写的Shader中可以包括：{ForwardOnly，DepthForwardOnly}。 如果出现：{ForwardOnly，DepthOnly}就会出现不可预知的结果。</p><h4 id="ShadowCaster"><a href="#ShadowCaster" class="headerlink" title="ShadowCaster"></a>ShadowCaster</h4><p>用于渲染阴影的Pass，和老版本不同的是：HDRP的阴影和深度使用了两个不同的Pass。</p><h4 id="DistortionVectors"><a href="#DistortionVectors" class="headerlink" title="DistortionVectors"></a>DistortionVectors</h4><p>扭曲向量</p><h4 id="DistortionVectors-1"><a href="#DistortionVectors-1" class="headerlink" title="DistortionVectors"></a>DistortionVectors</h4><p>屏幕运动向量</p><h3 id="Shader编写"><a href="#Shader编写" class="headerlink" title="Shader编写"></a>Shader编写</h3><h4 id="定义LightMode和ShaderPass"><a href="#定义LightMode和ShaderPass" class="headerlink" title="定义LightMode和ShaderPass"></a>定义LightMode和ShaderPass</h4><p>如果要实现自己的Shader，第一步需要正确的定义ShaderPass：</p><p>不透明物体:主要需要基本的光照渲染Forward或者Deferred、阴影ShadowCaster，深度DepthOnly：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;HDRP&quot;</span><br>&#123;<br><br>    SubShader<br>    &#123;<br>        Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;Forward&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;Forward&quot;</span> &#125;<br>        &#125;<br>         Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;Deferred&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;Deferred&quot;</span> &#125;<br>        &#125;<br>        Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;DepthOnly&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;DepthOnly&quot;</span> &#125;<br>        &#125;<br>        Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;ShadowCaster&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;ShadowCaster&quot;</span> &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不透明物体也可以是（类似StackLit方式）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;HDRP&quot;</span><br>&#123;<br>    SubShader<br>    &#123;<br>        Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;ForwardOnly&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;ForwardOnly&quot;</span> &#125;<br>        &#125;<br>        Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;DepthForwardOnly&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;DepthForwardOnly&quot;</span> &#125;<br>            HLSLPROGRAM<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex Vert</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment Frag</span><br>            ENDHLSL<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>透明物体,需要基本的光照Pass（也可以不计算光照）ForwardOnly或者Forward，深度TransparentDepthPrepass、TransparentDepthPostpass</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;HDRP&quot;</span><br>&#123;<br><br>    SubShader<br>    &#123;<br>        Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;ForwardOnly&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;Forward&quot;</span> &#125;<br>            HLSLPROGRAM<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex Vert</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment Frag</span><br>            ENDHLSL<br>        &#125;<br>        Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;TransparentDepthPrepass&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;TransparentDepthPrepass&quot;</span> &#125;<br>        &#125;<br>        Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;TransparentDepthPostpass&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;TransparentDepthPostpass&quot;</span> &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以根据自己的需求组合不同的Pass达到不同的效果。例如：一个物体如果不想要阴影，可以直接去掉ShadowCaster Pass，这样对深度没有任何影响。<strong>还有一个重要的问题就是：所有ShaderGraph或者HDRP内置的Shader都包括了ShadowCaster Pass和Depth Pass。所以，需要之后应该需要我们根据需求手动去除这个Pass。</strong></p><h4 id="设置Queue"><a href="#设置Queue" class="headerlink" title="设置Queue"></a>设置Queue</h4><p>控制渲染时机的除了LightMode之外，另一个是Queue。</p><p>HDRP的Queue和原本不同，现在只能定义到SubShader级别.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Shader &quot;&quot;<br>&#123;<br>     SubShader<br>     &#123;<br>        Tags &#123; &quot;Queue&quot; = &quot;Transparent&quot; &#125;<br>        Pass<br>        &#123;<br>            // rest of the shader body...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>HDRP使用了Priority定义Queue，具体参考HDMaterialTags.cs文件。</p><p>完成了Queue和LightMode的设置就算是完成一个完整的Shader设置。</p><h4 id="Material参数"><a href="#Material参数" class="headerlink" title="Material参数"></a>Material参数</h4><p>HDRP的自定义参数设置和原始版本的使用方式是一样的。</p><p>不同的是内置参数。HDRP的内置参数全部通过可查看的C#代码设置。需要包括以下两个文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl&quot;</span></span><br><br></code></pre></td></tr></table></figure><p>这两个文件包括了：版本相关的变量关键字、摄像机矩阵、场景参数、摄像机参数等内容。矩阵类型和原本也有所差异。</p><h4 id="灯光设置"><a href="#灯光设置" class="headerlink" title="灯光设置"></a>灯光设置</h4><p>HDRP和原始版本最大的区别就是灯光计算，HDPR在一个Pass当中会计算完所有的灯光（包括区域光、环境光、雾、LightMap、LightProbe）。需要从LightList当中读取各种信息。</p><p>下面是读取灯光信息的基本形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CustomLighting.hlsl&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">LightLoop</span><span class="hljs-params">(...)</span><br>&#123;<br><br>    <span class="hljs-type">float</span> NdotV = dot(bsdfData.normalWS, V);<br>    LightLoopContext context;<br>    context.shadowContext    = InitShadowContext();<br>    <span class="hljs-comment">// 计算基于屏幕的细节阴影</span><br>    context.contactShadow    = InitContactShadow(posInput);<br>    context.shadowValue      = <span class="hljs-number">1</span>;<br>    context.sampleReflection = <span class="hljs-number">0</span>;<br><br>    uint lightCount, lightStart;<br><br>    <span class="hljs-comment">// ===================  读取点光、聚光灯  ===================== </span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    struct LightData</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        float3 positionRWS;</span><br><span class="hljs-comment">        uint lightLayers;</span><br><span class="hljs-comment">        float lightDimmer;</span><br><span class="hljs-comment">        float volumetricLightDimmer;</span><br><span class="hljs-comment">        float angleScale;</span><br><span class="hljs-comment">        float angleOffset;</span><br><span class="hljs-comment">        float3 forward;</span><br><span class="hljs-comment">        int lightType;</span><br><span class="hljs-comment">        float3 right;</span><br><span class="hljs-comment">        float range;</span><br><span class="hljs-comment">        float3 up;</span><br><span class="hljs-comment">        float rangeAttenuationScale;</span><br><span class="hljs-comment">        float3 color;</span><br><span class="hljs-comment">        float rangeAttenuationBias;</span><br><span class="hljs-comment">        int cookieIndex;</span><br><span class="hljs-comment">        int tileCookie;</span><br><span class="hljs-comment">        int shadowIndex;</span><br><span class="hljs-comment">        int contactShadowMask;</span><br><span class="hljs-comment">        int rayTracedAreaShadowIndex;</span><br><span class="hljs-comment">        float shadowDimmer;</span><br><span class="hljs-comment">        float volumetricShadowDimmer;</span><br><span class="hljs-comment">        int nonLightMappedOnly;</span><br><span class="hljs-comment">        float minRoughness;</span><br><span class="hljs-comment">        float4 shadowMaskSelector;</span><br><span class="hljs-comment">        float2 size;</span><br><span class="hljs-comment">        float diffuseDimmer;</span><br><span class="hljs-comment">        float specularDimmer;</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    根据世界坐标位置和灯光类型，返回灯光索引的开始索引和数量.</span><br><span class="hljs-comment">    */</span><br>    GetCountAndStart(posInput, LIGHTCATEGORY_PUNCTUAL, lightStart, lightCount);<br>    uint i = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; lightCount; ++i)<br>    &#123;<br>        LightData lightData = FetchLight(lightStart, i);<br>        <span class="hljs-comment">// 计算光照</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ===================  读取直线光  =====================</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    _DirectionalLightCount：直线光个数</span><br><span class="hljs-comment">    _DirectionalLightDatas：所有直线光数组.</span><br><span class="hljs-comment">    直线光保存在CB当中，不参与FPTL,所以直接通过数组计算。</span><br><span class="hljs-comment">    _DirectionalLightDatas的数据结构：</span><br><span class="hljs-comment">    struct DirectionalLightData</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        float3 positionRWS;</span><br><span class="hljs-comment">        uint lightLayers;</span><br><span class="hljs-comment">        float lightDimmer;</span><br><span class="hljs-comment">        float volumetricLightDimmer;</span><br><span class="hljs-comment">        float angleScale;</span><br><span class="hljs-comment">        float angleOffset;</span><br><span class="hljs-comment">        float3 forward;</span><br><span class="hljs-comment">        int cookieIndex;</span><br><span class="hljs-comment">        float3 right;</span><br><span class="hljs-comment">        int tileCookie;</span><br><span class="hljs-comment">        float3 up;</span><br><span class="hljs-comment">        int shadowIndex;</span><br><span class="hljs-comment">        float3 color;</span><br><span class="hljs-comment">        int contactShadowMask;</span><br><span class="hljs-comment">        float shadowDimmer;</span><br><span class="hljs-comment">        float volumetricShadowDimmer;</span><br><span class="hljs-comment">        int nonLightMappedOnly;</span><br><span class="hljs-comment">        float minRoughness;</span><br><span class="hljs-comment">        float4 shadowMaskSelector;</span><br><span class="hljs-comment">        float diffuseDimmer;</span><br><span class="hljs-comment">        float specularDimmer;</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">    */</span><br>    uint i = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; _DirectionalLightCount; ++i)<br>    &#123;<br>        _DirectionalLightDatas[i];<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">// ====================== 读取区域光 =====================</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">   LightData定义同读取点光、聚光灯。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     在Lit当中Loop当中可以看到用了两个while，主要是为了GPU优化。</span><br><span class="hljs-comment">    */</span><br>    GetCountAndStart(posInput, LIGHTCATEGORY_AREA, lightStart, lightCount);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; lightCount; i++)<br>    &#123;<br>        LightData lightData = FetchLight(lightStart, i);<br>       <span class="hljs-comment">// 计算光照</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 读取环境光，主要处理反射和折射光的分量 =====================</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    这里有个重要的内容，就是反射和折射信息和光照计算不同，不是叠加，而是反射的上限应该是1。所以具体如何处理不同的反射和折射的关系需要参考Lit。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    struct EnvLightData</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        uint lightLayers;</span><br><span class="hljs-comment">        float3 capturePositionRWS;</span><br><span class="hljs-comment">        int influenceShapeType;</span><br><span class="hljs-comment">        float3 proxyExtents;</span><br><span class="hljs-comment">        float minProjectionDistance;</span><br><span class="hljs-comment">        float3 proxyPositionRWS;</span><br><span class="hljs-comment">        float3 proxyForward;</span><br><span class="hljs-comment">        float3 proxyUp;</span><br><span class="hljs-comment">        float3 proxyRight;</span><br><span class="hljs-comment">        float3 influencePositionRWS;</span><br><span class="hljs-comment">        float3 influenceForward;</span><br><span class="hljs-comment">        float3 influenceUp;</span><br><span class="hljs-comment">        float3 influenceRight;</span><br><span class="hljs-comment">        float3 influenceExtents;</span><br><span class="hljs-comment">        float unused00;</span><br><span class="hljs-comment">        float3 blendDistancePositive;</span><br><span class="hljs-comment">        float3 blendDistanceNegative;</span><br><span class="hljs-comment">        float3 blendNormalDistancePositive;</span><br><span class="hljs-comment">        float3 blendNormalDistanceNegative;</span><br><span class="hljs-comment">        float3 boxSideFadePositive;</span><br><span class="hljs-comment">        float3 boxSideFadeNegative;</span><br><span class="hljs-comment">        float weight;</span><br><span class="hljs-comment">        float multiplier;</span><br><span class="hljs-comment">        int envIndex;</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">//Lit当中首先定义了反射和折射的成分，初始化为0.</span><br>    <span class="hljs-type">float</span> reflectionHierarchyWeight = <span class="hljs-number">0.0</span>; <span class="hljs-comment">// Max: 1.0</span><br>    <span class="hljs-type">float</span> refractionHierarchyWeight = _EnableSSRefraction ? <span class="hljs-number">0.0</span> : <span class="hljs-number">1.0</span>; <span class="hljs-comment">// Max: 1.0</span><br>    <span class="hljs-comment">// 读取环境光照信息</span><br>    GetCountAndStart(posInput, LIGHTCATEGORY_ENV, envLightStart, envLightCount);<br>    <br>    <span class="hljs-comment">// 先计算屏幕空间反射：叠加reflectionHierarchyWeight。这部分信息不再Tile当中</span><br>    &#123;<br>        IndirectLighting indirect = EvaluateBSDF_ScreenSpaceReflection(posInput, preLightData, bsdfData,                                     reflectionHierarchyWeight);<br>        AccumulateIndirectLighting(indirect, aggregateLighting);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 计算屏幕折射。</span><br>    <span class="hljs-keyword">if</span> ((featureFlags &amp; LIGHTFEATUREFLAGS_SSREFRACTION) &amp;&amp; (_EnableSSRefraction &gt; <span class="hljs-number">0</span>))<br>    &#123;<br>        <span class="hljs-comment">// 折射信息</span><br>        envLightData = FetchEnvLight(envLightStart, <span class="hljs-number">0</span>);<br>    &#125;<br>        <br>    <span class="hljs-comment">// 反射和折射探针。</span><br>    <span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_ENV)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;envLightCount;i++)<br>        &#123;<br>            uint v_envLightIdx = FetchIndex(envLightStart, i);<br>            EnvLightData s_envLightData = FetchEnvLight(v_envLightIdx);    <br>   <span class="hljs-comment">// 处理环境光</span><br>        &#125;<br><br>        <span class="hljs-comment">// 使用天空纹理计算IBL</span><br>        <span class="hljs-keyword">if</span> ((featureFlags &amp; LIGHTFEATUREFLAGS_SKY) &amp;&amp; _EnvLightSkyEnabled)<br>        &#123;<br>            context.sampleReflection = SINGLE_PASS_CONTEXT_SAMPLE_SKY;<br>            EnvLightData envLightSky = InitSkyEnvLightData(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 处理envLightSky </span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h4><h5 id="需要通过Tile读取的灯光"><a href="#需要通过Tile读取的灯光" class="headerlink" title="需要通过Tile读取的灯光"></a>需要通过Tile读取的灯光</h5><p>#define LIGHTCATEGORY_PUNCTUAL (0)<br>#define LIGHTCATEGORY_AREA (1)<br>#define LIGHTCATEGORY_ENV (2)</p><h5 id="FetchLight"><a href="#FetchLight" class="headerlink" title="FetchLight"></a>FetchLight</h5><p>灯光就是直接从Buffer当中读取的，但是索引是要通过FPTL、Cluster、Big-Tile等方法读取的，下面是直接读取灯光信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">LightData <span class="hljs-title function_">FetchLight</span><span class="hljs-params">(uint start, uint i)</span><br>&#123;<br>    uint j = FetchIndex(start, i);<br><br>    <span class="hljs-keyword">return</span> _LightDatas[j];<br>&#125;<br><br>LightData <span class="hljs-title function_">FetchLight</span><span class="hljs-params">(uint index)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> _LightDatas[index];<br>&#125;<br><br>EnvLightData <span class="hljs-title function_">FetchEnvLight</span><span class="hljs-params">(uint start, uint i)</span><br>&#123;<br>    <span class="hljs-type">int</span> j = FetchIndex(start, i);<br><br>    <span class="hljs-keyword">return</span> _EnvLightDatas[j];<br>&#125;<br><br>EnvLightData <span class="hljs-title function_">FetchEnvLight</span><span class="hljs-params">(uint index)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> _EnvLightDatas[index];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="FetchIndex"><a href="#FetchIndex" class="headerlink" title="FetchIndex"></a>FetchIndex</h5><p>具体的索引如何读取，就要看是否使用FPTL、Cluster、Big-Tile或者不用光照优化策略：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_FPTL_LIGHTLIST    <span class="hljs-comment">// 使用FPTL</span></span><br>uint <span class="hljs-title function_">FetchIndex</span><span class="hljs-params">(uint tileOffset, uint lightOffset)</span><br>&#123;<br>    <span class="hljs-type">const</span> uint lightOffsetPlusOne = lightOffset + <span class="hljs-number">1</span>; <span class="hljs-comment">// Add +1 as first slot is reserved to store number of light</span><br>    <span class="hljs-comment">// Light index are store on 16bit</span><br>    <span class="hljs-keyword">return</span> (g_vLightListGlobal[DWORD_PER_TILE * tileOffset + (lightOffsetPlusOne &gt;&gt; <span class="hljs-number">1</span>)] &gt;&gt; ((lightOffsetPlusOne &amp; <span class="hljs-number">1</span>) * DWORD_PER_TILE)) &amp; <span class="hljs-number">0xffff</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(USE_CLUSTERED_LIGHTLIST) <span class="hljs-comment">// 使用Cluster  例如：对于透明物体就用Cluster</span></span><br><br>uint <span class="hljs-title function_">FetchIndex</span><span class="hljs-params">(uint lightStart, uint lightOffset)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> g_vLightListGlobal[lightStart + lightOffset];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(USE_BIG_TILE_LIGHTLIST) <span class="hljs-comment">// 使用BigTile</span></span><br><br>uint <span class="hljs-title function_">FetchIndex</span><span class="hljs-params">(uint lightStart, uint lightOffset)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> g_vBigTileLightList[lightStart + lightOffset];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span>             <span class="hljs-comment">// 没有</span></span><br><span class="hljs-comment">// Fallback case (mainly for raytracing right now)</span><br>uint <span class="hljs-title function_">FetchIndex</span><span class="hljs-params">(uint lightStart, uint lightOffset)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// USE_FPTL_LIGHTLIST</span></span><br></code></pre></td></tr></table></figure><h5 id="GetCountAndStart"><a href="#GetCountAndStart" class="headerlink" title="GetCountAndStart"></a>GetCountAndStart</h5><p>获取灯光列表的起始索引和数量，同上。具体查看LightLoopDef.hlsl源文件。</p>]]></content>
      
      
      <categories>
          
          <category> HDRPSource </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity HDRP主要功能和渲染管线的介绍</title>
      <link href="/2022/07/09/HDRPsource/new1.HDRP%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/09/HDRPsource/new1.HDRP%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity-HDRP主要功能和渲染管线的介绍"><a href="#Unity-HDRP主要功能和渲染管线的介绍" class="headerlink" title="Unity HDRP主要功能和渲染管线的介绍"></a>Unity HDRP主要功能和渲染管线的介绍</h1><h2 id="1-SRP和HDRP介绍"><a href="#1-SRP和HDRP介绍" class="headerlink" title="1. SRP和HDRP介绍"></a>1. SRP和HDRP介绍</h2><p>unity SRP可以让我们自己控制摄像机每一帧的渲染流程。他把渲染管线可以进行的操作都暴露给了用户，不再是一个封闭的引擎内置流程。</p><p>为了方便用户使用，Unity提供了两个已经实现好的SRP流程，分别针对不同的平台。</p><ul><li>Lightweight Render Pipeline (LWRP) ：支持手机平台和PC平台，目的是提供一个高性能的渲染，牺牲了引擎的表现效果。</li><li>High Definition Render Pipeline (HDRP) ：使用了基于物理的灯光技术以及基于Compute Shader的光照计算。针对高端的PC和主机平台。</li></ul><h2 id="2-HDRP渲染效果与材质类型"><a href="#2-HDRP渲染效果与材质类型" class="headerlink" title="2. HDRP渲染效果与材质类型"></a>2. HDRP渲染效果与材质类型</h2><p>Unity HDRP提供了更丰富的材质效果，包括：SSS效果、透光、Coat等。通过ShaderGraph和基础的LitShader都可以构建出支持这些效果的Shader。</p><p>在Lit Shader中可以通过Surface Options当中的Material Type来选择需要的材质效果。</p><p>Unity的说明文档:<a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@6.7/manual/Material-Type.html">材质类型官网介绍</a>。</p><p>下面简要介绍这些材质效果主要的功能。</p><h3 id="2-1-Standard"><a href="#2-1-Standard" class="headerlink" title="2.1 Standard"></a>2.1 Standard</h3><p>Standard就是标准的光照模型。渲染流程如下：</p><ul><li>Gbuffer Pass ：填充GBuffer</li><li>Deferred Lighting Pass：Compute Shader计算光照。</li></ul><p>基础的输入参数：</p><ul><li>Diffuse贴图：表面颜色，同时支持用Color参数对其进行调整。Alpha通道在开启透明模式的时候，可以用作透明度。</li><li>Normal贴图：支持Object空间和Tangent空间，支持调节法线强度。</li><li>Mask贴图：R通道对应金属度，G通道对应平滑度，B通道对应细节贴图的区域，A通道对应平滑度，同时提供了多个滑块参数对金属度和平滑度进行调整。</li><li>BentNormal贴图：主要用于计算AO，比AO贴图准确。</li><li>DetialMap贴图：支持平铺的细节，可以给Diffuse、normal、smoothness调节细节，通过Mask贴图B通道控制区域。</li><li>Height贴图：开启Displacement Mode，可以使用高度贴图。</li><li>开启透明模式：支持扭曲、折射。</li><li>支持Clear Coat：效果。</li></ul><p>上面的效果Lit材质球默认支持，Lit的Inspector是一个专门为LitShader写的材质编辑器，通过开启选项可修改Lit的材质效果。</p><p>另外，可以看到Lit支持很多贴图输入，一般而言这样做开销很高，但是Lit Shader内部做了优化，如果不使用某一张贴图就不要给他赋值，它就不会对这个贴图进行采样。</p><h3 id="2-2-Specular"><a href="#2-2-Specular" class="headerlink" title="2.2 Specular"></a>2.2 Specular</h3><p>这个是和Standard（金属工作流）相对的高光工作流。区别只是金属度变成了高光颜色。其他计算没有区别。</p><h3 id="2-3-Anisotropy"><a href="#2-3-Anisotropy" class="headerlink" title="2.3 Anisotropy"></a>2.3 Anisotropy</h3><p>计算高光时使用各项异性的高光计算。和Standard区别只在于高光的计算，同时多出了一张各向异性贴图和强度控制。例如：拉丝金属。</p><h3 id="2-4-Iridescence"><a href="#2-4-Iridescence" class="headerlink" title="2.4 Iridescence"></a>2.4 Iridescence</h3><p>彩虹色是指：随着光照角度的变化光照颜色发生变化。例如：肥皂泡沫，昆虫翅膀。</p><p>和Standard的区别在于：光的颜色随光照角度发生变化。</p><h3 id="2-5-Translucent"><a href="#2-5-Translucent" class="headerlink" title="2.5 Translucent"></a>2.5 Translucent</h3><p>透光效果是指：在背光面可以看到光穿过物体的效果。主要用于半透明材质。例如：树叶。</p><p><strong>以上效果的开销没有太大区别，效果的差距只在于计算公式的不同，而渲染流程基本一致。</strong></p><h3 id="2-6-Surface-Scattering"><a href="#2-6-Surface-Scattering" class="headerlink" title="2.6 Surface Scattering"></a>2.6 Surface Scattering</h3><p>SSS效果用来描述光线在表面多次散射的效果。可以用来描述灯光和半透物体的交互过程。可以用来制作：玉、冰、皮肤等物体。</p><p>Surface Scattering的效果和上面几种效果不同，并且需要额外的计算。大致的渲染流程如下：</p><ul><li>Gbuffer Pass ：和Standard一样填充Gbuffer</li><li>Deferred Lighting Pass：计算光照</li><li>Convolution Pass：对需要SSS的部位进行卷积（通过Diffuse Profile）。</li><li>Combine Pass：计算好的SSS光和原始光融合。</li></ul><h3 id="2-7-Displacement-高度图"><a href="#2-7-Displacement-高度图" class="headerlink" title="2.7 Displacement,  高度图"></a>2.7 Displacement,  高度图</h3><p>Unity支持高度图计算。</p><p>所有的材质都可以使用高度图。</p><p>在Surface Options 当中选择Displacement Mode：</p><p>None：不使用高度图。</p><p>Vertex Displacement:  在Vertex阶段直接移动顶点，高度图作为移动距离。</p><p>Pixel displacement： 将高度图作为视差贴图。（POM）</p><p>当开启Pixel displacement时，视差贴图对应的参数就会开启。</p><p>官方说明：<a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@6.7/manual/Displacement-Mode.html">Displacement Mode</a></p><h2 id="3-渲染流程介绍"><a href="#3-渲染流程介绍" class="headerlink" title="3. 渲染流程介绍"></a>3. 渲染流程介绍</h2><p>这里主要描述实现上述效果需要的基本渲染流程。</p><p>HDRP中Lit的渲染流程和Built-in Standard当中的延迟渲染基本一致，不透明物体流程如下：</p><ul><li>Gbuffer Pass  :填充Gbuffer，不过Gbuffer的内容和Built-in的内容有所区别。</li><li>Deferred Lighting Pass：进行光照计算。HDRP当中的光照计算放在了ComputeShader当中，计算效率更高。</li></ul><h3 id="3-1-Gbuffer结构"><a href="#3-1-Gbuffer结构" class="headerlink" title="3.1 Gbuffer结构"></a>3.1 Gbuffer结构</h3><p>下面是HDRP当中Gbuffer的结构类型。</p><table><thead><tr><th>G-Buffer Usage</th><th>Format</th><th>RGB</th><th>A</th></tr></thead><tbody><tr><td>GBuffer0</td><td>RGBA32</td><td>Albedo Color &#x2F;      SSS Color</td><td>Spacular Occlusiion &#x2F; SSS Parameter</td></tr><tr><td>GBuffer1</td><td>RGBA32</td><td>Packed Normal</td><td>Roughness</td></tr><tr><td>GBuffer2</td><td>RGBA32</td><td>BSDF Model Specific Parameters</td><td>Coat Mask + Material ID</td></tr><tr><td>GBuffer3</td><td>R11G11B10</td><td>GI + Emissive</td><td>&#x2F;</td></tr><tr><td>GBuffer4 - Optional</td><td>RGBA32</td><td>R:&#x2F;             G:&#x2F;             B: AO</td><td>Light Layer</td></tr><tr><td>GBuffer5 - Optional</td><td>RGBA32</td><td>shadowmask0 - 2</td><td>shadowmask3</td></tr></tbody></table><p>其中Gbuffer0 、Gbuffer1、Gbuffer3的内容和Built-in的内容类型基本一致，主要是金属工作流需要的参数。</p><p>Gbuffer2和Gbuffer4当中保存了用于区分材质的标记，例如：</p><ul><li>Light Layer: 区分使用哪个Layer的光源。</li><li>Coat Mask：区分使用Coat效果的区域。</li><li>Material ID：区分材质类型。</li></ul><p>还有其他的参数可以在Shader当中查看具体使用方式。</p><h3 id="3-2-灯光列表"><a href="#3-2-灯光列表" class="headerlink" title="3.2 灯光列表"></a>3.2 灯光列表</h3><p>HDRP使用FPTL和Cluster策略，将灯光列表一次性传递到一个Pass当中完成计算。</p><p>Unity灯光计算就是（使用FPTL或Cluster策略）生成影响每一个Tile的灯光列表，在Compute Shader当中根据自己所在的Tile读取光照列表，然后一次性完成灯光计算。</p><h4 id="3-2-1-FPTL和Cluster"><a href="#3-2-1-FPTL和Cluster" class="headerlink" title="3.2.1 FPTL和Cluster"></a>3.2.1 FPTL和Cluster</h4><p>Unity有两种灯管列表的计算方式，FPTL的方式能够依赖深度区分需要使用的灯光是否能够作用在表面。透明物体没有深度，所以需要使用Cluster方式对灯管列表进行进一步的纵向划分。</p><p>Cluster将视锥体划分成多个体素块，在体素块中保存属于它的内容索引。体素块当中不止保存了灯光列表索引，还可以保存光照探针、Decal、Density Volume的内容。</p><p>FPTL目的是为了能够在一个pass当中读取所有的光照信息，这样就能够在一个Pass当中完成光照计算，节省了大量DrawCall。</p><p>如果要想查看灯光列表计算方式，查看LightLoops.cs源文件中的BuildGPULightListsCommon函数。</p><p><strong>下面简要介绍FPTL的计算过程和使用方式：</strong></p><ol start="0"><li><p>首先需要场景中所有灯光，场景灯光是在CPU中统一收集的，记录了<strong>光照信息</strong>及其<strong>包围盒</strong>。</p></li><li><p>FPTL是基于屏幕坐标计算的所以需要将<strong>灯光转换到摄像机空间的矩阵（上一步已经完成）</strong>。</p><p><strong>这部分计算在函数LightLoop.cs:PrepareLightsForGPU当中。这部分主要是CPU计算。统计LightList,讲LightBounds转换到View空间</strong></p></li><li><p>生成剪裁空间的AABB包围盒：用于FPTL和Cluster。代码位于：Runtime&#x2F;Lighting&#x2F;LightLoop&#x2F;scrbound.compute</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//scrbound.compute</span><br><span class="hljs-comment">// 读取光的AABB包围盒</span><br> SFiniteLightBound lgtDat = g_data[eyeAdjustedLgtIndex];<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">包围盒数据结构</span><br><span class="hljs-comment">    public struct SFiniteLightBound</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        public Vector3 boxAxisX;</span><br><span class="hljs-comment">        public Vector3 boxAxisY;</span><br><span class="hljs-comment">        public Vector3 boxAxisZ;</span><br><span class="hljs-comment">        public Vector3 center;        // a center in camera space inside the bounding volume of the light source.</span><br><span class="hljs-comment">        public Vector2 scaleXY;</span><br><span class="hljs-comment">        public float radius;</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">  */</span><br><br><span class="hljs-comment">// 包围盒的计算函数 LightingConvexHullUtils.hlsl</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">GetHullQuad</span><span class="hljs-params">(out float3 p0, out float3 p1, out float3 p2, out float3 p3, <span class="hljs-type">const</span> float3 boxX, <span class="hljs-type">const</span> float3 boxY, <span class="hljs-type">const</span> float3 boxZ, <span class="hljs-type">const</span> float3 center, <span class="hljs-type">const</span> float2 scaleXY, <span class="hljs-type">const</span> <span class="hljs-type">int</span> sideIndex)</span><br>&#123;<br>    <span class="hljs-comment">// 开启6个thread分别计算light的AABB的六个面在view空间的AABB凸包。因为线程每次提交8个所以两个thread被丢弃。</span><br>    ...<br>    GroupMemoryBarrierWithGroupSync();<br>    <span class="hljs-comment">// 保留6个thread中的第一个，组合成一个完整的AABB凸包。 计算在屏幕中的位置。其中包括了大量的优化计算。最终输出到g_vBoundsBuffer当中。这里面包括的z坐标。</span><br>    ...<br>    g_vBoundsBuffer[boundsIndices.min] = ...;<br>    g_vBoundsBuffer[boundsIndices.max] = ...;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>根据屏幕空间的AABB生成big-Tile：（enable coarse 2D pass on 64x64 tiles ）。目的是优化fptl和cluster的计算。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//lightlistbuild-bigtile.compute:BigTileLightListGen</span><br><span class="hljs-comment">//CPU提交时每一个big-tile提交一次。GPU每一次提交计算64个thread。</span><br><br>[numthreads(NR_THREADS, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-type">void</span> <span class="hljs-title function_">BigTileLightListGen</span><span class="hljs-params">(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID)</span><br>&#123;<br>    <span class="hljs-comment">// 首先64个thread同事计算所有光照列表，判断每一个光源的AABB是否在这个Tile当中。通过元操作进行累加和记录</span><br>    ...<br><span class="hljs-comment">// 在这个tile中，累加并返回uIndex当前值。</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> uInc = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> uIndex;<br>    InterlockedAdd(lightOffs, uInc, uIndex);<br><span class="hljs-comment">// 记录灯光索引</span><br>    <span class="hljs-keyword">if</span>(uIndex&lt;MAX_NR_BIGTILE_LIGHTS) lightsListLDS[uIndex] = l;     <span class="hljs-comment">// add to light list</span><br>    ...<br>    <span class="hljs-comment">// sort lights:对光源类型排序。</span><br>    SORTLIST(lightsListLDS, iNrCoarseLights, MAX_NR_BIG_TILE_LIGHTS_PLUS_ONE, t, NR_THREADS);<br>    ...<br>    <span class="hljs-comment">// 输出 :第一个放光源个数，后面是索引。</span><br> <span class="hljs-keyword">for</span>(i=t; i&lt;(iNrCoarseLights+<span class="hljs-number">1</span>); i+=NR_THREADS)<br>        g_vLightList[MAX_NR_BIG_TILE_LIGHTS_PLUS_ONE*offs + i] = i==<span class="hljs-number">0</span> ? iNrCoarseLights : lightsListLDS[max(i<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>)];<br></code></pre></td></tr></table></figure><ol start="4"><li>进行FPTL计算。参考相关论文或者Shader源代码。</li><li>进行Cluster计算，这里面不只包括了光照，还包括了环境光、Decal、DensityVolume。</li></ol><h3 id="3-3-光照计算"><a href="#3-3-光照计算" class="headerlink" title="3.3 光照计算"></a>3.3 光照计算</h3><p>​完成光照计算和Gbuffer填充之后就可以进行最终的光照计算，HDRP的Gbuffer光照计算使用了Compute Shader。</p><p>Compute Shader源文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">HDRP/Runtime/Lighting/LightLoop: Deferred.compute.<br></code></pre></td></tr></table></figure><p>在lightloop函数当中读取了光照列表，使用BSDF函数计算最终的材质颜色。</p><h3 id="3-4-BSDF"><a href="#3-4-BSDF" class="headerlink" title="3.4 BSDF"></a>3.4 BSDF</h3><p>​由于物体表面上有凹凸不平的微小表面，一道入射光线射到表面会产生光的散射现象，BSDF 用来表示这种散射现象（散射到各个方向的光的强度）。</p><p>Unity HDRP支持多种BSDF函数，例如：</p><p>Lit Shader的BSDF计算位于Lit.hlsl</p><p>Hair Shader的BSDF计算位于Hair.hlsl</p><h3 id="3-5-BSDF中PBR材质参数的意义"><a href="#3-5-BSDF中PBR材质参数的意义" class="headerlink" title="3.5 BSDF中PBR材质参数的意义"></a>3.5 BSDF中PBR材质参数的意义</h3><p>在光照计算当中除了光源的参数和BSDF函数以外，最重要的就是材质相关的参数，下面表格解释了基本的材质参数。结合了Unity人员的说明和Shader源代码总结了如下内容：</p><table><thead><tr><th align="left"><strong>Property</strong></th><th align="left"><strong>Description</strong></th></tr></thead><tbody><tr><td align="left"><strong>Base Color</strong></td><td align="left">表示物体颜色，不应该包含任何明暗、AO、阴影信息。除了基础颜色外，还可以包含一些偏色、或者色相的变化。</td></tr><tr><td align="left"><strong>Smoothness</strong></td><td align="left">平滑度，用来描述物体的粗糙程度。在Shader源代码中，Smoothness会转化成粗糙度进行计算。有两种粗糙度。PerceptualRoughness &#x3D; 1- smoothness。Roughness&#x3D; PerceptualRoughness * PerceptualRoughness；</td></tr><tr><td align="left">**Ambient Occlusion **</td><td align="left">AO贴图：unity人员说可以使用sRGB格式，也可以使用RGB格式，但是需要统一。主要用来控制环境光（间接光）的明暗，对于直接光照没有影响。AO用来表现物体的明暗层次。</td></tr><tr><td align="left"><strong>Mask Map</strong></td><td align="left">Assign a Texture that packs different Material maps into each of its RGBA channels. • <strong>Red</strong>: Stores the metallic map.  • <strong>Green</strong>: Stores the ambient occlusion map. • <strong>Blue</strong>: Stores the detail mask map. • <strong>Alpha</strong>: Stores the smoothness map.</td></tr><tr><td align="left">**Normal **</td><td align="left">法线，LitShader支持模型空间和切线空间的法线，使用模型空间法线，可以在LOD当中过度更好，使用切线空间法线，可以压缩纹理空间。</td></tr><tr><td align="left"><strong>Bent Normal</strong></td><td align="left">Bent normal实际上也是一个表面方向和Normal接近，主要用来优化AO效果，只对GI（lightmap&#x2F;lightprobe&#x2F;volume proxy）生效。shaer代码：builtinData.bakeDiffuseLighting &#x3D; SampleBakedGI(posInput.positionWS, bennormalWS, texCoord1.xy, texCoord2.xy);</td></tr><tr><td align="left"><strong>Coat Mask</strong></td><td align="left">Coat效果强弱，0-1之间</td></tr></tbody></table><h2 id="4-HDRP的其他渲染特性"><a href="#4-HDRP的其他渲染特性" class="headerlink" title="4. HDRP的其他渲染特性"></a>4. HDRP的其他渲染特性</h2><h3 id="4-1-StackLit"><a href="#4-1-StackLit" class="headerlink" title="4.1 StackLit"></a>4.1 StackLit</h3><p>Unity提供了ShaderGraph Package。能够实现LitShader当中的所有功能。但是无法修改光照计算。如果需要修改光照计算就需要手写Shader。默认的Shader Graph的Lit节点使用的是Deferred光照，所以能够支持的效果有限（由于Gbuffer容量限制）</p><p>为了实现更好的效果，<strong>Shader Graph提供了Forward模式的StackLit Master节点</strong>，它支持更加物理正确的Shading模型，提供了更多的渲染功能。</p><p>使用StackLit可以制作：包括头发、毛发、布料、皮肤等效果。但是<strong>Forward模式渲染开销非常大，所以不建议在游戏当中使用</strong>，但是可以在选人界面等简单场景使用。</p><h3 id="4-2-透明物体渲染"><a href="#4-2-透明物体渲染" class="headerlink" title="4.2 透明物体渲染"></a>4.2 透明物体渲染</h3><p>HDRP当中的所有透明物体都是在Forward下渲染的，所以渲染开销比较大。</p><p>除此之外透明物体还支持两个pass：TransparentDepthPrepas和TransparentDepthPostpass。下面是透明物体渲染部分的Pipeline代码和对应说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 渲染天空球 </span><br>RenderSky(hdCamera, cmd);<br><span class="hljs-comment">// 渲染透明物体的Prepass，用于处理透明物体之间的遮挡。</span><br>RenderTransparentDepthPrepass(cullingResults, hdCamera, renderContext, cmd);<br><br><br><span class="hljs-comment">// 渲染需要被折射的透明物体。RenderQueue:[2750-100,2750+100]</span><br>RenderForward(cullingResults, hdCamera, renderContext, cmd, ForwardPass.PreRefraction);<br><br><span class="hljs-comment">// 如果开启RoughRefraction，则生成ColorPyramid</span><br>&#123;<br>...<br>    RenderColorPyramid(hdCamera, cmd, <span class="hljs-literal">true</span>);<br>&#125;<br><br>cmd.SetGlobalTexture(HDShaderIDs._ColorPyramidTexture, currentColorPyramid);<br><br><span class="hljs-comment">// 渲染所有其他透明物体。</span><br><span class="hljs-comment">// RenderQueue:[3000-100,3000+100]（没有开启LowResolutionTrans）</span><br><span class="hljs-comment">// RenderQueue:[3000-100,3400+100]（开启LowResolutionTrans）</span><br>RenderForward(cullingResults, hdCamera, renderContext, cmd, ForwardPass.Transparent);<br><br>...<br><br><span class="hljs-comment">// 渲染LowResTransparency。RenderQueue:[3400-100,3400+100]</span><br>DownsampleDepthForLowResTransparency(hdCamera, cmd);<br>RenderLowResTransparent(cullingResults, hdCamera, renderContext, cmd);<br>UpsampleTransparent(hdCamera, cmd);<br><br><span class="hljs-comment">// 渲染TransparentDepthPostpass，为了能够在需要深度的后处理效果中正确的处理透明物体  </span><br>RenderTransparentDepthPostpass(cullingResults, hdCamera, renderContext, cmd);<br><br><span class="hljs-comment">// 渲染颜色金字塔。</span><br>RenderColorPyramid(hdCamera, cmd, <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// 渲染扭曲效果。</span><br>AccumulateDistortion(cullingResults, hdCamera, renderContext, cmd);<br>RenderDistortion(hdCamera, cmd);<br></code></pre></td></tr></table></figure><p>上面提到了渲染LowResTransparency，如果要使用这个功能就需要在HDRPRenderPipelineAsset中开启LowResTransparency。</p><p>开启LowResTransparency后，材质中的LowRes属性生效。勾选这个属性，就会在低分辨率的RenderTarget上渲染这个透明物体，由于透明物体是Forward渲染。所以这样可以大幅提升效果。</p><p><strong>另外可以看到，代码是通过RenderQueue区分一个物体在什么时候被渲染的，所以不建议修改material的Queue，而是使用Priority。</strong>例如：在3200到3300这段区间的物体，如果HDRP设置中没有开启LowResTran选项，则永远不会被渲染。</p><h3 id="4-3-Decal"><a href="#4-3-Decal" class="headerlink" title="4.3 Decal"></a>4.3 Decal</h3><p>Unity HDRP提供了Decal的支持。原始Decal直接往Gbuffer写数据，而HDRP的Decal使用了Dbuffer先存储Decal的信息，然后在计算Gbuffer的过程中在合并到光照计算中。</p><p><strong>Decal有两种一种是Dbuffer Decal一种是ClusterDecal。</strong></p><p><strong>Dbuffer Decal：</strong>（Projector Decal就是一个方块，可以往Dbuffer（类似Gbuffer）写入Decal纹理）。</p><p><strong>Dbuffer 结构：</strong>类似Gbuffer结构，可以影响物体Diffuse，Normal，Emssive等，不需要GI信息（Dbuffer0,Dbuffer1,Dbuffer2）。</p><p>HDRenderPipelineAsset有设置:Metal &amp; Amitent Propterty，用来控制Decal是否影响金属度和AO，勾选以后就会多使用一张Dbuffer，增加开销。</p><p><strong>Emssive Decal：</strong>会多绘制一次。Emissive不能受光照影响。</p><p><strong>Mesh Decal：</strong>和透明物体很像，直接绘制到Debuffer当中。</p><p><strong>关于Decal物体的剪裁：</strong></p><p>Decal 参与Culling，所以在CPU上有消耗。我们可以仿照Decal的方式对我们自己管理的对象用Culling Group手动culling。</p><p><strong>ClusterDecal：</strong>HDRP支持透明物体的Decal，Dbuffer需要深度。不透明物体没有深度，所以不透明物体需要使用Cluster信息。与Cluster灯光原理一样。Decal 有Affect Transparent选项，开启后生效。</p><p><strong>不过LightList当中不光有Light信息，还有Reflection Probe ，Decal，Local Density Volume信息。</strong></p><p><strong>其他：</strong></p><p>视锥体内不依赖深度的简单物体都可以使用Cluster方式来做。这样就不用在CPU上做物体和物体的相交计算。通过记录索引可以让大部分物体进行合并。</p><p>例如：不是同一个Reflection Probe，可以Batch在一起。因为他们不依赖CPU来决定这次Batch使用哪一个Probe，而是通过LightList在GPU上实时计算。 然后通过Cluster当中的List查找信息。</p><p>Cluster Decal会被patch在一个大的纹理，一起传送给GPU，通过UV偏移来找。在Setting当中有decal相关选项：Atlas Weight和Atlas Height，这个选项直接影响占用显存的大小。</p><h3 id="4-4-体积光"><a href="#4-4-体积光" class="headerlink" title="4.4 体积光"></a>4.4 体积光</h3><p><strong>全局体积雾设置：</strong>场景当中的SceneSetting &#x2F;Volumetric Fog 是全局的体积光的设置。</p><p><strong>Density Volume局部的体积雾</strong>：只控制Abledo和浓度，其他的参数通过Global控制。</p><p><strong>基础原理：</strong></p><p>HDRP体积光不是屏幕空间的体积光（从屏幕空间 Reymarching），他是视锥体空间的3D体素纹理。有一个体素化的Pass，会把能看见的Density Volume体素化（Voxelization）到3D纹理里。Density Volume也是通过Cluster来记录的。体素化的时候通过ID知道是哪个Density Volume。</p><p><strong>Volumetric 参数：</strong></p><p>体积雾的颜色由大气散射决定（需要使用Precedual Sky），如果要用HDRISky，就需要自己计算大气散射颜色。</p><p>计算方式参考：Pre-compute Atemosphere Scattering相关文章。</p><p><strong>Phase Function（全局各向异性）：</strong>光线在各个方向的散射强度。类似BRDF函数。</p><p>不同的物体Phase Function不同，例如：冰晶（强透射和折射）、尘土（吸收阻挡光照）。Phase Function主要控制朝向光的时候亮，还是背向光的方向亮、已经高光环的形状。灰尘就是Phase Function（0）只有颜色，水就是越朝光看越亮，大晴天很少有所以一般做成0。</p><p><strong>相关设置：</strong>HDRenderPipelineAsset（涉及到资源分配的内容）当中可以设置精度（3D体素的分辨率）：Volumetric Hight Quality。</p><p>Hight Quality 是屏幕1&#x2F;4大小，slice是128.</p><p>Midum 是屏幕1&#x2F;8大小，深度slice是64.</p><p>PS4上测试：  屏幕1&#x2F;16 大小 , slice64耗时0.8毫秒。 优化时需要考虑：体素化、Volume数量。</p><p><strong>体积雾纵向切分方式：</strong></p><p>Slice Distribution Uniformition：Slice的分布，近处密集还是等距划分。</p><p>Depth Extrent：覆盖多远。</p><h2 id="5-HDRP与引擎自带模块"><a href="#5-HDRP与引擎自带模块" class="headerlink" title="5. HDRP与引擎自带模块"></a>5. HDRP与引擎自带模块</h2><p><strong>Culling 模块：</strong></p><p>我们可以定义自己的Custom数据，然后使用Unity的Culling Group，每帧收集数据转换成AABB让引擎Culling。HDRP的Volume、Decal都是使用的这种方式。</p><p><strong>Baking 模块：</strong></p><p>支持原始所有内容。</p><p>GI信息都是一个物体计算一次，在填充Gbuffer时计算。</p><p>小型物体推荐使用light probe。大物体推荐用Lightmap或者开启light probe volume。</p><h2 id="6-Package"><a href="#6-Package" class="headerlink" title="6. Package"></a>6. Package</h2><p><strong>Core Package：</strong></p><p>包含大量的基础c#渲染工具。</p><p>包含光照计算等基础的Shader函数。</p><p>包含重要的功能：Volume System。</p><p><strong>ShaderGraph：</strong></p><p><strong>基础功能：</strong>Lit和StackLit等自带master节点。</p><p><strong>扩展功能：</strong>ShaderGraph模板和Shader Custom Node。</p><p><strong>VFX：</strong></p><p>必须和HDRP一起用。需要Compute Shader，基于indrect Dispatch效率高。</p><p><strong>基础原理：</strong>将Compute buffer作为一个RWbuffer，放到compute Shader里面。在Compute Shader里面讲vertex buffer和index buffer动态生成好，然后把这个Compue buffer作为VB和IB传递到Graphic Pipeline里进行渲染。</p><p>LWRP不计划加入ComputeShader。</p><p><strong>扩展功能：</strong>VFX模板、自定义Shader、ShaderGraph（还不支持）</p>]]></content>
      
      
      <categories>
          
          <category> HDRPSource </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>new3.HDRP Shadow</title>
      <link href="/2022/07/09/HDRPsource/new3.HDRP%20Shadow/"/>
      <url>/2022/07/09/HDRPsource/new3.HDRP%20Shadow/</url>
      
        <content type="html"><![CDATA[<h1 id="准备阴影Atlas："><a href="#准备阴影Atlas：" class="headerlink" title="准备阴影Atlas："></a>准备阴影Atlas：</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在PrepareLightsForGPU当中分配阴影,PrepareLightsForGPU是用来CPU准备光照数据的</span><br><br><span class="hljs-comment">// 给阴影分配渲染请求，设置摄像机参数，阴影分辨率。</span><br>additionalData.ReserveShadows(camera, m_ShadowManager, m_ShadowInitParameters, cullResults, m_FrameSettings, lightIndex);<br><br>...<br><span class="hljs-comment">// Now that all the lights have requested a shadow resolution, we can layout them in the atlas</span><br><span class="hljs-comment">// And if needed rescale the whole atlas</span><br>m_ShadowManager.LayoutShadowMaps(debugDisplaySettings.data.lightingDebugSettings);<br></code></pre></td></tr></table></figure><p>当我设置多个方向光阴影的时候会报错，分配阴影贴图布局的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-type">void</span> <span class="hljs-title function_">LayoutShadowMaps</span><span class="hljs-params">(LightingDebugSettings lightingDebugSettings)</span><br>&#123;<br>    m_Atlas.UpdateDebugSettings(lightingDebugSettings);<br><br>    <span class="hljs-keyword">if</span> (m_CascadeAtlas != null)<br>        m_CascadeAtlas.UpdateDebugSettings(lightingDebugSettings);<br><br>    m_AreaLightShadowAtlas.UpdateDebugSettings(lightingDebugSettings);<br><br>    <span class="hljs-keyword">if</span> (lightingDebugSettings.shadowResolutionScaleFactor != <span class="hljs-number">1.0f</span>)<br>    &#123;<br>        foreach (var shadowResolutionRequest in m_ShadowResolutionRequests)<br>        &#123;<br>            <span class="hljs-comment">// We don&#x27;t rescale the directional shadows with the global shadow scale factor</span><br>            <span class="hljs-comment">// because there is no dynamic atlas rescale when it overflow.</span><br>            <span class="hljs-keyword">if</span> (shadowResolutionRequest.shadowMapType != ShadowMapType.CascadedDirectional)<br>                shadowResolutionRequest.resolution *= lightingDebugSettings.shadowResolutionScaleFactor;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Assign a position to all the shadows in the atlas, and scale shadows if needed</span><br>    <span class="hljs-keyword">if</span> (m_CascadeAtlas != null &amp;&amp; !m_CascadeAtlas.Layout(<span class="hljs-literal">false</span>))<br>        Debug.LogError(<span class="hljs-string">&quot;Cascade Shadow atlasing has failed, only one directional light can cast shadows at a time&quot;</span>);<br>    m_Atlas.Layout();<br>    m_AreaLightShadowAtlas.Layout();<br>&#125;<br></code></pre></td></tr></table></figure><p>渲染阴影的位置是在HDShadowAtlas类当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// HDShadowAtlas类</span><br><span class="hljs-comment">// 所有需要渲染阴影的灯光都会组织成一个HDShadowAtlas类。</span><br>public <span class="hljs-type">void</span> <span class="hljs-title function_">RenderShadows</span><span class="hljs-params">(ScriptableRenderContext renderContext, CommandBuffer cmd, ShadowDrawingSettings dss)</span><br>&#123;<br>    <span class="hljs-comment">// m_ShadowRequests是渲染阴影需要的所有的参数。</span><br>    <span class="hljs-keyword">if</span> (m_ShadowRequests.Count == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// shadow mask 纹理id</span><br>    cmd.SetRenderTarget(identifier);<br>    <span class="hljs-comment">// shadow 大小 </span><br>    cmd.SetGlobalVector(m_AtlasSizeShaderID, new Vector4(width, height, <span class="hljs-number">1.0f</span> / width, <span class="hljs-number">1.0f</span> / height));<br><br>    <span class="hljs-comment">// debug设置</span><br>    <span class="hljs-keyword">if</span> (m_LightingDebugSettings.clearShadowAtlas)<br>        CoreUtils.DrawFullScreen(cmd, m_ClearMaterial, null, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 渲染所以阴影请求，直线光渲染次数为级联阴影数。</span><br>    foreach (var shadowRequest in m_ShadowRequests)<br>    &#123;<br>        <span class="hljs-comment">// 设置渲染区域。</span><br>        cmd.SetViewport(shadowRequest.atlasViewport);<br><span class="hljs-comment">// 根据阴影设置是否启用zClip</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        zClip的设置：</span><br><span class="hljs-comment">        shadowRequest.zClip = (legacyLight.type != LightType.Directional);</span><br><span class="hljs-comment">        为什么关闭直线光的ZClip</span><br><span class="hljs-comment">        */</span><br>        cmd.SetGlobalFloat(HDShaderIDs._ZClip, shadowRequest.zClip ? <span class="hljs-number">1.0f</span> : <span class="hljs-number">0.0f</span>);<br>        <span class="hljs-keyword">if</span> (!m_LightingDebugSettings.clearShadowAtlas)<br>        &#123;<br>            CoreUtils.DrawFullScreen(cmd, m_ClearMaterial, null, <span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 读取灯光信息和剪裁信息</span><br>        dss.lightIndex = shadowRequest.lightIndex;<br>        dss.splitData = shadowRequest.splitData;<br><br>        <span class="hljs-comment">// 设置摄像机参数</span><br>        <span class="hljs-comment">// Setup matrices for shadow rendering:</span><br>        Matrix4x4 viewProjection = shadowRequest.deviceProjectionYFlip * shadowRequest.view;<br>        cmd.SetGlobalMatrix(HDShaderIDs._ViewMatrix, shadowRequest.view);<br>        cmd.SetGlobalMatrix(HDShaderIDs._InvViewMatrix, shadowRequest.view.inverse);<br>        cmd.SetGlobalMatrix(HDShaderIDs._ProjMatrix, shadowRequest.deviceProjectionYFlip);<br>        cmd.SetGlobalMatrix(HDShaderIDs._InvProjMatrix, shadowRequest.deviceProjectionYFlip.inverse);<br>        cmd.SetGlobalMatrix(HDShaderIDs._ViewProjMatrix, viewProjection);<br>        cmd.SetGlobalMatrix(HDShaderIDs._InvViewProjMatrix, viewProjection.inverse);<br>        cmd.SetGlobalVectorArray(HDShaderIDs._ShadowClipPlanes, shadowRequest.frustumPlanes);<br><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> remove this execute when DrawShadows will use a CommandBuffer</span><br>        <span class="hljs-comment">// 使用Command来绘制阴影，目前还没有实现？？</span><br>        renderContext.ExecuteCommandBuffer(cmd);<br>        cmd.Clear();<br><br>        renderContext.DrawShadows(ref dss);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置Clip启用</span><br>    cmd.SetGlobalFloat(HDShaderIDs._ZClip, <span class="hljs-number">1.0f</span>);   <span class="hljs-comment">// Re-enable zclip globally</span><br>&#125;<br></code></pre></td></tr></table></figure><p>HDShadowResolutionRequest表示一个灯光需要渲染阴影的次数。目前通过灯光类型，和shadow级联数决定，下面是所有相关的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// =================HDAdditionalLightData:ReserveShadows====</span><br><span class="hljs-type">int</span> count = HDAdditionalLightData:GetShadowRequestCount();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = <span class="hljs-number">0</span>; index &lt; count; index++)<br>    m_ShadowRequestIndices[index] = shadowManager.ReserveShadowResolutions(viewportSize, shadowMapType);<br><br><span class="hljs-comment">// =================HDAdditionalLightData:GetShadowRequestCount====</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">GetShadowRequestCount</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (legacyLight.type == LightType.Point <br>            &amp;&amp; lightTypeExtent == LightTypeExtent.Punctual) ? <br>        <span class="hljs-number">6</span> : <br>    <span class="hljs-comment">// 如果是直线光，则渲染次数等于级联阴影数。</span><br>            (legacyLight.type == LightType.Directional) ?     m_ShadowSettings.cascadeShadowSplitCount.value : <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//==================HDShadowManager:ReserveShadowResolutions ======</span><br><span class="hljs-keyword">switch</span> (shadowMapType)<br>&#123;<br>    <span class="hljs-keyword">case</span> ShadowMapType.PunctualAtlas:<br>      m_Atlas.ReserveResolution(resolutionRequest);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ShadowMapType.AreaLightAtlas:<br>      m_AreaLightShadowAtlas.ReserveResolution(resolutionRequest);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ShadowMapType.CascadedDirectional:<br>      m_CascadeAtlas.ReserveResolution(resolutionRequest);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过级联数据和剪裁结果计算剪裁平面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">cullResults.ComputeDirectionalShadowMatricesAndCullingPrimitives(lightIndex, (<span class="hljs-type">int</span>)cascadeIndex, cascadeCount, ratios, (<span class="hljs-type">int</span>)viewportSize.x, nearPlaneOffset, out view, out projection, out splitData);<br>           <br></code></pre></td></tr></table></figure><p>ShadowAtlas的纹理声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//HDShadowManager:</span><br><span class="hljs-comment">// The cascade atlas will be allocated only if there is a directional light</span><br>m_Atlas = new HDShadowAtlas(renderPipelineResources, punctualLightAtlasInfo.shadowAtlasResolution, punctualLightAtlasInfo.shadowAtlasResolution, HDShaderIDs._ShadowAtlasSize, clearMaterial, <span class="hljs-literal">false</span>, depthBufferBits: punctualLightAtlasInfo.shadowAtlasDepthBits, name: <span class="hljs-string">&quot;Shadow Map Atlas&quot;</span>);<br><span class="hljs-comment">// Cascade atlas render texture will only be allocated if there is a shadow casting directional light</span><br><span class="hljs-type">bool</span> useMomentShadows = GetDirectionalShadowAlgorithm() == DirectionalShadowAlgorithm.IMS;<br>m_CascadeAtlas = new HDShadowAtlas(renderPipelineResources, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, HDShaderIDs._CascadeShadowAtlasSize, clearMaterial, useMomentShadows, depthBufferBits: directionalShadowDepthBits, name: <span class="hljs-string">&quot;Cascade Shadow Map Atlas&quot;</span>);<br><br>m_AreaLightShadowAtlas = new HDShadowAtlas(renderPipelineResources, areaLightAtlasInfo.shadowAtlasResolution, areaLightAtlasInfo.shadowAtlasResolution, HDShaderIDs._AreaShadowAtlasSize, clearMaterial, <span class="hljs-literal">false</span>, BlurredEVSM: <span class="hljs-literal">true</span>, depthBufferBits: areaLightAtlasInfo.shadowAtlasDepthBits, name: <span class="hljs-string">&quot;Area Light Shadow Map Atlas&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>在HDRenderPipelineAsset当中可以设置每种Atlas的大小，以及每种纹理深度的精度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// LightLoop</span><br><span class="hljs-comment">// 下面是阴影相关设置的使用位置。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitShadowSystem</span><span class="hljs-params">(HDRenderPipelineAsset hdAsset)</span><br>&#123;<br>    m_ShadowInitParameters = hdAsset.currentPlatformRenderPipelineSettings.hdShadowInitParams;<br>    m_ShadowManager = new HDShadowManager(<br>        hdAsset.renderPipelineResources,<br>        m_ShadowInitParameters.directionalShadowsDepthBits,<br>        m_ShadowInitParameters.punctualLightShadowAtlas,<br>        m_ShadowInitParameters.areaLightShadowAtlas,<br>        m_ShadowInitParameters.maxShadowRequests,<br>        hdAsset.renderPipelineResources.shaders.shadowClearPS<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>Unity支持的Soft Shadow 类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-type">static</span> DirectionalShadowAlgorithm <span class="hljs-title function_">GetDirectionalShadowAlgorithm</span><span class="hljs-params">()</span><br>&#123;<br>    var hdAsset = (GraphicsSettings.renderPipelineAsset as HDRenderPipelineAsset);<br>    <span class="hljs-keyword">switch</span> (hdAsset.currentPlatformRenderPipelineSettings.hdShadowInitParams.shadowQuality)<br>    &#123;<br>        <span class="hljs-keyword">case</span> HDShadowQuality.Low:<br>            &#123;<br>                <span class="hljs-keyword">return</span> DirectionalShadowAlgorithm.PCF5x5;<br>            &#125;<br>        <span class="hljs-keyword">case</span> HDShadowQuality.Medium:<br>            &#123;<br>                <span class="hljs-keyword">return</span> DirectionalShadowAlgorithm.PCF7x7;<br>            &#125;<br>        <span class="hljs-keyword">case</span> HDShadowQuality.High:<br>            &#123;<br>                <span class="hljs-keyword">return</span> DirectionalShadowAlgorithm.PCSS;<br>            &#125;<br>        <span class="hljs-keyword">case</span> HDShadowQuality.VeryHigh:<br>            &#123;<br>                <span class="hljs-keyword">return</span> DirectionalShadowAlgorithm.IMS;<br>            &#125;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> DirectionalShadowAlgorithm.PCF5x5;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HDRPSource </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity SRP实现SDF渲染框架</title>
      <link href="/2022/07/09/SDF/SDFRenderFrameWork/"/>
      <url>/2022/07/09/SDF/SDFRenderFrameWork/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity-SRP实现SDF渲染框架"><a href="#Unity-SRP实现SDF渲染框架" class="headerlink" title="Unity SRP实现SDF渲染框架"></a>Unity SRP实现SDF渲染框架</h1><p>目前，接触到SDF和RayCasting相关的内容，花了一点时间通过SRP来构建一个SDF渲染pipeline。</p><p>这里主要介绍一下大概的过程。</p><p>目前的结果：</p><p><img src="/../../images/img/SDF1.jpg" alt="SDF1"></p><h2 id="SRP部分代码"><a href="#SRP部分代码" class="headerlink" title="SRP部分代码"></a>SRP部分代码</h2><p>全部代码如下，具体说明见注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c">using System.Collections;<br>using System.Collections.Generic;<br>using UnityEngine;<br>using UnityEngine.Rendering;<br>using UnityEngine.Experimental.Rendering;<br>using UnityEngine.Experimental.Rendering;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDFPipeline</span> :</span> UnityEngine.Rendering.RenderPipeline<br>&#123;<br>    ShaderTagId forwardBase;<br>    <span class="hljs-comment">// 相关的Shader和数据存储在asset当中。</span><br>    private SDFPipelineAsset asset;<br>    private Material sdfMat;<br>    <span class="hljs-comment">// 需要初始化一个LightMode名字，这个名字主要用来指定要渲染的pass。</span><br>    public <span class="hljs-title function_">SDFPipeline</span><span class="hljs-params">(SDFPipelineAsset vasset)</span><br>    &#123;<br>        asset = vasset;<br>        sdfMat = new Material(asset.sdfRenderShader);<br>        forwardBase = new ShaderTagId(<span class="hljs-string">&quot;ForwardBase&quot;</span>);<br>    &#125;<br><br><span class="hljs-comment">// 渲染每一个Camera</span><br>    protected override <span class="hljs-type">void</span> <span class="hljs-title function_">Render</span><span class="hljs-params">(ScriptableRenderContext context, Camera[] cameras)</span><br>    &#123;<br>        foreach (var camera in cameras)<br>        &#123;<br>            Render(context, camera);<br>        &#125;<br><br>        context.Submit();<br>    &#125;<br><br><span class="hljs-comment">// 针对每一个Camera的渲染</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">Render</span><span class="hljs-params">(ScriptableRenderContext context, Camera camera)</span><br>    &#123;<br>    <span class="hljs-comment">// 进行模型剪裁。</span><br>        ScriptableCullingParameters cullingParameters;<br>        camera.TryGetCullingParameters(<span class="hljs-literal">false</span>, out cullingParameters);<br>        CullingResults cull = context.Cull(ref cullingParameters);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">        设置摄像机数据：其中的内容包括摄像机的unity_WorldToCamera,unity_CameraToWorld等矩阵</span><br><span class="hljs-comment">        */</span><br>        context.SetupCameraProperties(camera); <span class="hljs-comment">//设置Unity V  和 P矩阵</span><br>       <br>        var buffer = new CommandBuffer &#123; name = camera.name &#125;;<br>        CameraClearFlags clearFlags = camera.clearFlags;<br>        buffer.ClearRenderTarget(<br>                (clearFlags &amp; CameraClearFlags.Depth) != <span class="hljs-number">0</span>,<br>                (clearFlags &amp; CameraClearFlags.Color) != <span class="hljs-number">0</span>,<br>                camera.backgroundColor<br>            );<br><span class="hljs-comment">// </span><br>        sdfMat.shader = asset.sdfRenderShader;<br><br>        <span class="hljs-comment">// 获取SDF代理体数据</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        ComputeBuffer cb = SDFProxyObject.GetProxy(ref  count);<br><br><span class="hljs-comment">// 设置相关矩阵参数。</span><br>        buffer.SetGlobalBuffer(Shader.PropertyToID(<span class="hljs-string">&quot;SDFlist&quot;</span>),cb);<br>        buffer.SetGlobalInt(<span class="hljs-string">&quot;I_SDFCount&quot;</span>, count);<br>        buffer.SetGlobalMatrix(<span class="hljs-string">&quot;M_WorldToCamera&quot;</span>, camera.worldToCameraMatrix);<br>        buffer.SetGlobalMatrix(<span class="hljs-string">&quot;M_Inv_WorldToCamera&quot;</span>, camera.worldToCameraMatrix.inverse);<br>        buffer.SetGlobalMatrix(<span class="hljs-string">&quot;M_Projection&quot;</span>, GL.GetGPUProjectionMatrix(camera.projectionMatrix, camera.cameraType == CameraType.SceneView));<br>        buffer.SetGlobalMatrix(<span class="hljs-string">&quot;M_Inv_Projection&quot;</span>, GL.GetGPUProjectionMatrix(camera.projectionMatrix, camera.cameraType == CameraType.SceneView).inverse);<br>        buffer.SetGlobalVector(<span class="hljs-string">&quot;V_CameraWPos&quot;</span>, camera.transform.position);<br>        <br>        <span class="hljs-comment">// 进行SDF绘制，这里和HDRP的灯光一样一次性绘制所有的SDF数据。</span><br>        buffer.Blit(BuiltinRenderTextureType.None, camera.targetTexture, sdfMat);<br>       <br>        context.ExecuteCommandBuffer(buffer);<br>        buffer.Release();<br><br><span class="hljs-comment">// 后面的内容 就是要在编辑器模式绘制矩形，为了方便编辑。</span><br>        SortingSettings st = new SortingSettings(camera);<br>       <br>        DrawingSettings ds = new DrawingSettings(forwardBase, st);<br>        FilteringSettings fs = new FilteringSettings(new RenderQueueRange(<span class="hljs-number">0</span>, <span class="hljs-number">4000</span>));<br><br>        <span class="hljs-keyword">if</span>(camera.cameraType == CameraType.SceneView)<br>        &#123;<br>            context.DrawRenderers(<br>                cull, ref ds, ref fs<br>            );<br>        &#125;<br><br>        context.Submit();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应pipeline的asset。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">using System.Collections;<br>using System.Collections.Generic;<br>using UnityEngine;<br><br>using UnityEngine;<br>using UnityEngine.Experimental.Rendering;<br>using UnityEngine.Rendering;<br><br>[CreateAssetMenu(menuName = <span class="hljs-string">&quot;Rendering/SDFPipeline&quot;</span>)]<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDFPipelineAsset</span> :</span> RenderPipelineAsset, ISerializationCallbackReceiver<br>&#123;<br>    [SerializeField]<br>    public Shader sdfRenderShader;<br><br>    protected override UnityEngine.Rendering.RenderPipeline <span class="hljs-title function_">CreatePipeline</span><span class="hljs-params">()</span><br>    &#123;<br>       <span class="hljs-keyword">return</span> new SDFPipeline(this);<br>    &#125;<br><br>    <span class="hljs-type">void</span> ISerializationCallbackReceiver.OnAfterDeserialize()<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">void</span> ISerializationCallbackReceiver.OnBeforeSerialize()<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了能够更加容易编辑内容，所以需要在Scene视图当中绘制简单的物体,同时用GameObject表示出来：</p><p><img src="/../../images/img/SDF2.jpg" alt="SDF2"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c">using System.Collections;<br>using System.Collections.Generic;<br>using UnityEngine;<br>public <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SDFProxy</span></span><br><span class="hljs-class">&#123;</span><br>    Matrix4x4 o2wMatrix;<br>    Vector4 param;<br>    public <span class="hljs-type">int</span> SDFtype;<br><span class="hljs-comment">// 每一个SDF的代理体都需要一个数据，保存位置、形状参数等。</span><br>    public <span class="hljs-title function_">SDFProxy</span><span class="hljs-params">(Matrix4x4 lTow, Vector4 lparam,<span class="hljs-type">int</span> type)</span><br>    &#123;<br>        o2wMatrix = lTow;<br>        SDFtype = type;<br>        param = lparam;<br>    &#125;<br>&#125;<br><br>[ExecuteInEditMode]<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDFProxyObject</span> :</span> MonoBehaviour<br>&#123;<br>    public <span class="hljs-type">static</span> List&lt;SDFProxyObject&gt; sdfObjlist;<br>    public <span class="hljs-type">static</span> List&lt;SDFProxy&gt; sdflist;<br><br>    <span class="hljs-type">static</span> ComputeBuffer cb;<br><br>    public <span class="hljs-type">int</span> proxytype;<br>    public Vector4 param;<br><br><span class="hljs-comment">// 获取代理体的方法</span><br>    public <span class="hljs-type">static</span> ComputeBuffer <span class="hljs-title function_">GetProxy</span><span class="hljs-params">(ref <span class="hljs-type">int</span> count)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (sdfObjlist ==null)<br>            sdfObjlist = new List&lt;SDFProxyObject&gt;();<br><br>        <span class="hljs-keyword">if</span> (sdflist == null)<br>            sdflist = new List&lt;SDFProxy&gt;();<br>        sdflist.Clear();<br>        <br>        <span class="hljs-keyword">if</span>(cb == null)<br>        cb = new ComputeBuffer(<span class="hljs-number">10000</span>,System.Runtime.InteropServices.Marshal.SizeOf(typeof(SDFProxy)));<br>        <br>        foreach (var obj in sdfObjlist)<br>        &#123;<br>            sdflist.Add(new SDFProxy(obj.transform.worldToLocalMatrix, obj.param, obj.proxytype));<br>        &#125;<br><br>        <span class="hljs-comment">//性能提升 ：提前排序減少分支，和HDRP一样</span><br>        sdflist.Sort((d1, d2) =&gt; d1.SDFtype.CompareTo(d2.SDFtype));<br><br>        cb.SetData&lt;SDFProxy&gt;(sdflist);<br>        count = sdflist.Count;<br>        <span class="hljs-keyword">return</span> cb;<br>    &#125;<br><br>    private <span class="hljs-type">void</span> <span class="hljs-title function_">OnEnable</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (sdfObjlist == null)<br>            sdfObjlist = new List&lt;SDFProxyObject&gt;();<br>        sdfObjlist.Add(this);<br>    &#125;<br><br>    private <span class="hljs-type">void</span> <span class="hljs-title function_">OnDisable</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (sdfObjlist == null)<br>            sdfObjlist = new List&lt;SDFProxyObject&gt;();<br>        sdfObjlist.Remove(this);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>目前，Scene视图当中使用的是一个黑色的盒子，用于观察位置、进行旋转等操作：</p><p><img src="/../../images/img/SDF3.jpg" alt="SDF3"></p><p>场景当中的灯光也需要设置，目前只设置了直线光，通过脚本把光照信息设置成全局的Shader变量：</p><p><img src="/../../images/img/SDF4light.jpg" alt="SDF4light"></p><h2 id="SDF渲染Shader"><a href="#SDF渲染Shader" class="headerlink" title="SDF渲染Shader"></a>SDF渲染Shader</h2><p>下面是SDF的Shader片段着色器代码，这里只放基础部分的代码，省略优化部分的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">real4 frag (v2f i) : SV_Target<br>&#123;<br>    real3 rayDir = normalize(i.worldPos - V_CameraWPos);<br>    // 背景色<br>    real3 col = float3(0.1,0.1,0.2);  <br>    real t = 0;<br>    real Pnum = 1;<br><br>    for(int s = 0; s&lt; 100; s++)<br>    &#123;<br>        real d = 10;<br>        int interact_id = 0;<br>        // 遍历所有SDF数据，这部分可以预先计算相交，同时使用八叉树管理SDF代理体。<br>        for(int p = 0; p &lt; I_SDFCount; p++)<br>        &#123;<br>            SDFProxy currSdf = SDFlist[p];<br>            real3 raypos = t * rayDir+V_CameraWPos;<br><br>            d = min(d,sdf(raypos, currSdf));<br>            if(d &lt;= 0.0001)<br>            &#123;<br>                interact_id = p;<br>                break;<br>            &#125;<br>        &#125;<br><br>        if(d &gt; 0.0001)<br>        &#123;<br>        t += d;<br>        &#125;<br>        else<br>        &#123;<br>        // 相交后执行光照计算<br>            real3 raypos = t * rayDir + V_CameraWPos;<br>            col = saturate(dot(-rayDir, calcNormal(raypos, SDFlist[interact_id])));<br><br>            col = brdf(calcNormal(raypos, SDFlist[interact_id]), normalize(-rayDir), (-_LightDirection));<br>            break;     <br>        &#125;<br><br>        if(t &gt; 100)&#123;<br>        break;<br>        &#125;<br>    &#125;<br>    return float4(col/ (1 + col), 1);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SDF的BRDF"><a href="#SDF的BRDF" class="headerlink" title="SDF的BRDF"></a>SDF的BRDF</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;brdf.hlsl&quot;</span></span><br>real3 <span class="hljs-title function_">brdf</span><span class="hljs-params">(float3 N, float3 V, float3 L)</span><br>&#123;<br>    float3 diffuse = <span class="hljs-number">0</span>;<br>    float3 specular = <span class="hljs-number">0</span>; <br>    float3 H =  normalize(L + V);<br>    <span class="hljs-type">float</span> HdotN = dot(N,H);<br>    <span class="hljs-type">float</span> HdotL = dot(L,H);<br><br>    <span class="hljs-type">float</span> F0 = <span class="hljs-number">0.54</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                    float _Metallic;</span><br><span class="hljs-comment">                    float _Smoothness;</span><br><span class="hljs-comment">                    float3 _Diffuse;</span><br><span class="hljs-comment">                    float3 _LightPosition;</span><br><span class="hljs-comment">                    float3 _LightColor;</span><br><span class="hljs-comment">                */</span><br>    <span class="hljs-comment">// Fresnel 使用Schlick</span><br>    <span class="hljs-type">float</span> F = F_Schlick(F0 ,HdotL);<br>    <span class="hljs-comment">// 目前使用blinn Phong模型光照</span><br>    specular = F * _LightIntensity *<span class="hljs-built_in">pow</span>(saturate(dot(N,L)),<span class="hljs-number">5</span>); <br>    diffuse = _LightIntensity *_LightColor * _Diffuse * _LightColor * saturate(dot(N,L))/ <span class="hljs-number">3.14159</span>;<br>    <span class="hljs-keyword">return</span> diffuse * _DiffuseDimmer   +<br>        specular * _SpecularDimmer;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SDF的形状"><a href="#SDF的形状" class="headerlink" title="SDF的形状"></a>SDF的形状</h3><p>最后是SDF,,这部分内容来自<a href="http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm">博客</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">float</span> <span class="hljs-title function_">dot2</span><span class="hljs-params">( in real3 v )</span> &#123; <span class="hljs-keyword">return</span> dot(v,v); &#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">dot2</span><span class="hljs-params">( in real2 v )</span> &#123; <span class="hljs-keyword">return</span> dot(v,v); &#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdSphere</span><span class="hljs-params">( real3 p, <span class="hljs-type">float</span> s )</span><br>&#123;<br>  <span class="hljs-keyword">return</span> length(p)-s;<br>&#125;<br><br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdBox</span><span class="hljs-params">( real3 p, real3 b )</span><br>&#123;<br>  real3 d = <span class="hljs-built_in">abs</span>(p) - b;<br>  <span class="hljs-keyword">return</span> length(max(d,<span class="hljs-number">0.0</span>))<br>         + min(max(d.x,max(d.y,d.z)),<span class="hljs-number">0.0</span>); <span class="hljs-comment">// remove this line for an only partially signed sdf </span><br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdRoundBox</span><span class="hljs-params">( real3 p, real3 b, <span class="hljs-type">float</span> r )</span><br>&#123;<br>  real3 d = <span class="hljs-built_in">abs</span>(p) - b;<br>  <span class="hljs-keyword">return</span> length(max(d,<span class="hljs-number">0.0</span>)) - r<br>         + min(max(d.x,max(d.y,d.z)),<span class="hljs-number">0.0</span>); <span class="hljs-comment">// remove this line for an only partially signed sdf </span><br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdTorus</span><span class="hljs-params">( real3 p, real2 t )</span><br>&#123;<br>  real2 q = real2(length(p.xz)-t.x,p.y);<br>  <span class="hljs-keyword">return</span> length(q)-t.y;<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdCappedTorus</span><span class="hljs-params">(in real3 p, in real2 sc, in <span class="hljs-type">float</span> ra, in <span class="hljs-type">float</span> rb)</span><br>&#123;<br>  p.x = <span class="hljs-built_in">abs</span>(p.x);<br>  <span class="hljs-type">float</span> k = (sc.y*p.x&gt;sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>( dot(p,p) + ra*ra - <span class="hljs-number">2.0</span>*ra*k ) - rb;<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdCylinder</span><span class="hljs-params">( real3 p, real3 c )</span><br>&#123;<br>  <span class="hljs-keyword">return</span> length(p.xz-c.xy)-c.z;<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdCone</span><span class="hljs-params">( real3 p, real2 c )</span><br>&#123;<br>    <span class="hljs-comment">// c must be normalized</span><br>    <span class="hljs-type">float</span> q = length(p.xy);<br>    <span class="hljs-keyword">return</span> dot(c,real2(q,p.z));<br>&#125;<br><br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdPlane</span><span class="hljs-params">( real3 p, real4 n )</span><br>&#123;<br>  <span class="hljs-comment">// n must be normalized</span><br>  <span class="hljs-keyword">return</span> dot(p,n.xyz) + n.w;<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdHexPrism</span><span class="hljs-params">( real3 p, real2 h )</span><br>&#123;<br>    <span class="hljs-type">const</span> real3 k = real3(<span class="hljs-number">-0.8660254</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.57735</span>);<br>    p = <span class="hljs-built_in">abs</span>(p);<br>    p.xy -= <span class="hljs-number">2.0</span>*min(dot(k.xy, p.xy), <span class="hljs-number">0.0</span>)*k.xy;<br>    real2 d = real2(<br>       length(p.xy-real2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),<br>       p.z-h.y );<br>    <span class="hljs-keyword">return</span> min(max(d.x,d.y),<span class="hljs-number">0.0</span>) + length(max(d,<span class="hljs-number">0.0</span>));<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdTriPrism</span><span class="hljs-params">( real3 p, real2 h )</span><br>&#123;<br>    real3 q = <span class="hljs-built_in">abs</span>(p);<br>    <span class="hljs-keyword">return</span> max(q.z-h.y,max(q.x*<span class="hljs-number">0.866025</span>+p.y*<span class="hljs-number">0.5</span>,-p.y)-h.x*<span class="hljs-number">0.5</span>);<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdCapsule</span><span class="hljs-params">( real3 p, real3 a, real3 b, <span class="hljs-type">float</span> r )</span><br>&#123;<br>    real3 pa = p - a, ba = b - a;<br>    <span class="hljs-type">float</span> h = clamp( dot(pa,ba)/dot(ba,ba), <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> );<br>    <span class="hljs-keyword">return</span> length( pa - ba*h ) - r;<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdVerticalCapsule</span><span class="hljs-params">( real3 p, <span class="hljs-type">float</span> h, <span class="hljs-type">float</span> r )</span><br>&#123;<br>    p.y -= clamp( p.y, <span class="hljs-number">0.0</span>, h );<br>    <span class="hljs-keyword">return</span> length( p ) - r;<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdCappedCylinder</span><span class="hljs-params">( real3 p, real2 h )</span><br>&#123;<br>  real2 d = <span class="hljs-built_in">abs</span>(real2(length(p.xz),p.y)) - h;<br>  <span class="hljs-keyword">return</span> min(max(d.x,d.y),<span class="hljs-number">0.0</span>) + length(max(d,<span class="hljs-number">0.0</span>));<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdRoundedCylinder</span><span class="hljs-params">( real3 p, <span class="hljs-type">float</span> ra, <span class="hljs-type">float</span> rb, <span class="hljs-type">float</span> h )</span><br>&#123;<br>    real2 d = real2( length(p.xz)<span class="hljs-number">-2.0</span>*ra+rb, <span class="hljs-built_in">abs</span>(p.y) - h );<br>    <span class="hljs-keyword">return</span> min(max(d.x,d.y),<span class="hljs-number">0.0</span>) + length(max(d,<span class="hljs-number">0.0</span>)) - rb;<br>&#125;<br><br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdCappedCone</span><span class="hljs-params">( in real3 p, in <span class="hljs-type">float</span> h, in <span class="hljs-type">float</span> r1, in <span class="hljs-type">float</span> r2 )</span><br>&#123;<br>    real2 q = real2( length(p.xz), p.y );<br>    <br>    real2 k1 = real2(r2,h);<br>    real2 k2 = real2(r2-r1,<span class="hljs-number">2.0</span>*h);<br>    real2 ca = real2(q.x-min(q.x,(q.y &lt; <span class="hljs-number">0.0</span>)?r1:r2), <span class="hljs-built_in">abs</span>(q.y)-h);<br>    real2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> );<br>    <span class="hljs-type">float</span> s = (cb.x &lt; <span class="hljs-number">0.0</span> &amp;&amp; ca.y &lt; <span class="hljs-number">0.0</span>) ? <span class="hljs-number">-1.0</span> : <span class="hljs-number">1.0</span>;<br>    <span class="hljs-keyword">return</span> s*<span class="hljs-built_in">sqrt</span>( min(dot2(ca),dot2(cb)) );<br>&#125;<br><br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdRoundCone</span><span class="hljs-params">( in real3 p, in <span class="hljs-type">float</span> r1, <span class="hljs-type">float</span> r2, <span class="hljs-type">float</span> h )</span><br>&#123;<br>    real2 q = real2( length(p.xz), p.y );<br>    <br>    <span class="hljs-type">float</span> b = (r1-r2)/h;<br>    <span class="hljs-type">float</span> a = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span>-b*b);<br>    <span class="hljs-type">float</span> k = dot(q,real2(-b,a));<br>    <br>    <span class="hljs-keyword">if</span>( k &lt; <span class="hljs-number">0.0</span> ) <span class="hljs-keyword">return</span> length(q) - r1;<br>    <span class="hljs-keyword">if</span>( k &gt; a*h ) <span class="hljs-keyword">return</span> length(q-real2(<span class="hljs-number">0.0</span>,h)) - r2;<br>        <br>    <span class="hljs-keyword">return</span> dot(q, real2(a,b) ) - r1;<br>&#125;<br><br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdEllipsoid</span><span class="hljs-params">( in real3 p, in real3 r )</span><br>&#123;<br>    <span class="hljs-type">float</span> k0 = length(p/r);<br>    <span class="hljs-type">float</span> k1 = length(p/(r*r));<br>    <span class="hljs-keyword">return</span> k0*(k0<span class="hljs-number">-1.0</span>)/k1;<br>&#125;<br><br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdOctahedron</span><span class="hljs-params">( in real3 p, in <span class="hljs-type">float</span> s)</span><br>&#123;<br>    p = <span class="hljs-built_in">abs</span>(p);<br>    <span class="hljs-type">float</span> m = p.x+p.y+p.z-s;<br>    real3 q;<br>         <span class="hljs-keyword">if</span>( <span class="hljs-number">3.0</span>*p.x &lt; m ) q = p.xyz;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-number">3.0</span>*p.y &lt; m ) q = p.yzx;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-number">3.0</span>*p.z &lt; m ) q = p.zxy;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> m*<span class="hljs-number">0.57735027</span>;<br>    <br>    <span class="hljs-type">float</span> k = clamp(<span class="hljs-number">0.5</span>*(q.z-q.y+s),<span class="hljs-number">0.0</span>,s); <br>    <span class="hljs-keyword">return</span> length(real3(q.x,q.y-s+k,q.z-k)); <br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">sdOctahedron_Bound</span><span class="hljs-params">( in real3 p, in <span class="hljs-type">float</span> s)</span><br>&#123;<br>    p = <span class="hljs-built_in">abs</span>(p);<br>    <span class="hljs-keyword">return</span> (p.x+p.y+p.z-s)*<span class="hljs-number">0.57735027</span>;<br>&#125;<br><br><br><span class="hljs-type">float</span> <span class="hljs-title function_">udTriangle</span><span class="hljs-params">( real3 p, real3 a, real3 b, real3 c )</span><br>&#123;<br>    real3 ba = b - a; real3 pa = p - a;<br>    real3 cb = c - b; real3 pb = p - b;<br>    real3 ac = a - c; real3 pc = p - c;<br>    real3 nor = cross( ba, ac );<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(<br>    (sign(dot(cross(ba,nor),pa)) +<br>     sign(dot(cross(cb,nor),pb)) +<br>     sign(dot(cross(ac,nor),pc))&lt;<span class="hljs-number">2.0</span>)<br>     ?<br>     min( min(<br>     dot2(ba*clamp(dot(ba,pa)/dot2(ba),<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>)-pa),<br>     dot2(cb*clamp(dot(cb,pb)/dot2(cb),<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>)-pb) ),<br>     dot2(ac*clamp(dot(ac,pc)/dot2(ac),<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>)-pc) )<br>     :<br>     dot(nor,pa)*dot(nor,pa)/dot2(nor) );<br>&#125;<br><br><br><span class="hljs-type">float</span> <span class="hljs-title function_">udQuad</span><span class="hljs-params">( real3 p, real3 a, real3 b, real3 c, real3 d )</span><br>&#123;<br>    real3 ba = b - a; real3 pa = p - a;<br>    real3 cb = c - b; real3 pb = p - b;<br>    real3 dc = d - c; real3 pc = p - c;<br>    real3 ad = a - d; real3 pd = p - d;<br>    real3 nor = cross( ba, ad );<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(<br>    (sign(dot(cross(ba,nor),pa)) +<br>     sign(dot(cross(cb,nor),pb)) +<br>     sign(dot(cross(dc,nor),pc)) +<br>     sign(dot(cross(ad,nor),pd))&lt;<span class="hljs-number">3.0</span>)<br>     ?<br>     min( min( min(<br>     dot2(ba*clamp(dot(ba,pa)/dot2(ba),<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>)-pa),<br>     dot2(cb*clamp(dot(cb,pb)/dot2(cb),<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>)-pb) ),<br>     dot2(dc*clamp(dot(dc,pc)/dot2(dc),<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>)-pc) ),<br>     dot2(ad*clamp(dot(ad,pd)/dot2(ad),<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>)-pd) )<br>     :<br>     dot(nor,pa)*dot(nor,pa)/dot2(nor) );<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SDF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>游戏分类</title>
      <link href="/2022/07/09/game/classfiy/"/>
      <url>/2022/07/09/game/classfiy/</url>
      
        <content type="html"><![CDATA[<h1 id="游戏分类"><a href="#游戏分类" class="headerlink" title="游戏分类"></a>游戏分类</h1><p><a href="../../index.md">back</a></p><p><a href="game_index.md">back to game</a></p><p>作者：陈迪飞<br>链接：<a href="https://www.zhihu.com/question/22248093/answer/20751642">https://www.zhihu.com/question/22248093/answer/20751642</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>ACT :ACTION.动作游戏.</p><p>A.RPG :ACTION ROLE PLAYING GAME.动作角色扮演游戏.</p><p>AVG :ADVENTURE GAME.冒险游戏.</p><p>A.AVG :ACTION ADVENTURE GAME.动作冒险游戏.</p><p>RPG :ROLE PLAYING GAME.角色扮演游戏.</p><p>ETC :其他类游戏.</p><p>FPS :FIRST PERSON SHOOTING .第一人称射击游戏.</p><p>FTG :FIGHTING GAME.格斗游戏.</p><p>GAL:美少女游戏</p><p>MMORPG :MASSIVE MULTI-PLAYER ONLINE ROLE PLAYING GAME.大型多人在线角色扮演游戏.</p><p>MUG :MUSIC GAME.音乐游戏.</p><p>MOBA:MULITIPLAYER ONLINE BATTLE ARENA GAME 多人在线竞技场类游戏</p><p>PUZ :PUZZLE.益智类游戏.</p><p>RAC :RACING.赛车,竞速类游戏.</p><p>RTS :REAL TIME STRATEGY.即时战略类游戏.</p><p>SLG :SIMULATION GAME.模拟&#x2F;战略类游戏.</p><p>S.RPG :SIMULATION ROLE PLAYING GAME.战略角色扮演类游戏.</p><p>SPG :SPORTS GAME.运动类游戏.</p><p>STG :SHOOTING GAME.射击类游戏.</p><p>TAB :TABLE.桌面游戏.</p><p>TCG:TRADING CARD GAME.集换式卡牌游戏</p>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>这里记录了一些游戏相关的基础</title>
      <link href="/2022/07/09/game/game_index/"/>
      <url>/2022/07/09/game/game_index/</url>
      
        <content type="html"><![CDATA[<h1 id="这里记录了一些游戏相关的基础"><a href="#这里记录了一些游戏相关的基础" class="headerlink" title="这里记录了一些游戏相关的基础"></a>这里记录了一些游戏相关的基础</h1><h2 id="游戏分类"><a href="#游戏分类" class="headerlink" title="游戏分类"></a>游戏分类</h2><p><a href="classfiy.md">游戏分类</a></p><p><a href="syn.md">游戏同步技术</a></p><p><a href="../../index.md">back</a></p>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>游戏同步技术</title>
      <link href="/2022/07/09/game/syn/"/>
      <url>/2022/07/09/game/syn/</url>
      
        <content type="html"><![CDATA[<h1 id="游戏同步技术"><a href="#游戏同步技术" class="headerlink" title="游戏同步技术"></a>游戏同步技术</h1><p><a href="../../index.md">back</a></p><p><a href="game_index.md">back to game</a></p><p>目前看到的同步技术分为帧同步和状态同步，针对的游戏环节为psp和cs两种模式。</p><p>腾讯手游在处理游戏同步中的模式：</p><p>本部分内容摘录自（<a href="http://mp.weixin.qq.com/s?__biz=MjM5MDI5MjAyMA==&mid=402528028&idx=1&sn=50b90cadc10d545865ebd6897fc6a6c0&scene=23&srcid=03191karOzdEnKKkG78DqeSR##">51CTO</a>）</p><p><strong>MMOG模式</strong></p><p>服务器负责计算全部的游戏逻辑，并且广播这些计算的结果，客户端仅仅负责发送玩家的操作，以及表现收到的游戏结果。</p><p>一般来说，玩家发送一个操作到服务器上，服务器根据玩家操作去修改内存中的游戏世界模型，同时运算游戏世界对这个操作的反应，然后把这些反应都广播给相关的多个客户端，每个客户端负责把这些数据表现出来给玩家看。</p><p>优点：安全，服务器只接受合法操作，逻辑简单。</p><p>缺点：依赖网络质量。人数多会导致广播数据量大，服务器运算过多。</p><p>结论：因此根据以上的特点，腾讯一般会在那些同局游戏人数不太多，但讲求玩法变化快和安全性高的游戏中采用这种同步方案。</p><p><strong>主机模式</strong></p><p>以参与对战的一个客户端为“主机”，其他的客户端为“副机”。游戏逻辑的主要运算由“主机”完成，所有的“副机”把操作指令，通过服务器中转，集中发送给“主机”；“主机”完成游戏运算后，把结果指令再通过服务器中转，广播给所有的“副机”。</p><p>优点：因此把整个游戏逻辑由客户端负责，就能让服务器端无需再开发这部分功能。服务器只负责做转发、广播的操作，所以能承载的人数和第一种方案有数量级上的差别。</p><p>结论：在以PVE玩法为主的游戏中，用户关注的是自己的体验，不会太在意同伴的准确动作，这种情况下，主机模式就是一种不错的同步方案。安全性依赖客户端</p><p><strong>帧同步模式</strong>（ <strong>传统单机-局域网游戏中最常用的。</strong>）</p><p>一般是以服务器按固定的帧率，来搜集每个客户端的输入，然后把这些输入广播给所有的客户端；由于每个操作指令到达所有客户端的时间（帧）都是一样的，所以每个客户端运算的结果也是一样的，同样的输入就会得到同样的结果。非常适合高度要求操作技巧的游戏。</p><p>优点：强一致性，由于广播的仅是玩家的操作，所以数据量很少。不管游戏中的角色数、状态量有多大、多复杂，都不会影响广播的数据量。另外在帧同步模式中，数据同步的频率较高，网络延迟越小越好。</p><p> 缺点：如果有一个客户端网络卡了，所有的客户端都要停下来等。由于TCP的滑动窗口机制和重传机制，导致延时无法控制，因此帧同步一般采用udp进行网络传输，但udp又会衍生出可靠性问题。安全性依赖客户端。</p>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Color Grading</title>
      <link href="/2022/07/09/post/ColorGrading/"/>
      <url>/2022/07/09/post/ColorGrading/</url>
      
        <content type="html"><![CDATA[<h1 id="Color-Grading"><a href="#Color-Grading" class="headerlink" title="Color Grading"></a>Color Grading</h1><p><strong>颜色分级就是一种颜色矫正。 Color Grading ，Color Correction。</strong></p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>色彩分级是让图像在不同设备不同环境下改进表现力的一种做法。</p><p>颜色、饱和度、灰阶、白平衡都可以增强。</p><p>色彩分级和色彩校正包括特殊的艺术化的图片处理都可以理解为一个类型的操作。</p><p>下面是wiki的描述:</p><p>Some of the main artistic functions of color correction (digital color grading):[<a href="https://en.wikipedia.org/wiki/Color_grading#cite_note-filmintovideo-1">1]</a></p><ul><li>Reproduce accurately what was shot</li><li>Compensate for variations in the material (i.e., film errors, white balance, varying lighting conditions)</li><li>Compensate for the intended viewing environment (dark, dim, bright surrounds)</li><li>Optimize base appearance for inclusion of special visual effects</li><li>Establish a desired artistic ‘look’</li><li>Enhance and&#x2F;or alter the mood of a scene — the visual equivalent to the musical accompaniment of a film; compare also <a href="https://en.wikipedia.org/wiki/Film_tinting">film tinting</a></li></ul><p>需要强调的一点是一些内容必须优先于另一些内容处理。</p><p>颜色分级通常有特殊的用处，例如：在拍天更好的制作夜景。</p><p>二级分级过去视为了让颜色更加的连续，现在则是为了追求艺术化得效果。</p><p>基础颜色分级：通过控制整个图像当中的RGB色彩密度曲线来控制整个图像。</p><p>二级颜色分级就是控制固定区间内容HSB的变化</p><h2 id="颜色矫正"><a href="#颜色矫正" class="headerlink" title="颜色矫正"></a>颜色矫正</h2><p>颜色分级是使用颜色矫正工具进行。</p><h3 id="白平衡"><a href="#白平衡" class="headerlink" title="白平衡"></a>白平衡</h3><p>在后期制作中发现的白平衡工具是基于专业摄像机上发现的白平衡设置。这些工具可以改变图像的颜色，<strong>使其在开氏温标下变暖或变冷</strong>。可以模拟日光和阴天的色温。</p><p><strong>该工具的主要目的是纠正用不正确调整白平衡设置拍摄的视频;</strong></p><p>它也可以创造性地用于模拟特定自然光照条件的外观。</p><h3 id="亮度和对比度"><a href="#亮度和对比度" class="headerlink" title="亮度和对比度"></a>亮度和对比度</h3><p>亮度和对比度就是两个滑块。</p><p>亮度和曝光度不是一个东西，如果场景曝光过渡或者曝光不足需要首先调节场景的曝光度。</p><p>颜色和对比度的滑块会互相影响。</p>]]></content>
      
      
      <categories>
          
          <category> HDRPSource </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PostProcessing V3版本的代码结构</title>
      <link href="/2022/07/09/post/PostprocessingV3/"/>
      <url>/2022/07/09/post/PostprocessingV3/</url>
      
        <content type="html"><![CDATA[<h1 id="PostProcessing-V3版本的代码结构"><a href="#PostProcessing-V3版本的代码结构" class="headerlink" title="PostProcessing V3版本的代码结构"></a>PostProcessing V3版本的代码结构</h1><p>Hdrp目前使用了PostV3版本，即将抛弃postV2，这里总结一下PostprocessingV3的基本代码结构。</p><p>PostV3是直接集成在HDRP当中的不需要在单独使用一个Package。</p><h2 id="源代码结构"><a href="#源代码结构" class="headerlink" title="源代码结构"></a>源代码结构</h2><p>源代码的位置如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">package/High Definition RP/Runtime/PostProcessing<br></code></pre></td></tr></table></figure><p>主要包括四个文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">GlobalPostProcessingSettings<br>IPostProcessComponent<span class="hljs-comment">// 后处理接口</span><br>PostProcessSystem <span class="hljs-comment">// 完整的后处理</span><br>TexctureCurve <span class="hljs-comment">//为了支持曲线属性，这里给AnimationCurve封装了一层。</span><br></code></pre></td></tr></table></figure><p>Shader文件都保存在Shaders目录当中，PostV3全部使用了ComputeShader。</p><p>所有后处理的组件保存在Components目录当中。下面以bloom为例分析V3后处理的实现方式。</p><h2 id="Bloom与后处理参数"><a href="#Bloom与后处理参数" class="headerlink" title="Bloom与后处理参数"></a>Bloom与后处理参数</h2><p>在Bloom.cs源文件当中和V2一样使用了**Parameter类型的类，内部实现了插值接口。这部分内容是和Volume是通用的。</p><p>每一个Parameter继承了VolumeParameter。目前支持的Parameter类型也都在VolumeParameter.cs源文件当中。</p><p>V3版本的后处理实现和V2当中不同的是: 不再单独的实现后处理(例如:Bloom.cs当中只保存了Parameter参数，而没有后处理实现)，而是所有的后处理全部都集中在了PostProcessSystem.cs文件当中。</p><h2 id="后处理实现"><a href="#后处理实现" class="headerlink" title="后处理实现"></a>后处理实现</h2><p>后处理实现都在PostProcessSystem.cs文件当中。</p><p>下面查看如何进行完整的后处理。</p><p>主要的类是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">public sealed <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostProcessSystem</span>&#123;</span>&#125;<br></code></pre></td></tr></table></figure><p>类当中首先保存了后处理的临时数据，纹理格式等不需要通过面板调整的参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Exposure data</span><br>       <span class="hljs-type">const</span> <span class="hljs-type">int</span> k_ExposureCurvePrecision = <span class="hljs-number">128</span>;<br>       readonly Color[] m_ExposureCurveColorArray = new Color[k_ExposureCurvePrecision];<br>       readonly <span class="hljs-type">int</span>[] m_ExposureVariants = new <span class="hljs-type">int</span>[<span class="hljs-number">4</span>];<br><br>       Texture2D m_ExposureCurveTexture;<br>       RTHandle m_EmptyExposureTexture; <span class="hljs-comment">// RGHalf</span><br><br>       <span class="hljs-comment">// Depth of field data</span><br>       ComputeBuffer m_BokehNearKernel;<br>       ComputeBuffer m_BokehFarKernel;<br>       ComputeBuffer m_BokehIndirectCmd;<br>       ComputeBuffer m_NearBokehTileList;<br>       ComputeBuffer m_FarBokehTileList;<br><br>       <span class="hljs-comment">// Bloom data</span><br>       <span class="hljs-type">const</span> <span class="hljs-type">int</span> k_MaxBloomMipCount = <span class="hljs-number">16</span>;<br>       readonly RTHandle[] m_BloomMipsDown = new RTHandle[k_MaxBloomMipCount + <span class="hljs-number">1</span>];<br>       readonly RTHandle[] m_BloomMipsUp = new RTHandle[k_MaxBloomMipCount + <span class="hljs-number">1</span>];<br>       RTHandle m_BloomTexture;<br><br>       <span class="hljs-comment">// Chromatic aberration data</span><br>       Texture2D m_InternalSpectralLut;<br><br>       <span class="hljs-comment">// Color grading data</span><br>       readonly <span class="hljs-type">int</span> m_LutSize;<br>       RTHandle m_InternalLogLut; <span class="hljs-comment">// ARGBHalf</span><br><br></code></pre></td></tr></table></figure><p>然后保存了各种后处理参数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">Exposure m_Exposure;<br>DepthOfField m_DepthOfField;<br>MotionBlur m_MotionBlur;<br>PaniniProjection m_PaniniProjection;<br>Bloom m_Bloom;<br>ChromaticAberration m_ChromaticAberration;<br>LensDistortion m_LensDistortion;<br>Vignette m_Vignette;<br>Tonemapping m_Tonemapping;<br>WhiteBalance m_WhiteBalance;<br>ColorAdjustments m_ColorAdjustments;<br>ChannelMixer m_ChannelMixer;<br>SplitToning m_SplitToning;<br>LiftGammaGain m_LiftGammaGain;<br>ShadowsMidtonesHighlights m_ShadowsMidtonesHighlights;<br>ColorCurves m_Curves;<br>FilmGrain m_FilmGrain;<br></code></pre></td></tr></table></figure><p>然后是初始化和清空数据的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-title function_">PostProcessSystem</span><span class="hljs-params">(HDRenderPipelineAsset hdAsset)</span><br>public <span class="hljs-type">void</span> <span class="hljs-title function_">Cleanup</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><p>抓取设置数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">BeginFrame（） <span class="hljs-comment">// 这里面从VolumeManager当中读取所有的后处理设置。</span><br><br>var <span class="hljs-built_in">stack</span> = VolumeManager.instance.<span class="hljs-built_in">stack</span>;<br>m_Exposure                  = <span class="hljs-built_in">stack</span>.GetComponent&lt;Exposure&gt;();<br>m_DepthOfField              = <span class="hljs-built_in">stack</span>.GetComponent&lt;DepthOfField&gt;();<br>m_MotionBlur                = <span class="hljs-built_in">stack</span>.GetComponent&lt;MotionBlur&gt;();<br>m_PaniniProjection          = <span class="hljs-built_in">stack</span>.GetComponent&lt;PaniniProjection&gt;();<br>m_Bloom                     = <span class="hljs-built_in">stack</span>.GetComponent&lt;Bloom&gt;();<br>m_ChromaticAberration       = <span class="hljs-built_in">stack</span>.GetComponent&lt;ChromaticAberration&gt;();<br>m_LensDistortion            = <span class="hljs-built_in">stack</span>.GetComponent&lt;LensDistortion&gt;();<br>m_Vignette                  = <span class="hljs-built_in">stack</span>.GetComponent&lt;Vignette&gt;();<br>m_Tonemapping               = <span class="hljs-built_in">stack</span>.GetComponent&lt;Tonemapping&gt;();<br>m_WhiteBalance              = <span class="hljs-built_in">stack</span>.GetComponent&lt;WhiteBalance&gt;();<br>m_ColorAdjustments          = <span class="hljs-built_in">stack</span>.GetComponent&lt;ColorAdjustments&gt;();<br>m_ChannelMixer              = <span class="hljs-built_in">stack</span>.GetComponent&lt;ChannelMixer&gt;();<br>m_SplitToning               = <span class="hljs-built_in">stack</span>.GetComponent&lt;SplitToning&gt;();<br>m_LiftGammaGain             = <span class="hljs-built_in">stack</span>.GetComponent&lt;LiftGammaGain&gt;();<br>m_ShadowsMidtonesHighlights = <span class="hljs-built_in">stack</span>.GetComponent&lt;ShadowsMidtonesHighlights&gt;();<br>m_Curves                    = <span class="hljs-built_in">stack</span>.GetComponent&lt;ColorCurves&gt;();<br>m_FilmGrain                 = <span class="hljs-built_in">stack</span>.GetComponent&lt;FilmGrain&gt;();<br></code></pre></td></tr></table></figure><p>进行后处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-type">void</span> <span class="hljs-title function_">Render</span><span class="hljs-params">(CommandBuffer cmd, HDCamera camera, BlueNoise blueNoise, RTHandle colorBuffer, RTHandle afterPostProcessTexture, RTHandle lightingBuffer, RenderTargetIdentifier finalRT, RTHandle depthBuffer, <span class="hljs-type">bool</span> flipY)</span><br></code></pre></td></tr></table></figure><p>所有的后处理都在名字为Do**的方法中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> DoStopNaNs<br><span class="hljs-type">void</span> DoDynamicExposure<br><span class="hljs-type">void</span> DoBloom<br>...<br></code></pre></td></tr></table></figure><h2 id="Render"><a href="#Render" class="headerlink" title="Render"></a>Render</h2><p>Render方法中是整合后处理的完整流程</p><p>首先是开启Sampler()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 首先获取Handler？</span><br>var dynResHandler = HDDynamicResolutionHandler.instance;<br><br><span class="hljs-comment">// Handler相关的出来</span><br><span class="hljs-keyword">if</span> (dynResHandler.HardwareDynamicResIsEnabled() &amp;&amp; dynResHandler.hasSwitchedResolution)<br>    m_Pool.Cleanup();<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PoolSource</span><span class="hljs-params">(ref RTHandle src, RTHandle dst)</span><br>&#123;<br>    <span class="hljs-comment">// Special case to handle the source buffer, we only want to send it back to our</span><br>    <span class="hljs-comment">// target pool if it&#x27;s not the input color buffer</span><br>    <span class="hljs-keyword">if</span> (src != colorBuffer) m_Pool.Recycle(src);<br>    src = dst;<br>&#125;<br><br><span class="hljs-comment">// 上面Handler部分没有详细研究，这个和SRP应该是相关的</span><br><span class="hljs-comment">//判断视图场景</span><br><span class="hljs-type">bool</span> isSceneView = camera.camera.cameraType == CameraType.SceneView;<br><br><br>using (new ProfilingSample(cmd, <span class="hljs-string">&quot;Post-processing&quot;</span>, <br>                      CustomSamplerId.PostProcessing.GetSampler()))<br>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在Sampler内部是完整的后处理过程，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (m_PostProcessEnabled)<br>&#123;<br>    <span class="hljs-comment">// 读取摄像机大小，设置渲染目标，可以看出来，这里的渲染使用的是commandbuffer的DrapProcedural，这里主要用来清空buffer，暂时这两个buffer用来做什么还没有详细研究。</span><br>    &#123;<br>        <span class="hljs-type">int</span> w = camera.actualWidth;<br>        <span class="hljs-type">int</span> h = camera.actualHeight;<br>        cmd.SetRenderTarget(source, <span class="hljs-number">0</span>, CubemapFace.Unknown, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-keyword">if</span> (w &lt; source.rt.width || h &lt; source.rt.height)<br>        &#123;<br>            cmd.SetViewport(new Rect(w, <span class="hljs-number">0</span>, k_RTGuardBandSize, h));<br>            cmd.DrawProcedural(Matrix4x4.identity, m_ClearBlackMaterial, <span class="hljs-number">0</span>, MeshTopology.Triangles, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>            cmd.SetViewport(new Rect(<span class="hljs-number">0</span>, h, w + k_RTGuardBandSize, k_RTGuardBandSize));<br>            cmd.DrawProcedural(Matrix4x4.identity, m_ClearBlackMaterial, <span class="hljs-number">0</span>, MeshTopology.Triangles, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//首先判断是否启用了后处理，启用后处理的第一步，就是处理stopNaNs。</span><br>    <span class="hljs-comment">//而且可以发现，如果要在Scene产生效果就需要特殊的设置。</span><br>    <span class="hljs-type">bool</span> stopNaNs = camera.stopNaNs;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_EDITOR</span><br>    <span class="hljs-keyword">if</span> (isSceneView)<br>            stopNaNs = HDRenderPipelinePreferences.sceneViewStopNaNs;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 清楚坏像素，否则在Bloom阶段会影响整个屏幕</span><br>    <span class="hljs-keyword">if</span> (stopNaNs)<br>    &#123;<br>        using (new ProfilingSample(cmd, <span class="hljs-string">&quot;Stop NaNs&quot;</span>, CustomSamplerId.StopNaNs.GetSampler()))<br>        &#123;<br>            var destination = m_Pool.Get(Vector2.one, k_ColorFormat);<br>            DoStopNaNs(cmd, camera, source, destination);<br>            PoolSource(ref source, destination);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Bloom"><a href="#Bloom" class="headerlink" title="Bloom"></a>Bloom</h2><p>后处理的过程大体如上，现在详细看一下Bloom效果。</p><p>下面是Bloom部分的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> bloomActive = m_Bloom.IsActive();<br><br><span class="hljs-keyword">if</span> (bloomActive)<br>&#123;<br>    using (new ProfilingSample(cmd, <span class="hljs-string">&quot;Bloom&quot;</span>, CustomSamplerId.Bloom.GetSampler()))<br>    &#123;<br>        <span class="hljs-comment">// 这里开启Bloom</span><br>        DoBloom(cmd, camera, source, cs, kernel);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-comment">// 这里可以看到如果没有开启Bloom那么会设置几个默认的Bloom参数，也就是DoBloom最终要生成的结果。</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    _BloomTexture Bloom纹理</span><br><span class="hljs-comment">    _BloomDirtTexture BloomDirtexture纹理</span><br><span class="hljs-comment">    _BloomParams Bloom参数</span><br><span class="hljs-comment">    上面的三个参数在Bloom开启式，在DoBloom中生产</span><br><span class="hljs-comment">    */</span><br>    cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._BloomTexture, TextureXR.GetBlackTexture());<br>    cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._BloomDirtTexture, Texture2D.blackTexture);<br>    cmd.SetComputeVectorParam(cs, HDShaderIDs._BloomParams, Vector4.zero);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面看在DoBloom当中如何生成参数：</p><p>​    _BloomTexture Bloom纹理<br>​    _BloomDirtTexture BloomDirtexture纹理<br>​    _BloomParams Bloom参数</p><p>下面是DoBloom方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 首先计算Bloom贴图的大小，1/2 或者 1/4 分别对应half和quater</span><br>var resolution = m_Bloom.resolution.value;<br><span class="hljs-type">float</span> scaleW = <span class="hljs-number">1f</span> / ((<span class="hljs-type">int</span>)resolution / <span class="hljs-number">2f</span>);<br><span class="hljs-type">float</span> scaleH = <span class="hljs-number">1f</span> / ((<span class="hljs-type">int</span>)resolution / <span class="hljs-number">2f</span>);<br><br><span class="hljs-comment">// 下面是Bloom的变形和失真</span><br><span class="hljs-keyword">if</span> (m_Bloom.anamorphic.value)<br>&#123;<br>    <span class="hljs-comment">// 这里需要一个屋里摄像机的参数，用来控制XY方向的变形。</span><br>    <span class="hljs-type">float</span> anamorphism = m_PhysicalCamera.anamorphism * <span class="hljs-number">0.5f</span>;<br>    scaleW *= anamorphism &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1f</span> + anamorphism : <span class="hljs-number">1f</span>;<br>    scaleH *= anamorphism &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1f</span> - anamorphism : <span class="hljs-number">1f</span>;<br>&#125;<br><br><span class="hljs-comment">// 下面决定Bloom的迭代次数</span><br><span class="hljs-comment">// 首先计算最大长宽</span><br><span class="hljs-type">int</span> maxSize = Mathf.Max(camera.actualWidth, camera.actualHeight);<br><span class="hljs-comment">// 根据Log得到/2的整数并且考虑是half和quater，计算/2次数</span><br><span class="hljs-type">int</span> iterations = Mathf.FloorToInt(Mathf.Log(maxSize, <span class="hljs-number">2f</span>) - <span class="hljs-number">2</span> - (resolution == BloomResolution.Half ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>));<br><span class="hljs-comment">// 根据迭代次数</span><br><span class="hljs-type">int</span> mipCount = Mathf.Clamp(iterations, <span class="hljs-number">1</span>, k_MaxBloomMipCount);<br>var mipSizes = stackalloc Vector2Int[mipCount];<br><br><span class="hljs-comment">//第一次循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mipCount; i++)<br>&#123;<br>    <span class="hljs-comment">// 缩小的比例，每次缩小1/2</span><br>    <span class="hljs-type">float</span> p = <span class="hljs-number">1f</span> / Mathf.Pow(<span class="hljs-number">2f</span>, i + <span class="hljs-number">1f</span>);<br>    <span class="hljs-comment">// 缩小后的比例，叠加了走样比例</span><br>    <span class="hljs-type">float</span> sw = scaleW * p;<br>    <span class="hljs-type">float</span> sh = scaleH * p;<br>    <span class="hljs-comment">// 当前mip的实际像素大小。</span><br>    <span class="hljs-type">int</span> pw = Mathf.Max(<span class="hljs-number">1</span>, Mathf.RoundToInt(sw * camera.actualWidth));<br>    <span class="hljs-type">int</span> ph = Mathf.Max(<span class="hljs-number">1</span>, Mathf.RoundToInt(sh * camera.actualHeight));<br>    <span class="hljs-comment">// 缩放比例</span><br>    var scale = new Vector2(sw, sh);<br>    <span class="hljs-comment">// 像素大小</span><br>    var pixelSize = new Vector2Int(pw, ph);<br><br>    mipSizes[i] = pixelSize;<br>    <span class="hljs-comment">// 获取对应的RT</span><br>    m_BloomMipsDown[i] = m_Pool.Get(scale, k_ColorFormat);<br>    m_BloomMipsUp[i] = m_Pool.Get(scale, k_ColorFormat);<br>&#125;<br><br><span class="hljs-comment">// 这里定义了一个局部函数，主要的作用是进行上下采样。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DispatchWithGuardBands</span><span class="hljs-params">(ComputeShader shader, <span class="hljs-type">int</span> kernelId, in Vector2Int size)</span><br>&#123;<br>    <span class="hljs-type">int</span> w = size.x;<br>    <span class="hljs-type">int</span> h = size.y;<br><br>    <span class="hljs-keyword">if</span> (w &lt; source.rt.width &amp;&amp; w % <span class="hljs-number">8</span> &lt; k_RTGuardBandSize)<br>        w += k_RTGuardBandSize;<br>    <span class="hljs-keyword">if</span> (h &lt; source.rt.height &amp;&amp; h % <span class="hljs-number">8</span> &lt; k_RTGuardBandSize)<br>        h += k_RTGuardBandSize;<br><br>    cmd.DispatchCompute(shader, kernelId, (w + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>, (h + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>, camera.computePassCount);<br>&#125;<br><br><span class="hljs-comment">// 首先第一步是prefilter，对图像进行预滤波</span><br><span class="hljs-comment">// Pre-filtering</span><br>ComputeShader cs;<br><span class="hljs-type">int</span> kernel;<br><br><span class="hljs-keyword">if</span> (m_Bloom.prefilter.value)<br>&#123;<br>    var size = mipSizes[<span class="hljs-number">0</span>];<br>    cs = m_Resources.shaders.bloomPrefilterCS;<br>    kernel = cs.FindKernel(<span class="hljs-string">&quot;KMain&quot;</span>);<br><br>    cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._InputTexture, source);<br>    cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._OutputTexture, m_BloomMipsUp[<span class="hljs-number">0</span>]); <span class="hljs-comment">// Use m_BloomMipsUp as temp target</span><br>    cmd.SetComputeVectorParam(cs, HDShaderIDs._TexelSize, new Vector4(size.x, size.y, <span class="hljs-number">1f</span> / size.x, <span class="hljs-number">1f</span> / size.y));<br>    DispatchWithGuardBands(cs, kernel, size);<br><br>    cs = m_Resources.shaders.bloomBlurCS;<br>    kernel = cs.FindKernel(<span class="hljs-string">&quot;KMain&quot;</span>); <span class="hljs-comment">// Only blur</span><br><br>    cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._InputTexture, m_BloomMipsUp[<span class="hljs-number">0</span>]);<br>    cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._OutputTexture, m_BloomMipsDown[<span class="hljs-number">0</span>]);<br>    cmd.SetComputeVectorParam(cs, HDShaderIDs._TexelSize, new Vector4(size.x, size.y, <span class="hljs-number">1f</span> / size.x, <span class="hljs-number">1f</span> / size.y));<br>    DispatchWithGuardBands(cs, kernel, size);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    var size = mipSizes[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// bloom的Blur用来下采样</span><br>    cs = m_Resources.shaders.bloomBlurCS;<br>    kernel = cs.FindKernel(<span class="hljs-string">&quot;KMainDownsample&quot;</span>);<br><br>    <span class="hljs-comment">// 设置输入和输出的纹理</span><br>    cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._InputTexture, source);<br>    cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._OutputTexture, m_BloomMipsDown[<span class="hljs-number">0</span>]);<br>    <br>    <span class="hljs-comment">// 设置尺寸参数，进行第一次下采样</span><br>    cmd.SetComputeVectorParam(cs, HDShaderIDs._TexelSize, new Vector4(size.x, size.y, <span class="hljs-number">1f</span> / size.x, <span class="hljs-number">1f</span> / size.y));<br>    DispatchWithGuardBands(cs, kernel, size);<br>&#125;<br><br><span class="hljs-comment">// Blur pyramid</span><br><br><span class="hljs-comment">// 进行模糊金字塔的构建。这部分就是不断的进行1/2的下采样。</span><br>kernel = cs.FindKernel(<span class="hljs-string">&quot;KMainDownsample&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mipCount - <span class="hljs-number">1</span>; i++)<br>&#123;<br>    var src = m_BloomMipsDown[i];<br>    var dst = m_BloomMipsDown[i + <span class="hljs-number">1</span>];<br>    var size = mipSizes[i + <span class="hljs-number">1</span>];<br><br>    cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._InputTexture, src);<br>    cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._OutputTexture, dst);<br>    cmd.SetComputeVectorParam(cs, HDShaderIDs._TexelSize, new Vector4(size.x, size.y, <span class="hljs-number">1f</span> / size.x, <span class="hljs-number">1f</span> / size.y));<br>    DispatchWithGuardBands(cs, kernel, size);<br>&#125;<br><br><span class="hljs-comment">// Upsample &amp; combine</span><br><br><span class="hljs-comment">// 进行模糊金字塔的构建。这部分就是不断的进行1/2的上采样。</span><br>cs = m_Resources.shaders.bloomUpsampleCS;<br>kernel = cs.FindKernel(m_Bloom.highQualityFiltering.value ? <span class="hljs-string">&quot;KMainHighQ&quot;</span> : <span class="hljs-string">&quot;KMainLowQ&quot;</span>);<br><br><span class="hljs-type">float</span> scatter = Mathf.Lerp(<span class="hljs-number">0.05f</span>, <span class="hljs-number">0.95f</span>, m_Bloom.scatter.value);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mipCount - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br>    var low = (i == mipCount - <span class="hljs-number">2</span>) ? m_BloomMipsDown : m_BloomMipsUp;<br>    var srcLow = low[i + <span class="hljs-number">1</span>];<br>    var srcHigh = m_BloomMipsDown[i];<br>    var dst = m_BloomMipsUp[i];<br>    var highSize = mipSizes[i];<br>    var lowSize = mipSizes[i + <span class="hljs-number">1</span>];<br><br>    cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._InputLowTexture, srcLow);<br>    cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._InputHighTexture, srcHigh);<br>    cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._OutputTexture, dst);<br>    cmd.SetComputeVectorParam(cs, HDShaderIDs._Params, new Vector4(scatter, <span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>));<br>    cmd.SetComputeVectorParam(cs, HDShaderIDs._BloomBicubicParams, new Vector4(lowSize.x, lowSize.y, <span class="hljs-number">1f</span> / lowSize.x, <span class="hljs-number">1f</span> / lowSize.y));<br>    cmd.SetComputeVectorParam(cs, HDShaderIDs._TexelSize, new Vector4(highSize.x, highSize.y, <span class="hljs-number">1f</span> / highSize.x, <span class="hljs-number">1f</span> / highSize.y));<br>    DispatchWithGuardBands(cs, kernel, highSize);<br>&#125;<br><br><span class="hljs-comment">//上采样和下采样的具体算法需要和V2进行比较一下。</span><br><br><span class="hljs-comment">// Cleanup 清楚掉Buffer的数据，回收</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mipCount; i++)<br>&#123;<br>    m_Pool.Recycle(m_BloomMipsDown[i]);<br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) m_Pool.Recycle(m_BloomMipsUp[i]);<br>&#125;<br><br><span class="hljs-comment">// Set uber data 设置Bloom的相关数据</span><br>var bloomSize = mipSizes[<span class="hljs-number">0</span>];<br>m_BloomTexture = m_BloomMipsUp[<span class="hljs-number">0</span>]; <span class="hljs-comment">//得到了Bloom的纹理</span><br><br><span class="hljs-comment">// 计算Bloom强度</span><br><span class="hljs-type">float</span> intensity = Mathf.Pow(<span class="hljs-number">2f</span>, m_Bloom.intensity.value) - <span class="hljs-number">1f</span>; <span class="hljs-comment">// Makes intensity easier to control</span><br><span class="hljs-comment">// Bloom颜色</span><br>var tint = m_Bloom.tint.value.linear;<br>var luma = ColorUtils.Luminance(tint);<br>tint = luma &gt; <span class="hljs-number">0f</span> ? tint * (<span class="hljs-number">1f</span> / luma) : Color.white;<br><br><span class="hljs-comment">// 镜头污渍：这部分应该不怎么使用，后续再了解原理</span><br><span class="hljs-comment">// Lens dirtiness</span><br><span class="hljs-comment">// Keep the aspect ratio correct &amp; center the dirt texture, we don&#x27;t want it to be</span><br><span class="hljs-comment">// stretched or squashed</span><br>var dirtTexture = m_Bloom.dirtTexture.value == null ? Texture2D.blackTexture : m_Bloom.dirtTexture.value;<br><span class="hljs-type">int</span> dirtEnabled = m_Bloom.dirtTexture.value != null &amp;&amp; m_Bloom.dirtIntensity.value &gt; <span class="hljs-number">0f</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><span class="hljs-type">float</span> dirtRatio = (<span class="hljs-type">float</span>)dirtTexture.width / (<span class="hljs-type">float</span>)dirtTexture.height;<br><span class="hljs-type">float</span> screenRatio = (<span class="hljs-type">float</span>)camera.actualWidth / (<span class="hljs-type">float</span>)camera.actualHeight;<br>var dirtTileOffset = new Vector4(<span class="hljs-number">1f</span>, <span class="hljs-number">1f</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>);<br><span class="hljs-type">float</span> dirtIntensity = m_Bloom.dirtIntensity.value * intensity;<br><span class="hljs-keyword">if</span> (dirtRatio &gt; screenRatio)<br>&#123;<br>    dirtTileOffset.x = screenRatio / dirtRatio;<br>    dirtTileOffset.z = (<span class="hljs-number">1f</span> - dirtTileOffset.x) * <span class="hljs-number">0.5f</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (screenRatio &gt; dirtRatio)<br>&#123;<br>    dirtTileOffset.y = dirtRatio / screenRatio;<br>    dirtTileOffset.w = (<span class="hljs-number">1f</span> - dirtTileOffset.y) * <span class="hljs-number">0.5f</span>;<br>&#125;<br><br><span class="hljs-comment">//下面就是把计算好的参数设置。</span><br><br>cmd.SetComputeTextureParam(uberCS, uberKernel, HDShaderIDs._BloomTexture, m_BloomTexture);<br>cmd.SetComputeTextureParam(uberCS, uberKernel, HDShaderIDs._BloomDirtTexture, dirtTexture);<br>cmd.SetComputeVectorParam(uberCS, HDShaderIDs._BloomParams, new Vector4(intensity, dirtIntensity, <span class="hljs-number">1f</span>, dirtEnabled));<br>cmd.SetComputeVectorParam(uberCS, HDShaderIDs._BloomTint, (Vector4)tint);<br>cmd.SetComputeVectorParam(uberCS, HDShaderIDs._BloomBicubicParams, new Vector4(bloomSize.x, bloomSize.y, <span class="hljs-number">1f</span> / bloomSize.x, <span class="hljs-number">1f</span> / bloomSize.y));<br>cmd.SetComputeVectorParam(uberCS, HDShaderIDs._BloomDirtScaleOffset, dirtTileOffset);<br></code></pre></td></tr></table></figure><p>我们法线这里只是把需要的参数设置给computeShader，实际的计算是在UberPost.compute文件当中的。</p><p> <strong>Chromatic aberration ， Bloom，Vignette，Grading, tonemapping这几个特效是同时在一个Pass当中写入到屏幕当中的。</strong></p><p>前面的内容只是在给这个cs设置参数。在最后合并所有结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Run</span><br>var destination = m_Pool.Get(Vector2.one, k_ColorFormat);<br>cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._InputTexture, source);<br>cmd.SetComputeTextureParam(cs, kernel, HDShaderIDs._OutputTexture, destination);<br>cmd.DispatchCompute(cs, kernel, (camera.actualWidth + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>, (camera.actualHeight + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>, camera.computePassCount);<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> post </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HDRP自定义后处理</title>
      <link href="/2022/07/09/post/HDRP%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8E%E5%A4%84%E7%90%86/"/>
      <url>/2022/07/09/post/HDRP%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8E%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="HDRP自定义后处理"><a href="#HDRP自定义后处理" class="headerlink" title="HDRP自定义后处理"></a>HDRP自定义后处理</h1><p>在HDRP当中， commandbuffer无法通过AddCommandBuffer的方式被摄像机调用，所以需要使用别的方法。</p><p>目前有两种方式可以插入自己的渲染内容：<strong>重写渲染流程</strong>和<strong>扩展PPV3代码</strong>。</p><h2 id="重写渲染流程"><a href="#重写渲染流程" class="headerlink" title="重写渲染流程"></a>重写渲染流程</h2><p>通过重写HDAdditionalCameraData的CunstomRender方法。</p><p>重写后的CustomRender方法会在HDRenderPipeline当中被调用。</p><p>调用方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">protected override <span class="hljs-type">void</span> <span class="hljs-title function_">Render</span><span class="hljs-params">(ScriptableRenderContext renderContext, Camera[] cameras)</span><br>&#123;<br>    ...<br><span class="hljs-comment">// Culling loop</span><br>    foreach (var camera in cameras)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (camera == null)<br>            <span class="hljs-keyword">continue</span>;<br>        <br>        ...<br>        <span class="hljs-comment">// 如果当前摄像机有additionalCameraData类型的脚本，并且脚本当中的CustomRender被重写，那么就会走自定义的摄像机流程。</span><br>        <span class="hljs-keyword">if</span> (additionalCameraData != null &amp;&amp; additionalCameraData.hasCustomRender)<br>        &#123;<br>            skipRequest = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// Execute custom render</span><br>            additionalCameraData.ExecuteCustomRender(renderContext, hdCamera);<br>        &#125;<br>        <br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>目前这个方法可以用于自定义整个摄像机的渲染过程。</p><h2 id="扩展PPV3代码"><a href="#扩展PPV3代码" class="headerlink" title="扩展PPV3代码"></a>扩展PPV3代码</h2><p>目前要添加自定义的后处理，就需要扩展PPV3的代码。</p><p>通过阅读PPV3的源代码，我们可以仿照他的代码进行自定义的后处理。</p><h3 id="PPV3后处理原理"><a href="#PPV3后处理原理" class="headerlink" title="PPV3后处理原理"></a>PPV3后处理原理</h3><p>下面简单的解释一下新版PPV3实现的过程。</p><p>PostProcessSystem.cs是整个后处理的处理过程。</p><p>其中下面的方法是在HDRenderPipeline当中调用的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-type">void</span> <span class="hljs-title function_">Render</span><span class="hljs-params">(CommandBuffer cmd, HDCamera camera, BlueNoise blueNoise, RTHandle colorBuffer, RTHandle afterPostProcessTexture, RTHandle lightingBuffer, RenderTargetIdentifier finalRT, RTHandle depthBuffer, <span class="hljs-type">bool</span> flipY)</span><br>&#123;&#125;<br><br></code></pre></td></tr></table></figure><p>也就是说后处理直接被HDRP的渲染流程集成了，无法再通过独立的代码执行。调用位置如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"> ...<br>     <span class="hljs-comment">// Set the depth buffer to the main one to avoid missing out on transparent depth for post process.</span><br>     cmd.SetGlobalTexture(HDShaderIDs._CameraDepthTexture, m_SharedRTManager.GetDepthStencilBuffer());<br><br>    <span class="hljs-comment">// Post-processes output straight to the backbuffer</span><br>    m_PostProcessSystem.Render(<br>        cmd: cmd,<br>        camera: hdCamera,<br>        blueNoise: m_BlueNoise,<br>        colorBuffer: m_CameraColorBuffer,<br>        afterPostProcessTexture: GetAfterPostProcessOffScreenBuffer(),<br>        lightingBuffer: null,<br>        finalRT: destination,<br>        depthBuffer: m_SharedRTManager.GetDepthStencilBuffer(),<br>        flipY: flipInPostProcesses<br>                );<br><br>    StopStereoRendering(cmd, renderContext, hdCamera.camera);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在后处理的Render方法当中，主要通过CommandBuffer进行渲染控制，具体的渲染方式有3种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>cmd.DispatchCompute <span class="hljs-comment">// 通过ComputeShader直接写入对应像素。</span><br><span class="hljs-number">2.</span>HDUtils.DrawFullScreen(); <br><span class="hljs-comment">// 通过绘制全屏的颜色，底层原理是cmd.DrawProcedural</span><br><span class="hljs-number">3.</span>cmd.Blit<br></code></pre></td></tr></table></figure><p>理论上可以使用CommandBuffer的所有方法，具体还没有测试，我们可以根据需要使用不同的方式，进行后处理。</p><h3 id="自定义后处理"><a href="#自定义后处理" class="headerlink" title="自定义后处理"></a>自定义后处理</h3><p>在后处理的Render方法中可以搜索下面的注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> User effects go here</span><br></code></pre></td></tr></table></figure><p>我猜测这个是Unity给自定义后处理留的位置。</p><p>我们可以插入代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> User effects go here</span><br>&#123;<br>    <span class="hljs-comment">// 开启Profiler</span><br>    using (new ProfilingSample(cmd, <span class="hljs-string">&quot;UserEffect&quot;</span>))<br>    &#123;<br>        <span class="hljs-comment">// 从缓存池中获取一个渲染RT：destination。</span><br>        var destination = m_Pool.Get(Vector2.one, k_ColorFormat);<br>        <br>        <span class="hljs-comment">// 设置材质参数：m_CustomMaterial需要提前设置好，是我们的后处理材质。</span><br>        m_CustomMaterial.SetTexture(HDShaderIDs._InputTexture, source);<br>        <br>        <span class="hljs-comment">// 调用工具方法将结果绘制到destination当中。</span><br>        HDUtils.DrawFullScreen(cmd, camera, m_CustomMaterial, destination);<br>        <br>        <span class="hljs-comment">// 将渲染目标destination回收到缓存池，并把结果还原到source用于接下来的计算。</span><br>        PoolSource(ref source, destination);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中source是上下文已经设置好的输入贴图，会在接下来继续处理。</p><p>所以我们要做的就是操作source，并且输出source。</p><p>这个过程相当于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Render</span><span class="hljs-params">(RT source, RT destination)</span><br>&#123;<br>cmd.Blit(source, destination,m_CustomMaterial);<br>&#125;<br></code></pre></td></tr></table></figure><p>注：</p><ol><li><p>另外还需要判断Scene视图等操作。</p></li><li><p>同时还要注意DrawProcedural的Vertex部分要特殊处理。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> post </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Caffe源代码阅读笔记</title>
      <link href="/2022/07/09/caffe_reader/caffe_index/"/>
      <url>/2022/07/09/caffe_reader/caffe_index/</url>
      
        <content type="html"><![CDATA[<h1 id="Caffe源代码阅读笔记"><a href="#Caffe源代码阅读笔记" class="headerlink" title="Caffe源代码阅读笔记"></a>Caffe源代码阅读笔记</h1><p>之后打算深入学习，深度学习的内容，同时考虑到使用c++的需求。接下来大学阅读caffe的源代码。主要的笔记目录将会记录在这一部分</p><p><a href="caffe.md">caffe安装</a></p><h2 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h2><p><a href="src_blob_cpp.md">blob学习</a></p><h2 id="layer"><a href="#layer" class="headerlink" title="layer"></a>layer</h2><p><a href="src_layer_cpp.md">layer学习</a></p><h2 id="net"><a href="#net" class="headerlink" title="net"></a>net</h2><h2 id="solver"><a href="#solver" class="headerlink" title="solver"></a>solver</h2><p><a href="../../index.md">back</a></p>]]></content>
      
      
      <categories>
          
          <category> caffe </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>介绍caffe的安装过程</title>
      <link href="/2022/07/09/caffe_reader/caffe/"/>
      <url>/2022/07/09/caffe_reader/caffe/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍caffe的安装过程"><a href="#介绍caffe的安装过程" class="headerlink" title="介绍caffe的安装过程"></a>介绍caffe的安装过程</h1><blockquote><p>首先需要从github上clone最新的代码</p></blockquote><blockquote><p>官方提到的安装方式有两种：cmake和make两种方式</p></blockquote><blockquote><p>建议使用官方方式，因为使用example的时候不太一样</p></blockquote><p><a href="https://github.com/BVLC/caffe">Github Caffe</a></p><p><a href="http://caffe.berkeleyvision.org/">Caffe 官方网站</a></p><p>在安装的过程当中遇到了两种问题</p><ol><li>(30 vs.0)这个问题主要是由于cuda版本和显卡驱动的版本不匹配。通过官方下载最新的显卡驱动就能解决</li><li>(8 vs .0)这个问题主要是由于，显卡无法容纳batchsize，调小就可以了。</li><li>还有可能提及到libopencv*的错误，这个需要是由于没能够找到合适的opencv，看情况重新编译，或者制定目录即可。</li></ol><p><a href="../../index.md">back to list</a></p>]]></content>
      
      
      <categories>
          
          <category> caffe </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>blob.cpp</title>
      <link href="/2022/07/09/caffe_reader/src_blob_cpp/"/>
      <url>/2022/07/09/caffe_reader/src_blob_cpp/</url>
      
        <content type="html"><![CDATA[<h1 id="blob-cpp"><a href="#blob-cpp" class="headerlink" title="blob.cpp"></a>blob.cpp</h1><p><a href="../../index.md">back</a></p><p><a href="caffe_index.md">back to caffe</a></p><p>注释当中的解释是：同步内存的包装器，基本的计算单元。</p><p>这部分内容主要来自两个文件： <strong>blob.cpp</strong> 和 <strong>blob.hpp</strong></p><p>先来看看Bolb的初始化，除了默认的初始化构造函数之外，就是需要通过尺寸定义一个内存空间。</p><ol><li>num: 每个batch的尺寸</li><li>channels: 图像的通道数</li><li>height、weight: 图像的大小</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">Blob(): data_(), diff_(), count_(<span class="hljs-number">0</span>), capacity_(<span class="hljs-number">0</span>) &#123;&#125;<br>Blob(<span class="hljs-type">const</span> <span class="hljs-type">int</span> num, <span class="hljs-type">const</span> <span class="hljs-type">int</span> channels, <span class="hljs-type">const</span> <span class="hljs-type">int</span> height, <span class="hljs-type">const</span> <span class="hljs-type">int</span> width);<br>Blob(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; shape);<br></code></pre></td></tr></table></figure><p>除了通过构造函数能够决定内存空间的大小外，也可以通过成员函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Reshape</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> num, <span class="hljs-type">const</span> <span class="hljs-type">int</span> channels, <span class="hljs-type">const</span> <span class="hljs-type">int</span> height, <span class="hljs-type">const</span> <span class="hljs-type">int</span> width)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Reshape</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; shape)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Reshape</span><span class="hljs-params">(<span class="hljs-type">const</span> BlobShape&amp; shape)</span>;<br></code></pre></td></tr></table></figure><p>需要保存的内容主要是三种：前向计算的输入，后向计算的梯度和尺寸大小。这些内容保存在SynceMemory当中，通过智能指针shared_ptr管理。同时count_表示总大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">shared_ptr</span>&lt;SyncedMemory&gt; data_;<br><span class="hljs-built_in">shared_ptr</span>&lt;SyncedMemory&gt; diff_;<br><span class="hljs-built_in">shared_ptr</span>&lt;SyncedMemory&gt; shape_data_;<br><span class="hljs-type">int</span> count_;<span class="hljs-comment">//data_或diff_需要占用的大小；</span><br><span class="hljs-type">int</span> capacity_;<span class="hljs-comment">//表示当前所申请空间的大小，如果count_&gt;capacity_则需要重新申请空间</span><br></code></pre></td></tr></table></figure><p>在reshape当中如果尺寸变大，则需要重新申请空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//shape_ 是vector&lt;int&gt;成员变量,shape</span><br><span class="hljs-keyword">if</span> (!shape_data_ || shape_data_-&gt;size() &lt; shape.size() * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)) &#123;<br>    shape_data_.reset(new SyncedMemory(shape.size() * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)));<br>&#125;<br><span class="hljs-comment">//如果count_&gt;capacity_则需要重新申请空间</span><br><span class="hljs-keyword">if</span> (count_ &gt; capacity_) &#123;<br>    capacity_ = count_;<br>    data_.reset(new SyncedMemory(capacity_ * <span class="hljs-keyword">sizeof</span>(Dtype)));<br>diff_.reset(new SyncedMemory(capacity_ * <span class="hljs-keyword">sizeof</span>(Dtype)));<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的内容主要是申请空间，然后通过以下方法访问数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">data_-&gt;gpu_data();<br>data_-&gt;cpu_data();<br>data_-&gt;mutable_gpu_data();<br>data_-&gt;mutable_cpu_data();<br></code></pre></td></tr></table></figure><p>其中还有两个重要的方法，使用了google的格式.proto，这个随后再看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">template &lt;typename Dtype&gt; <span class="hljs-type">void</span> Blob&lt;Dtype&gt;::FromProto(<span class="hljs-type">const</span> BlobProto&amp; proto, <span class="hljs-type">bool</span> reshape)<br>template &lt;&gt; <span class="hljs-type">void</span> Blob&lt;<span class="hljs-type">double</span>&gt;::ToProto(BlobProto* proto, <span class="hljs-type">bool</span> write_diff)<br></code></pre></td></tr></table></figure><p>进行不同格式的转换。</p>]]></content>
      
      
      <categories>
          
          <category> caffe </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>layer.cpp</title>
      <link href="/2022/07/09/caffe_reader/src_layer_cpp/"/>
      <url>/2022/07/09/caffe_reader/src_layer_cpp/</url>
      
        <content type="html"><![CDATA[<h1 id="layer-cpp"><a href="#layer-cpp" class="headerlink" title="layer.cpp"></a>layer.cpp</h1><p><a href="../../index.md">back</a><br><a href="caffe_index.md">back to caffe</a></p><ol><li>这一部分的的内容主要了解一下layer是如何构建的。代码当中的解释是：构成网络的基本组件。</li><li>Layer必须实现的函数包括<strong>Forward</strong>和<strong>Backward</strong>函数。</li><li>每一个Layer都对应两个Blob(每一个Blob当中有data_ 和diff_两个空间来分别保存数据本身和数据的梯度，具体见blob)。</li><li>在Forward当中，从bottom blob当中读取输入数据进行当前层定义的计算（卷积、pooling、ReLu等），然后输出到top blob当中。因为caffe网络的定义是从低向上的，所以每一层都是从bottom读取想top输出。</li><li>Backward层当中，从top blob当中提取数据进行梯度计算，输出到bottom blob当中。</li></ol><p>首先来看一下每个layer当中保存的成员变量和成员函数<br>第一部分是对于锁的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> is_shared_; <span class="hljs-comment">//表示是否是一个被多个网络共享的层</span><br><span class="hljs-built_in">shared_ptr</span>&lt;boost::mutex&gt; forward_mutex_; <span class="hljs-comment">//如果一个层是被共享的，则需要一个互斥锁</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitMutex</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Lock</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Unlock</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>下面是对一个layer需要的基本的成员变量，我们要知道top和bottom的blob当中保存的是每一层的输入和输出的数据，而每一层当中的blob是等待学习的参数。对于一个卷积层而言下面代码中vectoer当中的每一个blob都保存的是一个卷积。对于top和bottom的blob都是保存在vector当中的，一个vector表示的是一个batch，一个元素是一个数据。所以top.size应该等于bottom.size。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">LayerParameter layer_param_; <span class="hljs-comment">//protobuf结构，保存层的参数</span><br>Phase phase_; <span class="hljs-comment">//记录当前所处的阶段，训练阶段还是测试阶段</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">shared_ptr</span>&lt;Blob&lt;Dtype&gt; &gt; &gt; blobs_;<span class="hljs-comment">//记录一系列等待学习的参数</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt; param_propagate_down_; <span class="hljs-comment">//记录每一个参数是否需要计算梯度</span><br><span class="hljs-built_in">vector</span>&lt;Dtype&gt; loss_; <span class="hljs-comment">//每个目标函数在top 中是否有非零的权重向量</span><br></code></pre></td></tr></table></figure><p>在每一次初始化的过程中，需要调用下面的函数对layer进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SetUp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;Blob&lt;Dtype&gt;*&gt;&amp; top)</span> &#123;<br>    InitMutex(); <span class="hljs-comment">//初始化互斥锁</span><br>    CheckBlobCounts(bottom, top); <span class="hljs-comment">//检查输入输出数据的数量是否匹配</span><br>    LayerSetUp(bottom, top); <span class="hljs-comment">//对层做一些设置,目前是一个空函数</span><br>    Reshape(bottom, top);<span class="hljs-comment">//根据输入输出对每一个训练参数进行大小调整,目前是纯虚函数</span><br>    SetLossWeights(top);<span class="hljs-comment">//设置误差权重，对呀loss的设置还有一系列的内容，随后再看看</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面就是最重要的backward和forward,这两个函数中目前已经实现了一个框架负责调用我们自己的实现。我们可以清楚的看到这里前向和后向都分别有gpu和cpu版本，cpu版本目前全部都是纯虚函数，而GPU版本暂时直接调用cpu所以在继承时，cpu版本必须实现而gpu不一定需要实现。</p><p>对于被多个网络共享的层使用了锁，为什么反向传播没有使用锁呢？</p><p>另外在前向传播当中我注释了loss相关的部分，loss应该是涉及到了误差计算的部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">template &lt;typename Dtype&gt;<br><span class="hljs-keyword">inline</span> Dtype Layer&lt;Dtype&gt;::Forward(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) &#123;<br>    Lock(); <span class="hljs-comment">//加互斥锁</span><br>    Dtype loss = <span class="hljs-number">0</span>;<br>    Reshape(bottom, top);<br>    <span class="hljs-keyword">switch</span> (Caffe::mode()) &#123;<br>        <span class="hljs-keyword">case</span> Caffe::CPU:<br>            Forward_cpu(bottom, top);<br>            <span class="hljs-comment">//……loss</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> Caffe::GPU:<br>          Forward_gpu(bottom, top);<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CPU_ONLY</span><br>        <span class="hljs-comment">//……loss</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br>    Unlock();<span class="hljs-comment">//解锁</span><br>    <span class="hljs-keyword">return</span> loss;<br>&#125;<br><br>template &lt;typename Dtype&gt;<br><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> Layer&lt;Dtype&gt;::Backward(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;Blob&lt;Dtype&gt;*&gt;&amp; top, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;&amp; propagate_down,<br>      <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom) &#123;<br>    <span class="hljs-keyword">switch</span> (Caffe::mode()) &#123;<br>        <span class="hljs-keyword">case</span> Caffe::CPU:<br>            Backward_cpu(top, propagate_down, bottom);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> Caffe::GPU:<br>          Backward_gpu(top, propagate_down, bottom);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> caffe </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vulkan Shader编译与加载过程</title>
      <link href="/2022/07/09/GPUAartch/Vulkan_Shader/"/>
      <url>/2022/07/09/GPUAartch/Vulkan_Shader/</url>
      
        <content type="html"><![CDATA[<h1 id="Vulkan-Shader编译与加载过程"><a href="#Vulkan-Shader编译与加载过程" class="headerlink" title="Vulkan Shader编译与加载过程"></a>Vulkan Shader编译与加载过程</h1><h2 id="间接"><a href="#间接" class="headerlink" title="间接"></a>间接</h2><p>参考了<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules">Vulkan教程</a></p><p>​和一般的图形API不同（GL\DX），Vulkan 的shader代码是通过字节码的格式保存的，而非具备可读性的HLSL和GLSL。字节码的格式交过SPIR-V，它设计出来和Vulkan和OpenCL一同使用。可以用来编写图形Shader和计算Shader，这部分专注于图形Shader。</p><p>使用字节码的优点是由GPU供应商提供的把Shader代码转换成本地代码的编译器能复杂度更低。</p><p>过去使用可读代码的风险，编译器实现灵活，尝试特性实现不同：The past has shown that with human-readable syntax like GLSL, some GPU vendors were rather flexible with their interpretation of the standard. If you happen to write non-trivial shaders with a GPU from one of these vendors, then you’d risk other vendor’s drivers rejecting your code due to syntax errors, or worse, your shader running differently because of compiler bugs. With a straightforward bytecode format like SPIR-V that will hopefully be avoided.</p><p>我们不需要手写字节码，而是需要用与供应商独立的编译器把GLSL转化成SPIR-V.编译器用来验证Shader代码是完全标准的，并且声称SPIR-V代码集成在程序中。编译器提供了library用来集成在程序中，也可以用现有编译好的程序工具。</p><p>我们可以直接使用编译器glslangValidator.exe，不过这里使用glslc工具，因为这个工具提供了includes功能，并且它的参数和gcc和Clang很相似。这些已经集成在了VulkanSDK当中。</p><p>后面先展示GLSL代码，然后转换成SPIR-V，并在运行时加载。</p><p>GLSL语法：<a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/">语法简介</a></p><span id="more"></span><h2 id="Shader基本使用"><a href="#Shader基本使用" class="headerlink" title="Shader基本使用"></a>Shader基本使用</h2><h3 id="编写GLSL代码"><a href="#编写GLSL代码" class="headerlink" title="编写GLSL代码"></a>编写GLSL代码</h3><p>首先先编写GLSL代码文件shader.vert：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#version 450</span><br><span class="hljs-meta">#extension GL_ARB_separate_shader_objects : enable</span><br><br>layout(location = <span class="hljs-number">0</span>) out vec3 fragColor;<br><br>vec2 positions[<span class="hljs-number">3</span>] = vec2[](<br>    vec2(<span class="hljs-number">0.0</span>, <span class="hljs-number">-0.5</span>),<br>    vec2(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>),<br>    vec2(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0.5</span>)<br>);<br><br>vec3 colors[<span class="hljs-number">3</span>] = vec3[](<br>    vec3(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>),<br>    vec3(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>),<br>    vec3(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>)<br>);<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    gl_Position = vec4(positions[gl_VertexIndex], <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fragColor = colors[gl_VertexIndex];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译成字节码"><a href="#编译成字节码" class="headerlink" title="编译成字节码"></a>编译成字节码</h3><p>代码写完后使用编译器的工具编译成字节码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">C:/VulkanSDK/x.x.x.x/Bin32/glslc.exe shader.vert -o vert.spv<br></code></pre></td></tr></table></figure><p>之后我们就得到了字节码文件vert.spv。</p><h3 id="程序运行时加载字节码文件"><a href="#程序运行时加载字节码文件" class="headerlink" title="程序运行时加载字节码文件"></a>程序运行时加载字节码文件</h3><p>需要用于渲染是加载字节码文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title function_">readFile</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; filename)</span> &#123;<br>    <span class="hljs-built_in">std</span>::ifstream <span class="hljs-title function_">file</span><span class="hljs-params">(filename, <span class="hljs-built_in">std</span>::ios::ate | <span class="hljs-built_in">std</span>::ios::binary)</span>;<br><br>    <span class="hljs-keyword">if</span> (!file.is_open()) &#123;<br>        throw <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">&quot;failed to open file!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-type">size_t</span> fileSize = (<span class="hljs-type">size_t</span>) file.tellg();<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title function_">buffer</span><span class="hljs-params">(fileSize)</span>;<br>    file.seekg(<span class="hljs-number">0</span>);<br>file.read(buffer.data(), fileSize);<br>    file.close();<br><br><span class="hljs-keyword">return</span> buffer;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="根据字节码数据穿件Shader-Modules"><a href="#根据字节码数据穿件Shader-Modules" class="headerlink" title="根据字节码数据穿件Shader Modules"></a>根据字节码数据穿件Shader Modules</h3><p>这部分内容就进入了图形API的部分。根据ShaderModule就可以吧这个Shader代码设置成渲染状态的一部分。</p><h2 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h2><p>SPIR-V是二进制的中间吗，优点是不需要考虑供应商特性。缺点是需要考虑如何将shader语言编译成SPIR-V.</p><p>最好的方案是：<a href="https://github.com/KhronosGroup/glslang">Khronos’ glslang library</a> 和 <a href="https://github.com/google/shaderc">Google’s shaderc</a>.</p><p>都是开源的Shader编译库。</p><p>使用GLSL到SPIR-V的优点是不需要在程序中发布Shader代码</p><h3 id="一种GLSL不同的版本"><a href="#一种GLSL不同的版本" class="headerlink" title="一种GLSL不同的版本"></a>一种GLSL不同的版本</h3><p>GLSL有很多不同的版本：</p><ul><li>Modern mobile (GLES3+)</li><li>Legacy mobile (GLES2)</li><li>Modern desktop (GL3+)</li><li>Legacy desktop (GL2)</li><li>Vulkan GLSL</li></ul><p>Vulkan当中有很多和其他变体不兼容的地方</p><ul><li>Descriptor sets, no such concept in OpenGL</li><li>Push constants, no such concept in OpenGL, but very similar to “uniform vec4 UsuallyRegisterMappedUniform;”</li><li>Subpass input attachments, maps well to <a href="https://community.arm.com/graphics/b/blog/posts/pixel-local-storage-on-arm-mali-gpus">Pixel Local Storage on ARM Mali GPUs</a></li><li>gl_InstanceIndex vs gl_InstanceID. Same, but Vulkan GLSL’s version InstanceIndex (finally!) adds base instance offset for you</li></ul><h2 id="变体策略"><a href="#变体策略" class="headerlink" title="变体策略"></a>变体策略</h2><p>等待补充</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LuaJIT的变量实现</title>
      <link href="/2022/07/09/Asm/luajit-value/"/>
      <url>/2022/07/09/Asm/luajit-value/</url>
      
        <content type="html"><![CDATA[<p>Lua是动态类型的编程语言，变量的值可以是数值、字符串、table等所有支持的数据类型。在Lua虚拟机中每个变量都是用一个TValue结构体表示。LuaJIT出于效率的考虑重新组织了TValue结构体。</p><h1 id="lua-5-1中的TValue结构"><a href="#lua-5-1中的TValue结构" class="headerlink" title="lua-5.1中的TValue结构"></a>lua-5.1中的TValue结构</h1><p>lua-5.1中TValue的结构定义在lobject.h中，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">typedef union &#123;<br>  GCObject *gc;<br>  void *p;<br>  lua_Number n;<br>  int b;<br>&#125; Value;<br><br>#define TValuefields Value value;<br>int tt;<br><br>typedef struct lua_TValue &#123;<br>  TValuefields;<br>&#125; TValue;<br></code></pre></td></tr></table></figure><p>TValue结构体包含了两个部分，int类型的成员tt表示类型，Value成员是一个union结构，依据类型，有不同的含义。</p><ul><li>当类型位nil时，nil本身不再需要其他标识，Value成员没有意义</li><li>当类型为boolean时，成员b为0或1表示false或true</li><li>当类型为number时，成员n表示，为double类型</li><li>当类型为lightuserdata时，成员p，表示指针</li><li>当类型为function&#x2F;string&#x2F;userdata&#x2F;table&#x2F;thread等需要GC管理的类型时，成员gc表示相应GC对象的指针。<br>这样一个变量只要对应一个TValue结构便可以表示Lua支持的所有类型。</li></ul><span id="more"></span><p>lua中所有的数值都是用double类型的浮点数来表示，需要占用64位的空间。再加上额外的int类型成员tt来表示类型，一个TValue结构至少需要64+32&#x3D;96位的空间，如果按照8字节对其的话就需要占用128位的空间。而LuaJIT中通过Nan-boxing技术，重组了TValue，只需要占用64位的空间。</p><p>Nan-boxing<br>ieee754是使用最广泛的浮点数编码格式，它将浮点数编码成三个部分，符号、指数和尾数。如下所示</p><p><img src="/../images/2022-07-09-17-19-13.png"></p><p>双精度类型即double类型，最高位为符号位，后面的11位表示指数，最低52位为尾数。三个组合表示浮点数的值。</p><p>浮点数有些特殊的值，其中之一就是NaN(Not a Number)。有些浮点数运算如0&#x2F;0得到的结果就是NaN。IEEE 754标准中，如果指数部分全为1，且尾数部分不全为0时，表示值为 NaN。double类型的浮点数尾数部分有52位，NaN只要求这52位不全为0即可，只要其中一个是1剩余的51位就可以编码表示其他的含义。</p><p>实际使用的浮点数运算单元也只会产生一种NaN表示，即0xfff8_0000_0000_0000，只用了最高的13位，剩余的的51位便可以表示Lua中其他的字符串、table等。</p><h1 id="内存地址的处理"><a href="#内存地址的处理" class="headerlink" title="内存地址的处理"></a>内存地址的处理</h1><p>TValue结构中有些成员是指针，64位系统中，指针的长度为64位，那么如何在剩下的51位中表示指针类型呢？为此LuaJIT对不同类型有两种处理方式。</p><h2 id="1-用47位地址表示指针"><a href="#1-用47位地址表示指针" class="headerlink" title="1. 用47位地址表示指针"></a>1. 用47位地址表示指针</h2><p>对于64位系统，理论上每个进程都有64位的线性地址空间，共有16,777,216TB。然而可预见的将来，操作系统和应用并不需要这么多的内存，支持如此大的地址会增加地址转换的复杂性和成本， 因此现在的实现并不允许使用全部的地址空间。</p><p>以率先实现64位架构的AMD为例，在进行内存地址转换时，只会使用地址的低48位，并且要求从第48到63的这16位需要与第47位相同。即地址必须在0到00007FFF’FFFFFFFF 和 FFFF8000’00000000 到 FFFFFFFF’FFFFFFFF这两个范围内，共有256TB的虚拟地址空间。</p><p>操作系统本身也会对内存使用进行限制，以Linux为例，将高128TB的空间划归内核使用，这样用户态进程只能低128TB的地址，如下图所示。地址的高17位皆为0，因此使用47位即可表示所有能够使用的地址。</p><p><img src="/../images/2022-07-09-17-22-39.png"></p><h2 id="2-只使用最低的2G的地址空间"><a href="#2-只使用最低的2G的地址空间" class="headerlink" title="2. 只使用最低的2G的地址空间"></a>2. 只使用最低的2G的地址空间</h2><p>以Linux为例，LuaJIT默认通过mmap系统调用来分配内存，对于x86_64平台的64位程序，mmap有一个MAP_32BIT标记选项，表示只分配虚拟地址空间的低2GB的空间，这样分配的内存地址，高33位皆为0, 相应的指针只需要32位的空间即可。</p><h2 id="3-LuaJIT的处理与GC64模式"><a href="#3-LuaJIT的处理与GC64模式" class="headerlink" title="3. LuaJIT的处理与GC64模式"></a>3. LuaJIT的处理与GC64模式</h2><p>对于lightuserdata类型的值，LuaJIT用47位表示，对于GC类型的对象，都是通过mmap加MAP_32BIT标记分配的，用32位表示，这限制了LuaJIT只能使用不超过2GB的内存。为了摆脱这个限制，LuaJIT增加了GC64模式，开启后，所有的指针类型，包括lightuserdata都使用47位指针来表示。</p><p>LuaJIT的TValue结构<br>默认模式下TValue布局<br>LuaJIT中的TValue布局如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C">**<br>** Format <span class="hljs-keyword">for</span> <span class="hljs-number">32</span> bit GC <span class="hljs-title function_">references</span> <span class="hljs-params">(!LJ_GC64)</span>:<br>**<br>** Internal tags overlap the MSW of a number <span class="hljs-title function_">object</span> <span class="hljs-params">(must be a <span class="hljs-type">double</span>)</span>.<br>** Interpreted as a <span class="hljs-type">double</span> these are special NaNs. The FPU only generates<br>** one type of <span class="hljs-title function_">NaN</span> <span class="hljs-params">(<span class="hljs-number">0xfff8</span>_0000_0000_0000)</span>. So MSWs &gt; 0xfff80000 are available<br>** <span class="hljs-keyword">for</span> use as internal tags. Small negative numbers are used to shorten the<br>** encoding of type <span class="hljs-title function_">comparisons</span> <span class="hljs-params">(reg/mem against sign-ext. <span class="hljs-number">8</span> bit immediate)</span>.<br>**<br>**                  ---MSW---.---LSW---<br>** primitive types |  itype  |         |<br>** lightuserdata   |  itype  |  <span class="hljs-type">void</span> * |  <span class="hljs-params">(<span class="hljs-number">32</span> bit platforms)</span><br>** lightuserdata   |ffff|    <span class="hljs-type">void</span> *    |  <span class="hljs-params">(<span class="hljs-number">64</span> bit platforms, <span class="hljs-number">47</span> bit pointers)</span><br>** GC objects      |  itype  |  GCRef  |<br>** <span class="hljs-title function_">int</span> <span class="hljs-params">(LJ_DUALNUM)</span>|  itype  |   <span class="hljs-type">int</span>   |<br>** number           -------<span class="hljs-type">double</span>------<br></code></pre></td></tr></table></figure><p>可以通过下面的步骤判断值的类型</p><p>如果最高的16位（即48到63位）不全为1，表示这是一个double类型的浮点数，<br>最高的16位全为1，如果第47位为0时表示一个lightuserdata类型，<br>其余情况下，高32位表示类型，低32位表示实际值。</p><h1 id="GC64模式下TValue布局"><a href="#GC64模式下TValue布局" class="headerlink" title="GC64模式下TValue布局"></a>GC64模式下TValue布局</h1><p>GC64模式开启后如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">**<br>** The upper <span class="hljs-number">13</span> bits must be <span class="hljs-number">1</span> (<span class="hljs-number">0xfff8</span>...) <span class="hljs-keyword">for</span> a special NaN. The next<br>** <span class="hljs-number">4</span> bits hold the internal tag. The lowest <span class="hljs-number">47</span> bits either hold a pointer,<br>** a zero-extended <span class="hljs-number">32</span> bit integer or all bits <span class="hljs-built_in">set</span> to <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> primitive types.<br>**<br>**                     ------MSW------.------LSW------<br>** primitive types    |<span class="hljs-number">1.</span><span class="hljs-number">.1</span>|itype|<span class="hljs-number">1.</span>................<span class="hljs-number">.1</span>|<br>** GC objects/lightud |<span class="hljs-number">1.</span><span class="hljs-number">.1</span>|itype|-------GCRef--------|<br>** <span class="hljs-type">int</span> (LJ_DUALNUM)   |<span class="hljs-number">1.</span><span class="hljs-number">.1</span>|itype|<span class="hljs-number">0.</span><span class="hljs-number">.0</span>|-----<span class="hljs-type">int</span>-------|<br>** number              ------------<span class="hljs-type">double</span>-------------<br></code></pre></td></tr></table></figure><p>这里比较特殊的是最高的13位全位1表double类型，itype表示类型，占4位，指针占用47位，总共仍是64位。</p><p>TValue结构<br>LuaJIT的TValue定义在lj_obj.h中，如下面所示，因为Nan-boxing的缘故，这里的TValue结构并没有直接反映实际的内存布局。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* Tagged value. */<br>typedef LJ_ALIGN(8) union TValue &#123;<br>  uint64_t u64;  /* 64 bit pattern overlaps number. */<br>  lua_Number n;  /* Number object overlaps split tag/value object. */<br>#if LJ_GC64<br>  GCRef gcr;  /* GCobj reference with tag. */<br>  int64_t it64;<br>  struct &#123;<br>    LJ_ENDIAN_LOHI(<br>      int32_t i; /* Integer value. */<br>    , uint32_t it; /* Internal object tag. Must overlap MSW of number. */<br>    )<br>  &#125;;<br>#else<br>  struct &#123;<br>    LJ_ENDIAN_LOHI(<br>      union &#123;<br>trueGCRef gcr; /* GCobj reference (if any). */<br>trueint32_t i; /* Integer value. */<br>      &#125;;<br>    , uint32_t it; /* Internal object tag. Must overlap MSW of number. */<br>    )<br>  &#125;;<br>#endif<br><br> ..........<br><br>&#125; TValue;<br></code></pre></td></tr></table></figure><h1 id="类型的定义"><a href="#类型的定义" class="headerlink" title="类型的定义"></a>类型的定义</h1><p>所有的数据类型定义中最高的几位均为1，方便与浮点数的区分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TNIL   (~0u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TFALSE  (~1u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TTRUE  (~2u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TLIGHTUD  (~3u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TSTR   (~4u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TUPVAL  (~5u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TTHREAD  (~6u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TPROTO  (~7u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TFUNC  (~8u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TTRACE  (~9u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TCDATA  (~10u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TTAB   (~11u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TUDATA  (~12u)</span><br><span class="hljs-comment">/* This is just the canonical number type used in some places. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TNUMX  (~13u)</span><br><br><span class="hljs-comment">/* Integers have itype == LJ_TISNUM doubles have itype &lt; LJ_TISNUM */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LJ_64 &amp;&amp; !LJ_GC64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TISNUM  0xfffeffffu</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TISNUM  LJ_TNUMX</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>判断类型的宏定义<br>LuaJIT定义了一系列宏用来判断值的类型。<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LJ_GC64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> itype(o) ((uint32_t)((o)-&gt;it64 &gt;&gt; 47))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisnil(o) ((o)-&gt;it64 == -1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> itype(o) ((o)-&gt;it)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisnil(o) (itype(o) == LJ_TNIL)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisfalse(o) (itype(o) == LJ_TFALSE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvistrue(o) (itype(o) == LJ_TTRUE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisbool(o) (tvisfalse(o) || tvistrue(o))</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LJ_64 &amp;&amp; !LJ_GC64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvislightud(o) (((int32_t)itype(o) &gt;&gt; 15) == -2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvislightud(o) (itype(o) == LJ_TLIGHTUD)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisstr(o) (itype(o) == LJ_TSTR)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisfunc(o) (itype(o) == LJ_TFUNC)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisthread(o) (itype(o) == LJ_TTHREAD)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisproto(o) (itype(o) == LJ_TPROTO)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tviscdata(o) (itype(o) == LJ_TCDATA)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvistab(o) (itype(o) == LJ_TTAB)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisudata(o) (itype(o) == LJ_TUDATA)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisnumber(o) (itype(o) &lt;= LJ_TISNUM)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisint(o) (LJ_DUALNUM &amp;&amp; itype(o) == LJ_TISNUM)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisnum(o) (itype(o) &lt; LJ_TISNUM)</span><br>LJ_DUALNUM<br></code></pre></td></tr></table></figure><p>Lua中数值都是double类型的浮点数，而实际使用时经常会用到整数，而位操作等都需要将double类型转换成整数进行。为此LuaJIT提供了LJ_DUALNUM的选项，一些数值可以直接通过int类型存储，方便使用，相当于为Lua增加了整数这个数据类型。</p><p>LJ_DUALNUM的定义可以参考lj_arch.h，不过对常用的x86_64架构，默认并没有启用LJ_DUALNUM。</p><h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><p><a href="https://qlee.in/luajitde-bian-liang-shi-xian-tvalue/?tdsourcetag=s_pcqq_aiomsg">https://qlee.in/luajitde-bian-liang-shi-xian-tvalue/?tdsourcetag=s_pcqq_aiomsg</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>IEEE Standard for Floating-Point Arithmetic (IEEE 754)</li><li>X86_64 Virtual_address_space_details</li></ul>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编调用指令，堆栈操作详解</title>
      <link href="/2019/09/27/Asm/base-asm-calls/"/>
      <url>/2019/09/27/Asm/base-asm-calls/</url>
      
        <content type="html"><![CDATA[<h2 id="一些常用的汇编指令直观翻译"><a href="#一些常用的汇编指令直观翻译" class="headerlink" title="一些常用的汇编指令直观翻译"></a>一些常用的汇编指令直观翻译</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span> , <span class="hljs-built_in">ebx</span>            <span class="hljs-comment">; eax = ebx</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">eax</span> , [<span class="hljs-built_in">ebx</span> + <span class="hljs-number">30</span>]     <span class="hljs-comment">; eax = ebx + 30 </span><br>                         <span class="hljs-comment">; 不这样写就是两条指令 mov eax, ebx ;add eax 30</span><br><span class="hljs-keyword">push</span> <span class="hljs-keyword">pop</span>                 <span class="hljs-comment">; 入栈，出栈</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">5</span>               <span class="hljs-comment">; eax += 5</span><br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">5</span>               <span class="hljs-comment">; eax -= 5</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">eax</span>                  <span class="hljs-comment">; eax += 1</span><br><span class="hljs-keyword">mul</span>                      <span class="hljs-comment">; 乘法</span><br><span class="hljs-keyword">div</span>                      <span class="hljs-comment">; 除法</span><br></code></pre></td></tr></table></figure><h2 id="改变堆栈的操作"><a href="#改变堆栈的操作" class="headerlink" title="改变堆栈的操作"></a>改变堆栈的操作</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span>   // <span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span> , <span class="hljs-number">4</span>  <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span>] , <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span>    // <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span> , [<span class="hljs-built_in">esp</span>]   <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span> , <span class="hljs-number">4</span><br><span class="hljs-keyword">call</span> <span class="hljs-number">1234</span>  // <span class="hljs-keyword">push</span> <span class="hljs-built_in">eip</span>   <span class="hljs-keyword">jmp</span> <span class="hljs-number">1234</span><br><span class="hljs-keyword">retn</span> <span class="hljs-number">8</span>     // <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eip</span>   <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span> , <span class="hljs-number">8</span>   常用于 __stdcall,这种函数自己清理自己的参数的<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span> , xxx<br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span> , xxx<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="栈指针、帧指针的学习"><a href="#栈指针、帧指针的学习" class="headerlink" title="栈指针、帧指针的学习"></a>栈指针、帧指针的学习</h2><p>ESP栈指针,每一次push或者pop值会跟这变，永远指向栈顶 </br><br>EBP帧指针，其实有无无所谓，如果没有使用ESP取局部变量和参数的时候因为地址会一直改变，人的理解上比较麻烦，于是在call指令save 的 EIP后记录下来当前的ESP到EBP中，这样子取参数或者局部变量的时候回更方便。</br></p><p>以下面这个在32位x86计算机上编译的函数为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span>; <span class="hljs-comment">// a function to call</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">demo_stackframe</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, in c)</span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> z;<br>    bar(z, y);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../../images/only_esp.png" alt="&quot;&quot;"></p><p>调用bar函数的时候,如果没有设置 ebp传递参数汇编码如下:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; 假设为__cdecl,参数从右往左入栈，调用者清理堆栈</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">4</span>]    <span class="hljs-comment">; push y</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">4</span>]    <span class="hljs-comment">; push z</span><br><span class="hljs-keyword">call</span> bar              <span class="hljs-comment">; push eip,jmp bar</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">8</span>            <span class="hljs-comment">; 清理堆栈</span><br></code></pre></td></tr></table></figure><p>我们可以发现，如果根据esp来寻找地址，很不直观，第一次我们将 y push到堆栈中后，导致esp sub 4,然后取z的时候地址就会跟着改变，显然这样理解上比较麻烦，同一个参数获取的时候esp的偏移量总是不一样。</p><p>为了更好的计算偏移量，我们需要一个固定不变的堆栈地址，这样就不会出现同一个参数然后偏移不一样的情况。于是引入了ebp(帧指针)的概念,在call bar之后将esp地址记录下来，此时的堆栈情况如下。</p><p><img src="/../../images/use_ebp.png" alt="&quot;&quot;"><br>注意调用前要把caller的ebp保存起来，不然到调用完成后，caller的ebp就找不到了。所以调用bar函数前要写上“序言”代码</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span>        <span class="hljs-comment">; 保存 caller的 ebp </span><br><span class="hljs-keyword">mov</span>  <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span>   <span class="hljs-comment">; 将bar函数的ebp设置为当前的esp</span><br><span class="hljs-keyword">sub</span>  <span class="hljs-built_in">esp</span>, <span class="hljs-number">76</span>    <span class="hljs-comment">; 提前扩容好局部变量</span><br></code></pre></td></tr></table></figure><p>注意这里仅仅保存了caller函数的ebp,如果想要保存caller函数的其他寄存器信息比如eax之类的，需要在序言这边push进去</p><p>现在调用bar函数的汇编指令差不多为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">72</span>]         <span class="hljs-comment">; push y</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">76</span>]         <span class="hljs-comment">; push z</span><br><span class="hljs-keyword">call</span> bar<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">8</span>                  <span class="hljs-comment">; 清栈</span><br></code></pre></td></tr></table></figure><p>使用了帧指针ebp后，所有的变量相对于ebp的偏移量都可以计算出来。许多时候，正偏移量用于访问函数参数，而负偏移量用于访问局部变量。使用ebp指针后，我们可以自由的更改esp指针而不用担心，其他变量的偏移地址</p><p>最后完成bar函数调用的时候：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>,<span class="hljs-built_in">ebp</span>          <span class="hljs-comment">; 清理局部变量</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span>              <span class="hljs-comment">; 恢复caller函数的ebp</span><br><span class="hljs-keyword">ret</span>                  <span class="hljs-comment">; pop eip</span><br></code></pre></td></tr></table></figure><p>由于 这种操作非常常见，因此x86体系提供了leave指令来缩短汇编指令长度</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">leave</span>                <span class="hljs-comment">; 相当于</span><br>                     <span class="hljs-comment">; mov esp,ebp</span><br>                     <span class="hljs-comment">; pop ebp</span><br><br><span class="hljs-keyword">ret</span>                  <span class="hljs-comment">; pop eip</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 汇编逆向 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Unity 符号表上传</title>
      <link href="/2019/09/27/Asm/bugly-symbol/"/>
      <url>/2019/09/27/Asm/bugly-symbol/</url>
      
        <content type="html"><![CDATA[<h2 id="Why-do-it"><a href="#Why-do-it" class="headerlink" title="Why do it"></a>Why do it</h2><p>最近游戏内测，发现不少崩溃的堆栈发生在libunity.so之中，而大部分仅仅给一个代码执行到的PC地址，查起来代码比较蛋疼。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-meta">#00 pc 00a6ac38 /data/app/.../libunity.so</span><br><span class="hljs-meta">#01 pc 00a6c128 /data/app/.../x86/libunity.so</span><br><span class="hljs-meta">#02 pc 003f1bf6 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#03 pc 003f0b4a /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#04 pc 0039ff68 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#05 pc 00396e77 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#06 pc 00398ce0 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#07 pc 00398149 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#08 pc 003980a2 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#09 pc 004f2ca3 /data/app/.../x86/libunity.so </span><br></code></pre></td></tr></table></figure><span id="more"></span><p>这种一般没有符号表，不过我们可以使用addr2line这个经典的binutils工具将PC地址转换为函数名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./i686-linux-android-addr2line.exe -C -i -f -e libunity.sym.so 00a6ac38<br></code></pre></td></tr></table></figure><p>输出结果如下:</br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">mecanim::statemachine::EvaluateState(mecanim::ValueArrayConstant <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateConstant <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineInput <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineOutput&amp;, mecanim::statemachine::StateMachineMemory&amp;, mecanim::statemachine::StateOutput&amp;, mecanim::statemachine::StateWorkspace&amp;, <span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>)<br></code></pre></td></tr></table></figure><p>我们很快就可以定位到是一个动画状态机的问题，不过问题也接踵而至,BUG量有点多，然后一起看BUGLY的人也不少，客户端的其他人未必懂这些底层知识，那么其实就可以利用Bugly的符号表功能来做这件事情。</p><h2 id="How-to-do"><a href="#How-to-do" class="headerlink" title="How to do"></a>How to do</h2><p>首先去<a href="https://bugly.qq.com/v2/sdkDownload">Bugly官网</a>上下载最新的符号表导出工具</p><p>Android Unity的符号表路径在Editor\Data\PlaybackEngines\AndroidPlayer\Variations</p><p>搜索libunity.sym.so即可,注意MONO和IL2CPP要对应上传,输入导出和上传指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar buglySymbolAndroid.jar -i libunity.sym.so -u -<span class="hljs-built_in">id</span> <span class="hljs-variable">$yourappid</span> -key <span class="hljs-variable">$yourappkey</span> -package <span class="hljs-variable">$packagename</span> -version xx.xx.xx<br></code></pre></td></tr></table></figure><p>在BUGLY界面中打开界面，如果看到对应的符号表已上传就说明成功了</br><br><img src="/../../images/symbol_success.png" alt="成功截图"></br><br>报错堆栈变成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">#<span class="hljs-number">00</span> pc <span class="hljs-number">00</span>a6ac38 libunity.so mecanim::statemachine::EvaluateState(mecanim::ValueArrayConstant <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateConstant <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineInput <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineOutput&amp;, mecanim::statemachine::StateMachineMemory&amp;, mecanim::statemachine::StateOutput&amp;, mecanim::statemachine::StateWorkspace&amp;, <span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>) [x86]<br>#<span class="hljs-number">01</span> pc <span class="hljs-number">00</span>a6c128 libunity.so mecanim::statemachine::SetStateMachineInInitialState(mecanim::statemachine::StateMachineConstant <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineInput <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineOutput&amp;, mecanim::statemachine::StateMachineMemory&amp;, mecanim::statemachine::StateMachineWorkspace&amp;) [x86]<br>#<span class="hljs-number">02</span> pc <span class="hljs-number">003f</span>1bf6 libunity.so <span class="hljs-title function_">AnimatorControllerPlayable::GenerateGraph</span><span class="hljs-params">()</span> [x86]<br>#03 pc 003f0b4a libunity.so <span class="hljs-title function_">AnimatorControllerPlayable::SetAnimatorController</span><span class="hljs-params">(RuntimeAnimatorController*)</span> [x86]<br>#04 pc 0039ff68 libunity.so <span class="hljs-title function_">Animator::CreateInternalControllerPlayable</span><span class="hljs-params">()</span> [x86]<br>#05 pc 00396e77 libunity.so <span class="hljs-title function_">Animator::CreateObject</span><span class="hljs-params">()</span> [x86]<br>#06 pc 00398ce0 libunity.so <span class="hljs-title function_">Animator::Prepare</span><span class="hljs-params">()</span> [x86]<br></code></pre></td></tr></table></figure><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>将Addr2Line与IDA结合，定位报错汇编码</p>]]></content>
      
      
      <categories>
          
          <category> 汇编逆向 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
