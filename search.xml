<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/07/09/GPUAartch/HDR%E7%A1%AC%E4%BB%B6%E5%B1%82Framebuffer%E6%A0%BC%E5%BC%8F%E6%A0%87%E5%87%86%E4%B8%8E%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2022/07/09/GPUAartch/HDR%E7%A1%AC%E4%BB%B6%E5%B1%82Framebuffer%E6%A0%BC%E5%BC%8F%E6%A0%87%E5%87%86%E4%B8%8E%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="HDR硬件层Framebuffer格式标准与渲染阶段的关系"><a href="#HDR硬件层Framebuffer格式标准与渲染阶段的关系" class="headerlink" title="HDR硬件层Framebuffer格式标准与渲染阶段的关系"></a>HDR硬件层Framebuffer格式标准与渲染阶段的关系</h1><p>这里主要探讨的是<strong>SwapChain的格式</strong>、<strong>写入其中的数据</strong>以及<strong>屏幕实际亮度</strong>之间的关系。</p><h2 id="SDR格式"><a href="#SDR格式" class="headerlink" title="SDR格式"></a>SDR格式</h2><p>对于SDR屏幕 Buffer主要有：</p><p>R8G8B8A8_UNORM：首先屏幕的eotf曲线是始终存在的，这种格式输入的颜色，图像接口不会进行任何处理，需要我们自己在shader中进行sRGB编码。</p><p>R8G8B8A8_SNORM：这种格式输入的颜色在显示之前会自动编码到SRGB空间（自动Gamma矫正），所以我们不需要进行处理，也就是说shader当中直接写出线性颜色即可。A通道是线性的。</p><blockquote><p>  Vulkan的解释：</p><p>  specifies a four-component, 32-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit R component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3.</p><p>  On the other hand, <strong>non-*_SRGB formats</strong> will be very likely exposed in pair with a <strong>SRGB color space.</strong> <strong>This means, the hardware will not apply any transfer function when reading from or writing to such images, yet they will still be presented on a device with sRGB display characteristics</strong>。（即使使用非SRGB的format，仍然可以使用 SRGB的colorSpace），这意味着硬件不会帮助进行自动的空间转换（在读写buffer时），但是仍然使用srgb的eotf的显示特性。</p></blockquote><p>SRGB的进一步说明：</p><p><a href="https://docs.rs/vulkano/0.7.2/vulkano/swapchain/enum.ColorSpace.html">https://docs.rs/vulkano/0.7.2/vulkano/swapchain/enum.ColorSpace.html</a></p><p><img src="/HDR%E7%A1%AC%E4%BB%B6%E5%B1%82Framebuffer%E6%A0%BC%E5%BC%8F%E6%A0%87%E5%87%86%E4%B8%8E%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5%E7%9A%84%E5%85%B3%E7%B3%BB/1590989148165.png" alt="1590989148165"></p><h2 id="HDR格式"><a href="#HDR格式" class="headerlink" title="HDR格式"></a>HDR格式</h2><p>R16G16B16_Float:这种格式输出的是线性浮点数颜色，数据可以超过1，1对应的是80nits。使用的是scRGB。</p><p>DX的参考：</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range">https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range</a></p><p>R10G10B10A2_UNORM：这种格式不会进行任何处理，直接结合EOFT曲线进行显示， 所以需要我们自己在Shader中进行PQ编码。（在我的显示器上Vulkan不支持，暂时没有测试过，但是GL和DX是支持这个格式的）</p><p>VK_COLOR_SPACE_HDR10_ST2084_EXT：说明colorSpace，表示使用BT2020颜色空间，使用ST2048的EOTF。</p><blockquote><p>   Note:</p><p>  对于Vulkan来说所有的ColorSpace都需要在Shader当中进行函数编码，除了SRGB。（对于SRGB的ColorSpace，通过指定带有SRGB的Format就能自动转换）。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vulkan Shader编译与加载过程</title>
      <link href="/2022/07/09/Vulkan_Shader/"/>
      <url>/2022/07/09/Vulkan_Shader/</url>
      
        <content type="html"><![CDATA[<h1 id="Vulkan-Shader编译与加载过程"><a href="#Vulkan-Shader编译与加载过程" class="headerlink" title="Vulkan Shader编译与加载过程"></a>Vulkan Shader编译与加载过程</h1><h2 id="间接"><a href="#间接" class="headerlink" title="间接"></a>间接</h2><p>参考了<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules">Vulkan教程</a></p><p>​和一般的图形API不同（GL\DX），Vulkan 的shader代码是通过字节码的格式保存的，而非具备可读性的HLSL和GLSL。字节码的格式交过SPIR-V，它设计出来和Vulkan和OpenCL一同使用。可以用来编写图形Shader和计算Shader，这部分专注于图形Shader。</p><p>使用字节码的优点是由GPU供应商提供的把Shader代码转换成本地代码的编译器能复杂度更低。</p><p>过去使用可读代码的风险，编译器实现灵活，尝试特性实现不同：The past has shown that with human-readable syntax like GLSL, some GPU vendors were rather flexible with their interpretation of the standard. If you happen to write non-trivial shaders with a GPU from one of these vendors, then you’d risk other vendor’s drivers rejecting your code due to syntax errors, or worse, your shader running differently because of compiler bugs. With a straightforward bytecode format like SPIR-V that will hopefully be avoided.</p><p>我们不需要手写字节码，而是需要用与供应商独立的编译器把GLSL转化成SPIR-V.编译器用来验证Shader代码是完全标准的，并且声称SPIR-V代码集成在程序中。编译器提供了library用来集成在程序中，也可以用现有编译好的程序工具。</p><p>我们可以直接使用编译器glslangValidator.exe，不过这里使用glslc工具，因为这个工具提供了includes功能，并且它的参数和gcc和Clang很相似。这些已经集成在了VulkanSDK当中。</p><p>后面先展示GLSL代码，然后转换成SPIR-V，并在运行时加载。</p><p>GLSL语法：<a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/">语法简介</a></p><span id="more"></span><h2 id="Shader基本使用"><a href="#Shader基本使用" class="headerlink" title="Shader基本使用"></a>Shader基本使用</h2><h3 id="编写GLSL代码"><a href="#编写GLSL代码" class="headerlink" title="编写GLSL代码"></a>编写GLSL代码</h3><p>首先先编写GLSL代码文件shader.vert：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#version 450</span><br><span class="hljs-meta">#extension GL_ARB_separate_shader_objects : enable</span><br><br>layout(location = <span class="hljs-number">0</span>) out vec3 fragColor;<br><br>vec2 positions[<span class="hljs-number">3</span>] = vec2[](<br>    vec2(<span class="hljs-number">0.0</span>, <span class="hljs-number">-0.5</span>),<br>    vec2(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>),<br>    vec2(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0.5</span>)<br>);<br><br>vec3 colors[<span class="hljs-number">3</span>] = vec3[](<br>    vec3(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>),<br>    vec3(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>),<br>    vec3(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>)<br>);<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    gl_Position = vec4(positions[gl_VertexIndex], <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fragColor = colors[gl_VertexIndex];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译成字节码"><a href="#编译成字节码" class="headerlink" title="编译成字节码"></a>编译成字节码</h3><p>代码写完后使用编译器的工具编译成字节码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">C:/VulkanSDK/x.x.x.x/Bin32/glslc.exe shader.vert -o vert.spv<br></code></pre></td></tr></table></figure><p>之后我们就得到了字节码文件vert.spv。</p><h3 id="程序运行时加载字节码文件"><a href="#程序运行时加载字节码文件" class="headerlink" title="程序运行时加载字节码文件"></a>程序运行时加载字节码文件</h3><p>需要用于渲染是加载字节码文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title function_">readFile</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; filename)</span> &#123;<br>    <span class="hljs-built_in">std</span>::ifstream <span class="hljs-title function_">file</span><span class="hljs-params">(filename, <span class="hljs-built_in">std</span>::ios::ate | <span class="hljs-built_in">std</span>::ios::binary)</span>;<br><br>    <span class="hljs-keyword">if</span> (!file.is_open()) &#123;<br>        throw <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">&quot;failed to open file!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-type">size_t</span> fileSize = (<span class="hljs-type">size_t</span>) file.tellg();<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title function_">buffer</span><span class="hljs-params">(fileSize)</span>;<br>    file.seekg(<span class="hljs-number">0</span>);<br>file.read(buffer.data(), fileSize);<br>    file.close();<br><br><span class="hljs-keyword">return</span> buffer;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="根据字节码数据穿件Shader-Modules"><a href="#根据字节码数据穿件Shader-Modules" class="headerlink" title="根据字节码数据穿件Shader Modules"></a>根据字节码数据穿件Shader Modules</h3><p>这部分内容就进入了图形API的部分。根据ShaderModule就可以吧这个Shader代码设置成渲染状态的一部分。</p><h2 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h2><p>SPIR-V是二进制的中间吗，优点是不需要考虑供应商特性。缺点是需要考虑如何将shader语言编译成SPIR-V.</p><p>最好的方案是：<a href="https://github.com/KhronosGroup/glslang">Khronos’ glslang library</a> 和 <a href="https://github.com/google/shaderc">Google’s shaderc</a>.</p><p>都是开源的Shader编译库。</p><p>使用GLSL到SPIR-V的优点是不需要在程序中发布Shader代码</p><h3 id="一种GLSL不同的版本"><a href="#一种GLSL不同的版本" class="headerlink" title="一种GLSL不同的版本"></a>一种GLSL不同的版本</h3><p>GLSL有很多不同的版本：</p><ul><li>Modern mobile (GLES3+)</li><li>Legacy mobile (GLES2)</li><li>Modern desktop (GL3+)</li><li>Legacy desktop (GL2)</li><li>Vulkan GLSL</li></ul><p>Vulkan当中有很多和其他变体不兼容的地方</p><ul><li>Descriptor sets, no such concept in OpenGL</li><li>Push constants, no such concept in OpenGL, but very similar to “uniform vec4 UsuallyRegisterMappedUniform;”</li><li>Subpass input attachments, maps well to <a href="https://community.arm.com/graphics/b/blog/posts/pixel-local-storage-on-arm-mali-gpus">Pixel Local Storage on ARM Mali GPUs</a></li><li>gl_InstanceIndex vs gl_InstanceID. Same, but Vulkan GLSL’s version InstanceIndex (finally!) adds base instance offset for you</li></ul><h2 id="变体策略"><a href="#变体策略" class="headerlink" title="变体策略"></a>变体策略</h2><p>等待补充</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LuaJIT的变量实现</title>
      <link href="/2022/07/09/luajit-value/"/>
      <url>/2022/07/09/luajit-value/</url>
      
        <content type="html"><![CDATA[<p>Lua是动态类型的编程语言，变量的值可以是数值、字符串、table等所有支持的数据类型。在Lua虚拟机中每个变量都是用一个TValue结构体表示。LuaJIT出于效率的考虑重新组织了TValue结构体。</p><h1 id="lua-5-1中的TValue结构"><a href="#lua-5-1中的TValue结构" class="headerlink" title="lua-5.1中的TValue结构"></a>lua-5.1中的TValue结构</h1><p>lua-5.1中TValue的结构定义在lobject.h中，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">typedef union &#123;<br>  GCObject *gc;<br>  void *p;<br>  lua_Number n;<br>  int b;<br>&#125; Value;<br><br>#define TValuefields Value value;<br>int tt;<br><br>typedef struct lua_TValue &#123;<br>  TValuefields;<br>&#125; TValue;<br></code></pre></td></tr></table></figure><p>TValue结构体包含了两个部分，int类型的成员tt表示类型，Value成员是一个union结构，依据类型，有不同的含义。</p><ul><li>当类型位nil时，nil本身不再需要其他标识，Value成员没有意义</li><li>当类型为boolean时，成员b为0或1表示false或true</li><li>当类型为number时，成员n表示，为double类型</li><li>当类型为lightuserdata时，成员p，表示指针</li><li>当类型为function&#x2F;string&#x2F;userdata&#x2F;table&#x2F;thread等需要GC管理的类型时，成员gc表示相应GC对象的指针。<br>这样一个变量只要对应一个TValue结构便可以表示Lua支持的所有类型。</li></ul><span id="more"></span><p>lua中所有的数值都是用double类型的浮点数来表示，需要占用64位的空间。再加上额外的int类型成员tt来表示类型，一个TValue结构至少需要64+32&#x3D;96位的空间，如果按照8字节对其的话就需要占用128位的空间。而LuaJIT中通过Nan-boxing技术，重组了TValue，只需要占用64位的空间。</p><p>Nan-boxing<br>ieee754是使用最广泛的浮点数编码格式，它将浮点数编码成三个部分，符号、指数和尾数。如下所示</p><p><img src="/../images/2022-07-09-17-19-13.png"></p><p>双精度类型即double类型，最高位为符号位，后面的11位表示指数，最低52位为尾数。三个组合表示浮点数的值。</p><p>浮点数有些特殊的值，其中之一就是NaN(Not a Number)。有些浮点数运算如0&#x2F;0得到的结果就是NaN。IEEE 754标准中，如果指数部分全为1，且尾数部分不全为0时，表示值为 NaN。double类型的浮点数尾数部分有52位，NaN只要求这52位不全为0即可，只要其中一个是1剩余的51位就可以编码表示其他的含义。</p><p>实际使用的浮点数运算单元也只会产生一种NaN表示，即0xfff8_0000_0000_0000，只用了最高的13位，剩余的的51位便可以表示Lua中其他的字符串、table等。</p><h1 id="内存地址的处理"><a href="#内存地址的处理" class="headerlink" title="内存地址的处理"></a>内存地址的处理</h1><p>TValue结构中有些成员是指针，64位系统中，指针的长度为64位，那么如何在剩下的51位中表示指针类型呢？为此LuaJIT对不同类型有两种处理方式。</p><h2 id="1-用47位地址表示指针"><a href="#1-用47位地址表示指针" class="headerlink" title="1. 用47位地址表示指针"></a>1. 用47位地址表示指针</h2><p>对于64位系统，理论上每个进程都有64位的线性地址空间，共有16,777,216TB。然而可预见的将来，操作系统和应用并不需要这么多的内存，支持如此大的地址会增加地址转换的复杂性和成本， 因此现在的实现并不允许使用全部的地址空间。</p><p>以率先实现64位架构的AMD为例，在进行内存地址转换时，只会使用地址的低48位，并且要求从第48到63的这16位需要与第47位相同。即地址必须在0到00007FFF’FFFFFFFF 和 FFFF8000’00000000 到 FFFFFFFF’FFFFFFFF这两个范围内，共有256TB的虚拟地址空间。</p><p>操作系统本身也会对内存使用进行限制，以Linux为例，将高128TB的空间划归内核使用，这样用户态进程只能低128TB的地址，如下图所示。地址的高17位皆为0，因此使用47位即可表示所有能够使用的地址。</p><p><img src="/../images/2022-07-09-17-22-39.png"></p><h2 id="2-只使用最低的2G的地址空间"><a href="#2-只使用最低的2G的地址空间" class="headerlink" title="2. 只使用最低的2G的地址空间"></a>2. 只使用最低的2G的地址空间</h2><p>以Linux为例，LuaJIT默认通过mmap系统调用来分配内存，对于x86_64平台的64位程序，mmap有一个MAP_32BIT标记选项，表示只分配虚拟地址空间的低2GB的空间，这样分配的内存地址，高33位皆为0, 相应的指针只需要32位的空间即可。</p><h2 id="3-LuaJIT的处理与GC64模式"><a href="#3-LuaJIT的处理与GC64模式" class="headerlink" title="3. LuaJIT的处理与GC64模式"></a>3. LuaJIT的处理与GC64模式</h2><p>对于lightuserdata类型的值，LuaJIT用47位表示，对于GC类型的对象，都是通过mmap加MAP_32BIT标记分配的，用32位表示，这限制了LuaJIT只能使用不超过2GB的内存。为了摆脱这个限制，LuaJIT增加了GC64模式，开启后，所有的指针类型，包括lightuserdata都使用47位指针来表示。</p><p>LuaJIT的TValue结构<br>默认模式下TValue布局<br>LuaJIT中的TValue布局如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C">**<br>** Format <span class="hljs-keyword">for</span> <span class="hljs-number">32</span> bit GC <span class="hljs-title function_">references</span> <span class="hljs-params">(!LJ_GC64)</span>:<br>**<br>** Internal tags overlap the MSW of a number <span class="hljs-title function_">object</span> <span class="hljs-params">(must be a <span class="hljs-type">double</span>)</span>.<br>** Interpreted as a <span class="hljs-type">double</span> these are special NaNs. The FPU only generates<br>** one type of <span class="hljs-title function_">NaN</span> <span class="hljs-params">(<span class="hljs-number">0xfff8</span>_0000_0000_0000)</span>. So MSWs &gt; 0xfff80000 are available<br>** <span class="hljs-keyword">for</span> use as internal tags. Small negative numbers are used to shorten the<br>** encoding of type <span class="hljs-title function_">comparisons</span> <span class="hljs-params">(reg/mem against sign-ext. <span class="hljs-number">8</span> bit immediate)</span>.<br>**<br>**                  ---MSW---.---LSW---<br>** primitive types |  itype  |         |<br>** lightuserdata   |  itype  |  <span class="hljs-type">void</span> * |  <span class="hljs-params">(<span class="hljs-number">32</span> bit platforms)</span><br>** lightuserdata   |ffff|    <span class="hljs-type">void</span> *    |  <span class="hljs-params">(<span class="hljs-number">64</span> bit platforms, <span class="hljs-number">47</span> bit pointers)</span><br>** GC objects      |  itype  |  GCRef  |<br>** <span class="hljs-title function_">int</span> <span class="hljs-params">(LJ_DUALNUM)</span>|  itype  |   <span class="hljs-type">int</span>   |<br>** number           -------<span class="hljs-type">double</span>------<br></code></pre></td></tr></table></figure><p>可以通过下面的步骤判断值的类型</p><p>如果最高的16位（即48到63位）不全为1，表示这是一个double类型的浮点数，<br>最高的16位全为1，如果第47位为0时表示一个lightuserdata类型，<br>其余情况下，高32位表示类型，低32位表示实际值。</p><h1 id="GC64模式下TValue布局"><a href="#GC64模式下TValue布局" class="headerlink" title="GC64模式下TValue布局"></a>GC64模式下TValue布局</h1><p>GC64模式开启后如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">**<br>** The upper <span class="hljs-number">13</span> bits must be <span class="hljs-number">1</span> (<span class="hljs-number">0xfff8</span>...) <span class="hljs-keyword">for</span> a special NaN. The next<br>** <span class="hljs-number">4</span> bits hold the internal tag. The lowest <span class="hljs-number">47</span> bits either hold a pointer,<br>** a zero-extended <span class="hljs-number">32</span> bit integer or all bits <span class="hljs-built_in">set</span> to <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> primitive types.<br>**<br>**                     ------MSW------.------LSW------<br>** primitive types    |<span class="hljs-number">1.</span><span class="hljs-number">.1</span>|itype|<span class="hljs-number">1.</span>................<span class="hljs-number">.1</span>|<br>** GC objects/lightud |<span class="hljs-number">1.</span><span class="hljs-number">.1</span>|itype|-------GCRef--------|<br>** <span class="hljs-type">int</span> (LJ_DUALNUM)   |<span class="hljs-number">1.</span><span class="hljs-number">.1</span>|itype|<span class="hljs-number">0.</span><span class="hljs-number">.0</span>|-----<span class="hljs-type">int</span>-------|<br>** number              ------------<span class="hljs-type">double</span>-------------<br></code></pre></td></tr></table></figure><p>这里比较特殊的是最高的13位全位1表double类型，itype表示类型，占4位，指针占用47位，总共仍是64位。</p><p>TValue结构<br>LuaJIT的TValue定义在lj_obj.h中，如下面所示，因为Nan-boxing的缘故，这里的TValue结构并没有直接反映实际的内存布局。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* Tagged value. */<br>typedef LJ_ALIGN(8) union TValue &#123;<br>  uint64_t u64;  /* 64 bit pattern overlaps number. */<br>  lua_Number n;  /* Number object overlaps split tag/value object. */<br>#if LJ_GC64<br>  GCRef gcr;  /* GCobj reference with tag. */<br>  int64_t it64;<br>  struct &#123;<br>    LJ_ENDIAN_LOHI(<br>      int32_t i; /* Integer value. */<br>    , uint32_t it; /* Internal object tag. Must overlap MSW of number. */<br>    )<br>  &#125;;<br>#else<br>  struct &#123;<br>    LJ_ENDIAN_LOHI(<br>      union &#123;<br>trueGCRef gcr; /* GCobj reference (if any). */<br>trueint32_t i; /* Integer value. */<br>      &#125;;<br>    , uint32_t it; /* Internal object tag. Must overlap MSW of number. */<br>    )<br>  &#125;;<br>#endif<br><br> ..........<br><br>&#125; TValue;<br></code></pre></td></tr></table></figure><h1 id="类型的定义"><a href="#类型的定义" class="headerlink" title="类型的定义"></a>类型的定义</h1><p>所有的数据类型定义中最高的几位均为1，方便与浮点数的区分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TNIL   (~0u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TFALSE  (~1u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TTRUE  (~2u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TLIGHTUD  (~3u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TSTR   (~4u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TUPVAL  (~5u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TTHREAD  (~6u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TPROTO  (~7u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TFUNC  (~8u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TTRACE  (~9u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TCDATA  (~10u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TTAB   (~11u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TUDATA  (~12u)</span><br><span class="hljs-comment">/* This is just the canonical number type used in some places. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TNUMX  (~13u)</span><br><br><span class="hljs-comment">/* Integers have itype == LJ_TISNUM doubles have itype &lt; LJ_TISNUM */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LJ_64 &amp;&amp; !LJ_GC64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TISNUM  0xfffeffffu</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TISNUM  LJ_TNUMX</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>判断类型的宏定义<br>LuaJIT定义了一系列宏用来判断值的类型。<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LJ_GC64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> itype(o) ((uint32_t)((o)-&gt;it64 &gt;&gt; 47))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisnil(o) ((o)-&gt;it64 == -1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> itype(o) ((o)-&gt;it)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisnil(o) (itype(o) == LJ_TNIL)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisfalse(o) (itype(o) == LJ_TFALSE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvistrue(o) (itype(o) == LJ_TTRUE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisbool(o) (tvisfalse(o) || tvistrue(o))</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LJ_64 &amp;&amp; !LJ_GC64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvislightud(o) (((int32_t)itype(o) &gt;&gt; 15) == -2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvislightud(o) (itype(o) == LJ_TLIGHTUD)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisstr(o) (itype(o) == LJ_TSTR)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisfunc(o) (itype(o) == LJ_TFUNC)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisthread(o) (itype(o) == LJ_TTHREAD)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisproto(o) (itype(o) == LJ_TPROTO)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tviscdata(o) (itype(o) == LJ_TCDATA)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvistab(o) (itype(o) == LJ_TTAB)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisudata(o) (itype(o) == LJ_TUDATA)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisnumber(o) (itype(o) &lt;= LJ_TISNUM)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisint(o) (LJ_DUALNUM &amp;&amp; itype(o) == LJ_TISNUM)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisnum(o) (itype(o) &lt; LJ_TISNUM)</span><br>LJ_DUALNUM<br></code></pre></td></tr></table></figure><p>Lua中数值都是double类型的浮点数，而实际使用时经常会用到整数，而位操作等都需要将double类型转换成整数进行。为此LuaJIT提供了LJ_DUALNUM的选项，一些数值可以直接通过int类型存储，方便使用，相当于为Lua增加了整数这个数据类型。</p><p>LJ_DUALNUM的定义可以参考lj_arch.h，不过对常用的x86_64架构，默认并没有启用LJ_DUALNUM。</p><h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><p><a href="https://qlee.in/luajitde-bian-liang-shi-xian-tvalue/?tdsourcetag=s_pcqq_aiomsg">https://qlee.in/luajitde-bian-liang-shi-xian-tvalue/?tdsourcetag=s_pcqq_aiomsg</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>IEEE Standard for Floating-Point Arithmetic (IEEE 754)</li><li>X86_64 Virtual_address_space_details</li></ul>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Unity 符号表上传</title>
      <link href="/2019/09/27/bugly-symbol/"/>
      <url>/2019/09/27/bugly-symbol/</url>
      
        <content type="html"><![CDATA[<h2 id="Why-do-it"><a href="#Why-do-it" class="headerlink" title="Why do it"></a>Why do it</h2><p>最近游戏内测，发现不少崩溃的堆栈发生在libunity.so之中，而大部分仅仅给一个代码执行到的PC地址，查起来代码比较蛋疼。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-meta">#00 pc 00a6ac38 /data/app/.../libunity.so</span><br><span class="hljs-meta">#01 pc 00a6c128 /data/app/.../x86/libunity.so</span><br><span class="hljs-meta">#02 pc 003f1bf6 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#03 pc 003f0b4a /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#04 pc 0039ff68 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#05 pc 00396e77 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#06 pc 00398ce0 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#07 pc 00398149 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#08 pc 003980a2 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#09 pc 004f2ca3 /data/app/.../x86/libunity.so </span><br></code></pre></td></tr></table></figure><span id="more"></span><p>这种一般没有符号表，不过我们可以使用addr2line这个经典的binutils工具将PC地址转换为函数名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./i686-linux-android-addr2line.exe -C -i -f -e libunity.sym.so 00a6ac38<br></code></pre></td></tr></table></figure><p>输出结果如下:</br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">mecanim::statemachine::EvaluateState(mecanim::ValueArrayConstant <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateConstant <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineInput <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineOutput&amp;, mecanim::statemachine::StateMachineMemory&amp;, mecanim::statemachine::StateOutput&amp;, mecanim::statemachine::StateWorkspace&amp;, <span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>)<br></code></pre></td></tr></table></figure><p>我们很快就可以定位到是一个动画状态机的问题，不过问题也接踵而至,BUG量有点多，然后一起看BUGLY的人也不少，客户端的其他人未必懂这些底层知识，那么其实就可以利用Bugly的符号表功能来做这件事情。</p><h2 id="How-to-do"><a href="#How-to-do" class="headerlink" title="How to do"></a>How to do</h2><p>首先去<a href="https://bugly.qq.com/v2/sdkDownload">Bugly官网</a>上下载最新的符号表导出工具</p><p>Android Unity的符号表路径在Editor\Data\PlaybackEngines\AndroidPlayer\Variations</p><p>搜索libunity.sym.so即可,注意MONO和IL2CPP要对应上传,输入导出和上传指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar buglySymbolAndroid.jar -i libunity.sym.so -u -<span class="hljs-built_in">id</span> <span class="hljs-variable">$yourappid</span> -key <span class="hljs-variable">$yourappkey</span> -package <span class="hljs-variable">$packagename</span> -version xx.xx.xx<br></code></pre></td></tr></table></figure><p>在BUGLY界面中打开界面，如果看到对应的符号表已上传就说明成功了</br><br><img src="/../images/symbol_success.png" alt="成功截图"></br><br>报错堆栈变成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">#<span class="hljs-number">00</span> pc <span class="hljs-number">00</span>a6ac38 libunity.so mecanim::statemachine::EvaluateState(mecanim::ValueArrayConstant <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateConstant <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineInput <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineOutput&amp;, mecanim::statemachine::StateMachineMemory&amp;, mecanim::statemachine::StateOutput&amp;, mecanim::statemachine::StateWorkspace&amp;, <span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>) [x86]<br>#<span class="hljs-number">01</span> pc <span class="hljs-number">00</span>a6c128 libunity.so mecanim::statemachine::SetStateMachineInInitialState(mecanim::statemachine::StateMachineConstant <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineInput <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineOutput&amp;, mecanim::statemachine::StateMachineMemory&amp;, mecanim::statemachine::StateMachineWorkspace&amp;) [x86]<br>#<span class="hljs-number">02</span> pc <span class="hljs-number">003f</span>1bf6 libunity.so <span class="hljs-title function_">AnimatorControllerPlayable::GenerateGraph</span><span class="hljs-params">()</span> [x86]<br>#03 pc 003f0b4a libunity.so <span class="hljs-title function_">AnimatorControllerPlayable::SetAnimatorController</span><span class="hljs-params">(RuntimeAnimatorController*)</span> [x86]<br>#04 pc 0039ff68 libunity.so <span class="hljs-title function_">Animator::CreateInternalControllerPlayable</span><span class="hljs-params">()</span> [x86]<br>#05 pc 00396e77 libunity.so <span class="hljs-title function_">Animator::CreateObject</span><span class="hljs-params">()</span> [x86]<br>#06 pc 00398ce0 libunity.so <span class="hljs-title function_">Animator::Prepare</span><span class="hljs-params">()</span> [x86]<br></code></pre></td></tr></table></figure><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>将Addr2Line与IDA结合，定位报错汇编码</p>]]></content>
      
      
      <categories>
          
          <category> 汇编逆向 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编调用指令，堆栈操作详解</title>
      <link href="/2019/09/27/base-asm-calls/"/>
      <url>/2019/09/27/base-asm-calls/</url>
      
        <content type="html"><![CDATA[<h2 id="一些常用的汇编指令直观翻译"><a href="#一些常用的汇编指令直观翻译" class="headerlink" title="一些常用的汇编指令直观翻译"></a>一些常用的汇编指令直观翻译</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span> , <span class="hljs-built_in">ebx</span>            <span class="hljs-comment">; eax = ebx</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">eax</span> , [<span class="hljs-built_in">ebx</span> + <span class="hljs-number">30</span>]     <span class="hljs-comment">; eax = ebx + 30 </span><br>                         <span class="hljs-comment">; 不这样写就是两条指令 mov eax, ebx ;add eax 30</span><br><span class="hljs-keyword">push</span> <span class="hljs-keyword">pop</span>                 <span class="hljs-comment">; 入栈，出栈</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">5</span>               <span class="hljs-comment">; eax += 5</span><br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">5</span>               <span class="hljs-comment">; eax -= 5</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">eax</span>                  <span class="hljs-comment">; eax += 1</span><br><span class="hljs-keyword">mul</span>                      <span class="hljs-comment">; 乘法</span><br><span class="hljs-keyword">div</span>                      <span class="hljs-comment">; 除法</span><br></code></pre></td></tr></table></figure><h2 id="改变堆栈的操作"><a href="#改变堆栈的操作" class="headerlink" title="改变堆栈的操作"></a>改变堆栈的操作</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span>   // <span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span> , <span class="hljs-number">4</span>  <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span>] , <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span>    // <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span> , [<span class="hljs-built_in">esp</span>]   <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span> , <span class="hljs-number">4</span><br><span class="hljs-keyword">call</span> <span class="hljs-number">1234</span>  // <span class="hljs-keyword">push</span> <span class="hljs-built_in">eip</span>   <span class="hljs-keyword">jmp</span> <span class="hljs-number">1234</span><br><span class="hljs-keyword">retn</span> <span class="hljs-number">8</span>     // <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eip</span>   <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span> , <span class="hljs-number">8</span>   常用于 __stdcall,这种函数自己清理自己的参数的<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span> , xxx<br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span> , xxx<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="栈指针、帧指针的学习"><a href="#栈指针、帧指针的学习" class="headerlink" title="栈指针、帧指针的学习"></a>栈指针、帧指针的学习</h2><p>ESP栈指针,每一次push或者pop值会跟这变，永远指向栈顶 </br><br>EBP帧指针，其实有无无所谓，如果没有使用ESP取局部变量和参数的时候因为地址会一直改变，人的理解上比较麻烦，于是在call指令save 的 EIP后记录下来当前的ESP到EBP中，这样子取参数或者局部变量的时候回更方便。</br></p><p>以下面这个在32位x86计算机上编译的函数为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span>; <span class="hljs-comment">// a function to call</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">demo_stackframe</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, in c)</span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> z;<br>    bar(z, y);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../../images/only_esp.png" alt="&quot;&quot;"></p><p>调用bar函数的时候,如果没有设置 ebp传递参数汇编码如下:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; 假设为__cdecl,参数从右往左入栈，调用者清理堆栈</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">4</span>]    <span class="hljs-comment">; push y</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">4</span>]    <span class="hljs-comment">; push z</span><br><span class="hljs-keyword">call</span> bar              <span class="hljs-comment">; push eip,jmp bar</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">8</span>            <span class="hljs-comment">; 清理堆栈</span><br></code></pre></td></tr></table></figure><p>我们可以发现，如果根据esp来寻找地址，很不直观，第一次我们将 y push到堆栈中后，导致esp sub 4,然后取z的时候地址就会跟着改变，显然这样理解上比较麻烦，同一个参数获取的时候esp的偏移量总是不一样。</p><p>为了更好的计算偏移量，我们需要一个固定不变的堆栈地址，这样就不会出现同一个参数然后偏移不一样的情况。于是引入了ebp(帧指针)的概念,在call bar之后将esp地址记录下来，此时的堆栈情况如下。</p><p><img src="/../images/use_ebp.png" alt="&quot;&quot;"><br>注意调用前要把caller的ebp保存起来，不然到调用完成后，caller的ebp就找不到了。所以调用bar函数前要写上“序言”代码</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span>        <span class="hljs-comment">; 保存 caller的 ebp </span><br><span class="hljs-keyword">mov</span>  <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span>   <span class="hljs-comment">; 将bar函数的ebp设置为当前的esp</span><br><span class="hljs-keyword">sub</span>  <span class="hljs-built_in">esp</span>, <span class="hljs-number">76</span>    <span class="hljs-comment">; 提前扩容好局部变量</span><br></code></pre></td></tr></table></figure><p>注意这里仅仅保存了caller函数的ebp,如果想要保存caller函数的其他寄存器信息比如eax之类的，需要在序言这边push进去</p><p>现在调用bar函数的汇编指令差不多为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">72</span>]         <span class="hljs-comment">; push y</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">76</span>]         <span class="hljs-comment">; push z</span><br><span class="hljs-keyword">call</span> bar<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">8</span>                  <span class="hljs-comment">; 清栈</span><br></code></pre></td></tr></table></figure><p>使用了帧指针ebp后，所有的变量相对于ebp的偏移量都可以计算出来。许多时候，正偏移量用于访问函数参数，而负偏移量用于访问局部变量。使用ebp指针后，我们可以自由的更改esp指针而不用担心，其他变量的偏移地址</p><p>最后完成bar函数调用的时候：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>,<span class="hljs-built_in">ebp</span>          <span class="hljs-comment">; 清理局部变量</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span>              <span class="hljs-comment">; 恢复caller函数的ebp</span><br><span class="hljs-keyword">ret</span>                  <span class="hljs-comment">; pop eip</span><br></code></pre></td></tr></table></figure><p>由于 这种操作非常常见，因此x86体系提供了leave指令来缩短汇编指令长度</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">leave</span>                <span class="hljs-comment">; 相当于</span><br>                     <span class="hljs-comment">; mov esp,ebp</span><br>                     <span class="hljs-comment">; pop ebp</span><br><br><span class="hljs-keyword">ret</span>                  <span class="hljs-comment">; pop eip</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 汇编逆向 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
