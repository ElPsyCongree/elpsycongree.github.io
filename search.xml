<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>snp Profiler</title>
      <link href="/2022/07/18/Unity/profiler/"/>
      <url>/2022/07/18/Unity/profiler/</url>
      
        <content type="html"><![CDATA[<p><img src="/../../images/2022-07-19-18-03-57.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> snp android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDVS shader variants</title>
      <link href="/2022/07/13/ARM/IDVS-shader-variants/"/>
      <url>/2022/07/13/ARM/IDVS-shader-variants/</url>
      
        <content type="html"><![CDATA[<h1 id="IDVS-shader-variants"><a href="#IDVS-shader-variants" class="headerlink" title="IDVS shader variants"></a>IDVS shader variants</h1><p>On Mali GPUs in the Bifrost and Valhall families, vertex shaders are executed using an optimized shading flow called Index-Driven Vertex Shading (IDVS).</p><p>In the IDVS pipeline, vertex shaders are compiled into two binaries:</p><ul><li>A position shader, which computes only position.</li><li>A varying shader, which computes the remaining non-position vertex attribute outputs.</li></ul><h2 id="Figure-2-1-IDVS-pipeline"><a href="#Figure-2-1-IDVS-pipeline" class="headerlink" title="Figure 2-1 IDVS pipeline"></a>Figure 2-1 IDVS pipeline</h2><p><img src="/../../images/2022-07-13-14-47-58.png"></p>]]></content>
      
      
      <categories>
          
          <category> mali gpu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mali </tag>
            
            <tag> IDVS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mali Bifrost Family Performance Counters</title>
      <link href="/2022/07/11/ARM/mali-bifrost-family-performance-counters/"/>
      <url>/2022/07/11/ARM/mali-bifrost-family-performance-counters/</url>
      
        <content type="html"><![CDATA[<h1 id="Mali-Bifrost-Family-Performance-Counters"><a href="#Mali-Bifrost-Family-Performance-Counters" class="headerlink" title="Mali Bifrost Family Performance Counters"></a>Mali Bifrost Family Performance Counters</h1><p>Analysis and optimization of graphics and compute content running on a GPU is an important task when trying to build a top quality system integration, or a compelling high performance application. For developers working with the public APIs, such as OpenGL ES and OpenCL, the GPU is a black box which is very difficult to analyze based solely on the API visible behaviors. Frame pipelining and asynchronous processing of submitted work effectively decouple the application’s visible performance from the API calls which define the workload being executed, making analysis of performance an activity based on expert knowledge and intuition rather than direct measurement.</p><p>Tools such as ARM DS-5 Streamline provide developers access to the GPU hardware performance counters, the principle means to determine the behavior inside the black box beneath the API and identify any problem areas which need optimization. This work guide assumes that DS-5 Streamline is the tool being used for performance analysis, and follows the DS-5 naming conventions for the counters.</p><h2 id="1-Performance-Counter-Infrastructure"><a href="#1-Performance-Counter-Infrastructure" class="headerlink" title="1 Performance Counter Infrastructure"></a>1 Performance Counter Infrastructure</h2><p>The Bifrost GPU family supports many performance counters which can all be captured simultaneously. Performance counters are provided for each functional block in the design:</p><p>Job Manager<br>Tiler<br>Shader core(s)<br>L2 cache(s)<br>See my earlier blog series for an introduction to the Bifrost GPU architecture - it introduces some of the fundamental concepts which are important to understand, and which place the more detailed information in this document in context.</p><p>The Mali GPU: An Abstract Machine, Part 1 - Frame Pipelining<br>The Mali GPU: An Abstract Machine, Part 2 - Tile-based Rendering<br>The Mali GPU: An Abstract Machine, Part 4 - The Bifrost Shader Core</p><h3 id="1-1-Supported-Counters"><a href="#1-1-Supported-Counters" class="headerlink" title="1.1 Supported Counters"></a>1.1 Supported Counters</h3><p>The GPUs in the Bifrost family implement a large number of performance counters natively in the hardware, and it is also generally useful to generate some derived counters by combining one or more of the raw hardware counters in useful and interesting ways. This document will describe all of the counters exported from DS-5 Streamline, and some of the useful derived counters which can be derived from them. DS-5 Streamline allows custom performance counter graphs to be created using equations, so all of these performance counters can be directly visualized in the GUI.</p><h3 id="1-2-Counter-Implementation-Caveats"><a href="#1-2-Counter-Implementation-Caveats" class="headerlink" title="1.2 Counter Implementation Caveats"></a>1.2 Counter Implementation Caveats</h3><p>The hardware counter implementation in the GPU is designed to be low cost, such that it has minimal impact on performance and power. Many of the counters are close approximations of the behavior described in this document in order to minimize the amount of additional hardware logic required to generate the counter signals, so some small deviations from what you may expect may be encountered.</p><span id="more"></span><h2 id="2-Job-Manager-Counters"><a href="#2-Job-Manager-Counters" class="headerlink" title="2 Job Manager Counters"></a>2 Job Manager Counters</h2><p>This section describes the counters implemented by the Mali Job Manager component.</p><h3 id="2-1-Top-Level-Activity"><a href="#2-1-Top-Level-Activity" class="headerlink" title="2.1 Top Level Activity"></a>2.1 Top Level Activity</h3><p>These counters provide information about the overall number of cycles that the GPU was processing a workload, or waiting for software to handle workload completion interrupts.</p><h4 id="2-1-1-JM-GPU-ACTIVE"><a href="#2-1-1-JM-GPU-ACTIVE" class="headerlink" title="2.1.1 JM.GPU_ACTIVE"></a>2.1.1 JM.GPU_ACTIVE</h4><p>Availability: All</p><p>This counter increments every cycle that the GPU either has any workload queued in a Job slot. Note that this counter will increment any cycle a workload is present even if the GPU is totally stalled waiting for external memory to return data; that is still counted as active time even though no forward progress was made.</p><h4 id="2-1-2-JM-GPU-UTILIZATION-Derived"><a href="#2-1-2-JM-GPU-UTILIZATION-Derived" class="headerlink" title="2.1.2 JM.GPU_UTILIZATION (Derived)"></a>2.1.2 JM.GPU_UTILIZATION (Derived)</h4><p>Availability: All</p><p>If the GPU operating frequency is known then overall GPU utilization can be calculated as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">JM.GPU_UTILIZATION = JM.GPU_ACTIVE / GPU_MHZ<br></code></pre></td></tr></table></figure><p>Well pipelined applications which are not running at vsync and keeping the GPU busy should achieve a utilization of around 98%. Lower utilization than this typically indicates one of the following scenarios:</p><p>  Content running at vsync.<br>  In this scenario the GPU goes idle as it has no need to run until next vsync signal.<br>  Content which is bottlenecked by the CPU.<br>  In this scenario the application or driver is causing high CPU load, and cannot build new workloads for the GPU quickly enough to keep it busy.<br>  Content which is oscillating between CPU and the GPU activity.<br>  In this scenario the application is using APIs which break the frame-level pipeline needed to keep the GPU busy. The most common causes are calls to glReadPixels() or glFinish(), as these explicitly drain the pipeline, but other API calls can cause stalls if used in a blocking manner before their result is ready. These include calls such as glClientWaitSync(), glWaitSync(), or glGetQueryObjectuiv().<br>Collecting GPU activity and CPU activity as part of the same DS-5 Streamline data capture can help disambiguate between the cases above. This type of analysis is explored in more detail in my blog on Mali performance.</p><p>It is important to note that most modern devices support Dynamic Voltage and Frequency Scaling (DVFS) to optimize energy usage, which means that the GPU frequency is often not constant while running a piece of content. It is recommended that platform DVFS is disabled, locking the CPU, GPU and memory bus at a fixed frequency, if possible as it makes performance analysis much easier, and results more reproducible. The method for doing this is device specific, and many not be possible at all on production devices; please refer to your platform’s documentation for details.</p><h4 id="2-1-3-JM-JS0-ACTIVE"><a href="#2-1-3-JM-JS0-ACTIVE" class="headerlink" title="2.1.3 JM.JS0_ACTIVE"></a>2.1.3 JM.JS0_ACTIVE</h4><p>Availability: All</p><p>This counter increments every cycle that the GPU has a Job chain running in Job slot 0. This Job slot is used solely for the processing of fragment Jobs, so this corresponds directly to fragment shading workloads.</p><p>For most graphics content there are orders of magnitude more fragments than vertices, so this Job slot will usually be the dominant Job slot which has the highest processing load. In content which is not hitting vsync and the GPU is the performance bottleneck, it is normal for JS0_ACTIVE to be approximately equal to GPU_ACTIVE. In this scenario vertex processing can run in parallel to the fragment processing, allowing fragment processing to run all of the time.</p><h4 id="2-1-4-JM-JS0-UTILIZATION-Derived"><a href="#2-1-4-JM-JS0-UTILIZATION-Derived" class="headerlink" title="2.1.4 JM.JS0_UTILIZATION (Derived)"></a>2.1.4 JM.JS0_UTILIZATION (Derived)</h4><p>Availability: All</p><p>The percentage JS0 utilization can be calculated as:</p><p>JM.JS0_UTILIZATION &#x3D; JM.JS0_ACTIVE &#x2F; JM.GPU_ACTIVE<br>In content which is not hitting vsync and the GPU is the performance bottleneck it is normal for this utilization metric to be close to 1.0 (100%). Fragment processing is normally the dominant workload, and a utilization of close to 100% shows that vertex processing is running in parallel to the fragment processing, allowing maximum utilization of the functional units in the hardware.</p><h4 id="2-1-5-JM-JS1-ACTIVE"><a href="#2-1-5-JM-JS1-ACTIVE" class="headerlink" title="2.1.5 JM.JS1_ACTIVE"></a>2.1.5 JM.JS1_ACTIVE</h4><p>Availability: All</p><p>This counter increments every cycle the GPU has a Job chain running in Job slot 1. This Job slot can be used for compute shaders, vertex shaders, and tiling workloads. This counter cannot disambiguate between these workloads.</p><h4 id="2-1-6-JM-JS1-UTILIZATION-Derived"><a href="#2-1-6-JM-JS1-UTILIZATION-Derived" class="headerlink" title="2.1.6 JM.JS1_UTILIZATION (Derived)"></a>2.1.6 JM.JS1_UTILIZATION (Derived)</h4><p>Availability: All</p><p>The percentage JS1 utilization can be calculated as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">JM.JS1_UTILIZATION = JM.JS1_ACTIVE / JM.GPU_ACTIVE<br></code></pre></td></tr></table></figure><h4 id="2-1-7-JM-IRQ-ACTIVE"><a href="#2-1-7-JM-IRQ-ACTIVE" class="headerlink" title="2.1.7 JM.IRQ_ACTIVE"></a>2.1.7 JM.IRQ_ACTIVE</h4><p>Availability: All</p><p>This counter increments every cycle the GPU has an interrupt pending, awaiting handling by the driver running on the CPU. Note that this does not necessarily indicate lost performance because the GPU can still process Job chains from other Job slots, as well as process the next work item in the interrupt generating Job slot, while an interrupt is pending.</p><p>If a high JM.IRQ_ACTIVE cycle count is observed alongside other counters which make it look like the GPU is starving for work, such as a low SC.COMPUTE_ACTIVE and SC.FRAG_ACTIVE, this may indicate a system performance issue. Possible causes include:</p><p>A system where the CPU is fully utilized, causing a delay in scheduling IRQ handlers.<br>A system where a device driver, which may not be the Mali device driver, has IRQs masked for a long period of time, stopping the CPU receiving new interrupt notifications.<br>Processing a very high number of small framebuffers or small compute workloads, resulting in a high frequency of job completion interrupts to the CPU.</p><h3 id="2-2-Task-Dispatch"><a href="#2-2-Task-Dispatch" class="headerlink" title="2.2 Task Dispatch"></a>2.2 Task Dispatch</h3><p>This section looks at the counters related to how the Job Manager issues work to shader cores.</p><h4 id="2-2-1-JM-JS0-TASKS"><a href="#2-2-1-JM-JS0-TASKS" class="headerlink" title="2.2.1 JM.JS0_TASKS"></a>2.2.1 JM.JS0_TASKS</h4><p>Availability: All</p><p>This counter increments every time the Job Manager issues a task to a shader core. For JS0 these tasks correspond to a single 32x32 pixel screen region, although not all of these pixels may be rendered due to viewport or scissor settings.</p><h4 id="2-2-2-JM-PIXEL-COUNT-Derived"><a href="#2-2-2-JM-PIXEL-COUNT-Derived" class="headerlink" title="2.2.2 JM.PIXEL_COUNT (Derived)"></a>2.2.2 JM.PIXEL_COUNT (Derived)</h4><p>Availability: All</p><p>A approximation of the total scene pixel count can be computed as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">JM.PIXEL_COUNT = JM.JS0_TASKS * 32 * 32<br></code></pre></td></tr></table></figure><h2 id="3-Shader-Core-Counters"><a href="#3-Shader-Core-Counters" class="headerlink" title="3 Shader Core Counters"></a>3 Shader Core Counters</h2><p>This section describes the counters implemented by the Mali Shader Core. For the purposes of clarity this section talks about either fragment workloads or compute workloads. Vertex, Geometry, and Tessellation workloads are treated as a one dimensional compute problem by the shader core, so are counted as a compute workload from the point of view of the counters in this section.</p><p>The GPU hardware records separate counters per shader core in the system. DS-5 Streamline shows the average of all of the shader core counters.</p><h3 id="3-1-Shader-Core-Activity"><a href="#3-1-Shader-Core-Activity" class="headerlink" title="3.1 Shader Core Activity"></a>3.1 Shader Core Activity</h3><p>These counters show the total activity level of the shader core.</p><h4 id="3-1-1-SC-COMPUTE-ACTIVE"><a href="#3-1-1-SC-COMPUTE-ACTIVE" class="headerlink" title="3.1.1 SC.COMPUTE_ACTIVE"></a>3.1.1 SC.COMPUTE_ACTIVE</h4><p>Availability: All</p><p>This counter increments every cycle at least one compute task is active anywhere inside the shader core, including the fixed-function compute frontend, or the programmable execution core.</p><h4 id="3-1-2-SC-FRAG-ACTIVE"><a href="#3-1-2-SC-FRAG-ACTIVE" class="headerlink" title="3.1.2 SC.FRAG_ACTIVE"></a>3.1.2 SC.FRAG_ACTIVE</h4><p>Availability: All</p><p>This counter increments every cycle at least one fragment task is active anywhere inside the shader core, including the fixed-function fragment frontend, the programmable execution core, or the fixed-function fragment backend.</p><h4 id="3-1-3-SC-EXEC-CORE-ACTIVE"><a href="#3-1-3-SC-EXEC-CORE-ACTIVE" class="headerlink" title="3.1.3 SC.EXEC_CORE_ACTIVE"></a>3.1.3 SC.EXEC_CORE_ACTIVE</h4><p>Availability: All</p><p>This counter increments every cycle at least one quad is active inside the programmable execution core. Note that this counter does not give any idea of total utilization of the shader core resources, but simply gives an indication that something was running.</p><h4 id="3-1-4-SC-EXEC-CORE-UTILIZATION-Derived"><a href="#3-1-4-SC-EXEC-CORE-UTILIZATION-Derived" class="headerlink" title="3.1.4 SC.EXEC_CORE_UTILIZATION (Derived)"></a>3.1.4 SC.EXEC_CORE_UTILIZATION (Derived)</h4><p>Availability: All</p><p>An approximation of the overall utilization of the execution core can be determined using the following equation:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.EXEC_CORE_UTILIZATION = SC.EXEC_CORE_ACTIVE / JM.GPU_ACTIVE<br></code></pre></td></tr></table></figure><p>A low utilization of the execution core indicates possible lost performance, as there are spare shader core cycles which could be used if they could be accessed. There are multiple possible root causes of low utilization. The most common cause is content with a significant number tiles which do not require any fragment shader program to be executed. This may occur because:</p><p>Screen regions are simply a clear color and contain no drawn geometry.<br>Screen regions contain significant amount of geometry which only does a depth&#x2F;stencil update and this update can be entirely resolved at the point of early-zs, prior to fragment shading.<br>Other causes include:</p><p>Screen regions containing a high level of front-to-back geometry, resulting in one layer being drawn and multiple redundant layers being killed by early-zs. If the cost of loading the redundant geometry exceeds the cost of shading the visible layer then some idle time will be observed.<br>Screen regions containing a high level of opaque back-to-front geometry, resulting in one layer being drawn and multiple redundant layers being killed by Forward Pixel Kill (FPK); see Killing Pixels - A New Optimization for Shading on ARM Mali GPUs.</p><h3 id="3-2-Compute-Frontend-Events"><a href="#3-2-Compute-Frontend-Events" class="headerlink" title="3.2 Compute Frontend Events"></a>3.2 Compute Frontend Events</h3><p>These counters show the task and thread issue behavior of the shader core’s fixed function compute frontend which issues work into the programmable core.</p><h4 id="3-2-1-SC-COMPUTE-QUADS"><a href="#3-2-1-SC-COMPUTE-QUADS" class="headerlink" title="3.2.1 SC.COMPUTE_QUADS"></a>3.2.1 SC.COMPUTE_QUADS</h4><p>Availability: All</p><p>This counter increments for every compute quad spawned by the shader core. One compute quad is spawned for every four work items (compute shaders), vertices (vertex and tessellation evaluation shaders), primitives (geometry shaders), or control points (tessellation control shaders). To ensure full utilization of the four thread capacity of a quad any compute workgroups should be a multiple of four in size.</p><h4 id="3-2-2-SC-COMPUTE-QUAD-CYCLES-Derived"><a href="#3-2-2-SC-COMPUTE-QUAD-CYCLES-Derived" class="headerlink" title="3.2.2 SC.COMPUTE_QUAD_CYCLES (Derived)"></a>3.2.2 SC.COMPUTE_QUAD_CYCLES (Derived)</h4><p>Availability: All</p><p>This counter calculates an average compute cycles per compute quad, giving some measure of the per-quad processing load.</p><p>SC.COMPUTE_QUAD_CYCLES &#x3D; SC.COMPUTE_ACTIVE &#x2F; SC.COMPUTE_QUADS<br>Note that in most cases the dominant cost here is the programmable code running on the execution core, and so there will be some cross-talk caused by compute and fragment workloads running concurrently on the same hardware. This counter is therefore indicative of cost, but does not reflect precise costing.</p><h3 id="3-3-Fragment-Frontend-Events"><a href="#3-3-Fragment-Frontend-Events" class="headerlink" title="3.3 Fragment Frontend Events"></a>3.3 Fragment Frontend Events</h3><p>These counters show the task and thread issue behavior of the shader core’s fixed-function fragment frontend. This unit is significantly more complicated than the compute frontend, so there are a large number of counters available.</p><h4 id="3-3-1-SC-FRAG-PRIMITIVES-RAST"><a href="#3-3-1-SC-FRAG-PRIMITIVES-RAST" class="headerlink" title="3.3.1 SC.FRAG_PRIMITIVES_RAST"></a>3.3.1 SC.FRAG_PRIMITIVES_RAST</h4><p>Availability: All</p><p>This counter increments for every primitive entering the frontend fixed-function rasterization stage; these primitives are guaranteed to be inside the current tile being rendered.</p><p>Note that this counter will increment once per primitive per tile in which that primitive is located. If you wish to know the total number of primitives in the scene without factoring in tiling effects see the Tiler block’s primitive counters.</p><h4 id="3-3-2-SC-FRAG-QUADS-RAST"><a href="#3-3-2-SC-FRAG-QUADS-RAST" class="headerlink" title="3.3.2 SC.FRAG_QUADS_RAST"></a>3.3.2 SC.FRAG_QUADS_RAST</h4><p>Availability: All</p><p>This counter increments for every 2x2 pixel quad which is rasterized by the rasterization unit. The quads generated have at least some coverage based on the current sample pattern, but may subsequently be killed by early depth and stencil testing and as such never issued to the programmable core.</p><h4 id="3-3-3-SC-FRAG-QUADS-EZS-TEST"><a href="#3-3-3-SC-FRAG-QUADS-EZS-TEST" class="headerlink" title="3.3.3 SC.FRAG_QUADS_EZS_TEST"></a>3.3.3 SC.FRAG_QUADS_EZS_TEST</h4><p>Availability: All</p><p>This counter increments for every 2x2 pixel quad which is subjected to ZS testing. We want as many quads as possible to be subject to early ZS testing as it is significantly more efficient than late ZS testing, which will only kill threads after they have been fragment shaded.</p><h4 id="3-3-4-SC-FRAG-QUADS-EZS-UPDATE"><a href="#3-3-4-SC-FRAG-QUADS-EZS-UPDATE" class="headerlink" title="3.3.4 SC.FRAG_QUADS_EZS_UPDATE"></a>3.3.4 SC.FRAG_QUADS_EZS_UPDATE</h4><p>Availability: All</p><p>This counter increments for every 2x2 pixel quad which has completed an early ZS update operation. Quads which have a depth value which depends on shader execution, or which have indeterminate coverage due to use of discard statements in the shader or the use of alpha-to-coverage, may be early ZS tested but cannot do an early ZS update.</p><h4 id="3-3-5-SC-FRAG-QUADS-EZS-KILLED"><a href="#3-3-5-SC-FRAG-QUADS-EZS-KILLED" class="headerlink" title="3.3.5 SC.FRAG_QUADS_EZS_KILLED"></a>3.3.5 SC.FRAG_QUADS_EZS_KILLED</h4><p>Availability: All</p><p>This counter increments for every 2x2 pixel quad which is completely killed by early ZS testing. These killed quads will not generate any further processing in the shader core.</p><h4 id="3-3-6-SC-FRAG-QUADS-KILLED-BY-OVERDRAW-Derived"><a href="#3-3-6-SC-FRAG-QUADS-KILLED-BY-OVERDRAW-Derived" class="headerlink" title="3.3.6 SC.FRAG_QUADS_KILLED_BY_OVERDRAW (Derived)"></a>3.3.6 SC.FRAG_QUADS_KILLED_BY_OVERDRAW (Derived)</h4><p>Availability: All</p><p>This derived counter increments for every 2x2 pixel quad which survives early-zs testing but that is overdrawn by an opaque quad before spawning as fragment shading threads in the programmable core.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.FRAG_QUADS_KILLED_BY_OVERDRAW = SC.FRAG_QUADS_RAST - SC.FRAG_QUADS_EZS_KILL - SC.FRAG_QUADS<br></code></pre></td></tr></table></figure><p>If a significant percentage of the total rasterized quads are overdrawn, this is indicative that the application is rendering in a back-to-front order which means that the early-zs test is unable to kill the redundant workload. Schemes such as Forward Pixel Kill can minimize the cost, but it is recommended that the application renders opaque geometry front-to-back as early-zs testing provides stronger guarantees of efficiency.</p><h4 id="3-3-7-SC-FRAG-QUADS-OPAQUE"><a href="#3-3-7-SC-FRAG-QUADS-OPAQUE" class="headerlink" title="3.3.7 SC.FRAG_QUADS_OPAQUE"></a>3.3.7 SC.FRAG_QUADS_OPAQUE</h4><p>Availability: All</p><p>This counter increments for every 2x2 pixel quad which is architecturally opaque – i.e. not using blending, shader discard, or alpha-to-coverage – that survives early-zs testing. Opaque fragments are normally more efficient for the GPU to handle, as only the top opaque layer needs to be drawn, so we recommend ensuring opacity of draw calls whenever possible.</p><h4 id="3-3-8-SC-FRAG-QUADS-TRANSPARENT-Derived"><a href="#3-3-8-SC-FRAG-QUADS-TRANSPARENT-Derived" class="headerlink" title="3.3.8 SC.FRAG_QUADS_TRANSPARENT (Derived)"></a>3.3.8 SC.FRAG_QUADS_TRANSPARENT (Derived)</h4><p>Availability: All</p><p>This counter increments for every 2x2 pixel quad which is architecturally transparent – i.e. using blending, shader discard, or alpha-to-coverage – that survives early-zs testing. Note that transparent in this context implies either alpha transparency, or a shader-dependent coverage mask.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.FRAG_QUADS_TRANSPARENT = SC.FRAG_QUADS_RAST - SC.FRAG_QUADS_EZS_KILL - SC.FRAG_QUADS_OPAQUE<br></code></pre></td></tr></table></figure><h4 id="3-3-9-SC-FRAG-QUAD-BUFFER-NOT-EMPTY"><a href="#3-3-9-SC-FRAG-QUAD-BUFFER-NOT-EMPTY" class="headerlink" title="3.3.9 SC.FRAG_QUAD_BUFFER_NOT_EMPTY"></a>3.3.9 SC.FRAG_QUAD_BUFFER_NOT_EMPTY</h4><p>Availability: All</p><p>This counter increments every cycle the fragment unit is active, and the pre-pipe buffer contains at least one 2x2 pixel quad waiting to be executed in the execution core. If this buffer drains the frontend will be unable to spawn a new quad if an execution core quad slot becomes free.</p><p>If this counter is low relative to SC.FRAG_ACTIVE then the shader core may be running out of rasterized quads to turn in to fragment quads, which can in turn cause low utilization of the functional units in the execution core if the total number of quads active in the execution core drops too far. Possible causes for this include:</p><p>Tiles which contain no geometry.<br>Tiles which contain a lot of geometry which can be dropped at early-zs, either because it is redundant and it is killed, or because it is a simple depth and stencil update which can be resolved without fragment shader execution.<br>Tiles which contain triangles from a large number of different drawing operations, causing state loading to become a bottleneck. It is recommended that industry best practice, such as draw batching, is used to minimize the number of unique drawing operations present in a frame.</p><h4 id="3-3-10-SC-FRAG-QUADS"><a href="#3-3-10-SC-FRAG-QUADS" class="headerlink" title="3.3.10 SC.FRAG_QUADS"></a>3.3.10 SC.FRAG_QUADS</h4><p>Availability: All</p><p>This counter increments for every fragment quad created by the GPU.</p><p>In most situations a single quad contains threads for four fragments spanning a 2×2 pixel region of the screen. If an application is rendering to a multi-sampled render target with GL_SAMPLE_SHADING enabled then shader evaluation is per-sample rather than per pixel and one fragment thread will be generated for example sample point covered. For example, an 8xMSAA render target using sample rate shading will generate two fragment quads per screen pixel covered by the primitive.</p><h4 id="3-3-11-SC-FRAG-PARTIAL-QUADS"><a href="#3-3-11-SC-FRAG-PARTIAL-QUADS" class="headerlink" title="3.3.11 SC.FRAG_PARTIAL_QUADS"></a>3.3.11 SC.FRAG_PARTIAL_QUADS</h4><p>Availability: All</p><p>This counter increments for every fragment quad which contains at least one thread slot which has no sample coverage, and is therefore indicative of lost performance. Partial coverage in a 2×2 fragment quad will occur if its sample points span the edge of a triangle, or if one or more sample points fail an early-zs test.</p><h4 id="3-3-12-SC-FRAG-PARTIAL-QUAD-PERCENTAGE-Derived"><a href="#3-3-12-SC-FRAG-PARTIAL-QUAD-PERCENTAGE-Derived" class="headerlink" title="3.3.12 SC.FRAG_PARTIAL_QUAD_PERCENTAGE (Derived)"></a>3.3.12 SC.FRAG_PARTIAL_QUAD_PERCENTAGE (Derived)</h4><p>Availability: All</p><p>This counter calculates an percentage of spawned quads that have partial coverage.</p><p>SC.FRAG_PARTIAL_QUAD_PERCENTAGE &#x3D; SC.FRAG_PARTIAL_QUADS &#x2F; SC.FRAG_QUADS<br>A high percentage of partial quads indicates possible problems with meshes containing high numbers of small triangles; the ratio of the total edge length of a primitive to the screen area of a primitive increases as primitives shrink, so quads which span primitive edges become more common.</p><p>Partial coverage issues can be reduced by using object meshes which contain larger triangles. One common optimization technique which helps reduce the frequency of microtriangles is the use of dynamic model level of detail selection. In these schemes, each object mesh is generated at multiple detail levels during content generation, and an appropriate mesh is chosen per draw call based on the distance between the object and the camera. The further the object is from the camera, the lower the selected mesh complexity needs to be.</p><h4 id="3-3-13-SC-FRAG-QUAD-CYCLES-Derived"><a href="#3-3-13-SC-FRAG-QUAD-CYCLES-Derived" class="headerlink" title="3.3.13 SC.FRAG_QUAD_CYCLES (Derived)"></a>3.3.13 SC.FRAG_QUAD_CYCLES (Derived)</h4><p>Availability: All</p><p>This counter calculates an average fragment cycles per fragment quad, giving some measure of the per-quad processing cost.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.FRAG_QUAD_CYCLES = SC.FRAG_ACTIVE / SC.FRAG_QUADS<br></code></pre></td></tr></table></figure><p>Note that in most cases the dominant cost here is the programmable code running on the execution core, so there will be some cross-talk caused by compute and fragment workloads running concurrently on the same hardware. This counter is therefore indicative of cost, but does not reflect precise costing.</p><h3 id="3-4-Fragment-Backend-Events"><a href="#3-4-Fragment-Backend-Events" class="headerlink" title="3.4 Fragment Backend Events"></a>3.4 Fragment Backend Events</h3><p>These counters record the fragment backend behavior.</p><h4 id="3-4-1-SC-FRAG-THREADS-LZS-TEST"><a href="#3-4-1-SC-FRAG-THREADS-LZS-TEST" class="headerlink" title="3.4.1 SC.FRAG_THREADS_LZS_TEST"></a>3.4.1 SC.FRAG_THREADS_LZS_TEST</h4><p>Availability: All</p><p>This counter increments for every thread triggering late depth and stencil (ZS) testing.</p><h4 id="3-4-2-SC-FRAG-THREADS-LZS-KILLED"><a href="#3-4-2-SC-FRAG-THREADS-LZS-KILLED" class="headerlink" title="3.4.2 SC.FRAG_THREADS_LZS_KILLED"></a>3.4.2 SC.FRAG_THREADS_LZS_KILLED</h4><p>Availability: All</p><p>This counter increments for every thread killed by late ZS testing. These threads are killed after their fragment program has executed, so a significant number of threads being killed at late ZS implies a significant amount of lost performance and&#x2F;or wasted energy performing rendering which has no useful visual output.</p><p>The main causes of threads using late-zs are:</p><p>Fragment shader programs using explicit discard statements<br>Fragment shader programs using implicit discard (alpha-to-coverage).<br>Fragment shader programs with side-effects on shared resources, such as shader storage buffer objects, images, or atomics.</p><h4 id="3-4-3-SC-FRAG-NUM-TILES"><a href="#3-4-3-SC-FRAG-NUM-TILES" class="headerlink" title="3.4.3 SC.FRAG_NUM_TILES"></a>3.4.3 SC.FRAG_NUM_TILES</h4><p>Availability: All</p><p>This counter increments for every tile rendered. The size of a physical tile can vary from 16×16 pixels (largest) downwards. The size of physical tile actually used depends on the number of bytes of memory needed to store the working set for each pixel; the largest tile size allows up to 128-bits per pixel of color storage – enough for a single 32-bit per pixel render target using 4xMSAA, or  4x32-bit per pixel surfaces using multiple-render targets (MRT). Requiring more than that will result in proportionally smaller tile sizes.</p><p>The total storage required per pixel depends on the use of:</p><p>Multi-sample anti-aliasing (MSAA)<br>Multiple render targets (MRT)<br>The size of the attached per-pixel color data format(s)<br>The use of pixel local storage (PLS); see Pixel Local Storage.<br>In general the larger tile sizes are more efficient than smaller tile sizes, especially for content with high geometry complexity. This counter cannot be used to directly determine the physical tile sizes used.</p><h4 id="3-4-4-SC-FRAG-TILES-CRC-CULLED"><a href="#3-4-4-SC-FRAG-TILES-CRC-CULLED" class="headerlink" title="3.4.4 SC.FRAG_TILES_CRC_CULLED"></a>3.4.4 SC.FRAG_TILES_CRC_CULLED</h4><p>Availability: All</p><p>This counter increments for every physical rendered tile which has its writeback cancelled due to a matching transaction elimination CRC hash. If a high percentage of the tile writes are being eliminated this implies that you are re-rendering the entire screen when not much has changed, so consider using scissor rectangles to minimize the amount of area which is redrawn. This isn’t always easy, especially for window surfaces which are pipelines using multiple buffers, but EGL extensions such as these may be supported on your platform which can help manage the partial frame updates:</p><p><a href="https://www.khronos.org/registry/egl/extensions/KHR/EGL_KHR_partial_update.txt">https://www.khronos.org/registry/egl/extensions/KHR/EGL_KHR_partial_update.txt</a><br><a href="https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_swap_buffers_with_damage.txt">https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_swap_buffers_with_damage.txt</a></p><h3 id="3-5-Execution-Engine-Events"><a href="#3-5-Execution-Engine-Events" class="headerlink" title="3.5 Execution Engine Events"></a>3.5 Execution Engine Events</h3><p>These counters look at the behavior of the arithmetic execution engine.</p><h4 id="3-5-1-SC-EE-INSTRS"><a href="#3-5-1-SC-EE-INSTRS" class="headerlink" title="3.5.1 SC.EE_INSTRS"></a>3.5.1 SC.EE_INSTRS</h4><p>Availability: All</p><p>This counter increments for every arithmetic instruction architecturally executed for a quad in an execution engine. This counter is normalized based on the number of execution engines implemented in the design, so gives the per engine performance, rather than the total executed application workload.</p><h4 id="3-5-2-SC-EE-UTILIZATION-Derived"><a href="#3-5-2-SC-EE-UTILIZATION-Derived" class="headerlink" title="3.5.2. SC.EE_UTILIZATION (Derived)"></a>3.5.2. SC.EE_UTILIZATION (Derived)</h4><p>Availability: All</p><p>The peak performance is one arithmetic instruction per engine per cycle, so the effective utilization of the arithmetic hardware can be computed as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.EE_UTILIZATION = SC.EE_INSTRS / SC.EXEC_CORE_ACTIVE<br></code></pre></td></tr></table></figure><h4 id="3-5-3-SC-EE-INSTRS-DIVERGED"><a href="#3-5-3-SC-EE-INSTRS-DIVERGED" class="headerlink" title="3.5.3 SC.EE_INSTRS_DIVERGED"></a>3.5.3 SC.EE_INSTRS_DIVERGED</h4><p>Availability: All</p><p>This counter increments for every arithmetic instruction architecturally executed where there is control flow divergence in the quad resulting in at least one lane of computation being masked out. Control flow divergence erodes arithmetic execution efficiency because it implies some arithmetic lanes are idle, so should be minimized when designing shader effects.</p><h3 id="3-6-Load-x2F-Store-Cache-Events"><a href="#3-6-Load-x2F-Store-Cache-Events" class="headerlink" title="3.6 Load&#x2F;Store Cache Events"></a>3.6 Load&#x2F;Store Cache Events</h3><p>These counters look at the behavior of the load&#x2F;store pipe.</p><h4 id="3-6-1-SC-LSC-READS-FULL"><a href="#3-6-1-SC-LSC-READS-FULL" class="headerlink" title="3.6.1 SC.LSC_READS_FULL"></a>3.6.1 SC.LSC_READS_FULL</h4><p>Availability: All</p><p>This counter increments for every LS cache access executed which returns 128-bits of data.</p><h4 id="3-6-2-SC-LSC-READS-SHORT"><a href="#3-6-2-SC-LSC-READS-SHORT" class="headerlink" title="3.6.2 SC.LSC_READS_SHORT"></a>3.6.2 SC.LSC_READS_SHORT</h4><p>Availability: All</p><p>This counter increments for every LS cache access executed which returns less than 128-bits of data.</p><p>Full width data loads make best use of the cache, so where possible efficiency can be improved by merging short loads together.</p><p>Maximize data locality in attributes, varyings, and uniform buffers within a thread, for example packing data into adjacent vector elements and structure fields.<br>Minimize the amount of unused data in vector data types, uniform buffer control structures, and interleaved vertex attribute buffers.<br>Write compute shaders so adjacent threads sharing a quad access adjacent addresses in memory, allowing multiple loads to return data from the same cache line.</p><h4 id="3-6-3-SC-LSC-WRITES-FULL"><a href="#3-6-3-SC-LSC-WRITES-FULL" class="headerlink" title="3.6.3 SC.LSC_WRITES_FULL"></a>3.6.3 SC.LSC_WRITES_FULL</h4><p>Availability: All</p><p>This counter increments for every LS cache access executed which writes 128-bits of data.</p><h4 id="3-6-4-SC-LSC-WRITES-SHORT"><a href="#3-6-4-SC-LSC-WRITES-SHORT" class="headerlink" title="3.6.4 SC.LSC_WRITES_SHORT"></a>3.6.4 SC.LSC_WRITES_SHORT</h4><p>Availability: All</p><p>This counter increments for every LS cache access executed which writes less than 128-bits of data.</p><p>Full width data writes make best use of the cache, so where possible efficiency can be improved by merging short writes together. See LS_READ_SHORT section for advice on how this can be achieved.</p><h4 id="3-6-5-SC-LSC-ATOMICS"><a href="#3-6-5-SC-LSC-ATOMICS" class="headerlink" title="3.6.5 SC.LSC_ATOMICS"></a>3.6.5 SC.LSC_ATOMICS</h4><p>Availability: All</p><p>This counter increments for atomic operation issued to the LS cache.</p><h4 id="3-6-6-SC-LSC-ISSUES-Derived"><a href="#3-6-6-SC-LSC-ISSUES-Derived" class="headerlink" title="3.6.6 SC.LSC_ISSUES (Derived)"></a>3.6.6 SC.LSC_ISSUES (Derived)</h4><p>Availability: All</p><p>This counter counts the total number of load&#x2F;store cache access operations issued. Each operation is executed with single cycle throughput, but latency of response depends on cache hit rate and external memory system performance.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.LSC_ISSUES = SC.LSC_READS_FULL + SC.LSC_READS_SHORT + <br>                SC.LSC_WRITES_FULL + SC.LSC_WRITES_SHORT +<br>                SC.LSC_ATOMICS<br></code></pre></td></tr></table></figure><h4 id="3-6-7-SC-LSC-UTILIZATION-Derived"><a href="#3-6-7-SC-LSC-UTILIZATION-Derived" class="headerlink" title="3.6.7 SC.LSC_UTILIZATION (Derived)"></a>3.6.7 SC.LSC_UTILIZATION (Derived)</h4><p>Availability: All</p><p>The utilization of the load&#x2F;store cache can be determined as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.LSC_UTILIZATION = SC.LSC_ISSUES / SC.EXEC_CORE_ACTIVE<br></code></pre></td></tr></table></figure><h4 id="3-6-8-SC-LSC-READ-BEATS"><a href="#3-6-8-SC-LSC-READ-BEATS" class="headerlink" title="3.6.8 SC.LSC_READ_BEATS"></a>3.6.8 SC.LSC_READ_BEATS</h4><p>Availability: All</p><p>This counter increments for every 16 bytes of data fetched from the L2 memory system.</p><h4 id="3-6-9-SC-LSC-L2-BYTES-PER-ISSUE-Derived"><a href="#3-6-9-SC-LSC-L2-BYTES-PER-ISSUE-Derived" class="headerlink" title="3.6.9 SC.LSC_L2_BYTES_PER_ISSUE (Derived)"></a>3.6.9 SC.LSC_L2_BYTES_PER_ISSUE (Derived)</h4><p>Availability: All</p><p>The average number of bytes read from the L2 cache per load&#x2F;store L1 cache access can be given as.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.LSC_L2_BYTES_PER_ISSUE = (SC.LSC_READ_BEATS * 16) / SC.LSC_ISSUES<br></code></pre></td></tr></table></figure><p>This gives some idea of level one cache efficiency, although does require some knowledge of how the application is using non-texture data to interpret. For example some use cases expect to have good cache hit rates and reuse the same data many times from different threads, whereas other use cases are data streaming use cases are use each data item exactly once.</p><h4 id="3-6-10-SC-LSC-READ-BEATS-EXTERNAL"><a href="#3-6-10-SC-LSC-READ-BEATS-EXTERNAL" class="headerlink" title="3.6.10 SC.LSC_READ_BEATS_EXTERNAL"></a>3.6.10 SC.LSC_READ_BEATS_EXTERNAL</h4><p>Availability: All</p><p>This counter increments for every 16 bytes of data fetched from the L2 memory system which missed in the L2 cache and required a fetch from external memory.</p><h4 id="3-6-11-SC-LSC-EXTERNAL-BYTES-PER-ISSUE-Derived"><a href="#3-6-11-SC-LSC-EXTERNAL-BYTES-PER-ISSUE-Derived" class="headerlink" title="3.6.11 SC.LSC_EXTERNAL_BYTES_PER_ISSUE (Derived)"></a>3.6.11 SC.LSC_EXTERNAL_BYTES_PER_ISSUE (Derived)</h4><p>Availability: All</p><p>The average number of bytes read from the external memory interface per load&#x2F;store L1 cache access can be given as.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.LSC_EXTERNAL_BYTES_PER_ISSUE = (SC.LSC_READ_BEATS_EXTERNAL * 16) / SC.<br></code></pre></td></tr></table></figure><p>LSC_ISSUES<br>This gives some idea of level two cache efficiency, although does require some knowledge of how the application is using non-texture data to interpret. For example some use cases expect to have good cache hit rates and reuse the same data many times from different threads, whereas other use cases are data streaming use cases are use each data item exactly once.</p><h4 id="3-6-12-SC-LSC-WRITE-BEATS"><a href="#3-6-12-SC-LSC-WRITE-BEATS" class="headerlink" title="3.6.12 SC.LSC_WRITE_BEATS"></a>3.6.12 SC.LSC_WRITE_BEATS</h4><p>Availability: All</p><p>This counter increments for every 16 bytes of data written to the L2 memory system.</p><h3 id="3-7-Texture-Pipe-Events"><a href="#3-7-Texture-Pipe-Events" class="headerlink" title="3.7 Texture Pipe Events"></a>3.7 Texture Pipe Events</h3><p>This counter set looks at the texture pipe behavior.</p><p>Note: The texture pipe event counters increment per thread (fragment), not per quad.</p><h4 id="3-7-1-SC-TEX-INSTRS"><a href="#3-7-1-SC-TEX-INSTRS" class="headerlink" title="3.7.1 SC.TEX_INSTRS"></a>3.7.1 SC.TEX_INSTRS</h4><p>Availability: All</p><p>This counter increments for every architecturally executed texture instruction.</p><h4 id="3-7-2-SC-TEX-ISSUES"><a href="#3-7-2-SC-TEX-ISSUES" class="headerlink" title="3.7.2 SC.TEX_ISSUES"></a>3.7.2 SC.TEX_ISSUES</h4><p>Availability: All</p><p>This counter increments for every texture issue cycle used. Some instructions take more than one cycle due to multi-cycle data access and filtering operations:</p><p>2D bilinear filtering takes one cycle.<br>2D trilinear filtering takes two cycles.<br>3D bilinear filtering takes two cycles.<br>3D trilinear filtering takes four cycles.<br>Sampling from multi-plane YUV may take multiple cycles on some implementations.<br>Sampling from wide (&gt;&#x3D; 16-bit per channel)  textures may take multiple cycles.<br>Note: sampling from a depth texture only requires a single channel to be returned and so only takes a single cycle, even though it would otherwise qualify as a wide data format.</p><h4 id="3-7-3-SC-TEX-UTILIZATION-Derived"><a href="#3-7-3-SC-TEX-UTILIZATION-Derived" class="headerlink" title="3.7.3 SC.TEX_UTILIZATION (Derived)"></a>3.7.3 SC.TEX_UTILIZATION (Derived)</h4><p>Availability: All</p><p>The texture unit utilization is computed as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.TEX_UTILIZATION = SC.TEX_ISSUES / SC.EXEC_CORE_ACTIVE<br></code></pre></td></tr></table></figure><h4 id="3-7-4-SC-TEX-CPI-Derived"><a href="#3-7-4-SC-TEX-CPI-Derived" class="headerlink" title="3.7.4 SC.TEX_CPI (Derived)"></a>3.7.4 SC.TEX_CPI (Derived)</h4><p>Availability: All</p><p>The average cycle usage of the texture unit per instruction can be computed as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.TEX_CPI = SC.TEX_ISSUES / SC.TEX_INSTRS<br></code></pre></td></tr></table></figure><p>The best case CPI is 1.0; CPI above 1.0 implies the use of multi-cycle texture instructions. The following counters give a direct view of two of the sources of multi-cycle texture operations:</p><p>SC.TEX_INSTR_3D (see )<br>SC.TEX_INSTR_TRILINEAR (see section)<br>If both of these counter sources are zero then the third source of multi-cycle operations (for which a direct counter does not exist) is accesses to wide channel texture formats such as the OpenGL ES 3.x 16-bit and 32-bit per channel integer and floating point formats, or multi-plane YUV formats.</p><h4 id="3-7-5-SC-TEX-INSTR-3D"><a href="#3-7-5-SC-TEX-INSTR-3D" class="headerlink" title="3.7.5 SC.TEX_INSTR_3D"></a>3.7.5 SC.TEX_INSTR_3D</h4><p>Availability: All</p><p>This counter increments for every architecturally executed texture instruction which is accessing a 3D texture. These will take at least two cycles to process, and may take four cycles if trilinear filtering is used.</p><h4 id="3-7-6-SC-TEX-INSTR-TRILINEAR"><a href="#3-7-6-SC-TEX-INSTR-TRILINEAR" class="headerlink" title="3.7.6 SC.TEX_INSTR_TRILINEAR"></a>3.7.6 SC.TEX_INSTR_TRILINEAR</h4><p>Availability: All</p><p>This counter increments for every architecturally executed texture instruction which is using a trilinear (GL_LINEAR_MIPMAP_LINEAR) minification filter. These will take at least two cycles to process, and may take four cycles if a 3D texture is being sampled from.</p><p>In content which is texture filtering throughput limited, switching from trilinear filtering to bilinear filtering (GL_LINEAR_MIPMAP_NEAREST) may improve performance.</p><h4 id="3-7-7-SC-TEX-INSTR-MIPMAP"><a href="#3-7-7-SC-TEX-INSTR-MIPMAP" class="headerlink" title="3.7.7 SC.TEX_INSTR_MIPMAP"></a>3.7.7 SC.TEX_INSTR_MIPMAP</h4><p>Availability: All</p><p>This counter increments for every architecturally executed texture instruction which is accessing a texture which has mipmaps enabled. Mipmapping provides improved 3D texturing quality, as it provides some pre-filtering for minified texture samples, and also improves performance as it reduces pressure on texture caches. It is highly recommended that mipmapping is used for all 3D texturing operations reading from static input textures.</p><h4 id="3-7-8-SC-TEX-INSTR-COMPRESSED"><a href="#3-7-8-SC-TEX-INSTR-COMPRESSED" class="headerlink" title="3.7.8 SC.TEX_INSTR_COMPRESSED"></a>3.7.8 SC.TEX_INSTR_COMPRESSED</h4><p>Availability: All</p><p>This counter increments for every architecturally executed texture instruction which is accessing a texture which is compressed, including both application-level texture compression such as ETC and ASTC, as well as internal texture compression such as AFBC framebuffer compression. Texture compression can significantly improve performance due to reduced pressure on the texture data caches and external memory system. It is recommended that all input assets from the application use compression whenever it is possible to do so.</p><h4 id="3-7-9-SC-TEX-READ-BEATS"><a href="#3-7-9-SC-TEX-READ-BEATS" class="headerlink" title="3.7.9 SC.TEX_READ_BEATS"></a>3.7.9 SC.TEX_READ_BEATS</h4><p>Availability: All</p><p>This counter increments for every 16 bytes of texture data fetched from the L2 memory system.</p><h4 id="3-7-10-SC-TEX-L2-BYTES-PER-ISSUE-Derived"><a href="#3-7-10-SC-TEX-L2-BYTES-PER-ISSUE-Derived" class="headerlink" title="3.7.10 SC.TEX_L2_BYTES_PER_ISSUE (Derived)"></a>3.7.10 SC.TEX_L2_BYTES_PER_ISSUE (Derived)</h4><p>Availability: All</p><p>The average number of bytes read from the L2 cache per texture L1 cache access can be given as.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.TEX_L2_BYTES_PER_ISSUE = (SC.TEX_READ_BEATS * 16) / SC.TEX_ISSUES<br></code></pre></td></tr></table></figure><p>This gives some idea of level one cache efficiency, although does require some knowledge of how the application is using texture data to interpret. For example some use cases expect to have good cache hit rates and reuse the same data many times from different threads, whereas other use cases are data streaming use cases are use each data item exactly once.</p><h4 id="3-7-11-SC-TEX-READ-BEATS-EXTERNAL"><a href="#3-7-11-SC-TEX-READ-BEATS-EXTERNAL" class="headerlink" title="3.7.11 SC.TEX_READ_BEATS_EXTERNAL"></a>3.7.11 SC.TEX_READ_BEATS_EXTERNAL</h4><p>Availability: All</p><p>This counter increments for every 16 bytes of texture data fetched from the L2 memory system which missed in the L2 cache and required a fetch from external memory.</p><h4 id="3-7-12-SC-TEX-EXTERNAL-BYTES-PER-ISSUE-Derived"><a href="#3-7-12-SC-TEX-EXTERNAL-BYTES-PER-ISSUE-Derived" class="headerlink" title="3.7.12 SC.TEX_EXTERNAL_BYTES_PER_ISSUE (Derived)"></a>3.7.12 SC.TEX_EXTERNAL_BYTES_PER_ISSUE (Derived)</h4><p>Availability: All</p><p>The average number of bytes read from the external memory interface per texture operation can be given as.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.TEX_EXTERNAL_BYTES_PER_ISSUE = (SC.TEX_READ_BEATS_EXTERNAL * 16) / SC.TEX_ISSUES<br></code></pre></td></tr></table></figure><p>This gives some idea of level two cache efficiency, although does require some knowledge of how the application is using texture data to interpret. For example some use cases expect to have good cache hit rates and reuse the same data many times from different threads, whereas other use cases are data streaming use cases are use each data item exactly once.</p><h3 id="3-8-Varying-Unit-Events"><a href="#3-8-Varying-Unit-Events" class="headerlink" title="3.8 Varying Unit Events"></a>3.8 Varying Unit Events</h3><p>This counter set looks at the varying unit behavior:</p><h4 id="3-8-1-SC-VARY-INSTR"><a href="#3-8-1-SC-VARY-INSTR" class="headerlink" title="3.8.1 SC.VARY_INSTR"></a>3.8.1 SC.VARY_INSTR</h4><p>Availability: All</p><p>This counter increments for every architecturally executed varying unit instruction for a fragment quad.</p><h4 id="3-8-2-SC-VARY-ISSUES-16"><a href="#3-8-2-SC-VARY-ISSUES-16" class="headerlink" title="3.8.2 SC.VARY_ISSUES_16"></a>3.8.2 SC.VARY_ISSUES_16</h4><p>Availability: All</p><p>This counter increments for every architecturally executed cycle of “mediump” 16-bit varying interpolation.</p><p>Interpolating mediump fp16 values is twice as fast as interpolating highp fp32 values, so should be used whenever it is suitable. Most use cases which contribute to computing an 8-bit unorm color value can safely use fp16 precision</p><h4 id="3-8-3-SC-VARY-ISSUES-32"><a href="#3-8-3-SC-VARY-ISSUES-32" class="headerlink" title="3.8.3 SC.VARY_ISSUES_32"></a>3.8.3 SC.VARY_ISSUES_32</h4><p>Availability: All</p><p>This counter increments for every architecturally executed cycle of “highp” 32-bit varying interpolation.</p><p>Interpolating highp fp32 values is half the performance and twice the bandwidth of interpolating medium fp16 values, so should only be used for cases where the additional floating point precision is necessary. The most common use cases requiring high-precision varyings are texture sampling coordinates, and anything related to accurately computing 3D position in the scene.</p><h4 id="3-8-4-SC-VARY-UTILIZATION-Derived"><a href="#3-8-4-SC-VARY-UTILIZATION-Derived" class="headerlink" title="3.8.4 SC.VARY_UTILIZATION (Derived)"></a>3.8.4 SC.VARY_UTILIZATION (Derived)</h4><p>Availability: All</p><p>The utilization of the varying unit can be determined as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SC.VARY_UTILIZATION = (SC.VARY_ISSUES_16 + SC.VARY_ISSUES_32) / SC.EXEC_CORE_ACTIVE<br></code></pre></td></tr></table></figure><h2 id="4-Tiler-Counters"><a href="#4-Tiler-Counters" class="headerlink" title="4 Tiler Counters"></a>4 Tiler Counters</h2><p>The tiler counters provide details of the workload of the fixed function tiling unit, which places primitives into the tile lists which are subsequently read by the fragment frontend during fragment shading.</p><h3 id="4-1-Tiler-Activity"><a href="#4-1-Tiler-Activity" class="headerlink" title="4.1 Tiler Activity"></a>4.1 Tiler Activity</h3><p>These counters show the overall activity of the tiling unit.</p><h4 id="4-1-1-TI-ACTIVE"><a href="#4-1-1-TI-ACTIVE" class="headerlink" title="4.1.1 TI.ACTIVE"></a>4.1.1 TI.ACTIVE</h4><p>Availability: All</p><p>This counter increments every cycle the tiler is processing a task. The tiler can run in parallel to vertex shading and fragment shading so a high cycle count here does not necessarily imply a bottleneck, unless the SC.COMPUTE_ACTIVE counter in the shader cores are very low relative to this.</p><h4 id="4-2-Tiler-Primitive-Occurrence"><a href="#4-2-Tiler-Primitive-Occurrence" class="headerlink" title="4.2 Tiler Primitive Occurrence"></a>4.2 Tiler Primitive Occurrence</h4><p>These counters give a functional breakdown of the tiling workload given to the GPU by the application.</p><h4 id="4-2-1-TI-PRIMITIVE-POINTS"><a href="#4-2-1-TI-PRIMITIVE-POINTS" class="headerlink" title="4.2.1 TI.PRIMITIVE_POINTS"></a>4.2.1 TI.PRIMITIVE_POINTS</h4><p>Availability: All</p><p>This counter increments for every point primitive processed by the tiler. This counter is incremented before any clipping or culling, so reflects the raw workload from the application.</p><h4 id="4-2-2-TI-PRIMITIVE-LINES"><a href="#4-2-2-TI-PRIMITIVE-LINES" class="headerlink" title="4.2.2 TI.PRIMITIVE_LINES"></a>4.2.2 TI.PRIMITIVE_LINES</h4><p>Availability: All</p><p>This counter increments for every line segment primitive processed by the tiler. This counter is incremented before any clipping or culling, so reflects the raw workload from the application.</p><h4 id="4-2-3-TI-PRIMITIVE-TRIANGLES"><a href="#4-2-3-TI-PRIMITIVE-TRIANGLES" class="headerlink" title="4.2.3 TI.PRIMITIVE_TRIANGLES"></a>4.2.3 TI.PRIMITIVE_TRIANGLES</h4><p>Availability: All</p><p>This counter increments for every triangle primitive processed by the tiler. This counter is incremented before any clipping or culling, so reflects the raw workload from the application.</p><h4 id="4-2-4-TI-INPUT-PRIMITIVES-Derived"><a href="#4-2-4-TI-INPUT-PRIMITIVES-Derived" class="headerlink" title="4.2.4 TI.INPUT_PRIMITIVES (Derived)"></a>4.2.4 TI.INPUT_PRIMITIVES (Derived)</h4><p>Availability: All</p><p>This derived counter contains the total number of primitives entering primitive assembly.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">TI.INPUT_PRIMITIVES = TI.PRIMITIVE_POINTS + TI.PRIMITIVE_LINES + TI.PRIMITIVE_TRIANGLES<br></code></pre></td></tr></table></figure><h3 id="4-3-Tiler-Visibility-and-Culling-Occurrence"><a href="#4-3-Tiler-Visibility-and-Culling-Occurrence" class="headerlink" title="4.3 Tiler Visibility and Culling Occurrence"></a>4.3 Tiler Visibility and Culling Occurrence</h3><p>These counters give a breakdown of how the workload has been affected by clipping and culling. The culling schemes are applied in the order shown below:</p><p>Culling diagram</p><p>This order impacts the interpretation of the counters in terms of comparing the culling rates against the total number of primitives entering and leaving each stage.</p><h4 id="4-3-1-TI-CULLED-FACING"><a href="#4-3-1-TI-CULLED-FACING" class="headerlink" title="4.3.1 TI.CULLED_FACING"></a>4.3.1 TI.CULLED_FACING</h4><p>Availability: All</p><p>This counter is incremented for every primitive which is culled due to the application of front-face or back-face culling rules. For most meshes approximately half of the triangles are back facing so this counter should typically be similar to the visible primitives, although lower is always better.</p><h4 id="4-3-2-TI-CULLED-FRUSTUM"><a href="#4-3-2-TI-CULLED-FRUSTUM" class="headerlink" title="4.3.2 TI.CULLED_FRUSTUM"></a>4.3.2 TI.CULLED_FRUSTUM</h4><p>Availability: All</p><p>This counter is incremented for every primitive which is culled due to being totally outside of the clip-space volume. Application-side culling should be used to minimize the amount of out-of-shot geometry being sent to the GPU as it is expensive in terms of bandwidth and power. One of my blogs looks at application side culling in more detail</p><h4 id="4-3-3-TI-CULLED-COVERAGE"><a href="#4-3-3-TI-CULLED-COVERAGE" class="headerlink" title="4.3.3 TI.CULLED_COVERAGE"></a>4.3.3 TI.CULLED_COVERAGE</h4><p>Availability: All</p><p>This counter is incremented for every microtriangle primitive which is culled due to lack of any coverage of active sample points.</p><h4 id="4-3-4-TI-PRIMITIVE-VISIBLE"><a href="#4-3-4-TI-PRIMITIVE-VISIBLE" class="headerlink" title="4.3.4 TI.PRIMITIVE_VISIBLE"></a>4.3.4 TI.PRIMITIVE_VISIBLE</h4><p>Availability: All</p><p>This counter is incremented for every primitive which is visible, surviving all types of culling which are applied.</p><p>Note: Visible in this context simply means that a primitive is inside the viewing frustum, facing in the correct direction, and has at least some sample coverage. Primitives which are visible at this stage still may generate no rendered fragments; for example ZS testing during fragment processing may determine that a primitive is entirely occluded by other primitives.</p><h4 id="4-3-5-TI-CULLED-FACING-PERCENT-Derived"><a href="#4-3-5-TI-CULLED-FACING-PERCENT-Derived" class="headerlink" title="4.3.5 TI.CULLED_FACING_PERCENT (Derived)"></a>4.3.5 TI.CULLED_FACING_PERCENT (Derived)</h4><p>Availability: All</p><p>This counter determines the percentage of primitive inputs into the facing test which are culled by it.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">TI.CULLED_FACING_PERCENT = TI.CULLED_FACING / TI_INPUT_PRIMITIVES<br></code></pre></td></tr></table></figure><p>In typical 3D content it is expected that approximately half of the input primitives will be culled by the facing tests, as the side of a model which is facing away from the camera is not visible and can be dropped without fragment shading. If a low percentage of primitives are culled by the facing tests in a 3D application this implies that the application may not be enabling the back-face test for everything which could benefit from it; check the application draw calls for opaque objects are enabling GL_CULL_FACE correctly.</p><h4 id="4-3-6-TI-CULLED-FRUSTUM-PERCENT-Derived"><a href="#4-3-6-TI-CULLED-FRUSTUM-PERCENT-Derived" class="headerlink" title="4.3.6 TI.CULLED_FRUSTUM_PERCENT (Derived)"></a>4.3.6 TI.CULLED_FRUSTUM_PERCENT (Derived)</h4><p>Availability: All</p><p>This counter determines the percentage of primitive inputs into the frustum test which are culled by it.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">TI.CULLED_FRUSTUM_PERCENT = TI.CULLED_FRUSTUM / (TI.INPUT_PRIMITIVES - TL.CULLED_FACING)<br></code></pre></td></tr></table></figure><p>One of the most important optimizations an application can perform is efficiently culling objects which are outside of the visible frustum, as these optimizations can be applied quickly by exploiting scene knowledge such as object bounding volume checks (see Mali Performance 5: An Application’s Performance Responsibilities for more information on application culling techniques). It is expected that some triangles will be outside of the frustum – CPU culling is normally approximate, and some objects may be span frustum boundary – but this should be minimized as it indicates that redundant vertex processing is occurring.</p><h4 id="4-3-7-TI-CULLED-COVERAGE-PERCENT-Derived"><a href="#4-3-7-TI-CULLED-COVERAGE-PERCENT-Derived" class="headerlink" title="4.3.7 TI.CULLED_COVERAGE_PERCENT (Derived)"></a>4.3.7 TI.CULLED_COVERAGE_PERCENT (Derived)</h4><p>Availability: All</p><p>This counter determines the percentage of primitive inputs into the coverage test which are culled by it.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">TI.CULLED_COVERAGE_PERCENT = TI.CULLED_FRUSTUM / (TI.INPUT_PRIMITIVES - TL.CULLED_FACING - TI.CULLED_FRUSTUM)<br></code></pre></td></tr></table></figure><p>A significant number of triangles being culled due to the coverage test indicates that the application is using very dense models which are producing small microtriangles; even if the triangles which produce no coverage are killed it is expected that there will also be a number of visible triangles which cover a small number of sample points, which are still disproportionately expensive to process relative to their screen coverage.</p><p>Microtriangles are expensive to process for a number of reasons.</p><p>On mobile devices they are most expensive due to the bandwidth cost they incur. The vertex shader has to read the vertex attributes and write the varyings, and the fragment shader has to read and interpolate the varyings, which are typically bulky floating point vector data types. For example, the simplest vertex consisting of only a vec4 fp32 position attribute requires two 128-bit reads and one 128-bit write, a total of 24 bytes of memory bandwidth used. The cost of the vertex bandwidth is amortized over the number of fragments that a triangle generates. A triangle covering 50 pixels will effectively cost 0.5 bytes per pixel in terms of vertex bandwidth, which is equivalent of the cost of a single ETC2 compressed texture fetch. A microtriangle covering a two pixels will cost 12 bytes per pixel, and is therefore likely to generate stalls on the memory system.</p><p>Note: This example is for the “best case” microtriangle consisting of only of a position; most real applications will also have additional per-vertex attributes, such as vertex normals and texture coordinates. Applications loading between 50 and 100 bytes of input data per vertex are common.</p><p>Fragment workloads are always spawned as 2×2 pixel quads; quads which span the edges of a triangle may contain partial sample coverage, in which one or more of the fragments in the quad does not contribute to the final render, but which costs some performance to process. Microtriangles cause an increase in partial quads, as there are more edges per unit area shaded. The shader core counter SC.FRAG_PARTIAL_QUADS (see section 3.3.11) may provide additional evidence of the existence of microtriangles.</p><h4 id="4-3-8-TI-FRONT-FACING"><a href="#4-3-8-TI-FRONT-FACING" class="headerlink" title="4.3.8 TI.FRONT_FACING"></a>4.3.8 TI.FRONT_FACING</h4><p>Availability: All</p><p>This counter is incremented for every triangle which is front-facing. This counter is incremented after culling, so only counts visible primitives which are actually emitted into the tile list.</p><p>This counter is not directly useful for performance profiling as there is no rendering performance difference between front-facing and back-facing triangles, but is useful used for debugging culling related logic problems, and stencil test logic problems as stencil testing can do different things for front-facing and back-facing triangles.</p><h4 id="4-3-9-TI-BACK-FACING"><a href="#4-3-9-TI-BACK-FACING" class="headerlink" title="4.3.9 TI.BACK_FACING"></a>4.3.9 TI.BACK_FACING</h4><p>Availability: All</p><p>This counter is incremented for every triangle which is back-facing. This counter is incremented after culling, so only counts visible primitives which are actually emitted into the tile list.</p><p>If you are not using back-facing triangles for some special algorithmic purpose, such as Refraction Based on Local Cubemaps, then a high value here relative to the total number of triangles may indicate that the application has forgotten to turn on back-face culling. For most opaque geometry no back facing triangles should be expected.</p><p>This counter is not directly useful for performance profiling as there is no rendering performance difference between front-facing and back-facing triangles, but is useful used for debugging culling related logic problems, and stencil test logic problems as stencil testing can do different things for front-facing and back-facing triangles.</p><h3 id="4-4-Shading-Requests"><a href="#4-4-Shading-Requests" class="headerlink" title="4.4 Shading Requests"></a>4.4 Shading Requests</h3><p>These counters track the workload requests for the Index-Driver Vertex Shading pipeline, one of the new features introduced in the Bifrost GPU architecture.</p><h4 id="4-4-1-TI-IDVS-POSITION-SHADING-REQUEST"><a href="#4-4-1-TI-IDVS-POSITION-SHADING-REQUEST" class="headerlink" title="4.4.1 TI.IDVS_POSITION_SHADING_REQUEST"></a>4.4.1 TI.IDVS_POSITION_SHADING_REQUEST</h4><p>Availability: All</p><p>This counter is incremented for every batch of triangles which have been position shaded. Each batch consists of 4 vertices from sequential index ranges.</p><h4 id="4-4-2-TI-IDVS-VARYING-SHADING-REQUEST"><a href="#4-4-2-TI-IDVS-VARYING-SHADING-REQUEST" class="headerlink" title="4.4.2 TI.IDVS_VARYING_SHADING_REQUEST"></a>4.4.2 TI.IDVS_VARYING_SHADING_REQUEST</h4><p>Availability: All</p><p>This counter is incremented for every batch of triangles which have been varying shaded. Each batch consists of 4 vertices from sequential index ranges.</p><h2 id="5-L2-Cache-Counters"><a href="#5-L2-Cache-Counters" class="headerlink" title="5 L2 Cache Counters"></a>5 L2 Cache Counters</h2><p>This section documents the behavior of the L2 memory system counters.</p><p>In systems which implement multiple L2 caches or bus interfaces the counters presented in DS-5 Streamline are the sum of the counters from all of the L2 counter blocks present, as this gives the aggregate memory system usage.</p><p>All derivations in this document are computations per slice, so it may be necessary to divide these by the number of cache slices present in your design when using user-level equations in DS-5 Streamline.</p><h3 id="5-1-Internal-Cache-Usage"><a href="#5-1-Internal-Cache-Usage" class="headerlink" title="5.1 Internal Cache Usage"></a>5.1 Internal Cache Usage</h3><p>These counters profile the internal use of the L2 cache versus the available cycle capacity.</p><h3 id="5-1-1-L2-ANY-LOOKUP"><a href="#5-1-1-L2-ANY-LOOKUP" class="headerlink" title="5.1.1 L2.ANY_LOOKUP"></a>5.1.1 L2.ANY_LOOKUP</h3><p>Availability: All</p><p>The counter increments for any L2 read or write request from an internal master, or snoop request from an internal or external master.</p><h3 id="5-1-2-L2-INTERNAL-UTILIZATION-Derived"><a href="#5-1-2-L2-INTERNAL-UTILIZATION-Derived" class="headerlink" title="5.1.2 L2.INTERNAL_UTILIZATION (Derived)"></a>5.1.2 L2.INTERNAL_UTILIZATION (Derived)</h3><p>Availability: All</p><p>Each L2 cache slice can process a single read, write, or snoop operation per clock cycle. The internal utilization of the L2 cache by the processing masters in the system can be determined via the equation:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">LS.INTERNAL_UTILIZATION = L2.ANY_LOOKUP / JM.GPU_ACTIVE<br></code></pre></td></tr></table></figure><h3 id="5-2-Internal-Traffic-Profile"><a href="#5-2-Internal-Traffic-Profile" class="headerlink" title="5.2 Internal Traffic Profile"></a>5.2 Internal Traffic Profile</h3><p>These counters profile the internal read traffic into the L2 cache from the various internal masters.</p><h3 id="5-2-1-L2-READ-REQUEST"><a href="#5-2-1-L2-READ-REQUEST" class="headerlink" title="5.2.1 L2.READ_REQUEST"></a>5.2.1 L2.READ_REQUEST</h3><p>Availability: All</p><p>The counter increments for every read transaction received by the L2 cache.</p><h3 id="5-2-2-L2-EXTERNAL-READ-REQUEST"><a href="#5-2-2-L2-EXTERNAL-READ-REQUEST" class="headerlink" title="5.2.2 L2.EXTERNAL_READ_REQUEST"></a>5.2.2 L2.EXTERNAL_READ_REQUEST</h3><p>Availability: All</p><p>The counter increments for every read transaction sent by the L2 cache to external memory.</p><h3 id="5-2-3-L2-READ-MISS-RATE-Derived"><a href="#5-2-3-L2-READ-MISS-RATE-Derived" class="headerlink" title="5.2.3 L2.READ_MISS_RATE (Derived)"></a>5.2.3 L2.READ_MISS_RATE (Derived)</h3><p>Availability: All</p><p>The counter gives an indication of the number of reads which are missing and being sent on the L2 external interface to main memory.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">L2.READ_MISS_RATE = L2.EXTERNAL_READ_REQUEST / L2.READ_REQUEST<br></code></pre></td></tr></table></figure><h4 id="5-2-4-L2-WRITE-REQUEST"><a href="#5-2-4-L2-WRITE-REQUEST" class="headerlink" title="5.2.4 L2.WRITE_REQUEST"></a>5.2.4 L2.WRITE_REQUEST</h4><p>Availability: All</p><p>The counter increments for every write transaction received by the L2 cache.</p><h4 id="5-2-5-L2-EXTERNAL-WRITE-REQUEST"><a href="#5-2-5-L2-EXTERNAL-WRITE-REQUEST" class="headerlink" title="5.2.5 L2.EXTERNAL_WRITE_REQUEST"></a>5.2.5 L2.EXTERNAL_WRITE_REQUEST</h4><p>Availability: All</p><p>The counter increments for every write transaction sent by the L2 cache to external memory.</p><h4 id="5-2-6-L2-WRITE-MISS-RATE-Derived"><a href="#5-2-6-L2-WRITE-MISS-RATE-Derived" class="headerlink" title="5.2.6 L2.WRITE_MISS_RATE (Derived)"></a>5.2.6 L2.WRITE_MISS_RATE (Derived)</h4><p>Availability: All</p><p>The counter gives an indication of the number of writes which are missing and being sent on the L2 external interface to main memory.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">L2.WRITE_MISS_RATE = L2.EXTERNAL_WRITE_REQUEST / L2.WRITE_REQUEST<br></code></pre></td></tr></table></figure><p>Note: In most cases writes to main memory are necessary and not a bad thing, for example writing vertex data to intermediate storage for later use during fragment shading, or when writing back the final color contents of a tile at the end of a frame. A high write miss rate is therefore not necessarily indicative of a performance problem if those writes were always intended to be sent to main memory. </p><h3 id="5-3-External-Read-Traffic-Events"><a href="#5-3-External-Read-Traffic-Events" class="headerlink" title="5.3 External Read Traffic Events"></a>5.3 External Read Traffic Events</h3><p>These counters profile the external read memory interface behavior. Note that this includes traffic from the entire GPU L2 memory subsystem, not just traffic from the L2 cache, as some types of access will bypass the L2 cache.</p><h4 id="5-3-1-L2-EXTERNAL-READ-BEATS"><a href="#5-3-1-L2-EXTERNAL-READ-BEATS" class="headerlink" title="5.3.1 L2.EXTERNAL_READ_BEATS"></a>5.3.1 L2.EXTERNAL_READ_BEATS</h4><p>Availability: All</p><p>This counter increments on every clock cycle a read beat is read off the external AXI bus.</p><h4 id="5-3-2-L2-EXTERNAL-READ-BYTES-Derived"><a href="#5-3-2-L2-EXTERNAL-READ-BYTES-Derived" class="headerlink" title="5.3.2 L2.EXTERNAL_READ_BYTES (Derived)"></a>5.3.2 L2.EXTERNAL_READ_BYTES (Derived)</h4><p>Availability: All</p><p>With knowledge of the bus width used in the GPU the beat counter can be converted into a raw bandwidth counter.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">L2.EXTERNAL_READ_BYTES = SUM(L2.EXTERNAL_READ_BEATS * L2.AXI_WIDTH_BYTES)<br></code></pre></td></tr></table></figure><p>Note: Most implementations of a Bifrost GPU use a 128-bit (16 byte) AXI interface, but a 64-bit (8 byte) interface is also possible to reduce the area used by a design. This information can be obtained from your chipset manufacturer.</p><h4 id="5-3-3-L2-EXTERNAL-READ-UTILIZATION-Derived"><a href="#5-3-3-L2-EXTERNAL-READ-UTILIZATION-Derived" class="headerlink" title="5.3.3 L2.EXTERNAL_READ_UTILIZATION (Derived)"></a>5.3.3 L2.EXTERNAL_READ_UTILIZATION (Derived)</h4><p>Availability: All</p><p>The GPU can issue one read beat per clock per implemented cache slice. The total utilization of the AXI read interface can be determined per cache slice using:</p><p>L2.EXTERNAL_READ_UTILIZATION &#x3D; L2.EXTERNAL_READ_BEATS &#x2F; SC.GPU_ACTIVE<br>Note: This utilization metric ignores any frequency changes which may occur downstream of the GPU. If you have, for example, a 600MHz GPU connected to a 300MHz AXI bus of the same data width then it will be impossible for the GPU to achieve more than 50% utilization of its native interface because the AXI bus is unable to provide the data as quickly as the GPU can consume it.</p><h4 id="5-3-4-L2-EXTERNAL-READ-STALL"><a href="#5-3-4-L2-EXTERNAL-READ-STALL" class="headerlink" title="5.3.4 L2.EXTERNAL_READ_STALL"></a>5.3.4 L2.EXTERNAL_READ_STALL</h4><p>Availability: All</p><p>This counter increments every cycle that the GPU is unable to issue a new read transaction to AXI, because AXI is unable to accept the request. If this number is high it may indicate that the AXI bus is suffering from high contention due to accesses from other sources, or that the GPU is clocked faster than the AXI bus it is connected to.</p><h4 id="5-3-5-L2-Read-Latency-Histogram"><a href="#5-3-5-L2-Read-Latency-Histogram" class="headerlink" title="5.3.5 L2 Read Latency Histogram"></a>5.3.5 L2 Read Latency Histogram</h4><p>Availability: All</p><p>The L2 interface implements a six entry histogram which tracks the response latency for the external reads. The counter for the sixth level is synthesized from multiple raw counter values.</p><p>Histogram Range</p><p>Counter Equation</p><p>0-127 Cycles</p><p>L2.EXT_RRESP_0_127</p><p>128-191 Cycles</p><p>L2.EXT_RRESP_128_191</p><p>192-255 Cycles</p><p>L2.EXT_RRESP_192_255</p><p>256-319 Cycles</p><p>L2.EXT_RRESP_256_319</p><p>320-383 Cycles</p><p>L2.EXT_RRESP_320_383</p><blockquote><p>383 Cycles</p></blockquote><p>L2.EXTERNAL_READ_BEATS - L2.EXT_RRESP_0_127 -<br>L2.EXT_RRESP_128_191 - L2.EXT_RRESP_192_255 -<br>L2.EXT_RRESP_256_319 - L2.EXT_RRESP_320_383</p><p>Mali shader cores are designed to tolerate an external read response latency of 170 GPU cycles; systems reporting significantly higher latency than this for a high percentage of transactions will observe some reduction in performance, as the shader core will stall more often waiting for main memory to provide data.</p><h4 id="5-3-6-L2-Read-Outstanding-Transaction-Histogram"><a href="#5-3-6-L2-Read-Outstanding-Transaction-Histogram" class="headerlink" title="5.3.6 L2 Read Outstanding Transaction Histogram"></a>5.3.6 L2 Read Outstanding Transaction Histogram</h4><p>Availability: All</p><p>The L2 interface implements a four entry histogram which tracks the outstanding transaction levels for the external reads. The counter for the fourth level is synthesized from multiple raw counter values.</p><p>Histogram Range</p><p>Counter Equation</p><p>0-25%</p><p>L2.EXT_READ_CNT_Q1</p><p>25-50%</p><p>L2.EXT_READ_CNT_Q2</p><p>50-75%</p><p>L2.EXT_READ_CNT_Q3</p><p>75%-100%</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">L2.EXTERNAL_READ - L2.EXT_READ_CNT_Q1 - L2.EXT_READ_CNT_Q2 - L2.EXT_READ_CNT_Q3<br></code></pre></td></tr></table></figure><p>The number of currently outstanding transactions gives some idea of how many concurrent memory requests the shader core has queued on the AXI bus. This will not directly cost performance unless we completely run out of transactions; content with a high percentage of transactions in the 75-100% range may be losing performance because it is unable to construct new requests to be sent onto the AXI interface.</p><p>Note: The maximum number of outstanding transactions available is a synthesis time option when implementing the GPU. The total number of outstanding transaction count should be selected to ensure that the GPU can keep data requests queued on the external DDR controller. In a system with 170 cycles of read response latency, and a typical transaction size of 4 data beats, at least 170&#x2F;4 (42) outstanding transactions are required.</p><h3 id="5-4-External-Write-Traffic-Events"><a href="#5-4-External-Write-Traffic-Events" class="headerlink" title="5.4 External Write Traffic Events"></a>5.4 External Write Traffic Events</h3><p>These counters profile the external write memory interface behavior. Note that this includes traffic from the entire GPU L2 memory subsystem, not just traffic from the L2 cache, as some types of access will bypass the L2 cache.</p><h4 id="5-4-1-L2-EXTERNAL-WRITE-BEATS"><a href="#5-4-1-L2-EXTERNAL-WRITE-BEATS" class="headerlink" title="5.4.1 L2.EXTERNAL_WRITE_BEATS"></a>5.4.1 L2.EXTERNAL_WRITE_BEATS</h4><p>Availability: All</p><p>This counter increments on every clock cycle a write beat is read off the external AXI bus.</p><h4 id="5-4-2-L2-EXTERNAL-WRITE-BYTES-Derived"><a href="#5-4-2-L2-EXTERNAL-WRITE-BYTES-Derived" class="headerlink" title="5.4.2 L2.EXTERNAL_WRITE_BYTES (Derived)"></a>5.4.2 L2.EXTERNAL_WRITE_BYTES (Derived)</h4><p>Availability: All</p><p>With knowledge of the bus width used in the GPU the beat counter can be converted into a raw bandwidth counter.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">L2.EXTERNAL_WRITE_BYTES = SUM(L2.EXTERNAL_WRITE_BEATS * L2.AXI_WIDTH_BYTES)<br></code></pre></td></tr></table></figure><p>Note: Most implementations of a Bifrost GPU use a 128-bit (16 byte) AXI interface, but a 64-bit (8 byte) interface is also possible to reduce the area used by a design. This information can be obtained from your chipset manufacturer.</p><h4 id="5-4-3-L2-EXTERNAL-WRITE-UTILIZATION-Derived"><a href="#5-4-3-L2-EXTERNAL-WRITE-UTILIZATION-Derived" class="headerlink" title="5.4.3 L2.EXTERNAL_WRITE_UTILIZATION (Derived)"></a>5.4.3 L2.EXTERNAL_WRITE_UTILIZATION (Derived)</h4><p>Availability: All</p><p>The GPU can issue one read beat per clock per implemented cache slice. The total utilization of the AXI write interface can be determined per cache slice using:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">L2.EXTERNAL_WRITE_UTILIZATION = L2.EXTERNAL_WRITE_BEATS / SC.GPU_ACTIVE<br></code></pre></td></tr></table></figure><p>Note: This utilization metric ignores any frequency changes which may occur downstream of the GPU. If you have, for example, a 600MHz GPU connected to a 300MHz AXI bus of the same data width then it will be impossible for the GPU to achieve more than 50% utilization of its native interface because the AXI bus is unable to provide the data as quickly as the GPU can consume it.</p><h4 id="5-4-4-L2-EXTERNAL-WRITE-STALL"><a href="#5-4-4-L2-EXTERNAL-WRITE-STALL" class="headerlink" title="5.4.4 L2.EXTERNAL_WRITE_STALL"></a>5.4.4 L2.EXTERNAL_WRITE_STALL</h4><p>Availability: All</p><p>This counter increments every cycle that the GPU is unable to issue a new write transaction to AXI, because AXI is unable to accept the request. If this number is high it may indicate that the AXI bus is suffering from high contention due to accesses from other sources, or that the GPU is clocked faster than the AXI bus it is connected to.</p><h4 id="5-4-5-L2-Write-Outstanding-Transaction-Histogram"><a href="#5-4-5-L2-Write-Outstanding-Transaction-Histogram" class="headerlink" title="5.4.5 L2 Write Outstanding Transaction Histogram"></a>5.4.5 L2 Write Outstanding Transaction Histogram</h4><p>Availability: All</p><p>The L2 interface implements a four entry histogram which tracks the outstanding transaction levels for the external writes. The counter for the fourth level is synthesized from multiple raw counter values.</p><p>Histogram Range</p><p>Counter Equation</p><p>0-25%</p><p>L2.EXT_WRITE_CNT_Q1</p><p>25-50%</p><p>L2.EXT_WRITE_CNT_Q2</p><p>50-75%</p><p>L2.EXT_WRITE_CNT_Q3</p><p>75%-100%</p><p>L2.EXTERNAL_WRITE - L2.EXT_WRITE_CNT_Q1 -<br>L2.EXT_WRITE_CNT_Q2 - L2.EXT_WRITE_CNT_Q3</p><p>The number of currently outstanding transactions gives some idea of how many concurrent memory requests the shader core has queued on the AXI bus. This will not directly cost performance unless we completely run out of transactions; content with a high percentage of transactions in the 75-100% range may be losing performance because it is unable to construct new requests to be sent onto the AXI interface.</p><p>Note: The maximum number of outstanding transactions available is a synthesis time option when implementing the GPU. The total number of outstanding transaction count should be selected to ensure that the GPU can keep data requests queued on the external DDR controller. In a system with 90 cycles of write response latency, and a typical transaction size of 4 data beats, at least 90&#x2F;4 (23) outstanding transactions are required.</p><h2 id="6-Conclusions"><a href="#6-Conclusions" class="headerlink" title="6 Conclusions"></a>6 Conclusions</h2><p>This document has defined all of the Mali Bifrost family performance counters available via DS-5 Streamline, as well as some derived-counters which can be derived from them. Hopefully this provides a useful starting point for your application optimization activity when using Mali GPUs.</p><p>We also publish a Mali Application Optimization Guide. You can visit this by clicking on the link below:</p>]]></content>
      
      
      <categories>
          
          <category> mali gpu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mali </tag>
            
            <tag> Gpu Counters </tag>
            
            <tag> Bifrost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/07/09/GPUAartch/%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%E5%9C%A8GPU%E4%B8%AD%E7%9A%84%E4%B8%80%E7%94%9F/"/>
      <url>/2022/07/09/GPUAartch/%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%E5%9C%A8GPU%E4%B8%AD%E7%9A%84%E4%B8%80%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="一个三角形在GPU中的一生"><a href="#一个三角形在GPU中的一生" class="headerlink" title="一个三角形在GPU中的一生"></a>一个三角形在GPU中的一生</h1><p>这篇笔记总结自<a href="https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline">Life of a triangle - NVIDIA’s logical pipeline</a> 和知乎文章<a href="https://blog.uwa4d.com/archives/USparkle_GPU.html">渲染优化-从GPU的结构谈起</a>。</p><p>主要记录了GPU硬件是如何详细的工作的。另外附加了一些笔记和自己的理解。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先进的Fermi架构已经发布十年了（2010年左右发布），现在是时候更新它的基础图形架构了。</p><p>Fermi是Nvidia的第一个实现了完全可扩展的图形引擎（fully scalable graphics engine的概念请查阅wiki，有说明），在Kepler和Maxwell架构当中也能找到他的影子。</p><p>下面的文章，特别是下面的“精简的管道知识”图片，应该作为各种学习材料的。这篇文章主要从图形的角度讨论GPU是如何工作的，尤其是一些原则，比如：着色程序代码是如何执行的，对于计算来说是一样的。</p><h2 id="GPU管线架构"><a href="#GPU管线架构" class="headerlink" title="GPU管线架构"></a>GPU管线架构</h2><p>下面是一张涵盖了整个GPU架构的图片，后面会详细分开讲解。</p><p><img src="/../../images/%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%E5%9C%A8GPU%E4%B8%AD%E7%9A%84%E4%B8%80%E7%94%9F/fermipipeline.png" alt="NVIDIA&#39;s logical pipeline"></p><span id="more"></span><h2 id="gpu是超级并行工作分发器"><a href="#gpu是超级并行工作分发器" class="headerlink" title="gpu是超级并行工作分发器"></a>gpu是超级并行工作分发器</h2><p>在图形中，我们必须处理数据放大（很少的数据提交会产生很大的变化的工作负载：指的是整个图形流水线处理一个很少的渲染模型）。他的复杂性来源于：</p><blockquote><ul><li>每个drawcall可以生成不同数量的三角形。</li><li>裁剪后的顶点数量与三角形发生变化。</li><li>经过背面和深度剔除后，并不是所有的三角形都需要屏幕上的像素。</li><li>一个屏幕尺寸大小的三角形的意味着它需要数百万像素或者根本不需要（被挡住不渲染）。</li></ul></blockquote><p>因此，现代gpu让它们的基本类型(三角形、线、点)遵循<strong>逻辑管道</strong>，而不是<strong>物理管道</strong>。在G80的统一架构(DX9、ps3、xbox360)之前的日子里，流水线在芯片上表现为不同的<strong>硬件模块</strong>，工作一个接一个地通过这些硬件模块串行执行。（<strong>不同的物理硬件处理不同的数据</strong>）。G80能够让顶点和片段着色器重用一些硬件单元，但是它仍然有很多用于图元&#x2F;栅格化等阶段的硬件，是串行执行的。有了Fermi，管道变得完全并行化了，这意味着通过重用芯片上的多个引擎（不同的功能组件）实现了<strong>逻辑管道</strong>(我们后面要讲的三角形处理步骤)。</p><p>假设我们有两个三角形：A 和B。他们的不同部分可能在不同的逻辑阶段。A已经完成了空间转换操作需要进行光栅化。那么，A的一部分可能已经完成了Pixel-shader的执行，一部分可能被z-cull剪裁掉了，还有一部分可已经写入到了frame buffer，还有一部分可能在等待执行。除此之外，我们可以拉取三角形B的顶点数据。因此，虽然每个三角形都必须经过所有的逻辑步骤，但它们可能处在其生命周期的不同步骤中。这些工作会被划分成任务甚至子任务，然后并行执行。每个任务都被调度到可用的资源中，这并不局限于特定类型的任务。</p><h2 id="GPU-architecture：基础硬件结构"><a href="#GPU-architecture：基础硬件结构" class="headerlink" title="GPU architecture：基础硬件结构"></a>GPU architecture：基础硬件结构</h2><p>下图是Maxwell GPU架构，他和Fermi架构基本类似。</p><ul><li><strong>Giga Thread Engine</strong> ：有一个Giga线程引擎（<strong>Giga Thread Engine</strong> ）来管理所有正在进行的工作。</li><li><strong>Graphics Processing Cluster</strong>:GPU被划分为多个GPCs(图形处理集群：<strong>Graphics Processing Cluster</strong>)</li><li>每个都有多个SMs(流多处理器：<strong>Streaming Multiprocessor</strong>)和一个栅格引擎（<strong>Raster Engine</strong>）。</li><li><strong>Crossbar</strong>:在这个过程中有很多的互连，最明显的是一个<strong>Crossbar</strong> ，它允许各种任务在GPCs或其他功能单元(例如：ROP(<strong>render output unit</strong>))之间迁移。</li><li><strong>Shader</strong>是在SMs上完成的。SMs它包含许多核心<strong>Cores</strong> ，为线程执行数学操作（<strong>核心之间以SIMD的方式运行</strong>）。一个线程既可以是vertex shader 也可以是fragment shader.</li><li>这些核心和其他单元由<strong>Warp Schedulers</strong>驱动，<strong>Warp Schedulers</strong>以32个线程为一组进行管理，并将执行的指令交给<strong>Dispatch Units</strong>。</li><li><strong>代码逻辑</strong>由调度器<strong>Warp Schedulers</strong>处理，而不是在核心<strong>Cores</strong> 内部。<strong>Cores</strong> 只会看到调度程序中的类似“<strong>用寄存器4235和寄存器4234求和，并存储在4230中</strong>”的内容。（也就是说<strong>Cores</strong>一次只能执行一条Shader指令）。</li><li><strong>一个核心本身是相当愚蠢的，相比之下，一个CPU的核心是相当聪明的。</strong>GPU将智能提升到更高的层次，它可以执行一个整体(或者多个)的工作。(SIMD)</li><li>在GPU上，这些单元中的数量(每个GPC有多少 SMs，有多少GPC ..)取决于芯片配置本身。</li><li>SMs的设计本身(cores的数量，指令单元，schedulers…)也随着时间一代一代的变化(见第一张图片)，并保证芯片高效运行，它们可以从高端台式电脑扩展到笔记本电脑和移动设备。</li></ul><p><img src="/../../images/%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%E5%9C%A8GPU%E4%B8%AD%E7%9A%84%E4%B8%80%E7%94%9F/fermipipeline_maxwell_gpu.png" alt="fermipipeline_maxwell_gpu"></p><h2 id="The-logical-pipeline-逻辑管线"><a href="#The-logical-pipeline-逻辑管线" class="headerlink" title="The logical pipeline 逻辑管线"></a>The logical pipeline 逻辑管线</h2><p>这里开始介绍上面的物理硬件是如何通过逻辑管线配合起来的。</p><p>说明：假设<strong>drawcall</strong>引用了<strong>index buffer</strong>和<strong>vertex buffer</strong>，这些<strong>index buffer</strong>和<strong>vertex buffer</strong>已经被数据填满了，并且位于<strong>GPU</strong>的<strong>DRAM</strong>中，并且只使用了<strong>vertexshader</strong> 和 <strong>pixelshader</strong>。</p><ol><li><p>程序在图形api(DX or GL).中进行提交一个drawcall。这个drawcall将会在随后到达驱动程序（<strong>driver</strong>）。驱动程序会执行一系列验证确保操作合法，然后将指令<strong>以GPU可以读取的编码方式</strong>插入<strong>pushbuffer</strong>。在此时可能产生CPU端瓶颈，这就是为什么程序员需要合理的利用api和技术来利用gpu。（通过GPU功能降低drawcall）。</p></li><li><p>经过一段时间或显式的调用”flush” 指令后，驱动程序（<strong>driver</strong>）已在<strong>push buffer</strong>中缓冲了足够的任务并且发送给GPU进行处理（有操作系统的参与）。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/07/09/GPUAartch/%E7%BA%B9%E7%90%86%E7%BC%93%E5%AD%98/"/>
      <url>/2022/07/09/GPUAartch/%E7%BA%B9%E7%90%86%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="纹理缓存"><a href="#纹理缓存" class="headerlink" title="纹理缓存"></a>纹理缓存</h1><p>参考文献：</p><p><img src="/../../images/%E7%BA%B9%E7%90%86%E7%BC%93%E5%AD%98/1574825701596.png" alt="1574825701596"><br><a href="https://fileadmin.cs.lth.se/cs/Personal/Michael_Doggett/pubs/doggett12-tc.pdf">https://fileadmin.cs.lth.se/cs/Personal/Michael_Doggett/pubs/doggett12-tc.pdf</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>纹理缓存是现代GPU的基础组件，是实现实时渲染的性能的重要部分。</p><p>纹理缓存对GPU来说是Read-Only的。主要在texture-mapping阶段由GPU程序读取。</p><p>纹理缓存有很高的命中率，因为相邻像素之间有大量的重用，而且通常位于着色器处理器附近，所以纹理数据具有高吞吐量和低读延迟。</p><p>GPU的架构对程序员是不可见的，特备隐藏在API之下，这些架构包括纹理缓存被频繁的更新，基础的架构如图所示,L1和L2共同构成了GPU的分级内存：<img src="/../../images/%E7%BA%B9%E7%90%86%E7%BC%93%E5%AD%98/1573179467830.png" alt="1573179467830"></p><p>关于上图的描述：</p><p>紫色的部分是Texture Cache。<br>从最上边开始看，Thread Scheduler为不同的图形处理阶段收集任务。然后把任务安排到不同的Graphic Core上。<br>Graphic Core有一些固定功能的图像逻辑（Geometr，Raster），包括了几个处理功能和光栅化功能。<br>接着是Shader，包括了逻辑控制和ALU单元阵列，用于以SIMD的方式处理shader程序。Shader执行阶段使用了L1 数据指令Cache、texture mapping和与其关联的L1Texture Cache。Shader的输出和L1和L2之间需要通过crossbar来传输。<br>Crossbar连接了各种内存单元，包括L2Cache、ROP和内存控制器。内存控制器链接在了保存了framebuffer的外部内存上。大部分相邻的blocks是彼此链接的。</p><p>为了理解对纹理缓存的需求，我们首先要了解影响纹理缓存的功能：texture mapping和rasterization. </p><span id="more"></span><h2 id="Texture-Mapping"><a href="#Texture-Mapping" class="headerlink" title="Texture Mapping"></a>Texture Mapping</h2><p>纹理映射指获取图像数据并将其填充到几何表面的过程。屏幕上的每一个像素需要在纹理当中找到对应的图像数据。在贴图上的一个像素称为一个纹素。模型每一个顶点保存了一个贴图上的2D位置。这些位置称为纹理坐标，uv表示。这个坐标用来查找纹理贴图上的像素位置，st坐标下的位置。</p><p>通过整数坐标来查找单个颜色叫做nearestfiltering，并且可能产生走样。为了避免走样，通常使用邻域像素进行滤波，常用的滤波是bilinear。这个平滑操作可以解决纹理映射时产生的走样，但是无法解决纹理缩小时产生走样。</p><p><img src="/../../images/%E7%BA%B9%E7%90%86%E7%BC%93%E5%AD%98/1573202554755.png" alt="1573202554755"></p><p>​解决纹理所缩小的走样问题需要时用mipmap技术。Mipmap预先滤波是将纹理贴图生成一系列分辨率减半的贴图，构成一个图像金字塔。Trilinear mipmap是通过搜索金字塔相邻两层的贴图，然后在每个贴图上进行bilinear插值之后再用这两个值进行线性插值，最终会得到Trilinear滤波结果。下图可以看到在level0和level1上选择的2*2的像素进行bilinear 滤波。为了选择这两张贴图，需要计算lod值。lod值的计算需要计算相邻2*2像素的所对应的纹理坐标的偏差。</p><p><img src="/../../images/%E7%BA%B9%E7%90%86%E7%BC%93%E5%AD%98/1573532955239.png" alt="1573532955239"></p><h2 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h2><p>光栅会是将三角形转换成屏幕像素的过程，三角形是GPU使用的基本图元，通过限制使用三角形进行光栅化，算法可以根据硬件实现优化。最简单的像素生成顺序就是从上到下进行水平臊面。这个方法很直观，但这个不是最有的方法，所以通常顺序会进行修改来改进效率。</p><p>*** GPU的光栅化会把屏幕像素分成2*2的block，通常也称作QUAD。每一个像素保存了uv坐标和纹理梯度，纹理梯度是<br>$$ \frac{ \delta u }{ \delta x} $$<br>等内容，是通过计算邻域像素纹理坐标的差值得到的。这些纹理梯度，用于计算LOD。如果一个三角形没有覆盖完整的quad，GPU也会为空的像素产生开销，也就是会占据GPU计算引擎的空间。这回导致单一像素的三角形对于GPU来说十分低效，但是也有一些解决方案提出来。 ***</p><p>有关Texture Mapping和光栅化的更多的细节可以参考：[9] T. Akenine-M¨oller, E. Haines, and N. Hoffman, Real-Time Rendering, 3rd ed. AK Peters Ltd., 2008</p><h2 id="Texture-Map-Memory"><a href="#Texture-Map-Memory" class="headerlink" title="Texture Map Memory"></a>Texture Map Memory</h2><p>纹素被访问的顺序可以是与光栅化顺序有关的任何方向（The order of texels accessed in a texture map can have any orientation with respect to the rasterization order，不是很理解，列出原文）。如果纹素在贴图中以简单的行主序存储，纹理映射是水平进行的。缓存会保存很长的一条水平纹素提高命中率，但是如果纹理映射顺序旋转了90度那么，每一个像素都会丢失，每次访问都需要一次新的访存，读取新的一行，为了避免这种依赖朝向的纹理，纹理在内存中是以tile为单位保存的，或者是blocked。每一个纹理被分成n*n的tile，并且所有的纹素成组保存的。</p><p>研究显示如果要提高命中率，tile的尺寸需要和cacheline的尺寸一样大，128K或者256K，那么tile的大小就是8*8或者16*16</p><p>另外一个重要的概念是工作集尺寸working set size。Working Set Size指的是渲染一帧的图像分辨率（ ’The Principle of Texture Thrift’ ）研究显示，如果工作集匹配Cache丢失率会降低。</p><p>纹理缓存是只读的，因为他典型的使用就是放入三角形。但是使用GPU将计算的值放入纹理是一个常用的操作（RTT）。所以尽管他是只读的，他仍然可以改成可写的。如果纹理map改成了可写的，那么所有on-chip的对纹理的引用都会失效，然后GPU就可以写写入纹理了。也可以使用一个更简单的方法：直接刷新GPU的所有缓存。缓存失效是为了保证所有的缓存在一个一致状态。</p><h2 id="Tile-Rasterization"><a href="#Tile-Rasterization" class="headerlink" title="Tile Rasterization"></a>Tile Rasterization</h2><p>和一个内存中保存的是tilling的纹素一样，同样在光栅阶段tiling技术改进了纹理数据的访问顺序。一个简单的光栅化过程以行主序的方式生成像素，从三角形左边按行处理到右侧。每一个大的三角形一个纹理缓存进行填充，伴随像素按照逐行生成，并且进入下一行的时候上一行的像素已经丢弃了。这个水平的光栅化会造成纹理读取随着三角形宽度宽度变化。为了改进空间局部性，使用了tiled-rasterization，他会将屏幕分成等大小的矩形，通常的2的指数大小。每个tile逐个光栅化。</p><h2 id="Texture-Cache-Architecture"><a href="#Texture-Cache-Architecture" class="headerlink" title="Texture Cache Architecture"></a>Texture Cache Architecture</h2><p>纹理缓存的角色在出现了L2Cache的时候发生了变化。就Cache的尺寸而言，现代GPU的L1缓存的大小一般为：12KB，16KB等。L2分布在每一个DRAM通道上，通过cross Bar和L1相连。把一个L2 Cache放在内存控制器上，能够方便GPU进行规模的变化。设计内存架构的时候L2通常是线性内存（相对于根据纹理定制格式来说更好）。它就匀速L2Cache不知能把纹理当做Client还能用作别的内容的缓存。</p><p>其他的还有一些纹理并行和纹理压缩的问题。</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>纹理缓存的设计主要是为了性能。</p><p>如果纹理访问没有命中就需要重off-Chip的内存读取，会产生很大的延迟。为了隐藏延迟，需要需先计算需要的纹理地址，预先抓取缓存行。</p><p>略。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/07/09/GPUAartch/%E8%B0%88%E8%B0%88%E9%82%A3%E4%BA%9Bearly_depth_testing%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/07/09/GPUAartch/%E8%B0%88%E8%B0%88%E9%82%A3%E4%BA%9Bearly_depth_testing%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="谈谈那些early-depth-testing技术（草拟）"><a href="#谈谈那些early-depth-testing技术（草拟）" class="headerlink" title="谈谈那些early_depth_testing技术（草拟）"></a>谈谈那些early_depth_testing技术（草拟）</h1><h2 id="Early-Z（Immediate-Mode-Renderers-IMRs-：Nvidia-：-GeForces-and-Radeons）"><a href="#Early-Z（Immediate-Mode-Renderers-IMRs-：Nvidia-：-GeForces-and-Radeons）" class="headerlink" title="Early Z（Immediate Mode Renderers (IMRs) ：Nvidia ： GeForces and Radeons）"></a>Early Z（Immediate Mode Renderers (IMRs) ：Nvidia ： GeForces and Radeons）</h2><p>在OPengl 4.5 强制开启下面是原文。</p><h2 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h2><p>Early fragment tests, as an optimization, exist to prevent unnecessary executions of the <a href="https://www.khronos.org/opengl/wiki/Fragment_Shader">Fragment Shader</a>. If a fragment will be discarded based on the <a href="https://www.khronos.org/opengl/wiki/Depth_Test">Depth Test</a> (due perhaps to being behind other geometry), it saves performance to avoid executing the fragment shader. There is specialized hardware that makes this particularly efficient in many GPUs.</p><p>The most effective way to use early depth test hardware is to run a depth-only pre-processing pass. This means to render all available geometry, using minimal shaders and a rendering pipeline that <a href="https://www.khronos.org/opengl/wiki/Write_Mask">only writes to the depth buffer</a>. The <a href="https://www.khronos.org/opengl/wiki/Vertex_Shader">Vertex Shader</a>should do nothing more than transform positions, and the <a href="https://www.khronos.org/opengl/wiki/Fragment_Shader#Optional">Fragment Shader does not even need to exist</a>.</p><p>This provides the best performance gain if the fragment shader is expensive, or if you intend to use multiple passes across the geometry.</p><span id="more"></span><h3 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h3><p>The <a href="https://www.khronos.org/opengl/wiki/OpenGL_Specification">OpenGL Specification</a> states that these operations happens after fragment processing. However, a specification only defines apparent behavior, so the implementation is only required to behave “as if” it happened afterwards.</p><p>Therefore, an implementation is free to apply early fragment tests if the <a href="https://www.khronos.org/opengl/wiki/Fragment_Shader">Fragment Shader</a> being used does not do anything that would impact the results of those tests. So if a fragment shader writes to gl_FragDepth, thus changing the fragment’s depth value, then early testing cannot take place, since the test must use the new computed value.</p><p><strong>Note:</strong> Do recall that if a fragment shader writes to gl_FragDepth, even conditionally, it must write to it at least once on all codepaths.</p><p>There can be other hardware-based limitations as well. For example, some hardware will not execute an early depth test if the (deprecated) alpha test is active, as these use the same hardware on that platform. Because this is a hardware-based optimization, OpenGL has no direct controls that will tell you if early depth testing will happen.</p><p>Similarly, if the <a href="https://www.khronos.org/opengl/wiki/Fragment_Shader#Special_operations">fragment shader discards the fragment with the discard keyword</a>, this will almost always turn off early depth tests on some hardware. Note that even <em>conditional</em> use of discard will mean that the FS will turn off early depth tests.</p><p><strong>Note:</strong> All of the above limitations apply only to early testing as an optimization. They do not apply to anything below.</p><h2 id="Explicit-specification"><a href="#Explicit-specification" class="headerlink" title="Explicit specification"></a>Explicit specification</h2><table><thead><tr><th align="left"></th><th></th><th></th></tr></thead><tbody><tr><td align="left">Core in version</td><td>4.6</td><td></td></tr><tr><td align="left">Core since version</td><td>4.2</td><td></td></tr><tr><td align="left">Core ARB extension</td><td><a href="http://www.opengl.org/registry/specs/ARB/shader_image_load_store.txt">ARB_shader_image_load_store</a></td><td></td></tr></tbody></table><p>More recent hardware can force early depth tests, using a special fragment shader layout qualifier: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">layout(early_fragment_tests) in;<br></code></pre></td></tr></table></figure><p>This will also perform early stencil tests.</p><p>There is a caveat with this. This feature <em>cannot</em> be used to violate the sanctity of the depth test. When this is activated, any writes to gl_FragDepth will be <em>ignored</em>. The value written to the depth buffer will be exactly what was tested <em>against</em> the depth buffer: the fragment’s depth computed through rasterization.</p><p>This feature exists to ensure proper behavior when using <a href="https://www.khronos.org/opengl/wiki/Image_Load_Store">Image Load Store</a> or other <a href="https://www.khronos.org/opengl/wiki/Incoherent_Memory_Access">incoherent memory writing</a>. Without turning this on, fragments that fail the depth test would still perform their Image Load&#x2F;Store operations, since the fragment shader that performed those operations successfully executed. However, with early fragment tests, those tests were run before the fragment shader. So this ensures that image load&#x2F;store operations will only happen on fragments that pass the depth test.</p><p>Note that enabling this feature has consequences for <a href="https://www.khronos.org/opengl/wiki/Fragment_Discarding">the results of a discarded fragment.</a></p><h2 id="HSR（TBDR：Imagination：PowerVR）"><a href="#HSR（TBDR：Imagination：PowerVR）" class="headerlink" title="HSR（TBDR：Imagination：PowerVR）"></a>HSR（TBDR：Imagination：PowerVR）</h2><ol><li>通常在TBDR(iphone , PowerVR)架构的手机GPU当中，有HSR技术，所以不需要Early-Z。并且HSR比Early-Z的效果更好，完全没有OverDraw。</li></ol><h2 id="Forward-Pixel-Kill（TBD：ARM-Mali-GPUs-from-Mali-T62X-and-T678-onwards-）"><a href="#Forward-Pixel-Kill（TBD：ARM-Mali-GPUs-from-Mali-T62X-and-T678-onwards-）" class="headerlink" title="Forward Pixel Kill（TBD：ARM Mali GPUs from Mali-T62X and T678 onwards ）"></a>Forward Pixel Kill（TBD：ARM Mali GPUs from Mali-T62X and T678 onwards ）</h2><p>在Opengl ES3.1 当中规定了 Early z的说明。</p><p><strong>Early Z + FPK.</strong></p><p>材料1:<a href="https://community.arm.com/developer/tools-software/graphics/b/blog/posts/killing-pixels---a-new-optimization-for-shading-on-arm-mali-gpus">https://community.arm.com/developer/tools-software/graphics/b/blog/posts/killing-pixels---a-new-optimization-for-shading-on-arm-mali-gpus</a></p><p>材料2：Forward Pixel Kill专利书</p><p>材料3：Arm® Mali™ GPU Best Practices</p><p>重要的一句话：</p><p><strong>All Mali GPUs since the Mali-T620 GPU includes the FPK optimization. FPK provides automatic hidden surface removal of fragments that are occluded, but early-zs testing does not kill. This is due to the use of a back-to-front render order for opaque geometry. However, do not rely on the FPK optimization alone. An early-zs test is always more energy-efficient, consistent, and works on older Mali GPUs that do not include hidden surface removal.</strong></p><p>联想 ：<strong>FPK对CLIP像素是否有效?</strong></p><h2 id="Qualcomm-Adreno"><a href="#Qualcomm-Adreno" class="headerlink" title="Qualcomm Adreno"></a>Qualcomm Adreno</h2><p>在Opengl ES3.1 当中规定了 Early z的说明。</p><p><strong>Early Z rejection</strong> </p><p>Adreno 3xx and 4x can reject occluded pixels at up to four times the drawn pixel fill rate。To get maximum benefit from this feature, QTI recommends drawing a scene with primitives  sorted out from front-to-back; i.e., near-to-far. This ensures that the Z-reject rate is higher for the  far primitives, which is useful for applications that have high-depth complexity.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/07/09/GPUAartch/%E6%89%8B%E6%B8%B8GPU%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BC%98%E5%8C%96%E4%B9%8BUnifiedShaderCore/"/>
      <url>/2022/07/09/GPUAartch/%E6%89%8B%E6%B8%B8GPU%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BC%98%E5%8C%96%E4%B9%8BUnifiedShaderCore/</url>
      
        <content type="html"><![CDATA[<h1 id="手游GPU架构与优化之UnifiedShaderCore"><a href="#手游GPU架构与优化之UnifiedShaderCore" class="headerlink" title="手游GPU架构与优化之UnifiedShaderCore"></a>手游GPU架构与优化之UnifiedShaderCore</h1><p>在手游优化的过程中发现Metal当中出现了VSShder饱和PSShader等待的情况。</p><p>这主要是由于当前的渲染是VS密集型的。</p><p>但是在最新的GPU中已经使用了Unified Shader Cores。VS和PS应该可以进行统一的线程分配。</p><p>为了了解这个问题进一步研究了手机架构。</p><p>下面是ARM的图片，首先可以发现UTGARD基础架构的GPU还是Separate Shader Cores.也就是说会出现互相等待的情况。</p><p><img src="https://images.anandtech.com/doci/10375/4.%20Tech%20Day%20Bifrost%20FINAL-04_575px.png" alt="img"></p><p>使用ARM Mali芯片的主要是 联发科、华为海思、三星。</p><p>开始使用USA(Unified Shading Architecture a hardware design by which all shader processing units of a piece of graphics hardware are capable of handling any type of shading tasks. )的：</p><p>ATI架构在Radeon HD2000(PC)</p><p>Nvidia从GeForce 8系列(PC) 使用Tesla架构</p><p>高通Adreno 200 series  <a href="https://en.wikipedia.org/wiki/Adreno">wiki介绍</a></p><p>Mali Midgrad</p><p>PowerVR SGX</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/07/09/GPUAartch/%E6%89%8B%E6%9C%BAGPU%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>/2022/07/09/GPUAartch/%E6%89%8B%E6%9C%BAGPU%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="手机图形硬件工作方式"><a href="#手机图形硬件工作方式" class="headerlink" title="手机图形硬件工作方式"></a>手机图形硬件工作方式</h1><p>这部分内容参考SIGGRAPH 2016，Computer Graphics&amp;Interactive Technique. Course.</p><p>这部分主要是总结<strong>手机硬件的工作方式</strong>以及<strong>如何来让手机硬件发挥出更高的性能</strong>。由于没有做过手机开发，所以看完资料在总结上来可能不是很准确。这里只了解了一小部分，后面涉及到再补全。</p><p>首先是在任何平台上面都适用的方法：减少在屏幕上绘制物体的数量：<strong>降低帧率、降低分辨率、只有在需要重新绘制的时候才绘制。这些不在这里讨论</strong>。</p><p>这里讨论的是如何进行<strong>高性能的3D渲染。</strong></p><h2 id="手机芯片"><a href="#手机芯片" class="headerlink" title="手机芯片"></a>手机芯片</h2><p>下面是手机架构的一个简介：</p><p><img src="/../../images/img/MobleArchitecture.jpg" alt="MobleArchitecture"></p><p>手机的GPU设计通常和PC完全不同。</p><ul><li>手机的GPU通常来说是tiling的（也有例外），有多个Tilers（不知道怎么翻译），PC通常是立即渲染模式（Immediate-mode renderers）。</li><li>手机使用的是系统RAM，而PC使用的是分离的local memory和一个链接到GPU的总线，应该是PCI。</li><li>手机有多核处理器（但是没有太多的超线程技术），大部分为了低能耗做了优化而非高性能。<span id="more"></span></li></ul><h2 id="Tiling-Render"><a href="#Tiling-Render" class="headerlink" title="Tiling Render"></a>Tiling Render</h2><p>首先手机有很多tiling的渲染方式，不同的方式可能适合不同的优化。</p><p>经典的及时渲染模式直接按照图元提交的顺序渲染。</p><p>而Tiling渲染方式，首先需要执行一个Binning Pass。用来判断提交的所有图元都影响了哪些平铺片Tilers。每个三角形轮流测试，然后通过某种方式记录下Tilers中要渲染的三角形。</p><p>然后每个Tiler逐个运行，只处理影响这个Tile的图元和和这个Tile相交的图元。</p><p>光栅化是在一个芯片上的存储器（on-chip memory）进行的（包括overdraw和z comparison），之后才会写入到最终的内存。</p><h3 id="优化tiler"><a href="#优化tiler" class="headerlink" title="优化tiler"></a>优化tiler</h3><h4 id="Binning-Pass"><a href="#Binning-Pass" class="headerlink" title="Binning Pass"></a>Binning Pass</h4><p>Binning Pass只需要顶线信息。所以可以专门为Binning准备一组顶点信息。</p><p>某些硬件运行Cutdown shader，也就是在Bining Pass过程中使用一个精简版的顶点Shader。</p><h4 id="GPU-pipeline"><a href="#GPU-pipeline" class="headerlink" title="GPU pipeline"></a>GPU pipeline</h4><p>通过流水的方式处理。</p><p><img src="/../../images/img/MobleArchitecturepipeline.jpg" alt="MobleArchitecturepipeline"></p><p>大部分的手机GPU可以执行这一帧的binning pass的时候执行上一帧的光栅化。</p><p>可以上ALU-heavy的顶点操作和textrure-heavy的纹理操作同时进行，保证GPU利用率。</p><p>GLES和类似的API上，pass之间的依赖不明确。而Vulkan之间的依赖比较明确。</p><p>binning和rastersing同时执行的策略只有在避免了依赖的情况下才会有效。不过OpenGL ES之类的API比较容易做到。如果一个bining pass 依赖于上一个rasterising 就会造成暂停。</p><p>对于OPGL ES这个API而言依赖比较隐晦，比如：vertexshader依赖于上一帧的渲染或者每帧都会改变纹理（下一帧才会光栅化），这样就会得到错误的渲染结果。对于更新纹理而言，也可以每一帧保存没有更新的纹理，但是这样做开销比较大。</p><p>对于Vulkan而言，每个阶段之间的依赖很明确，可以判断那个策略结束了。</p><p>下面是Vulkan的pipeline：</p><p><img src="/../../images/img/vulkanpipeline.jpg" alt="vulkanpipeline"></p><p>可以看出在一个tier上，vertex shading发生在Binning pass阶段。</p><p>fragment shadering发生在Rasterising阶段。然后数据统一写入到内存。</p><p>Vulkan会让应用暂停，等待他需要的所有的资源都准备完毕，或者等待一个阶段的输出完毕。</p><p>Vulkan的每一个阶段都很明确：</p><p><img src="/../../images/img/vulkanpipelinestage.jpg" alt="vulkanpipelinestage"></p><p>这些阶段可以用来判断什么时候可以开始、什么时候完成。 可以让你分辨Binning pass和Rasterising pass。</p><p>有几个需要注意的：</p><p>VK_PIPELINE_STAGE_VERTEX_INPUT_BIT 定点计算</p><p>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT 片元着色</p><p>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT  结果输出</p><h4 id="FrameBuffer"><a href="#FrameBuffer" class="headerlink" title="FrameBuffer"></a>FrameBuffer</h4><p>下面是加上FrameBuffer的渲染过程：</p><p><img src="/../../images/img/vulkanpipelinestagefb.jpg" alt="vulkanpipelinestagefb"></p><p><strong>在一般的应用程序中渲染速度的瓶颈是一个新的渲染目标是否可用。</strong></p><p>binning pass和渲染目标无关，所以binnning pass可以在渲染目标准备好之前进行。但是，rasterising pass需要等待。</p><h4 id="subpass"><a href="#subpass" class="headerlink" title="subpass"></a>subpass</h4><p>我们知道一次完整的着色包括多个subpass：Geometry，lighting，Shading。</p><p>每一个SubPass都需要一次binning和rasterising。<strong>subpass之间也可以重叠这两个过程。</strong></p><p>正常的结果：</p><p><img src="/../../images/img/vulkanpipelinestagesp.jpg" alt="vulkanpipelinestagesp"></p><p>如果出现依赖，那么有依赖的这个subpass就必须等待上一个subpass完成rasterising pass 才能开始自己的 Binning pass。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/07/09/GPUAartch/%E5%85%B3%E4%BA%8ECuda%E3%80%81Shader%E4%B8%ADif%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2022/07/09/GPUAartch/%E5%85%B3%E4%BA%8ECuda%E3%80%81Shader%E4%B8%ADif%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="关于Cuda-Shader中if语句执行原理"><a href="#关于Cuda-Shader中if语句执行原理" class="headerlink" title="关于Cuda\Shader中if语句执行原理"></a>关于Cuda\Shader中if语句执行原理</h1><p>目前大部分人认为：shader当中动态if判断性能很低，只是用来做条件判断的，要避免使用。实际上if语句是可以用来做性能优化的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>主要来自于几个文档：</p><ol start="0"><li><p><a href="http://haifux.org/lectures/267/Introduction-to-GPUs.pdf">http://haifux.org/lectures/267/Introduction-to-GPUs.pdf</a> 直接说明了GPU分支是如何工作的。</p></li><li><p>第一个是GPU Gems 2当中提到的流控制<a href="https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter34.html">Chapter 34. GPU Flow-Control Idioms</a></p></li></ol><p>里面提到了对于Z-cull来说分支和warp分布的关系。</p><ol start="2"><li><p>和GPU分支优化相关的文章：[Reducing_branch_divergence_in_GPU_programs]，上面也提到了分支发散，并且提到了：</p><p>In the presence of a datadependent branch that causes diﬀerent threads in the same warp to follow diﬀerent paths (also known as branch divergence), the warp serially executes each branch path taken, disabling threads that are not on that path.</p><p>说明如果一个Warp没有进行分支发散，是所有warp只走一个分支的。</p></li><li><p>手机部分GPU架构主要是高通和AMD，目前找到了高通的资料：<a href="%5Bfile:///C:/Users/liangzhe/Desktop/80-nb295-11_a.pdf%5D(file:///C:/Users/liangzhe/Desktop/80-nb295-11_a.pdf)">Qualcomm® Snapdragon™ Mobile Platform OpenCL General Programming and Optimization</a></p><p>这里面提到了避免分支发散（Avoid branch divergence）可以从文本中推测出，手机的GPU架构和PC是一样的，有同Warp优化功能，并不会两个分支都走。</p></li><li><p>《GPU编程与优化》当中提到没有分支的Warp可以省略空跑分支。</p><span id="more"></span></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>更直观的解释参考<a href="GPU%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E6%80%A7%E8%83%BD.md">GPU分支语句性能</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/07/09/GPUAartch/TeraScale%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/"/>
      <url>/2022/07/09/GPUAartch/TeraScale%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="TeraScale"><a href="#TeraScale" class="headerlink" title="TeraScale"></a>TeraScale</h1><p>TeraScale架构是AMD公司在2011年之前的早期GPU架构。</p><p>TeraScale使用超长指令字架构。</p><p>使用TeraScale的图形显卡: HD 2000 - 6000 </p><h2 id="架构拆解"><a href="#架构拆解" class="headerlink" title="架构拆解"></a>架构拆解</h2><p>TeraScale的结构如下图：</p><p><img src="/../../images/img/TelascaleArch.jpg" alt="TelascaleArch"></p><p>上面的架构：</p><ol><li><p>包含10个SIMD核心，每一个包括了32个32bit流处理单元，总共320个。</p></li><li><p>包括4个纹理单元。</p></li></ol><p>一个SIMD core结构示意图：</p><p><img src="/../../images/img/SIMDcore.jpg" alt="SIMDcore"></p><p>上面的SIMD core：</p><ol><li><p>包括了16个Stream Processing Units（标量流处理单元），和16KB的本地数据共享存储器。</p></li><li><p>有一组运行的线程共享一个逻辑控制单元。</p></li><li><p>四个专用纹理单元和L1 Cache。</p></li></ol><p>下面是一组Stream Processing Units结构：</p><p><img src="/../../images/img/StreamProcessingUnits.jpg" alt="StreamProcessingUnits"></p><p>对于Stream Processing Units：</p><ol><li>有自己的通用寄存器</li><li>我的猜测四个小的黄色格子应该就是ALU。产生指令流水。<span id="more"></span></li></ol><h2 id="并行方式"><a href="#并行方式" class="headerlink" title="并行方式"></a>并行方式</h2><p>一次并行应该是一次WaveFront的提交，这个时候应该是一组SIMD运行单个指令执行多个数据。</p><p>假设编译后执行顺序确定如下：</p><p><img src="/../../images/img/TelascaleWavefrontA.jpg" alt="TelascaleWavefrontA"></p><p>那么执行过程应该是：</p><p><img src="/../../images/img/TelascaleWavefrontB.jpg" alt="TelascaleWavefrontB"></p><p>可以看出Telascale指令流水的切换方式应该是独立命令之间的流水切换。</p><h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>​这种架构的优势是处理Shader，但是缺陷是它专门为图形设计不适用于通用计算。</p><p>​指令的执行必须提前确定好，不适用于异步计算。</p><p>​以来指令不能连续，无法使用指令流水。</p><p>​指令对于图形友好，并行性好。</p><p>​可以看出来这个是2011年之前的架构，整个设计比较古老简单，能够看得出来专门为图形渲染设计。这种显卡基本上已经被淘汰了。</p><p>​要针对这种做优化的话就是降低代码上下依赖，使用局部变量之类的。具体要看代码编译以后的结构。 </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://meseec.ce.rit.edu/551-projects/fall2014/3-4.pdf">AMD’s Graphics Core Next (GCN) Architecture</a></p><p><a href="http://s08.idav.ucdavis.edu/houston-amd-terascale.pdf">Anatomy of AMD’s TeraScale Graphics Engine</a></p><p><a href="https://en.wikipedia.org/wiki/TeraScale_(microarchitecture)#cite_note-4">TeraScale (microarchitecture)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/07/09/GPUAartch/Partial_Derivatives(DDX)%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E5%AE%9E%E7%8E%B0%E5%B7%AE%E5%BC%82/"/>
      <url>/2022/07/09/GPUAartch/Partial_Derivatives(DDX)%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E5%AE%9E%E7%8E%B0%E5%B7%AE%E5%BC%82/</url>
      
        <content type="html"><![CDATA[<h1 id="Partial-Derivatives-DDX-原理与设备实现差异"><a href="#Partial-Derivatives-DDX-原理与设备实现差异" class="headerlink" title="Partial_Derivatives(DDX)原理与设备实现差异"></a>Partial_Derivatives(DDX)原理与设备实现差异</h1><h2 id="DDX-DDY的硬件条件"><a href="#DDX-DDY的硬件条件" class="headerlink" title="DDX\DDY的硬件条件"></a>DDX\DDY的硬件条件</h2><p>​“导数”意思是在某一点上“函数的变化”。在图形处理当中，指的是相邻像素之间的变化。</p><p>​ddx和ddy是常用的简单的图像导数，它们比较相邻的两个像素的垂直或水平值。具体的实现方法以及<strong>结果</strong>依赖于GPU的特殊架构结构细节。</p><p>​在图形计算过程中，像素着色阶段的最小调度单元是一个warp，一个warp执行同一段程序，包括了最少32个线程。但是最小的执行单元是一个quad。也就是说一次最少需要执行一个2 * 2的像素，而不需要的像素会被丢弃掉。</p><p>​这4个像素也就对应了四个线程，他们共同申请使用设备上下文，也就是说可以在硬件上，方便的访问到隔壁像素的数据。</p><p>​根据硬件这一特性，我们可以利用ddx、ddy获取到更多的信息。</p><span id="more"></span><h2 id="DDX-DDY的使用方式"><a href="#DDX-DDY的使用方式" class="headerlink" title="DDX\DDY的使用方式"></a>DDX\DDY的使用方式</h2><p>​我们通过DDX和DDY可以访问当前像素的导数。</p><p>​<strong>注意，DDY和DDX返回的是屏幕像素的导数，因为计算的依据是屏幕像素的2 * 2的Block。</strong></p><p>​具体的实现方式就是通过2 * 2 quad中的上（或下）、右（或左）相邻像素计算差值，获取到导数。</p><ol><li>通常我们可以用导数计算法线：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">surf</span> <span class="hljs-params">(Input IN, inout SurfaceOutput o)</span> &#123;<br>    o.Albedo = normalize(cross(ddy(IN.worldPos),ddx(IN.worldPos)));<br>&#125;<br></code></pre></td></tr></table></figure><p>2.通过导数我们也可以判断边缘，用来模糊或者锐化边界：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">surf</span> <span class="hljs-params">(Input IN, inout SurfaceOutput o)</span> &#123;<br>    half4 c = tex2D(_MainTex, IN.uv_MainTex);<br>    <span class="hljs-comment">//c += ddx(c)*2 + ddy(c)*2; //这行代码开启和关闭的效果</span><br>    o.Albedo = c.rgb;<br>    o.Alpha = c.a;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DDX-DDY的硬件差异"><a href="#DDX-DDY的硬件差异" class="headerlink" title="DDX\DDY的硬件差异"></a>DDX\DDY的硬件差异</h2><p>​在上面的两个案例当中，通常我们是看不出任何差异的，因为我们使用的仅仅是<strong>导数本身</strong>。</p><p>​并且当图像的变化比较平缓的时候（最大变化频率小于一个像素）。导数值可以代表周围一小个区域的导数（微积分的基础理论），此时看不出硬件和驱动的差异，但是在一些特殊的案例中就需要考虑硬件区别了。</p><p>​对于一个屏幕上2 * 2的quad而言：</p><p><img src="/../../images/Partial_Derivatives(DDX)%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E5%AE%9E%E7%8E%B0%E5%B7%AE%E5%BC%82/image-20201123160345783.png" alt="image-20201123160345783"></p><p>​判断屏幕某个像素位置(x,y)所处的quad像素位置（A?B?C?D?）,可以使用下面代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">INDEX <span class="hljs-title function_">CheckQuadPos</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><br>&#123;<br><span class="hljs-keyword">if</span>(x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; y % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> A;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">if</span>(x % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; y % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> B;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>​如果当前线程处在A则DDX、DDY返回的一定是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">TYPE <span class="hljs-title function_">DDX</span><span class="hljs-params">(TYPE value)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> B - A;<br>&#125;<br><br>TYPE <span class="hljs-title function_">DDY</span><span class="hljs-params">(TYPE value)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> C - A;<br>&#125;<br></code></pre></td></tr></table></figure><p>​通常可以假设：B-A可以代表周围几个像素的x方向的导数，包括位置C和位置D的x方向的倒数。所以通常对于一个quad中，驱动只需要计算B-A的值就可以知道整个quad的x方向偏导数。</p><p>​但是如果我们想知道D-C怎么办？<strong>返回的值和具体的图像API有关、不同的供应商对这个函数接口的实现可能也会有所差异。</strong></p><p>以下是实验结果：</p><p>对于ddx(C):</p><p>​<strong>在DX11上返回的是B-A，但是在openglES3、vulkan上，返回的是D-C。也就是说DX11可能对导数的实现进行了省略。</strong></p><p>对于ddy(D)</p><p>​<strong>在DX11上返回的是C-A，在OpenglES3、vulkan上，返回的是D-B。</strong></p><p>在一些特殊的应用当中我们就必须要考虑这个差异。</p><p>​例如：</p><p>​想在D线程上用ddx还原C的值：我在D处进行了纹理采样，想要通过ddx还原C的准确值，那么如果直接执行D-ddx(D)得到的结果可能是：D- B+A，这是对C的估计值而并非C的准确值。</p><p>​<strong>所以，ddx并不能用来节省纹理采样，因为结果依赖具体的图形接口。</strong></p><h2 id="Partial-Derivatives-与if语句"><a href="#Partial-Derivatives-与if语句" class="headerlink" title="Partial Derivatives 与if语句"></a><strong>Partial Derivatives</strong> 与if语句</h2><p>​在使用if语句的时候使用导数功能同样要特别注意！</p><p>​导数计算是基于一个着色器的多个实例在GPU硬件上的并行执行。</p><p>​<strong>标量操作通过SIMD(单指令多数据)架构在寄存器上执行，寄存器包含一个2×2像素块的4个值的向量。这意味着在执行的每一步，属于每个2×2块的着色器实例都是同步的，使得导数计算快速且易于在硬件中实现，只是简单地将包含在同一寄存器中的值进行减法。</strong></p><p>​但是在条件分支的情况下会发生什么呢?在这种情况下，如果不是一个核心中的所有线程都采用同一个分支，<strong>那么在代码执行中就会出现分歧</strong>。<strong>除了分支的效率和性能损失外，发散还破坏了块中像素之间的同步，使得导数操作无法定义。</strong></p><p>​当涉及到纹理采样，问题又变得不同了（需要用到mipmap级别选择、各向异性滤波等方面的<strong>导数</strong>）。当遇到这样的问题时，着色器编译器可以平化分支(从而避免它)，或者尝试重新排列代码，将纹理读取移动到分支控制流之外。当采样纹理时，使用显式导数（这里的显示导数指的是SampleGrad，而非DDX、DDY）或mipmap级别可以避免这个问题。</p><p>还有其他的细节可以参考：<a href="http://www.aclockworkberry.com/shader-derivative-functions/">An introduction to shader derivative functions</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/07/09/GPUAartch/GPU%E6%9E%B6%E6%9E%84%E7%B1%BB%E5%9E%8B%E6%95%B4%E5%90%88/"/>
      <url>/2022/07/09/GPUAartch/GPU%E6%9E%B6%E6%9E%84%E7%B1%BB%E5%9E%8B%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="GPU架构整合"><a href="#GPU架构整合" class="headerlink" title="GPU架构整合"></a>GPU架构整合</h1><p>AMD公司GPU芯片架构:</p><table><thead><tr><th align="center">Microarchitecture</th><th align="center">GPUs</th><th align="center">Graphic cards &#x2F; SoCs</th></tr></thead><tbody><tr><td align="center">GCN 5th</td><td align="center">Vega 10</td><td align="center">Radeon Rx Vega series</td></tr><tr><td align="center">GCN 4th</td><td align="center">Polaris 10, Polaris 11, Polaris 12</td><td align="center">Radeon Rx 400 series Radeon_500_series</td></tr><tr><td align="center">GCN 3rd</td><td align="center">Tonga, Fiji, Carrizo</td><td align="center">Radeon R9 Series</td></tr><tr><td align="center">GCN 2nd</td><td align="center">Bonaire, Hawaii, Kaveri, Kabini, Temash, Mullins, Beema, Carrizo-L</td><td align="center">Radeon HD 7790, <strong>PlayStation 4</strong>, Xbox One</td></tr><tr><td align="center">GCN 1st</td><td align="center">Oland, Cape Verde, Pitcairn, Tahiti</td><td align="center">Radeon HD 77xx–7900 Series</td></tr><tr><td align="center">TeraScale 3</td><td align="center">Cayman, Trinity&#x2F;Richland</td><td align="center">Radeon HD 69xx Series, Radeon HD 7xxx–76xx Series</td></tr><tr><td align="center">TeraScale 2</td><td align="center">Cedar, Cypress, Juniper, Redwood, Palm, Sumo</td><td align="center">Radeon HD 5000 Series, Radeon HD 6350, Radeon HD 64xx–68xx Series</td></tr><tr><td align="center">TeraScale 1</td><td align="center">R600, RV630, RV610, RV790, RV770, …</td><td align="center">Radeon HD 2000 Series, HD 3000, HD 4000</td></tr></tbody></table><span id="more"></span><p>Nvidia公司GPU芯片架构:</p><table><thead><tr><th>Microarchitecture</th><th>GPUs</th><th>Graphic cards &#x2F; SoCs</th></tr></thead><tbody><tr><td>Turing</td><td>TU10x, TU11x</td><td>GeForce 20 series, GeForce 16 series</td></tr><tr><td>Volta</td><td>GV10x</td><td>Nvidia Titan V</td></tr><tr><td>Pascal</td><td>GP10x</td><td>GeForce 10 series, Tegra X2</td></tr><tr><td>Maxwell</td><td>GM10x, GM20x</td><td>GeForce GTX 750 Ti, GTX 750, GTX 860M, GeForce 900 series, Tegra X1</td></tr><tr><td>Kepler</td><td>GK10x, GK110, GK208</td><td>GeForce 600 series, GeForce 700 series, Tegra K1</td></tr><tr><td>Fermi</td><td>GF10x, GF11x</td><td>GeForce 400 series, GeForce 500 series</td></tr><tr><td>Tesla</td><td>G8x, G9x, GT20x, GT21x</td><td>GeForce 8 series, GeForce 9 series, GeForce 100 series, GeForce 200 series, GeForce 300 series</td></tr></tbody></table><p>高通公司GPU架构:</p><table><thead><tr><th>Microarchitecture</th><th>GPUs</th><th>Graphic cards &#x2F; SoCs</th></tr></thead><tbody><tr><td>Adreno 500 series</td><td>Adreno 510, Adreno 530, Adreno 540Adreno 512</td><td>Snapdragon 430, 625, 650, 652, 660,820, 821, 835</td></tr><tr><td>Adreno 400 series</td><td>Adreno 418,Adreno 420,Adreno 430</td><td>Snapdragon 415, 615, 616, 617, 805, 808, 810</td></tr><tr><td>Adreno 300 series</td><td></td><td>Snapdragon 200, 208, 210, 212, 400, 410, 412, 600, 800, 801</td></tr></tbody></table><p>ARM公司GPU架构:</p><table><thead><tr><th>ARM</th><th>GPUs</th><th>Graphic cards &#x2F; SoCs</th></tr></thead><tbody><tr><td>Bifrost</td><td>Mali-G71, …</td><td>Kirin 960, 970, Exynos 8895, MediaTek Helio P23 (MT6763T), Helio P30</td></tr><tr><td>Midgard 4th</td><td>Mali-T860, Mali-T830, Mali-T880</td><td>Exynos 8890, Exynos 7880, Exynos 7870, Kirin 950, 955, MediaTek MT6738, MT6750, Helio X20 (MT6797), X25 (MT6797T), P10 (MT6755), P20 (MT6757)</td></tr><tr><td>Midgard 3rd</td><td>Mali-T760, …</td><td>Exynos 7420, Exynos 5433, MT6752, MT6732, RK3288</td></tr><tr><td>Midgard 2nd</td><td>Mali-T600 series, T720</td><td>Exynos 5250, 5260, 5410, 5420, 5422, 5430, 5800, 7580, Mediatek MT6735, MT6753, Kirin 920, 925, 930, 935</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/07/09/GPUAartch/GPU%E6%9E%B6%E6%9E%84/"/>
      <url>/2022/07/09/GPUAartch/GPU%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="GPU架构"><a href="#GPU架构" class="headerlink" title="GPU架构"></a>GPU架构</h1><p>参考资料:</p><p><a href="http://haifux.org/lectures/267/Introduction-to-GPUs.pdf">Introduction to GPU Architecture</a></p><p><a href="https://www.amd.com/Documents/GCN_Architecture_whitepaper.pdf">GCN_Architecture</a></p><p><a href="https://anteru.net/blog/2018/intro-to-compute-shaders/index.html">Compute Shader</a></p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>主要简单介绍GPU架构，已经架构带来的性能优化代码编写问题。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>同过总结上面的资料，大概梳理了相关内容。</p><span id="more"></span><h3 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h3><p> 一个完整的任务，可以理解为一次渲染程序的提交（包括一次vertex或者fragment）</p><p>下面是一个片段着色器的编译结果。</p><p><img src="/../../images/img/Shader.jpg"></p><p>下面是来自Unity内部的一段编译代码。</p><p><strong>查看Unity的CompiledShader可以看一个Pass的一个vertex或者一个fragment可以算作一个Domain。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader Disassembly:<br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Generated by Microsoft (R) D3D Shader Disassembler</span><br><span class="hljs-comment">// Input signature:</span><br><span class="hljs-comment">// Name   Index   Mask Register SysValue  Format   Used</span><br><span class="hljs-comment">// -------------------- ----- ------ -------- -------- ------- </span><br><span class="hljs-comment">// POSITION   0   xyz         0     NONE   float   xyz </span><br><span class="hljs-comment">// Output signature:</span><br><span class="hljs-comment">// Name        Index   Mask Register SysValue  Format   Used</span><br><span class="hljs-comment">// -------------------- ----- ------ -------- -------- ------- </span><br><span class="hljs-comment">// SV_Position       0   xyzw        0      POS   float   xyzw</span><br>      vs_5_0<br>      dcl_globalFlags refactoringAllowed<br>      dcl_constantbuffer CB0[<span class="hljs-number">4</span>], immediateIndexed<br>      dcl_constantbuffer CB1[<span class="hljs-number">51</span>], immediateIndexed<br>      dcl_input v0.xyz<br>      dcl_output_siv o0.xyzw, position<br>      dcl_temps <span class="hljs-number">4</span><br>   <span class="hljs-number">0</span>: mov r0.x, cb0[<span class="hljs-number">0</span>].y<br>   <span class="hljs-number">1</span>: mov r0.y, cb0[<span class="hljs-number">1</span>].y<br>   <span class="hljs-number">2</span>: mov r0.z, cb0[<span class="hljs-number">2</span>].y<br>   <span class="hljs-number">3</span>: add r1.xyw, cb0[<span class="hljs-number">3</span>].xyxz, -cb1[<span class="hljs-number">50</span>].xyxz<br>   <span class="hljs-number">4</span>: mov r0.w, r1.y<br>   <span class="hljs-number">5</span>: mov r2.xyz, v0.xyzx<br>   <span class="hljs-number">6</span>: mov r2.w, l(<span class="hljs-number">1.000000</span>)<br>   <span class="hljs-number">7</span>: dp4 r0.x, r0.xyzw, r2.xyzw<br>   <span class="hljs-number">8</span>: mul r0.xyzw, r0.xxxx, cb1[<span class="hljs-number">34</span>].xyzw<br>   <span class="hljs-number">9</span>: mov r3.w, r1.x<br>  <span class="hljs-number">10</span>: mov r3.x, cb0[<span class="hljs-number">0</span>].x<br>  <span class="hljs-number">11</span>: mov r3.y, cb0[<span class="hljs-number">1</span>].x<br>  <span class="hljs-number">12</span>: mov r3.z, cb0[<span class="hljs-number">2</span>].x<br>  <span class="hljs-number">13</span>: dp4 r3.x, r3.xyzw, r2.xyzw<br>  <span class="hljs-number">14</span>: mad r0.xyzw, cb1[<span class="hljs-number">33</span>].xyzw, r3.xxxx, r0.xyzw<br>  <span class="hljs-number">15</span>: mov r1.x, cb0[<span class="hljs-number">0</span>].z<br>  <span class="hljs-number">16</span>: mov r1.y, cb0[<span class="hljs-number">1</span>].z<br>  <span class="hljs-number">17</span>: mov r1.z, cb0[<span class="hljs-number">2</span>].z<br>  <span class="hljs-number">18</span>: dp4 r1.x, r1.xyzw, r2.xyzw<br>  <span class="hljs-number">19</span>: mad r0.xyzw, cb1[<span class="hljs-number">35</span>].xyzw, r1.xxxx, r0.xyzw<br>  <span class="hljs-number">20</span>: add o0.xyzw, r0.xyzw, cb1[<span class="hljs-number">36</span>].xyzw<br>  <span class="hljs-number">21</span>: ret <br><span class="hljs-comment">// Approximately 0 instruction slots used</span><br></code></pre></td></tr></table></figure><h3 id="Domain的执行"><a href="#Domain的执行" class="headerlink" title="Domain的执行"></a>Domain的执行</h3><p>要执行一个Domain需要一个类似CPU的处理器。</p><p><img src="/../../images/img/ShaderExe.jpg"></p><p><strong>然后就可以逐行执行右侧的Domain。Execution Context是存储单元，ALU是计算单元，Fetch&#x2F;Decode可以理解指令寄存器。</strong></p><h3 id="Workgroup"><a href="#Workgroup" class="headerlink" title="Workgroup"></a>Workgroup</h3><p>一个Domain可以划分成多个WorkGroup。WorkGroup之间独立互不依赖（有可能会产生依赖），放入同一个计算单元的多条指令可以理解为一个WorkGroup。</p><p><img src="/../../images/img/ShaderExe2.jpg"></p><h3 id="Workitem"><a href="#Workitem" class="headerlink" title="Workitem"></a>Workitem</h3><p><strong>Workgroup的一条指令我理解就是Workitem。</strong></p><p>例如一个加法指令。</p><p>这些指令操作的是一个运算单元的不同部件。</p><p>而且在一个指令操作寄存器的时候，别的微指令可以操作累加器，这样的特点可以让运算单元进行<strong>指令流水</strong>。</p><h3 id="SIMD-units"><a href="#SIMD-units" class="headerlink" title="SIMD units"></a>SIMD units</h3><p>如果我在不同的时间重复执行同一个指令四次（<strong>由四个16位宽的SIMD执行</strong>），那么就可以错开对寄存器的使用。如下图所示（图片来自上面的链接，暂时不看文字描述），这就算是<strong>指令流水</strong>。<strong>GPU当中主要是访问寄存器带来的指令流水</strong></p><p><img src="/../../images/img%5CSIMD.jpg"></p><p>也就是单指令多数据 SIMD。</p><p><strong>这时我们发现，我提交一条指令以后，虽然所有的部件都在进行运算，但是指令寄存器停滞了</strong>，也就是图中表示的<strong>wait</strong>。</p><p>为了让指令寄存器也提高利用率，GPU用了下面的方案：</p><p><img src="/../../images/img%5CSIMD_multi.jpg"></p><p>也就是一个指令寄存器（我猜的，可以能不是指的指令寄存器，但是就是上面的Issue Instruction）同时控制四组SIMD。<strong>上面的Issue Instruction是同一个，只不过控制了不同的SIMD。</strong></p><p>上面是从执行时间上看的，我们从物理架构上看应该长这样：</p><p><img src="/../../images/img/Structure.jpg"></p><p>因为要用同一个指令寄存器所以还要变成：</p><p><img src="/../../images/img/Structure2.jpg"></p><p>这是参考链接拿来的示意图，ALU和Ctx数量没有对上。</p><h3 id="Compute-units"><a href="#Compute-units" class="headerlink" title="Compute units"></a>Compute units</h3><p><strong>总结来说：GPU的一个CU（计算单元），就是一个指令寄存器控制的多组SIMD单元。</strong></p><p>每个CU内部的SIMD必须同时执行，所以<strong>一次指令会提交给四个SIMD</strong>，<strong>每个SIMD会通过类似指令流水执行四次</strong>，SIMD是16宽的，<strong>也就是一次同时处理16个数据。</strong></p><h3 id="Wavefront-or-Wave"><a href="#Wavefront-or-Wave" class="headerlink" title="Wavefront or Wave"></a>Wavefront or Wave</h3><p>一次完整的指令流水：16 * 4 * 4 &#x2F; 4 ，一个CU的吞吐量就是64（一个指令对应一个时钟周期，一个时钟周期同时处理了64个数据）。看图的话实际上也是一个指令同时处理64个数据（这是最小的处理单元），这个叫做<strong>Wavefront 或者Wave</strong></p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>下面是参考链接的一个并行架构示意图。</p><p><img src="/../../images/img/parallel.jpg"></p><p>下面是执行的示意图。</p><p><img src="/../../images/img/parallel2.jpg"></p><p>在参考资料中有提到，一个向量寄存器和标量寄存器的使用比较。</p><p>在一个ALU当中，原本的指令会变成向量指令。</p><p><img src="/../../images/img/I.jpg"></p><p>把指令向量化：</p><p><img src="/../../images/img/I2.jpg"></p><p>所以一个非uniform的vector变量类型，为了提高利用率，在一个CU当中需要占用16（float大小）*3（向量维度）*8（并行数）大小的寄存器。</p><p>所以一个ALU可以对应多组数据。</p><p><img src="/../../images/img/Structure3.jpg"></p><p>这个物理结构就和前面的寄存器流水结合起来了，一个ALU每次处理8组数据，分别切换1,2,3,4四组寄存器</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>如果并行程序中遇到分支：一个Wave的总耗时是不变的，只是通过遮盖的方式来不执行。</p><p>如下图如果遇到分支，首先会生成一个Mask，<strong>是针对每个ALU的（ALU逻辑运算单元，也是上面说的CU(Compute Unit) 而非CPU中的Control Unit）。</strong></p><p><img src="/../../images/img/branch.jpg"></p><p>通过遮盖来切换分支，并没有节省时间。</p><p><img src="/../../images/img/branch2.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/07/09/GPUAartch/GPU%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E6%80%A7%E8%83%BD/"/>
      <url>/2022/07/09/GPUAartch/GPU%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>下面就是一组线程同时执行，*表示空跑，&#x3D;表示执行。可以看到他们是同时完成的。一个计算单元的所有线程结束以后，可以开始下一组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========<span class="hljs-keyword">if</span>==============<span class="hljs-keyword">else</span>**********endif===========<br>线程B:  =========<span class="hljs-keyword">if</span>**************<span class="hljs-keyword">else</span>==========endif===========<br></code></pre></td></tr></table></figure><p>就可以理解为判断只会产生一个遮罩，这个遮罩会决定我这段代码是不是空跑。GPU的计算资源十分紧俏，空跑越多就是我们说的开销大。例如32个线程，每一个都跑不通的分支，那么就相当于性能下降到了1&#x2F;32。这里的开销是利用率降低而不是时间变长。</p><p>关于跑完会等待的。。。GPU一般不会阻塞等待别的线程的（有例外），假如w表示等待。下面的状态是不对的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========<span class="hljs-keyword">if</span>==============<span class="hljs-keyword">else</span> endif===========<br><br>线程B:  =========<span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span>=======endif===========wwwwwww<br></code></pre></td></tr></table></figure><span id="more"></span><p>也就是说不存在按照时间最长的分支算开销。</p><p>什么情况下会发生优化？那就是下面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========<span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span>======endif===========<br><br>线程B:  =========<span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span>======endif===========<br></code></pre></td></tr></table></figure><p>下面的状态不会发生：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========<span class="hljs-keyword">if</span> **********************<span class="hljs-keyword">else</span>======endif===========<br><br>线程B:  =========<span class="hljs-keyword">if</span> **********************<span class="hljs-keyword">else</span>======endif===========<br></code></pre></td></tr></table></figure><p>另外if本身是有开销的。就是下面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========ifififif **********************elseelse======endif===========<br><br>线程B:  =========ifififif **********************elseelse======endif===========<br></code></pre></td></tr></table></figure><p>如果我们用了if去切换了很短的语句就是浪费，想下面这种if就没有存在的必要，改成别的方式比较好。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========ifififif elseelse=endif===========<br><br>线程B:  =========ifififif elseelse=endif===========<br></code></pre></td></tr></table></figure><p>重头戏来了，什么时候if很有用？超高的计算是一种，例如：光追，因为光追的特性可以保证线程成批的走同一个分支，平型光。这个没有研究过就是个大概。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========ifififif 光追左边一点的位置-》》》》》》》》elseelse  ******** endif===========<br><br>线程B:  =========ifififif 光追右边一点的位置-》》》》》》》》elseelse  ******** endif===========<br></code></pre></td></tr></table></figure><p>另一个就是显存访问。这样走相同的分支，效率更高。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========ifififif  读取纹理 ~~~~~~~~~~~~~~~~ elseelse  endif===========<br><br>线程B:  =========ifififif  读取纹理 ~~~~~~~~~~~~~~~~ elseelse  endif===========<br></code></pre></td></tr></table></figure><p>可能会存在.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">线程A:  =========ifififif  读取纹理 A~~~~~~~~~elseelse  ********************endif==========<br><br>线程B:  =========ifififif  *********************elseelse读取纹理 B~~~~~~~~~endif===========<br></code></pre></td></tr></table></figure><p>但是GPU有很多个CU，如果大量的CU可以节省一个分支只有少部分会两部分都跑那么这个分支就是有意义的。剩下的时间可以处理别的任务。</p><p>上面不是很准确，只是用比较好理解的方式解释一下。不同的GPU架构，都是有自己的特性的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/07/09/GPUAartch/GCN%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/"/>
      <url>/2022/07/09/GPUAartch/GCN%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Graphics-Core-Next"><a href="#Graphics-Core-Next" class="headerlink" title="Graphics Core Next"></a>Graphics Core Next</h1><p>GCN是2012年之后的GPU架构。</p><p>使用了精简指令集合。</p><p>GCN架构同时用到了PS4和XboxOne APU的图形部分。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://en.wikipedia.org/wiki/Graphics_Core_Next#cite_note-24">Wiki Graphics_Core_Next</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/07/09/GPUAartch/HDR%E7%A1%AC%E4%BB%B6%E5%B1%82Framebuffer%E6%A0%BC%E5%BC%8F%E6%A0%87%E5%87%86%E4%B8%8E%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2022/07/09/GPUAartch/HDR%E7%A1%AC%E4%BB%B6%E5%B1%82Framebuffer%E6%A0%BC%E5%BC%8F%E6%A0%87%E5%87%86%E4%B8%8E%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="HDR硬件层Framebuffer格式标准与渲染阶段的关系"><a href="#HDR硬件层Framebuffer格式标准与渲染阶段的关系" class="headerlink" title="HDR硬件层Framebuffer格式标准与渲染阶段的关系"></a>HDR硬件层Framebuffer格式标准与渲染阶段的关系</h1><p>这里主要探讨的是<strong>SwapChain的格式</strong>、<strong>写入其中的数据</strong>以及<strong>屏幕实际亮度</strong>之间的关系。</p><h2 id="SDR格式"><a href="#SDR格式" class="headerlink" title="SDR格式"></a>SDR格式</h2><p>对于SDR屏幕 Buffer主要有：</p><p>R8G8B8A8_UNORM：首先屏幕的eotf曲线是始终存在的，这种格式输入的颜色，图像接口不会进行任何处理，需要我们自己在shader中进行sRGB编码。</p><p>R8G8B8A8_SNORM：这种格式输入的颜色在显示之前会自动编码到SRGB空间（自动Gamma矫正），所以我们不需要进行处理，也就是说shader当中直接写出线性颜色即可。A通道是线性的。</p><blockquote><p>  Vulkan的解释：</p><p>  specifies a four-component, 32-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit R component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3.</p><p>  On the other hand, <strong>non-*_SRGB formats</strong> will be very likely exposed in pair with a <strong>SRGB color space.</strong> <strong>This means, the hardware will not apply any transfer function when reading from or writing to such images, yet they will still be presented on a device with sRGB display characteristics</strong>。（即使使用非SRGB的format，仍然可以使用 SRGB的colorSpace），这意味着硬件不会帮助进行自动的空间转换（在读写buffer时），但是仍然使用srgb的eotf的显示特性。</p></blockquote><p>SRGB的进一步说明：</p><p><a href="https://docs.rs/vulkano/0.7.2/vulkano/swapchain/enum.ColorSpace.html">https://docs.rs/vulkano/0.7.2/vulkano/swapchain/enum.ColorSpace.html</a></p><p><img src="/../../images/HDR%E7%A1%AC%E4%BB%B6%E5%B1%82Framebuffer%E6%A0%BC%E5%BC%8F%E6%A0%87%E5%87%86%E4%B8%8E%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5%E7%9A%84%E5%85%B3%E7%B3%BB/1590989148165.png" alt="1590989148165"></p><span id="more"></span><h2 id="HDR格式"><a href="#HDR格式" class="headerlink" title="HDR格式"></a>HDR格式</h2><p>R16G16B16_Float:这种格式输出的是线性浮点数颜色，数据可以超过1，1对应的是80nits。使用的是scRGB。</p><p>DX的参考：</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range">https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range</a></p><p>R10G10B10A2_UNORM：这种格式不会进行任何处理，直接结合EOFT曲线进行显示， 所以需要我们自己在Shader中进行PQ编码。（在我的显示器上Vulkan不支持，暂时没有测试过，但是GL和DX是支持这个格式的）</p><p>VK_COLOR_SPACE_HDR10_ST2084_EXT：说明colorSpace，表示使用BT2020颜色空间，使用ST2048的EOTF。</p><blockquote><p>   Note:</p><p>  对于Vulkan来说所有的ColorSpace都需要在Shader当中进行函数编码，除了SRGB。（对于SRGB的ColorSpace，通过指定带有SRGB的Format就能自动转换）。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FBXFileFormat</title>
      <link href="/2022/07/09/3DBasic/FBXFileFormat/"/>
      <url>/2022/07/09/3DBasic/FBXFileFormat/</url>
      
        <content type="html"><![CDATA[<h1 id="FBX-test-version-file-format-specification"><a href="#FBX-test-version-file-format-specification" class="headerlink" title="FBX test version file format specification"></a>FBX test version file format specification</h1><p><em>This post is extract from <a href="https://archive.blender.org/wiki/index.php/User:Mont29/Foundation/FBX_File_Structure/">blender Doc :FBX File Structure</a>.</em></p><h2 id="Generalities"><a href="#Generalities" class="headerlink" title="Generalities"></a>Generalities</h2><p>FBX is a nodal format, with a root element (which is never explicitly written) and a tree of children.</p><p>Each element has an id (byte string), and can have data and children elements.</p><p>Data are a set of (values, type) tuples, available types are: bool, short, int, long, float, double, bytes, string, and arrays of those types.</p><p>Here is a (JSON) representation of an element:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Element_ID&quot;</span><span class="hljs-punctuation">,</span>                         # ID<br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;data_string&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">13</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>              # Data<br>     <span class="hljs-string">&quot;SI&quot;</span><span class="hljs-punctuation">,</span>                             # Data types<span class="hljs-punctuation">,</span> as single-char codes (S for String<span class="hljs-punctuation">,</span> I for Integer<span class="hljs-punctuation">,</span> etc.)<br>     <span class="hljs-punctuation">[</span>__other_children_elements__<span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>Everything is based on this simple schema.</p><span id="more"></span><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Properties are a way to add heavily typed data.</p><p>Properties are represented by elements children of a “Properties70” element, which does not contain any data.</p><p>Each property is an element. Its ID does not seem to be important (usually, it’s “P” or “PS” for all of them). Their data layout follow that schema:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;PropName&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;PropType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Label(?)&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Flags&quot;</span><span class="hljs-punctuation">,</span> __values__<span class="hljs-punctuation">,</span> …<span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>In other words, the four first data of a property are always strings (its name, its type, presumably its label (often empty), and some flags (optional)), they are the “metadata” of the property. The other data are the property’s value (usually only one, but e.g. for colors or 3D vectors they are three - and some property types have no value :&#x2F;), and their type depends on the data type!</p><p>Bellow are some basic examples of properties:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JSON">Integer<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;some_name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;int&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Integer&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSI&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>Double<span class="hljs-punctuation">:</span>  <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;some_name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;double&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Number&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1.0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSD&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>Color<span class="hljs-punctuation">:</span>   <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;some_name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;ColorRGB&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Color&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSDDD&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><h2 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h2><p>Each template is defined by an “ObjectType” element, which takes a single property, the name of the template, which is also the name of the Object they “define” (e.g. “Model”, “Geometry”, “Material”, etc.).</p><p>Each template has two children: “Count” is the number of Objects using this template, and “PropertyTemplate”, which simply contains some properties.</p><p>To summarize, here is the generic structure of a template definition:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ObjectType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Geometry&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span>            # Start of template definition<br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Count&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>                   # Number of Objects using this template<br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;PropertyTemplate&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KFbxMesh&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span>  # Start of template&#x27;s properties<br>        <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Properties70&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Color&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;ColorRGB&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Color&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.8</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.8</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.8</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSDDD&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;BBoxMin&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Vector3D&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Vector&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSDDD&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;BBoxMax&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Vector3D&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Vector&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSDDD&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            ...<br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><h2 id="Top-Structure"><a href="#Top-Structure" class="headerlink" title="Top Structure"></a>Top Structure</h2><p>A valid FBX file must contain a set of standard elements:</p><ul><li><strong>FBXHeaderExtension</strong>: Mandatory? Contains the metadata of the file.</li><li><strong>FileId</strong>: Mandatory. Some kind of (currently) obscure hash, apparently based on the CreationTime data.</li><li><strong>CreationTime</strong>: Mandatory. The date&#x2F;time of creation of that file, as a single string (e.g. “2013-08-05 10:27:44:000”).</li><li><strong>Creator</strong>: Mandatory? A string identifying the tool used to create that FBX.</li><li><strong>GlobalSettings</strong>: Mandatory? A set of properties defining general data, like the orientation of the scene…</li><li><strong>Documents</strong>: Optional. Not sure what it is used for actually, so far only saw FBX files with a single doc definition here… Maybe it allows for several scenes in a single FBX?</li><li><strong>References</strong>: ???</li><li><strong>Definitions</strong>: Optional. Here templates are defined.</li><li><strong>Objects</strong>: Optional. Here real, useful, static (?) data are stored (objects, geometries, textures, materials, etc.).</li><li><strong>Connections</strong>: Optional. Here are defined links between data defined in Objects (e.g. which object uses which material, etc.).</li><li><strong>Takes</strong>: Optional. Here animations are defined?</li></ul><h2 id="Main-Data-Objects"><a href="#Main-Data-Objects" class="headerlink" title="Main Data - Objects"></a>Main Data - Objects</h2><h3 id="Mesh-Data"><a href="#Mesh-Data" class="headerlink" title="Mesh Data"></a>Mesh Data</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Geometry&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">152167664</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Name::Geometry&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Mesh&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;LSS&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Vertices&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_floats&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;d&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;PolygonVertexIndex&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_integers&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Edges&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_integers&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;GeometryVersion&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">124</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementNormal&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Version&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">101</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;MappingInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ByVertice&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ReferenceInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Direct&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Normals&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_floats&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;d&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>     <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementSmoothing&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Version&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">102</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;MappingInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ByPolygon&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ReferenceInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Direct&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Smoothing&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_integers&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span>  # Yep<span class="hljs-punctuation">,</span> int32 for bool values...<br>     <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementUV&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Version&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">101</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;UVMap&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;MappingInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ByPolygonVertex&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ReferenceInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;IndexToDirect&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;UV&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_floats&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;d&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;UVIndex&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_integers&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementUV&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Version&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">101</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;UVMap.001&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;MappingInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ByPolygonVertex&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ReferenceInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;IndexToDirect&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;UV&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_floats&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;d&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;UVIndex&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&lt;array_of_integers&gt;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementMaterial&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Version&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">101</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;gold&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;MappingInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;AllSame&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ReferenceInformationType&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;IndexToDirect&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Materials&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>     <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Layer&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Version&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">100</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElement&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>             <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Type&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementNormal&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>             <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;TypedIndex&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>         <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElement&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>             <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Type&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementMaterial&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>             <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;TypedIndex&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>         <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElement&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>             <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Type&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementSmoothing&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>             <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;TypedIndex&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>         <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>     <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Layer&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Version&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">100</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElement&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>             <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Type&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;LayerElementUV&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;S&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>             <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;TypedIndex&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>         <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><h3 id="Armature-and-Bones"><a href="#Armature-and-Bones" class="headerlink" title="Armature and Bones"></a>Armature and Bones</h3><p>In FBX, there is no real armature concept, you rather have chains of bones, which are nearly only defined by “Model” elements (FbxNode), i.e. loc&#x2F;rot&#x2F;scale from parent bone. Root bones are children of an empty object (Model), which plays the role of an armature.</p><p>In other words, armatures are presented more like a set of chains of parented-hooks.</p><p>Each bone&#x2F;hook is represented by a “LimbNode”, which also contains a “Size” parameter (its length), not sure this is used&#x2F;understood by all importers though.</p><p>Bones and mesh are “linked” first by a BindPose element, which stores the (transform) matrix of the mesh and all bones in global (world) space, at the time of binding.</p><h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><p>(New) animation in FBX is actually fairly simple: you have a Stack (usually only one per FBX file, else you may have compatibility issues), to which a set of Layers are linked.</p><p>A set of CurveNodes is linked to each AnimLayer, which define which properties are animated:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;AnimationCurveNode&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">2045776</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;T::AnimCurveNode&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;LSS&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Properties70&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;d&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Compound&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSS&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;d|X&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Number&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;A&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2.227995</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSD&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;d|Y&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Number&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;A&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3.0238389999999997</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSD&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;P&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;d|Z&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Number&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;A&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-1.49012e-08</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;SSSSD&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;AnimationCurve&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">924545958</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;::AnimCurve&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;LSS&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Default&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">-120.30426094607161</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;D&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyVer&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">4008</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;I&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyTime&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">1847446320</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3694892640</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5542338960</span><span class="hljs-punctuation">,</span> <span class="hljs-number">7389785280</span><span class="hljs-punctuation">,</span> <span class="hljs-number">9237231600</span><span class="hljs-punctuation">,</span> <span class="hljs-number">11084677920</span><span class="hljs-punctuation">,</span> <span class="hljs-number">12932124240</span><span class="hljs-punctuation">,</span> <span class="hljs-number">14779570560</span><span class="hljs-punctuation">,</span> <span class="hljs-number">16627016880</span><span class="hljs-punctuation">,</span> <span class="hljs-number">18474463200</span><span class="hljs-punctuation">,</span> <span class="hljs-number">20321909520</span><span class="hljs-punctuation">,</span> <span class="hljs-number">22169355840</span><span class="hljs-punctuation">,</span> <span class="hljs-number">24016802160</span><span class="hljs-punctuation">,</span> <span class="hljs-number">25864248480</span><span class="hljs-punctuation">,</span> <span class="hljs-number">27711694800</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29559141120</span><span class="hljs-punctuation">,</span> <span class="hljs-number">31406587440</span><span class="hljs-punctuation">,</span> <span class="hljs-number">33254033760</span><span class="hljs-punctuation">,</span> <span class="hljs-number">35101480080</span><span class="hljs-punctuation">,</span> <span class="hljs-number">36948926400</span><span class="hljs-punctuation">,</span> <span class="hljs-number">38796372720</span><span class="hljs-punctuation">,</span> <span class="hljs-number">90524869680</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;l&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyValueFloat&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">-90.00000762939453</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-90.16700744628906</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-90.67182159423828</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-91.51591491699219</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-92.69371032714844</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-94.19062042236328</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-95.98118591308594</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-98.02799224853516</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-100.28105926513672</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-102.67914581298828</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-105.1521224975586</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-107.62510681152344</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-110.02317810058594</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-112.27626037597656</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-114.32304382324219</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-116.11365509033203</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-117.61054229736328</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-118.78833770751953</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-119.63243103027344</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-120.13725280761719</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-120.30426025390625</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-120.30426025390625</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;f&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyAttrFlags&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">24840</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyAttrDataFloat&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">0.0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">9.419963346924634e-30</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;f&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyAttrRefCount&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">22</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyAttrFlags&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>A<span class="hljs-punctuation">,</span> B<span class="hljs-punctuation">,</span> A<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyAttrDataFloat&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>A1<span class="hljs-punctuation">,</span> A2<span class="hljs-punctuation">,</span> A3<span class="hljs-punctuation">,</span> A4<span class="hljs-punctuation">,</span> B1<span class="hljs-punctuation">,</span> B2<span class="hljs-punctuation">,</span> B3<span class="hljs-punctuation">,</span> B4<span class="hljs-punctuation">,</span> A1<span class="hljs-punctuation">,</span> A2<span class="hljs-punctuation">,</span> A3<span class="hljs-punctuation">,</span> A4<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;f&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;KeyAttrRefCount&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">10</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span> <span class="hljs-number">10</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;i&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 3DBasic </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ColorGrading中LUT的生成与使用</title>
      <link href="/2022/07/09/Art/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/07/09/Art/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ColorGrading中LUT的生成与使用"><a href="#ColorGrading中LUT的生成与使用" class="headerlink" title="ColorGrading中LUT的生成与使用"></a>ColorGrading中LUT的生成与使用</h1><p>场景的LUT贴图有两种生成方式：</p><ol><li>通常DaVinCi生成的是.cube文件，需要用cube文件转换。</li><li>直接在PS当中调整。</li></ol><h2 id="PS直接调整"><a href="#PS直接调整" class="headerlink" title="PS直接调整"></a>PS直接调整</h2><p>对于用ps直接调整来说，只要把参考图片和Natural LUT一起调整即可，最终Natural LUT的结果就是我们要的LUT。</p><span id="more"></span><h2 id="cube文件转换"><a href="#cube文件转换" class="headerlink" title="cube文件转换"></a>cube文件转换</h2><p>打开PS，加载默认的LUT文件（就是netrual lut，不对图像产生影响的lut）。</p><p><img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1590739624304.png" alt="1590739624304"></p><p>确定颜色模式为RGB</p><p><img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1590739649754.png" alt="1590739649754"></p><p>开启颜色查找功能：</p><p><img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1590739676967.png" alt="1590739676967"></p><p>使用默认选项点击确认，得到lut图层：</p><p><img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1590739706978.png" alt="1590739706978"></p><p><img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1590739721058.png" alt="1590739721058"></p><p>下面是LUT的图层控制面板：</p><p><img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1590739883952.png" alt="1590739883952"></p><p>配置完成之后就得到了修改好的lut，保存成非压缩的png即可：</p><p><img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1590739972583.png" alt="1590739972583"></p><h2 id="下面是两种Natural-Lut"><a href="#下面是两种Natural-Lut" class="headerlink" title="下面是两种Natural Lut"></a>下面是两种Natural Lut</h2><p>64*64<img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/neutral-lut.png" alt="neutral-lut"></p><p>32*32</p><p><img src="/../../images/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/reshade-neutral-lut-768x24.png" alt="reshade-neutral-lut-768x24"></p>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PS颜色风格</title>
      <link href="/2022/07/09/Art/%E9%A2%9C%E8%89%B2%E9%A3%8E%E6%A0%BC/"/>
      <url>/2022/07/09/Art/%E9%A2%9C%E8%89%B2%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="PS颜色风格"><a href="#PS颜色风格" class="headerlink" title="PS颜色风格"></a>PS颜色风格</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>日系，ins风格，低饱和度，平和。</p><p>欧美系，高饱和，有侵略性。</p><p>明度，轻盈舒适。</p><p>低明度，压抑称重，有质感，金属—&gt; 铁和铝箔的IBL。</p><p>同类色-&gt; 15%的色相环，-&gt;靠明度和饱和度达到设计和层次感。–&gt;ToneMapping。</p><p><img src="/../../images/%E9%A2%9C%E8%89%B2%E9%A3%8E%E6%A0%BC/1592918191766.png" alt="1592918191766"></p><h2 id="Camera-Raw"><a href="#Camera-Raw" class="headerlink" title="Camera Raw"></a>Camera Raw</h2><p>Ctrl + Shift + A进入PS的Camera Raw风格。</p><p> 主要用来编辑Raw文件的。</p><p><img src="/../../images/%E9%A2%9C%E8%89%B2%E9%A3%8E%E6%A0%BC/1592918699887.png" alt="1592918699887"></p><p>自动白平衡和手动白平衡。</p><p>下面的图像有没有色偏？可以有也可以没有，但是自动白平衡会去掉。</p><p><img src="/../../images/%E9%A2%9C%E8%89%B2%E9%A3%8E%E6%A0%BC/1592919134345.png" alt="1592919134345"></p><p>渲染当中白色光就没有色偏！！怎么做。</p><span id="more"></span><h3 id="曝光工具"><a href="#曝光工具" class="headerlink" title="曝光工具"></a>曝光工具</h3><p>暗部不实，亮部不实，不通透。</p><p>过渡饱和，——&gt;细节丢失。</p><h2 id="日系风格"><a href="#日系风格" class="headerlink" title="日系风格"></a>日系风格</h2><p>主要特点：明度高 + 冷色调 + 饱和度低 + 大光圈（背景虚化）+ 有光线感觉 + 有点缀的暖色。</p><h2 id="欧美蓝调（胶片风）"><a href="#欧美蓝调（胶片风）" class="headerlink" title="欧美蓝调（胶片风）"></a>欧美蓝调（胶片风）</h2><p>欧美风格主要特点：色彩对比高 + 明暗对立感强 + 饱和度高 + 亮度低（画面的质感）+ 比较多的利用胶片感、湿润感 + 亮部暗部都不实（高光柔和）+ 使用暖色。</p><p>高光不刺眼： 湿润感。</p><p>阴影提亮、灰蒙蒙：光线感、空气感。</p><p>蓝调：阴影加入颜色。</p><p><strong>色彩曲线</strong></p><h2 id="欧美暗调"><a href="#欧美暗调" class="headerlink" title="欧美暗调"></a>欧美暗调</h2><p>色相统一 + 蓝色调为主 + 画面元素简单</p><p><strong>混合模式法</strong>：</p><p>柔光：</p><p>正片叠底：</p><p>滤色：</p><p>颜色、色相、饱和度、明度：使用原图层的信息和新图层的信息结合。</p><p><strong>色温法：</strong></p><p>对于中性色为主才有效。</p><p><strong>色调分离法：</strong></p><p>先去掉饱和度，然后通过高光和阴影加入颜色。</p><h2 id="赛博朋克"><a href="#赛博朋克" class="headerlink" title="赛博朋克"></a>赛博朋克</h2><p>色相统一 （洋红色 + 青色 的对比色）+ 整体饱和度高 + 未来感、科幻感 + 以夜景照片为主。</p><p><strong>色相饱和度工具：</strong></p><p>色相可以任意转换的。色彩变化范围比HSL工具更加广泛，可以同时调整多种颜色。</p><h2 id="浓郁胶片风"><a href="#浓郁胶片风" class="headerlink" title="浓郁胶片风"></a>浓郁胶片风</h2><p>饱和度高 +油润感 + 明暗对比反差大 + 没有大面积死黑 + 用阴影压暗 + 高光亮不过量、没有高光 + 高光偏灰色 + 空气感（左端点没有凸起，没有纯黑色） + 整体暖色调，有冷色调互补。+ 照片颗粒感 + 暗角。</p><p>黑色白色：画面通透度。</p><p>色调感：混合模式。</p><p>空气感（蒙上灰尘的感觉）：看看画面中是否有重元素（大面积黑色）</p><h2 id="青橙色调"><a href="#青橙色调" class="headerlink" title="青橙色调"></a>青橙色调</h2><p>橙色作为人物肤色的色相 + 人物颜色的反差色 得到了青橙色调的选择。</p><p>色相统一（青色橙色） + 整体亮度比较低（直方图靠左）+ 对比度高（明暗反差大） 。</p><p>核心特点就是色彩<strong>转化</strong> ，将其他颜色饱和度<strong>降低</strong>。</p><p><strong>可选颜色工具：</strong> </p><p>一个颜色受什么颜色控制：<strong>最大值</strong>和<strong>最大值和中间值的混合色</strong>，一种颜色最多受到两种颜色的控制。</p><h2 id="港风色调"><a href="#港风色调" class="headerlink" title="港风色调"></a>港风色调</h2><p>主要特点：对比度高 + 亮暗反差大 + 青色（冷色只有青色）、橙色、换色、红色为主，暗部红橙色，亮部青色 + 整体饱和度比较强。</p><p><strong>色彩感受：</strong></p><p><strong>基调颜色</strong>：-&gt;修改色温，得到基色 -&gt; 对基色进行HSL或者是可选颜色工具进行调整。</p><h2 id="Ins温暖风"><a href="#Ins温暖风" class="headerlink" title="Ins温暖风"></a>Ins温暖风</h2><p>色调统一（橙色调，有低饱和青色作为点缀）+ 饱和度偏高 + 空气感 </p>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BRDF与色彩与明暗</title>
      <link href="/2022/07/09/Art/BRDF%E4%B8%8E%E8%89%B2%E5%BD%A9%E4%B8%8E%E6%98%8E%E6%9A%97/"/>
      <url>/2022/07/09/Art/BRDF%E4%B8%8E%E8%89%B2%E5%BD%A9%E4%B8%8E%E6%98%8E%E6%9A%97/</url>
      
        <content type="html"><![CDATA[<h1 id="BRDF与色彩与明暗"><a href="#BRDF与色彩与明暗" class="headerlink" title="BRDF与色彩与明暗"></a>BRDF与色彩与明暗</h1><p>最近看了一些和色彩相关的文章。在美术当中，明暗变化和颜色的过度是紧紧关联起来的（例如：油画变暗并不是单纯地混入黑色），与BRDF模拟有一些差别（单纯考虑明暗，多个通道同样的明暗衰退过程），原画师、插画师一般是从HSV空间（色相环之类的）下手。</p><h2 id="BRDF明暗与美术明暗"><a href="#BRDF明暗与美术明暗" class="headerlink" title="BRDF明暗与美术明暗"></a>BRDF明暗与美术明暗</h2><p>在美术配色当中，颜色的变化并不只是混入黑色，现实世界同样是，<strong>亮度的降低往往伴随了饱和度的升高</strong>（下图蓝色）。</p><p>但是BRDF总是等比例降低RGB大小（下图黄色），饱和度没有变化。导致画面看起来暗部部分变脏。</p><p>brdf和实际的明暗在拾色器中的变化如下图：<br><img src="/../../images/brdf.jpg" alt="brdf"></p><p>在Cel Shading当中，画面通常需要保证高饱和度，所以通常需要通过后期的Tone Mapping或者Ramp Map的方式调整暗部颜色。</p><p>这里需要注意，BRDF符合正确的物理明暗变化，但是艺术处理上有所欠缺。</p><span id="more"></span><h2 id="色彩练习"><a href="#色彩练习" class="headerlink" title="色彩练习"></a>色彩练习</h2><p>下图是学了色彩之后的练习。主要为了思考明暗和光线以及BRDF的关系，亮度降低伴随了饱和度的升高。可以得到比较好的明暗结果。</p><p><img src="/../../images/color.jpg" alt="color"></p><h2 id="色彩练习2"><a href="#色彩练习2" class="headerlink" title="色彩练习2"></a>色彩练习2</h2><p>这次练习单一颜色的明暗处理。下面的图片只是使用了亮度和饱和度不同的红色。感觉上可以通过单一颜色的数学方法而不是Ramp Map来调整暗部。</p><p><img src="/../../images/sample.jpg" alt="sample"></p><p><img src="/../../images/color2.jpg" alt="color2"></p>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DaVinCi色彩处理原理</title>
      <link href="/2022/07/09/Art/DaVinCi%E8%89%B2%E5%BD%A9%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/"/>
      <url>/2022/07/09/Art/DaVinCi%E8%89%B2%E5%BD%A9%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="DaVinCi色彩处理原理"><a href="#DaVinCi色彩处理原理" class="headerlink" title="DaVinCi色彩处理原理"></a>DaVinCi色彩处理原理</h1><h2 id="Data-Level（pdf，P215）"><a href="#Data-Level（pdf，P215）" class="headerlink" title="Data Level（pdf，P215）"></a>Data Level（pdf，P215）</h2><p>不同的媒体数据文件使用不同范围的数据表示。通常来讲处理的是10bit的数据(0-1023)，有两种不同的data level用来保存图像数据：</p><ul><li><p><strong>Video：</strong>所有的图像数据从0-1的颜色强度，会映射到64-940之间。Y通道[64-940]，CB和CR[64-960],小于64用于表示比黑色更黑的区域，941&#x2F;961–1019 表示超过白色的区域。过低过高的数据称作：undershoots 和overshoots。</p></li><li><p><strong>Full：</strong>对于RGB444数据，数据强度0-1映射到4-1023。</p></li></ul><p>无论哪种数据类型，都有0-100的最大和最小亮度。当数据格式转换时，范围会重新映射：</p><ul><li>(minimum Video Level) 64 &#x3D; 4 (Data Level minimum) </li><li>(maximum Video Level) 940 or 960 &#x3D; 1023 (Data Level maximum）</li></ul><p>​      数据格式的转换几乎不会有变化，因为合法数据会被被保存下来。区别是undershoots 和overshoots可能丢失，但是Resolve软件内部会记录下来，保证之后可以还原。</p><p>   <strong>在DaVinci Resolve中，所有的图像格式都会以Full的格式进行处理。并且是未被压缩的32bit浮点数表示。</strong>也就是说，每一个图片无论原始的bit-depth是多少，都会转换成32bit的数据。转换的质量依赖于原始数据，总之是无压缩的转换。</p><span id="more"></span><h2 id="Color-management"><a href="#Color-management" class="headerlink" title="Color management"></a>Color management</h2><p>色彩被处理的方式依赖于Color Science设置。有四种：DaVinci YRGB、DaVinci YRGB Color Managed、 DaVinci ACEScc, 和 DaVinci ACEScct。</p><h3 id="RCM概念"><a href="#RCM概念" class="headerlink" title="RCM概念"></a>RCM概念</h3><p>指定输入数据的颜色空间、处理数据的颜色空间和输出的颜色空间。</p><p><strong>可以使用数值处理和LUT处理，如果过超过LUT范围会被clip。所以通常还需要执行preLUT调整</strong>。</p><p><img src="/../../images/DaVinCi%E8%89%B2%E5%BD%A9%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/1590046403438.png" alt="1590046403438"></p><h3 id="RCM设置"><a href="#RCM设置" class="headerlink" title="RCM设置"></a>RCM设置</h3><p>Color SpaceSetting中可以设置。</p><p>DaVinCi的颜色管理可以控制输入输出的图片格式——<strong>色域</strong>gamut和<strong>EOTF曲线</strong>gamma。</p><p>主要控制内容有两种，打开Use Separate Color Space and Gamma，就可以分别控制<strong>色域</strong>和<strong>EOTF曲线</strong>：</p><p><img src="/../../images/DaVinCi%E8%89%B2%E5%BD%A9%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/1590027078511.png" alt="1590027078511"></p><p>同时针对每一个Clip也可以独立的设置：</p><p><img src="/../../images/DaVinCi%E8%89%B2%E5%BD%A9%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/1590047180142.png" alt="1590047180142"></p><p>关闭Use Separate Color Space and Gamma，就能同时的修改。</p><h2 id="203nit对齐"><a href="#203nit对齐" class="headerlink" title="203nit对齐"></a>203nit对齐</h2><p>100nits的颜色亮度和和203nit的亮度的映射。</p><blockquote><p>  SDR content to HDR by mapping 100 nits to 203 nits (defined as the diffuse white level) according to the BT.2100 recommendation</p></blockquote><p>当输入数据是SDR输出数据是HDR的时候会进行转换。</p><h2 id="Gamut对齐"><a href="#Gamut对齐" class="headerlink" title="Gamut对齐"></a>Gamut对齐</h2><p>我们通常发布的数据格式会在一个很大的色域上，Rec.2020。但是需要把颜色限制在比较小的色域范围上来满足Consumer的显示器。</p><p>这样我们需要设置Gamut。</p><p>设置OutPutColor Space来保证输出的色域是宽色域，设置Limit Output Gamut来保证颜色范围是在小色域上（直接clip掉），以支持演示器的显示。</p>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>材质制作参数F0</title>
      <link href="/2022/07/09/Art/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E5%8F%82%E6%95%B0F0/"/>
      <url>/2022/07/09/Art/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E5%8F%82%E6%95%B0F0/</url>
      
        <content type="html"><![CDATA[<p>- <a href="#%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E5%8F%82%E6%95%B0f0">材质制作参数F0</a><br>    - <a href="#%E9%9D%9E%E9%87%91%E5%B1%9E">非金属</a><br>    - <a href="#%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8">金属材质</a><br>    - <a href="#%E5%B8%B8%E8%A7%81%E9%87%91%E5%B1%9E%E5%8F%82%E6%95%B0">常见金属参数</a></p><h1 id="材质制作参数F0"><a href="#材质制作参数F0" class="headerlink" title="材质制作参数F0"></a>材质制作参数F0</h1><h2 id="非金属"><a href="#非金属" class="headerlink" title="非金属"></a>非金属</h2><p>网上可以查到很多物体的折射率</p><p>对于非金属来说，将折射率转化成F0的公式：</p><p>$$ F0 &#x3D; \frac{(n-1)^2}{(n+1)^2} $$</p><p>不同物体的Fresnel的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Charcoal       0.04<br>Fresh asphalt  0.04<br>Worn asphalt   0.12<br>Bare soil      0.17<br>Green grass    0.25<br>Desert sand    0.40<br>New concrete   0.55<br>Ocean Ice      0.5–0.7<br>Fresh snow     0.80–0.90<br>Quartz    0.045593921<br>ice       0.017908907<br>Water     0.020373188<br>Alcohol   0.01995505<br>Glass     0.04<br>Milk      0.022181983<br>Ruby      0.077271957<br>Crystal   0.111111111<br>Diamond   0.171968833<br>Skin      0.028<br></code></pre></td></tr></table></figure><p>更多参数可以参考：<a href="https://www.btbat.com/12032.html">常见材质IOR</a>，不过因为电介质材质的IOR通常很小在渲染中一般为0.04即可。</p><p><strong>但是对于非金属的宝石之类的特殊物体，需要比较高的IOR，这个时候一般的金属工作流是不适用的，应为他需要特殊的F0</strong>.</p><p>电介质F0的定义准则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">No value under <span class="hljs-number">0.02</span><br>Common gemstones <span class="hljs-number">0.05</span><span class="hljs-number">-0.17</span><br>Common liquids <span class="hljs-number">0.02</span><span class="hljs-number">-0.04</span><br>When not finding reference <span class="hljs-keyword">for</span> a dielectric material, setting a value of <span class="hljs-number">0.04</span> (around plastic)<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="金属材质"><a href="#金属材质" class="headerlink" title="金属材质"></a>金属材质</h2><p>金属的处理和电介质是不同的。金属材料的折射率是<strong>复数</strong> ：$$ c &#x3D; n+ik $$.</p><p>金属的F0</p><p>$$  F0 &#x3D; \frac{(c-1)(c*-1)}{(c+1)(c*+1)} $$<br>其中，c*是c的共轭复数，而1代表的是真空折射率。</p><p>更复杂的推导：<a href="https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/">Memo on Fresnel equations</a></p><p>具体的各种金属的n和k的值可以在<a href="https://refractiveindex.info/">refractiveindex.info</a>中查看。这个网站同时给出了折射率、透光度等数据。他的结论也是一样的从折射率推导F0（也就是下面的R（0）),如下图：</p><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E5%8F%82%E6%95%B0F0/1575080116258.png" alt="1575080116258"></p><p>同时给出了一个基础的F0原则： The basic rule for metal is to setup a value above 0.5.</p><h2 id="常见金属参数"><a href="#常见金属参数" class="headerlink" title="常见金属参数"></a>常见金属参数</h2><p>下面有一些可以参考的F0.线性空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">               R            G            B<br>Silver      <span class="hljs-number">0.971519</span>    <span class="hljs-number">0.959915</span>    <span class="hljs-number">0.915324</span><br>Aluminium   <span class="hljs-number">0.913183</span>    <span class="hljs-number">0.921494</span>    <span class="hljs-number">0.924524</span><br>Gold        <span class="hljs-number">1</span>           <span class="hljs-number">0.765557</span>    <span class="hljs-number">0.336057</span><br>Copper      <span class="hljs-number">0.955008</span>    <span class="hljs-number">0.637427</span>    <span class="hljs-number">0.538163</span><br>Chromium    <span class="hljs-number">0.549585</span>    <span class="hljs-number">0.556114</span>    <span class="hljs-number">0.554256</span><br>Nickel      <span class="hljs-number">0.659777</span>    <span class="hljs-number">0.608679</span>    <span class="hljs-number">0.525649</span><br>Titanium    <span class="hljs-number">0.541931</span>    <span class="hljs-number">0.496791</span>    <span class="hljs-number">0.449419</span><br>Cobalt      <span class="hljs-number">0.662124</span>    <span class="hljs-number">0.654864</span>    <span class="hljs-number">0.633732</span><br>Platinum    <span class="hljs-number">0.672411</span>    <span class="hljs-number">0.637331</span>    <span class="hljs-number">0.585456</span><br></code></pre></td></tr></table></figure><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E5%8F%82%E6%95%B0F0/metalness.png" alt="metalness"></p>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>材质制作数值标准总结</title>
      <link href="/2022/07/09/Art/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/09/Art/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><p>- <a href="#%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93">材质制作数值标准总结</a></p><p>​    - <a href="#%E6%9D%90%E8%B4%A8%E5%8F%82%E6%95%B0%E8%8C%83%E5%9B%B4">材质参数范围</a></p><p>​        - <a href="#basecolorrgb-srgb">BaseColor（RGB-sRGB）</a></p><p>​            - <a href="#guidelines">Guidelines</a></p><p>​        - <a href="#metallic">Metallic</a></p><p>​            - <a href="#f0">F0</a></p><p>​            - <a href="#%E9%87%91%E5%B1%9E">金属</a></p><p>​            - <a href="#%E9%9D%9E%E9%87%91%E5%B1%9E">非金属</a></p><p>​            - <a href="#guideline">Guideline</a></p><p>​        - <a href="#roughness">Roughness</a></p><p>​            - <a href="#guideline">GuideLine</a></p><p>​        - <a href="#ao">AO</a></p><p>​            - <a href="#guidline">Guidline</a></p><p>​        - <a href="#%E6%80%BB%E7%BB%93">总结</a></p><p>​    - <a href="#gamma%E7%A9%BA%E9%97%B4">Gamma空间</a></p><p>​    - <a href="#%E9%AA%8C%E8%AF%81">验证</a></p><span id="more"></span><!-- /TOC --><h1 id="材质制作数值标准总结"><a href="#材质制作数值标准总结" class="headerlink" title="材质制作数值标准总结"></a>材质制作数值标准总结</h1><h2 id="材质参数范围"><a href="#材质参数范围" class="headerlink" title="材质参数范围"></a>材质参数范围</h2><h3 id="BaseColor（RGB-sRGB）"><a href="#BaseColor（RGB-sRGB）" class="headerlink" title="BaseColor（RGB-sRGB）"></a>BaseColor（RGB-sRGB）</h3><p>在metal&#x2F;roughness工作流中，非金属的反射颜色和金属的反射率（F0）保存在Abledo贴图中。</p><h4 id="Guidelines"><a href="#Guidelines" class="headerlink" title="Guidelines"></a>Guidelines</h4><ol><li><p>BaseColor是物体的固有色，没有色调的变化。所以对比度要比一般的DiffuseMap（画出光影的颜色贴图）低。</p></li><li><p>物体的色调往往比印象中的浅，过暗的色调无法被照亮:安全的颜色范围： 50 - 240 sRGB 或者（50-243. ）。控制得当可以使用更广的范围:  30 - 240 sRGB。（最黑的是煤炭，最亮的是雪）下面是参考范围:</p><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/1574848708374.png" alt="1574848708374"></p></li><li><p>BaseColor当中保存了非金属反射信息，所以不能包括光线本身的信息，比如：AO。但是可以添加微小的遮挡，但是当添加了微小遮挡之后，也必须在规定的亮度范围之内。</p></li></ol><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/1574843302369.png" alt="1574843302369"></p><ol start="4"><li><p>金属的折射率(就是Color)应该从实际测量中获得，通常的范围是：<strong>sRGB range of 180-255</strong>.下面是一部分金属颜色：下图是一部分可以参考的颜色：</p><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/1574839815423.png" alt="1574839815423"></p></li><li><p>如果金属出现了氧化和污渍不能被当做金属，尤其是当BaseColor当中加入了这种颜色，那么金属度也必须发生变化。</p></li></ol><h3 id="Metallic"><a href="#Metallic" class="headerlink" title="Metallic"></a>Metallic</h3><p>通常用于区分金属与非金属。通常当做Mask使用,非金属的F0通常不是手动创建的，如果一个位置的金属度是0，会把这个位置的F0当做0.04处理。</p><h4 id="F0"><a href="#F0" class="headerlink" title="F0"></a>F0</h4><p>F0&#x3D;Fresnel Reflectance at 0 Degrees</p><ol><li><p>电介质(dielectrics)  :  0.02-0.05  如果不确定可以设置成0.04</p></li><li><p>导体(conductors) :  0.5-1.0</p></li></ol><p>表面的反射率由折射率决定：</p><p>$$ F0 &#x3D;( \frac{n-1}{n+1})^2 $$</p><p>非金属（电介质&#x2F;绝缘体）应该是灰色值，金属（导体）应该是RGB值。对于光滑的表面电介质F0应该在 2%和5% of 之间,斜略角100%  他的F0变化不大。金属变化比较明显。</p><p>通常F0和导体和绝缘体相关，宝石是例外。</p><h4 id="金属"><a href="#金属" class="headerlink" title="金属"></a>金属</h4><p>我们通过折射率算出的折射光线是被吸收的光线。对于金属来说部分光线反射，折射光线直接被吸收。金属的颜色来自于折射的光线也就是F0,也就是说金属的F0就是金属的颜色。</p><p>虽然金属度为1通常是剖光金属，通常金属可以在 <strong>235-255 sRGB</strong> 之间，这个区间的材质反射率需要满足： 70-100%（Base ColorMap <strong>180-255 sRGB</strong> ）。</p><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/1574840422730.png" alt="1574840422730"></p><p>腐蚀金属在金属度贴图上是黑色，当做电介质处理。</p><p>涂漆金属被当做电介质。</p><p>污渍同样被当做非金属。</p><p>例子：</p><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/1574840762049.png" alt="1574840762049"></p><h4 id="非金属"><a href="#非金属" class="headerlink" title="非金属"></a>非金属</h4><p>非金属没有导电性，折射的光线、被散射或者被吸收（大部分会再次从表面发散出去）所以被散射和被吸收后再次发射的光线构成了Albedo颜色。但是他的折射率很低比金属底，所以颜色更低贴图中的颜色要暗。</p><p>被反射的颜色为F0，为0.02-0.05.（ 0.017-0.067 (40-75 sRGB) ），这些值通常会被硬编码成固定的0.04，特殊的：宝石会大于0.4。</p><h4 id="Guideline"><a href="#Guideline" class="headerlink" title="Guideline"></a>Guideline</h4><ol><li>腐蚀、氧化、污渍的金属不是金属,黑色的金属度，和灰色的非金属程度。</li><li>金属度应该被当做一个Mask，用来告诉Shader如何解释Albedo贴图中的颜色信息。（金属：反射率，非金属：反射颜色）</li><li>金属度不能总是0-1，在0-1之间应该有很窄的过渡灰。</li><li>金属度为0.85-1（ <strong>235-255 sRGB</strong> ）的区域需要有高于70-100%（180-255 sRGB 或者 186-255）的反射率。</li><li>如果金属度低于235 sRGB 那么需要降低对应BaseColor当中的颜色。降低程度可以根据氧化层、污渍层、腐蚀层的程度来决定。</li></ol><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/1574844210517.png" alt="1574844210517"></p><h3 id="Roughness"><a href="#Roughness" class="headerlink" title="Roughness"></a>Roughness</h3><p>描述表面不规则情况，和光线的散射程度。粗糙&#x3D;更大更黯淡的高光。</p><p>粗糙度用来描述同一种材质上的变化。磨损、折旧、风化、磨光。</p><p>粗糙度需要和法线贴图相关联。</p><h4 id="GuideLine"><a href="#GuideLine" class="headerlink" title="GuideLine"></a>GuideLine</h4><p>可以灵活的使用。</p><h3 id="AO"><a href="#AO" class="headerlink" title="AO"></a>AO</h3><p>描述环境光被遮挡。通常AO影响的是由环境贴图产生的环境光（amibient lighting）IBL。而不应该影响高光和直接光，所以不能放置在Albedo当中。尤其是对于金属，如果加到了Aldedo当中，对IBL和高光的影响会更加明显。</p><h4 id="Guidline"><a href="#Guidline" class="headerlink" title="Guidline"></a>Guidline</h4><p>从高度图或者根据模型烘焙生成。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/../../images/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E6%95%B0%E5%80%BC%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93/79369760-f4dd-4823-b2de-64a54e85ff8e.png" alt="img"></p><h2 id="Gamma空间"><a href="#Gamma空间" class="headerlink" title="Gamma空间"></a>Gamma空间</h2><p>需要被标记为Gamma的贴图：base color, diffuse, specular 和emissive. </p><p>需要被标记为线性空间的： roughness, ambient occlusion, normal, metallic, and height.</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>SD:</p><p><em>PBR Metal&#x2F;Roughness Validate</em> ：</p><p><strong>Material Filters &gt; PBR Utilities</strong>. 可以进行材质颜色、金属度的验证。</p><p>错-》对 ： 红&gt; 黄&gt; 绿</p><p>SP:</p><p><em>PBR Metal&#x2F;Roughness Validate (filter)</em> <a href="https://share.allegorithmic.com/libraries/824The">下载链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HDRColorGrading技术方案</title>
      <link href="/2022/07/09/Art/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
      <url>/2022/07/09/Art/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>- <a href="#hdrcolorgrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88">HDRColorGrading技术方案</a></p><p>​    - <a href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B">整体流程</a></p><p>​    - <a href="#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B">详细流程</a></p><p>​        - <a href="#pq%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2">PQ空间转换</a></p><p>​        - <a href="#amplify">Amplify</a></p><p>​        - <a href="#pg%E7%A9%BA%E9%97%B4colorgrading">PG空间ColorGrading</a></p><p>​        - <a href="#%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4tonemapping">线性空间ToneMapping</a></p><p>​        - <a href="#%E6%98%BE%E7%A4%BA%E5%99%A8%E4%BA%AE%E5%BA%A6%E9%85%8D%E9%80%82">显示器亮度配适</a></p><p>​            - <a href="#%E5%AF%B9%E4%BA%8Ehdr%E6%98%BE%E7%A4%BA%E5%99%A8">对于hdr显示器</a></p><p>​            - <a href="#%E5%AF%B9%E4%BA%8Esdr%E6%98%BE%E7%A4%BA%E5%99%A8">对于sdr显示器</a></p><p>​        - <a href="#tonemapping">ToneMapping</a></p><p>​            - <a href="#hdr%E6%98%BE%E7%A4%BA%E5%99%A8displaymapping%E6%9B%B2%E7%BA%BF%E8%AE%BE%E8%AE%A1">hdr显示器Displaymapping曲线设计</a></p><p>​            - <a href="#sdr%E6%98%BE%E7%A4%BA%E5%99%A8display-mapping%E6%9B%B2%E7%BA%BF%E8%AE%BE%E8%AE%A1">Sdr显示器Display Mapping曲线设计</a></p><p>​        - <a href="#gumatmapping">GumatMapping</a></p><p>​    - <a href="#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%E5%88%B6%E4%BD%9C">相关资源制作</a></p><p>​        - <a href="#davinci-colorgrading-lut%E5%88%B6%E4%BD%9C">DaVinCi ColorGrading Lut制作</a></p><p>​        - <a href="#%E5%BC%95%E6%93%8E%E4%B8%AD%E5%AF%BC%E5%87%BA%E5%9B%BE%E7%89%87%E6%88%96%E8%A7%86%E9%A2%91">引擎中导出图片或视频</a></p><p>​        - <a href="#davinci%E8%AE%BE%E7%BD%AE">DaVinCi设置</a></p><p>​        - <a href="#davinci%E5%AF%BC%E5%85%A5%E5%9B%BE%E7%89%87">DaVinCi导入图片</a></p><p>​        - <a href="#lut%E5%AF%BC%E5%87%BAcube">Lut导出cube</a></p><p>​        - <a href="#cube%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E5%BC%95%E6%93%8E%E5%8F%AF%E7%94%A8%E7%9A%84lut">cube文件转换成引擎可用的lut</a></p><span id="more"></span><h1 id="HDRColorGrading技术方案"><a href="#HDRColorGrading技术方案" class="headerlink" title="HDRColorGrading技术方案"></a>HDRColorGrading技术方案</h1><p>为了兼容HDR显示屏和SDR显示屏，重新设计了ColorGading和ToneMapping的技术方案。</p><p>重点是合理控制颜色空间、亮度和显示器的配适。</p><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>首先整体流程：</p><ol><li><p>定义lighting Render Target，格式为R16G16B16A16.</p></li><li><p>光照计算结果需进行限制：65535，这部分是为了防止数据溢出。</p></li><li><p>进行HDR阶段的后处理。</p></li><li><p>HDR最后阶段：PQ空间的ColorGrading。这里需要有一个信号放大，用来缩放屏幕亮度和nits的匹配关系。</p></li><li><p>针对nits的ToneMapping：根据显示器的nits值选择对应的ToneMapping曲线。</p></li></ol><blockquote><p>  为了能够更好地控制亮度的变化，我尝试使用显示器的nits值来做不同的ToneMapping。sdr为100nits, hdr为10000nits。sdr执行高强度的mapping，hdr执行低强度的mapping。其实原理和很简单，只要对颜色亮度做一个压缩，调整一下亮度范围即可。</p></blockquote><ol start="6"><li>Gamut Mapping。</li><li>配适显示器亮度曲线。</li></ol><p>颜色处理部分的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> Amplify = <span class="hljs-number">3</span>;<br><span class="hljs-type">float</span> ExposureFract = <span class="hljs-number">0.0001</span> * Amplify;<br><br>HDRColor *= ExposureFract;<br>float3 pqSpace = InvertPQcurve(saturate(HDRColor));<br><br><span class="hljs-comment">//PQ SPACE ColorLookupTable</span><br><br>HDRColor = PQcurve(pqSpace);<br>HDRColor /= ExposureFract;<br><br><span class="hljs-comment">// HDR Display</span><br>&#123;<br>OUT.Color.xyz = ToneMapping1(HDRColor * Amplify);<br>&#125;<br><span class="hljs-comment">// LDR Display</span><br>&#123;<br>OUT.Color.xyz = ToneMapping2(HDRColor * Amplify);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h2><p>这部分说明关键步骤详细流程。</p><h3 id="PQ空间转换"><a href="#PQ空间转换" class="headerlink" title="PQ空间转换"></a>PQ空间转换</h3><p>这里我们使用PQ空间，这样使用更多的数据位表示暗部数据。</p><blockquote><p>  Note:</p><p>  这里对于哪个空间更好还是存疑的，因为使用PQ曲线是寒霜引擎的推荐（但是他针对的是端游），同时最后一步还要执行一次PQ，这样精度损失理论上是最小，不过还需要测试和对比。</p></blockquote><p>PQ空间转换代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 <span class="hljs-title function_">InvertPQcurve</span><span class="hljs-params">(float3 x)</span>&#123;<br>    <span class="hljs-type">float</span> c2 = <span class="hljs-number">2413.0</span> / <span class="hljs-number">128</span>;<br>    <span class="hljs-type">float</span> c3 = <span class="hljs-number">2392.0</span> / <span class="hljs-number">128</span>;<br>    <span class="hljs-type">float</span> c1 = c3 - c2 + <span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">float</span> m1 = <span class="hljs-number">1305.0</span> / <span class="hljs-number">8192</span>;<br>    <span class="hljs-type">float</span> m2 = <span class="hljs-number">2523.0</span> / <span class="hljs-number">32</span>;<br><br>    float3 y = <span class="hljs-built_in">pow</span>( (c1 +  c2 * <span class="hljs-built_in">pow</span>(x,m1) )/(<span class="hljs-number">1</span> +  c3 * <span class="hljs-built_in">pow</span>(x,m1)), m2);<br>    <span class="hljs-keyword">return</span> y ;<br>&#125;<br></code></pre></td></tr></table></figure><p>PQ空间还原代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">def <span class="hljs-title function_">PQcurve</span><span class="hljs-params">(x)</span>:<br>    c2 = <span class="hljs-number">2413.0</span> / <span class="hljs-number">4096</span> * <span class="hljs-number">32</span><br>    c3 = <span class="hljs-number">2392.0</span> / <span class="hljs-number">4096</span> * <span class="hljs-number">32</span><br>    c1 = <span class="hljs-number">3424</span> / <span class="hljs-number">4096</span> <br>    m1 = <span class="hljs-number">2610.0</span> / <span class="hljs-number">4096</span> / <span class="hljs-number">4</span><br>    m2 = <span class="hljs-number">2523.0</span> / <span class="hljs-number">4096</span> * <span class="hljs-number">128</span><br><br>    y = <span class="hljs-built_in">pow</span>((<span class="hljs-built_in">pow</span>(x,<span class="hljs-number">1</span>/m2)-c1) / (c2-c3*<span class="hljs-built_in">pow</span>(x,<span class="hljs-number">1</span>/m2)), <span class="hljs-number">1.0</span>/m1)<br>    <span class="hljs-keyword">return</span> y <br></code></pre></td></tr></table></figure><p>PQ空间曲线：</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590136497248.png" alt="1590136497248"></p><h3 id="Amplify"><a href="#Amplify" class="headerlink" title="Amplify"></a>Amplify</h3><p>为了更好的配适亮度，需要一个缩放Amplify，模拟拍摄过程中的模拟信号放大。</p><h3 id="PG空间ColorGrading"><a href="#PG空间ColorGrading" class="headerlink" title="PG空间ColorGrading"></a>PG空间ColorGrading</h3><p>进入PQ空间之后采样制作好的PQ空间LUT：</p><p>这一步结束之后HDR的ColorGrading就制作完成了。</p><h3 id="线性空间ToneMapping"><a href="#线性空间ToneMapping" class="headerlink" title="线性空间ToneMapping"></a>线性空间ToneMapping</h3><p>颜色制作完成之后，我们就需要执行tonemap </p><blockquote><p>   Note:</p><p>  我还是考虑使用计算方式的tonemap，不过大部分项目都选择把ToneMapping结合到lut当中去，这里也可以延续这个做法。</p><p>  但是有个关键的问题是ColorGrading可以用来修改气氛，不同的场景是可以修改的，并且最好sdr和hdr使用同一套内容。所以优先希望简化tonemapping曲线，而不是合并lut。</p></blockquote><p>针对不同的显示器需要不同的曲线。</p><h3 id="显示器亮度配适"><a href="#显示器亮度配适" class="headerlink" title="显示器亮度配适"></a>显示器亮度配适</h3><blockquote><p>  在输出之前要确定亮度正确的编码，以被不同的显示器正确显示。</p></blockquote><h4 id="对于hdr显示器"><a href="#对于hdr显示器" class="headerlink" title="对于hdr显示器"></a>对于hdr显示器</h4><p>如果使用R10G10B10A2格式（目前确认过，HDR支持全部使用这种格式）需要使用PQ曲线进行mapping。</p><p>如果使用R16G16B16，使用线性缩放。</p><h4 id="对于sdr显示器"><a href="#对于sdr显示器" class="headerlink" title="对于sdr显示器"></a>对于sdr显示器</h4><p>如果使用sRGB8，使用线性压缩。</p><p>如果使用RGB8U，使用Gamma曲线mapping。</p><h3 id="ToneMapping"><a href="#ToneMapping" class="headerlink" title="ToneMapping"></a>ToneMapping</h3><h4 id="hdr显示器Displaymapping曲线设计"><a href="#hdr显示器Displaymapping曲线设计" class="headerlink" title="hdr显示器Displaymapping曲线设计"></a>hdr显示器Displaymapping曲线设计</h4><p>可以考虑使用UE的FilmToneMapping，这部分会和Sdr显示器有较大区别。</p><h4 id="Sdr显示器Display-Mapping曲线设计"><a href="#Sdr显示器Display-Mapping曲线设计" class="headerlink" title="Sdr显示器Display Mapping曲线设计"></a>Sdr显示器Display Mapping曲线设计</h4><p>目前根据常规做法，可以使用ACESFilmToneMapppiong曲线。</p><blockquote><p>  Note</p><p>  当然也可以使用UE的Filmic，不过参数完全不同，效果也一样会有所差别。</p></blockquote><h3 id="GumatMapping"><a href="#GumatMapping" class="headerlink" title="GumatMapping"></a>GumatMapping</h3><p>颜色空间的映射需要确定，目前来看是没有进行任何mapping。</p><h2 id="相关资源制作"><a href="#相关资源制作" class="headerlink" title="相关资源制作"></a>相关资源制作</h2><h3 id="DaVinCi-ColorGrading-Lut制作"><a href="#DaVinCi-ColorGrading-Lut制作" class="headerlink" title="DaVinCi ColorGrading Lut制作"></a>DaVinCi ColorGrading Lut制作</h3><p>需要制作的资源主要是lut。</p><h3 id="引擎中导出图片或视频"><a href="#引擎中导出图片或视频" class="headerlink" title="引擎中导出图片或视频"></a>引擎中导出图片或视频</h3><p><strong>导出的图片是linear空间的hdr数据，直接进行PQ编码，得到PQ编码后的文件。此时的数据范围为：0-1.</strong></p><h3 id="DaVinCi设置"><a href="#DaVinCi设置" class="headerlink" title="DaVinCi设置"></a>DaVinCi设置</h3><p>我们所有的设置都在HDR的PQ空间中进行。所以对于不同的显示器只需要用同一个LUT即可。</p><p>DaVinCi的设置大部分保持默认，LookUpTabbles保证为空：</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590733135642.png" alt="1590733135642"></p><p>在HDR显示器上进行Lut制作时的设置：</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590733737966.png" alt="1590733737966"></p><p>在SDR显示器上进行Lut制作时的设置，<strong>这里设置取决于我们如何执行Gamut Mapping</strong>，也可以保持和HDR一样：</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590734156399.png" alt="1590734156399"></p><p>我们不需要开启Node的HDR mode，只是控制有所区别，对于结果没有影响。</p><h3 id="DaVinCi导入图片"><a href="#DaVinCi导入图片" class="headerlink" title="DaVinCi导入图片"></a>DaVinCi导入图片</h3><p>直接将图片拖拽到Clip中即可，然后打开Color面板进行调整。</p><h3 id="Lut导出cube"><a href="#Lut导出cube" class="headerlink" title="Lut导出cube"></a>Lut导出cube</h3><p>完成设置后右键clip点击Generate 3D LUT(33 Point Cube)即可。</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590735234391.png" alt="1590735234391"></p><p>此时我们会得到一张.cube文件，大小为33 * 33 * 33的三维纹理。</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590736942822.png" alt="1590736942822"></p><h3 id="cube文件转换成引擎可用的lut"><a href="#cube文件转换成引擎可用的lut" class="headerlink" title="cube文件转换成引擎可用的lut"></a>cube文件转换成引擎可用的lut</h3><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590736912628.png" alt="1590736912628"></p><p>下面我们要把从DaVinCi当中导出的.cube文件转化成二维纹理。</p><p>打开PS，加载默认的LUT文件（就是netrual lut，不对图像产生影响的lut）。</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590739624304.png" alt="1590739624304"></p><p>确定颜色模式为RGB</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590739649754.png" alt="1590739649754"></p><p>开启颜色查找功能：</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590739676967.png" alt="1590739676967"></p><p>使用默认选项点击确认，得到lut图层：</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590739706978.png" alt="1590739706978"></p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590739721058.png" alt="1590739721058"></p><p>下面是LUT的图层控制面板：</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590739883952.png" alt="1590739883952"></p><p>配置完成之后就得到了修改好的lut，保存成非压缩的png即可：</p><p><img src="/../../images/HDRColorGrading%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/1590739972583.png" alt="1590739972583"></p><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>色彩表示的前世今生</title>
      <link href="/2022/07/09/Art/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/2022/07/09/Art/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="色彩表示的前世今生"><a href="#色彩表示的前世今生" class="headerlink" title="色彩表示的前世今生"></a>色彩表示的前世今生</h1><h2 id="眼睛"><a href="#眼睛" class="headerlink" title="眼睛"></a>眼睛</h2><p>因此，彩色光的表观亮度的变化是由于棒效应的叠加造成的，在视杆细胞上只刺激光感</p><p>眼睛的亮度感受： 10000:1<br>眼睛的色彩接收器：Rods and Cones<br>因此，光敏感曲线和暗敏感曲线基本上是单独作用于视锥细胞和视杆细胞的<br>猫的眼睛受视杆细胞支配。</p><h2 id="首先是从波长到颜色感知-CIE-1931-color-space来源-wiki"><a href="#首先是从波长到颜色感知-CIE-1931-color-space来源-wiki" class="headerlink" title="首先是从波长到颜色感知-CIE 1931 color space来源 wiki"></a><strong>首先是从波长到颜色感知</strong>-CIE 1931 color space来源 <a href="https://en.wikipedia.org/wiki/CIE_1931_color_space">wiki</a></h2><p>CIE是国际照明委员会（ <a href="https://en.wikipedia.org/wiki/International_Commission_on_Illumination">International Commission on Illumination</a>）的缩写。制定了与光和颜色相关的国际标准。</p><p>CIE 1931颜色空间是第一个在<strong>电磁可见光谱中波长分布</strong>（波长）和人类色觉中生理感知的颜色（颜色）之间的定量联系。</p><p>定义这些颜色空间的数学关系是颜色管理的基本工具，在处理彩色油墨、发光显示器和数字相机等记录设备时非常重要。</p><span id="more"></span><h2 id="从色彩感知要色彩表示"><a href="#从色彩感知要色彩表示" class="headerlink" title="从色彩感知要色彩表示"></a>从色彩感知要色彩表示</h2><p>CIE与1931年提出了 <strong>CIE 1931 RGB color space</strong> 和 <strong>CIE 1931 XYZ color space</strong>。从实验得出的标准。</p><p>将实验结果结合到CIE RGB颜色空间，又推到得到了CIE XYZ颜色空间。</p><h2 id="三色表示"><a href="#三色表示" class="headerlink" title="三色表示"></a>三色表示</h2><h3 id="LMS-color-space"><a href="#LMS-color-space" class="headerlink" title="LMS color space"></a>LMS color space</h3><p>LMS(长、中、短)是一个颜色空间，它代表了人眼三种视锥细胞的反应，以它们在长、中、短波长的响应(灵敏度)峰值命名。</p><p><strong>数值范围通常不指定，只是下端通常以0为界。</strong>在进行颜色适应(估计样品在不同光源下的外观)时，通常使用LMS颜色空间。它在色盲的研究中也很有用，当一个或多个锥体类型有缺陷时。</p><p><strong>视力正常的人眼有三种感知光的视锥细胞。</strong>（简而言之，具有光谱灵敏度的峰值 (“S”, 420 nm – 440 nm), middle (“M”, 530 nm – 540 nm), and long (“L”, 560 nm – 580 nm) ）</p><p><strong>下图是波长和感知能力的对应和亮度没有关系。</strong></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1280px-Cones_SMJ2_E.svg.png" alt="1280px-Cones_SMJ2_E.svg"></p><p>这些视锥细胞构建了对中、高亮度感知的基本能力。在很暗的环境下色觉减弱。</p><p>对于低亮度、单色的夜视感知器叫做视杆细胞.</p><p>三个颜色的强度对应三种视锥细胞的刺激水平，原则上描述任何人类的颜色感觉。根据三种视锥细胞的光谱灵敏度对总光功率谱进行加权，得到三种刺激的有效值。显示器就的制造就是来分别刺激三个颜色视锥细胞。这三个值构成了光谱客观颜色的三刺激规范。</p><p>这三个参数分别表示为“S”、“M”和“L”，并使用一个名为“LMS颜色空间”的三维空间表示，LMS颜色空间是用来量化人类颜色视觉的众多颜色空间之一</p><h3 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h3><p>与颜色空间相关的三色刺激值可以在三色加色的颜色模型中被概念化为三原色的数量。</p><p>颜色空间将物理的混合光线映射到一个人眼的客观感觉范围，但并不是在LMS空间（视锥细胞感知铭感度）与颜色空间相关的三色刺激值可以在三色加色的颜色模型中被概念化为三原色的数量。</p><p><strong>在某些颜色空间中，包括LMS和XYZ空间，使用的原色不是真正的颜色，因为它们不能在任何光谱中生成。</strong></p><p><strong>因为：LMS描述了三个分量，但是在光谱上他们是重合的。因此，某些三刺激值在物理上是不可能的，例如LMS三刺激值对于M分量为非零，对于L和S分量都为零。</strong></p><h2 id="XYZ颜色空间"><a href="#XYZ颜色空间" class="headerlink" title="XYZ颜色空间"></a>XYZ颜色空间</h2><p>CIE XYZ颜色空间包含了对视力一般的人可见的所有颜色感觉。它是定义许多其他颜色空间的标准参考。他的三坐标位置，例如主位置[1,0,0]、[0,1,0]和[0,0,1]，对应于可能的LMS坐标空间之外的假想颜色。假想的颜色不符合任何波长的光谱分布，因此没有物理现实。</p><h2 id="颜色三角形"><a href="#颜色三角形" class="headerlink" title="颜色三角形"></a>颜色三角形</h2><p>对于加法模型来说，描述了颜色的分布，三原色位于三个顶点。颜色可能超过这个范围。出现某个通道的负数，色品范围不是三角形，无法覆盖。</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/CIExy1931_srgb_gamut.png" alt="CIExy1931_srgb_gamut"></p><h3 id="光度函数"><a href="#光度函数" class="headerlink" title="光度函数"></a>光度函数</h3><p>人类倾向于认为光谱中绿色部分的光比同等功率的红色或蓝色光更亮,因此，描述不同波长感知亮度的光度函数与M锥的光谱灵敏度大致类似。</p><h3 id="XYZ推到"><a href="#XYZ推到" class="headerlink" title="XYZ推到"></a>XYZ推到</h3><p>CIE模型利用了这一事实，将Y设为亮度。Z等于蓝色，或者说S锥响应，X是非负响应曲线的组合。将Y设为亮度，得到的有用结果是，对于任何给定的Y值，XZ平面将包含该亮度下所有可能的色度</p><p><strong>三刺激值的单位X、Y和Z通常是任意选择的，因此Y &#x3D; 1或Y &#x3D; 100是彩色显示器所支持的最亮的白色。</strong></p><h2 id="CIE-xy-chromaticity-diagram-and-the-CIE-xyY-color-space"><a href="#CIE-xy-chromaticity-diagram-and-the-CIE-xyY-color-space" class="headerlink" title="CIE xy chromaticity diagram and the CIE xyY color space"></a>CIE xy chromaticity diagram and the CIE xyY color space</h2><p>将色品和亮度分离，下面的图片是色度图</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/300px-CIE-1931_diagram_in_LAB_space.svg-1582861390979.png" alt="300px-CIE-1931_diagram_in_LAB_space.svg"></p><ul><li>该图代表了普通人可见的所有色度，色域的弯曲边缘称为光谱轨迹，对应于单色光（每个点代表一个单一波长的纯色调）。色域下半部分的直线称为紫色线，这些颜色虽然处于色域的边缘，但在单色光中没有对应的颜色。较不饱和的颜色出现在图的内部，白色在中间</li><li></li></ul><h2 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h2><h2 id="颜色标准"><a href="#颜色标准" class="headerlink" title="颜色标准"></a>颜色标准</h2><p> IEC 61966-2-2  scRGB</p><h2 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h2><p>色域都是 100% SRGB<br>对比度 1000:1&#x2F;3000:1&#x2F;1000:1&#x2F;1000:1 </p><h1 id="Illuminant-D65"><a href="#Illuminant-D65" class="headerlink" title="Illuminant D65"></a>Illuminant D65</h1><p>D65大致相当于西欧&#x2F;北欧的平均正午光(包括直射光和晴空散射光)，因此它也被称为日光发光体。</p><p><strong>D65是一个表格式的SPD，从300nm到830nm递增5 nm的光谱分布。</strong></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/SPD_D65.png" alt="SPD_D65"></p><h2 id="色温"><a href="#色温" class="headerlink" title="色温"></a>色温</h2><p>黑体辐射</p><p><strong>黑体辐射</strong>指处于热力学平衡态的<strong>黑体</strong>发出的电磁<strong>辐射</strong>。 <strong>黑体辐射</strong>的电磁波谱只取决于<strong>黑体</strong>的温度。 另一方面，所謂<strong>黑體輻射</strong>其實就是光和物質達到平衡所表現出的現象。</p><p>在<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%AD%A6">物理学</a>中，<strong>普朗克黑体辐射定律</strong>（也简称作<strong>普朗克定律</strong>或**<a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E4%BD%93%E8%BE%90%E5%B0%84">黑体辐射</a>定律<strong>，英文：</strong>Planck’s law**, <strong>Blackbody radiation law</strong>）。</p><h3 id="黑体-wiki"><a href="#黑体-wiki" class="headerlink" title="黑体 wiki"></a>黑体 <a href="%5Bhttps://zh.wikipedia.org/wiki/%E9%BB%91%E4%BD%93_(%E7%89%A9%E7%90%86%E5%AD%A6)%5D(https://zh.wikipedia.org/wiki/%E9%BB%91%E4%BD%93_(%E7%89%A9%E7%90%86%E5%AD%A6)">wiki</a></h3><p>​黑体对于任何<a href="https://zh.wikipedia.org/wiki/%E6%B3%A2%E9%95%BF">波长</a>的<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E7%A3%81%E6%B3%A2">电磁波</a>的吸收系数为1，<a href="https://zh.wikipedia.org/wiki/%E9%80%8F%E5%B0%84%E4%BF%82%E6%95%B8">透射系数</a>为0。但黑体未必是黑色的，即使不反射任何的电磁波，它也可以放出电磁波，而这些电磁波的波长和能量则全取决于黑体的<a href="https://zh.wikipedia.org/wiki/%E6%BA%AB%E5%BA%A6">温度</a>，不因其他因素而改变。</p><p>​对于人的视觉而言，黑体在700<a href="https://zh.wikipedia.org/wiki/%E7%B5%95%E5%B0%8D%E6%BA%AB%E6%A8%99">K</a>以下时看起来是黑色的，这是由于在700K之下的黑体所放出来的辐射能量很小且辐射波长在<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E8%A6%8B%E5%85%89">可见光</a>范围之外。若黑体的温度高过上述的温度的话，黑体则不会再是黑色的了，它会开始变成红色，并且随着温度的升高，而分别有橘色、黄色、白色等颜色出现，即黑体吸收和放出电磁波的过程遵循了<a href="https://zh.wikipedia.org/wiki/%E5%85%89%E8%AD%9C">光谱</a>，其<a href="https://zh.wikipedia.org/wiki/%E8%BD%A8%E8%BF%B9">轨迹</a>为普朗克轨迹（或称为黑体轨迹）。<a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E9%AB%94%E8%BC%BB%E5%B0%84">黑体辐射</a>实际上是黑体的<a href="https://zh.wikipedia.org/wiki/%E7%86%B1%E8%BC%BB%E5%B0%84">热辐射</a>。在黑体的光谱中，<strong>由于高温引起高频率即短波长</strong>，因此较高温度的黑体靠近光谱结尾的蓝色区域而较低温度的黑体靠近红色区域。</p><h2 id="色温-1"><a href="#色温-1" class="headerlink" title="色温"></a>色温</h2><p>从理想黑体发射出的电磁辐射的<strong>色温定义为其表面温度</strong>，单位为开尔文或微观倒数度(深陷于)。<strong>这样就可以定义一个比较光源的标准。</strong></p><h2 id="色彩平衡"><a href="#色彩平衡" class="headerlink" title="色彩平衡"></a>色彩平衡</h2><h2 id="显示器的色域、色数、对比度"><a href="#显示器的色域、色数、对比度" class="headerlink" title="显示器的色域、色数、对比度"></a>显示器的色域、色数、对比度</h2><p>2.显示器是彩色的，显示器的彩色是由红绿蓝三色混合而成，刚才计算出每个颜色可以有256级的灰阶变化，那三种颜色可以有多少变化呢？就是256的3次方，256^3&#x3D;16777216，也就是1670万。</p><p>同样的方法，计算6bit&#x2F;10bit，结果分别是26万&#x2F;10亿。</p><p>色域 sRGB 100%   sRGB124%   Adobe RGB≥99.5%</p><p>色数 16.7M   1.07B  </p><p>可视角度 IPS 178°&#x2F;178°(CR&gt;10)</p><p>对比度   1000:1    3000:1    4000:1  20000000：1（动态）</p><p>基本定义：对比度简单些的定义是显示器的白色亮度与黑色亮度的比值。比如一台显示器在显示全白画面（255）时实测亮度值为200cd&#x2F;㎡，全黑画面实测亮度为0.5cd&#x2F;㎡，那么它的对比度就是400：1。</p><p>亮度 220 cd&#x2F;m2  300cd&#x2F;m2   450nits, 350nits, 280nits  720 cd &#x2F;m?（标准），1000 cd &#x2F;m?（峰值） 4000 nits</p><h2 id="Nivida对HDR的定义："><a href="#Nivida对HDR的定义：" class="headerlink" title="Nivida对HDR的定义："></a>Nivida对HDR的定义：</h2><ul><li><p>Deep blacks: Contrast of 50k:1 or better ：More contrast and detail in shadows</p></li><li><p>4K or higher resolution</p></li><li><p>Wide color gamut  ：Richer colors</p></li><li><p>Bright display: 750 cm&#x2F;m  minimum, 1000-10,000 cd&#x2F;m 2 highlights ：Realistic highlights</p></li></ul><p><strong>HDR isn’t simply about making brighter images</strong></p><p>亮度的增加 会带来：</p><p>色彩饱和度的感知提升。</p><p>空间分辨能力提升。</p><h1 id="Tonemapping"><a href="#Tonemapping" class="headerlink" title="Tonemapping"></a>Tonemapping</h1><p><strong>No one true tone mapper, choice depends on the desired aesthetics</strong></p><p><strong>For best results in HDR the tone mapper must understand the output luminance range of the display.</strong></p><h2 id="亮度和HDR的关系"><a href="#亮度和HDR的关系" class="headerlink" title="亮度和HDR的关系"></a>亮度和HDR的关系</h2><p><a href="https://developer.nvidia.com/displaying-hdr-nuts-and-bolts">https://developer.nvidia.com/displaying-hdr-nuts-and-bolts</a></p><p>First, as has been the case since Windows Vista, fp16 swap chains are expected to have linear color data. By this I mean that there is no gamma encoding. Secondly, with traditional displays, 1.0 always just meant the brightest intensity. With HDR, things have moved to a color space based on scRGB and a scheme where the value represents an absolute output level rather than a relative one. </p><p>Now, 1.0 is interpreted as the level of 80 nit white. This is the standard white level set by the sRGB standard for displays, and it is probably a white at or slightly dimmer compared to the white for the monitor you are reading this on. 12.5 represents the 1000 nit white that is the practical limit for most HDR displays you can buy today. </p><h1 id="摄像设备色彩压缩"><a href="#摄像设备色彩压缩" class="headerlink" title="摄像设备色彩压缩"></a>摄像设备色彩压缩</h1><p><a href="https://www.rocketstock.com/blog/tips-for-log-color-space-compositing/">https://www.rocketstock.com/blog/tips-for-log-color-space-compositing/</a></p><p>现在，几乎所有的相机制造商都提供自己的对数曲线(或多个)，摄像设备通常保存数据，使用了对数空间，厂商常用的空间包括 <strong>S-Log 2&amp;3</strong> (Sony), <strong>LogC</strong> (Arri), <strong>Canon Log</strong>, <strong>V-Log</strong> (panasonic), <strong>Red Logfilm</strong>, <strong>Blackmagic Log</strong>,。，这条曲线通常会根据传感器信息定制曲线，它们每一个都是不同的，通常是为特定制造商的产品的颜色科学定制的。<strong>目的就是:就能够保存尽可能多的传感器信息（并非为人眼保存，而是为了保存更多的原始数据）。</strong>它对摄像机看到的东西进行对数编码.</p><p>线性色彩空间具有恒定不变的亮度值，与场景中的精确数学值一致。在人眼看来，这将看起来非常黑暗和泥泞的某些地区和过度暴露的其他，<strong>因为我们的眼睛(和监视器的问题)看到的颜色不同于他们的确切亮度值</strong>,可以看到更多的细节在光明和黑暗的领域。.因此，我们必须应用一个不同的颜色空间，以更美观的方式看到颜色信息</p><ol><li><p>就像我们看到了，这个曲线向上推，以保留更多的阴影数据。</p></li><li><p>Rec. 709并不是一个完全线性的颜色空间，但它更接近于线性而不是对数。</p></li><li><p><strong>convert your CGI element from Rec. 709 to Log</strong>.</p></li></ol><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/Log-Curve.jpg" alt="Understanding LOG and Color Space In Compositing — LOG vs Linear"></p><p><strong>在特效合成领域</strong> ，例如：AE软件。我们的VFX特效数据通常是。</p><p>我们的拍摄素材是log空间的，这样各种素材才能保证尽可能多的数据，和准确度。但是我们的素材、特效通常是在Gamma空间的（接近线性空间），所以我们需要将素材转换到log空间。通常我们使用LUT表。可以执行颜色空间转换。可以将我们的素材转换到log空间。为了看到正确的结果，我们在把整个图像从log空间转换回sRGB空间。</p><p>影视大量的使用了Rec709颜色的特效和Log的背景。</p><p><img src="https://i1.wp.com/www.xdcam-user.com/wp-content/uploads/2014/10/Slide12.jpg?resize=474,356" alt="Slide12 Using S-log2 and S-Log3 from the A7S (色彩表示的前世今生/Slide12.jpg) in post production."></p><p>wiki的资料</p><p><a href="https://en.wikipedia.org/wiki/Log_profile">https://en.wikipedia.org/wiki/Log_profile</a></p><h1 id="Gamma"><a href="#Gamma" class="headerlink" title="Gamma"></a>Gamma</h1><p>Gamma编码：</p><p>A gamma value &lt; 1 is sometimes called an <strong>encoding gamma</strong>{会让颜色变亮}, and the process of encoding with this compressive power-law nonlinearity is called <strong>gamma compression</strong>; </p><p>conversely a gamma value &gt; 1 is called a <strong>decoding gamma</strong> and the application of the expansive power-law nonlinearity is called <strong>gamma expansion</strong>.</p><p>图像Gamma编码的作用：</p><p>Gamma encoding of images is used to <strong>optimize the usage of bits</strong> when encoding an image, or bandwidth used to transport an image, by taking <strong>advantage of the non-linear manner in which humans perceive light and color。</strong></p><p>The human perception of brightness, under common illumination conditions (<strong>neither pitch black nor blindingly bright</strong>), follows an approximate <a href="https://en.wikipedia.org/wiki/Power_function">power function</a> <strong>(note: no relation to the <a href="https://en.wikipedia.org/wiki/Gamma_function">gamma function</a>),</strong> with greater sensitivity to relative differences between darker tones than between lighter tones, consistent with the <a href="https://en.wikipedia.org/wiki/Stevens_power_law">Stevens power law</a> for brightness perception.</p><p>计算机显示器的Gamma：</p><p>In most computer display systems, images are encoded with a gamma of about 0.45 and decoded with the reciprocal gamma of 2.2. </p><p>CRT中Gamma作用：</p><p>Output to CRT-based television receivers and monitors does not usually require further gamma correction, since the standard video signals that are transmitted or stored in image files incorporate gamma compression that provides a pleasant image after the gamma expansion of the CRT</p><p>Although gamma encoding was developed originally to compensate for the input–output characteristic of <a href="https://en.wikipedia.org/wiki/Cathode_ray_tube">cathode ray tube</a> (CRT) displays, that is not its main purpose or advantage in modern systems. In CRT displays, the light intensity varies nonlinearly with the electron-gun voltage. **Altering the input signal by gamma compression can cancel this nonlinearity, such that the output picture has the intended luminance. **。</p><p>文件保存机制</p><p>The pixel’s intensity values in a given image file; that is, the binary pixel values are stored in the file in such way that they <strong>represent the light intensity via gamma-compressed values instead of a linear encoding</strong>. This is done systematically with digital video files (as those in a <a href="https://en.wikipedia.org/wiki/DVD">DVD</a> movie), in order to <strong>minimize the gamma-decoding step while playing, and maximize image quality for the given storage.</strong> </p><h1 id="显示器测试"><a href="#显示器测试" class="headerlink" title="显示器测试"></a>显示器测试</h1><p>一个HDR显示器支持的SwapChain格式：</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1583807985870.png" alt="1583807985870"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSurfaceFormatKHR</span> &#123;</span><br>    VkFormat           format;<br>    VkColorSpaceKHR    colorSpace;<br>&#125; VkSurfaceFormatKHR;<br><br><span class="hljs-comment">// Format进入swapchain的自动转码、读取的自动解码。</span><br>VK_FORMAT_B8G8R8A8_UNORM  +  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR<br>VK_FORMAT_B8G8R8A8_SRGB  +  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR<br>VK_FORMAT_R16G16B16A16_SFLOAT + VK_COLOR_SPACE_HDR10_ST2084_EXT<br><br></code></pre></td></tr></table></figure><p>VK_FORMAT_B8G8R8A8_SRGB ： specifies a four-component, 32-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit R component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3.<br>A通道是线性的。</p><p>VK_FORMAT_B8G8R8A8_SRGB：specifies a four-component, 32-bit unsigned normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3</p><p><strong>format 的作用</strong>：While the format of a presentable image refers to the encoding of each pixel, </p><p><strong>color space 的作用</strong>： the colorSpace determines how the presentation engine interprets the pixel values. 显示器。A color space in this document refers to a specific color space (defined by the chromaticities of its primaries and a white point in CIE Lab), and a transfer function that is applied before storing or transmitting color data in the given color space. 读取和写入的时候执行转换操作。</p><p>On the other hand, <strong>non-*_SRGB formats</strong> will be very likely exposed in pair with a <strong>SRGB color space.</strong> <strong>This means, the hardware will not apply any transfer function when reading from or writing to such images, yet they will still be presented on a device with sRGB display characteristics</strong></p><p><strong>normalized :表示0-1</strong></p><h3 id="测试1-输入线性数据-sRGB纹理-sRGB-EOTF"><a href="#测试1-输入线性数据-sRGB纹理-sRGB-EOTF" class="headerlink" title="测试1:输入线性数据+sRGB纹理 + sRGB EOTF"></a>测试1:输入线性数据+sRGB纹理 + sRGB EOTF</h3><p>如果使用Format格式为sRGB。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">VK_FORMAT_B8G8R8A8_SRGB +  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR（暗示了EOTF的类型）<br></code></pre></td></tr></table></figure><p>Shader当中直接方式输出颜色：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// SwapChain格式Format</span><br><br><span class="hljs-comment">//CPU端</span><br><span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Vertex&gt; vertices = &#123;<br>&#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;&#125;,<br>&#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;&#125;,<br>&#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;&#125;,<br>&#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;&#125;<br>&#125;;<br><span class="hljs-comment">// Shader PS程序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//outColor = vec4(fragColor, 1.0);</span><br>    outColor = vec4(fragColor, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-comment">//outColor = texture(texSampler, fragTexCoord);</span><br>    <span class="hljs-comment">//outColor = outColor*outColor;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出这个颜色的原因是，写入时执行了sRGB的编码（颜色变亮）。然后将buffer当中的内容当做sRGB空间颜色进行显示。<strong>下面这个效果就是线性颜色！！</strong></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1583818583086.png" alt="1583818583086"></p><h3 id="测试2-输入Gamma解码数据-sRGB纹理-sRGB-EOTF"><a href="#测试2-输入Gamma解码数据-sRGB纹理-sRGB-EOTF" class="headerlink" title="测试2:输入Gamma解码数据+sRGB纹理 + sRGB EOTF"></a>测试2:输入Gamma解码数据+sRGB纹理 + sRGB EOTF</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>   <span class="hljs-comment">// 设备会在写入时进行sRGB编码，然后数据当做sRGB内容在显示器进行显示。</span><br>    outColor = vec4(fragColor * fragColor, <span class="hljs-number">1.0</span>); <br>...<br></code></pre></td></tr></table></figure><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1583818522774.png" alt="1583818522774"></p><h3 id="测试3-输入线性数据-UNORM纹理-sRGB-EOTF"><a href="#测试3-输入线性数据-UNORM纹理-sRGB-EOTF" class="headerlink" title="测试3:输入线性数据+UNORM纹理 + sRGB EOTF"></a>测试3:输入线性数据+UNORM纹理 + sRGB EOTF</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">VK_FORMAT_B8G8R8A8_UNORM  +  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>    <span class="hljs-comment">// </span><br>    outColor = vec4( fragColor, <span class="hljs-number">1.0</span>); <br>...<br></code></pre></td></tr></table></figure><p>同样是正常的：</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1583818684976.png" alt="1583818684976"></p><h3 id="测试4-输入线性数据-Float16纹理-hdr-EOTF"><a href="#测试4-输入线性数据-Float16纹理-hdr-EOTF" class="headerlink" title="测试4:输入线性数据+Float16纹理 + hdr EOTF."></a>测试4:输入线性数据+Float16纹理 + hdr EOTF.</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">VK_FORMAT_R16G16B16A16_SFLOAT  VK_COLOR_SPACE_HDR10_ST2084_EXT<br>VK_COLOR_SPACE_HDR10_ST2084_EXT :specifies support <span class="hljs-keyword">for</span> the <span class="hljs-title function_">HDR10</span> <span class="hljs-params">(BT2020 color)</span> space to be displayed using the SMPTE ST2084 Perceptual <span class="hljs-title function_">Quantizer</span> <span class="hljs-params">(PQ)</span> EOTF.<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>    <span class="hljs-comment">// </span><br>    outColor = vec4( fragColor, <span class="hljs-number">1.0</span>); <br>...<br></code></pre></td></tr></table></figure><p>同样是线性响应函数：得到的和第一组测试一模一样。</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1583820889870.png" alt="1583820889870"></p><h2 id="电信号转换-：电阻发热导致的能量损失。"><a href="#电信号转换-：电阻发热导致的能量损失。" class="headerlink" title="电信号转换 ：电阻发热导致的能量损失。"></a>电信号转换 ：电阻发热导致的能量损失。</h2><h1 id="显示器如何还原颜色"><a href="#显示器如何还原颜色" class="headerlink" title="显示器如何还原颜色"></a>显示器如何还原颜色</h1><p>参考资料：<a href="https://www.tftcentral.co.uk/articles/pointers_gamut.htm">https://www.tftcentral.co.uk/articles/pointers_gamut.htm</a></p><p>颜色可以被分成亮度和色品。</p><p>亮度就是亮度。</p><p>色品就是构成光的不同波长的波的比例。</p><p>有两种定义色品的方式：</p><ol><li>the CIE 1931 xy chromaticity diagram。</li><li>the CIE 1976 u’v’ chromaticity diagram.</li></ol><h2 id="CIE-1931-xy-chromaticity-diagram"><a href="#CIE-1931-xy-chromaticity-diagram" class="headerlink" title="CIE 1931 xy chromaticity diagram"></a>CIE 1931 xy chromaticity diagram</h2><p>​完整来源和推导，暂时搁置。</p><p>简而言之，就是针对人眼的感受实验，CIE创造了两个标准：</p><ol><li>CIE 1931 XYZ </li><li>CIE 1931 RGB color spaces.</li></ol><p>从这两个颜色标准中，推导出了 CIE 1931 xyY 颜色空间。</p><p>xy就是色品分量，而Y就是亮度分量。</p><p>CIE1931色品图就是所有xyY色彩空间中不同人眼可见色品的可视化结果。它是一种手段来描述不同色域的颜色空间或显示的色度三原色。</p><p><img src="https://www.tftcentral.co.uk/images/pointers_gamut/large%20versions%20(wider%20than%20720px)/figure1_cie1931_small.jpg" alt="img"></p><h2 id="光谱轨迹"><a href="#光谱轨迹" class="headerlink" title="光谱轨迹"></a>光谱轨迹</h2><p>光谱轨迹是上图舌型去向。描述了所有的单色，波形范围在380和700nm之间。</p><h2 id="紫色线"><a href="#紫色线" class="headerlink" title="紫色线"></a>紫色线</h2><p>紫色线的颜色是波长380和700的混合，所有这些颜色都是完全饱和的</p><h2 id="普朗克黑体轨迹"><a href="#普朗克黑体轨迹" class="headerlink" title="普朗克黑体轨迹"></a>普朗克黑体轨迹</h2><p>舌形区域内的曲线称为普朗克轨迹。组成普朗克轨迹的点是由具有一定开尔文温度的黑体辐射体发出的光的色度坐标。横过普朗克轨迹的线就是等温线。</p><h2 id="CIE-1976-u’v’-chromaticity-diagram"><a href="#CIE-1976-u’v’-chromaticity-diagram" class="headerlink" title="CIE 1976 u’v’ chromaticity diagram"></a>CIE 1976 u’v’ chromaticity diagram</h2><p><img src="https://www.tftcentral.co.uk/images/pointers_gamut/large%20versions%20(wider%20than%20720px)/figure3_MacAdam%20ellipses%20CIE1931_small.jpg" alt="img"></p><p>变化成</p><p><img src="https://www.tftcentral.co.uk/images/pointers_gamut/large%20versions%20(wider%20than%20720px)/figure4_cie1976_small.jpg" alt="img"></p><h2 id="Pointer’s-gamut"><a href="#Pointer’s-gamut" class="headerlink" title="Pointer’s gamut"></a>Pointer’s gamut</h2><p>Michael R. Pointer (1980)的研究表示，所有可以被人眼看见的颜色，来自反射，反射是<strong>减法模型</strong>。</p><p>前面讨论的两个色度图是使用加性混色的一组颜色的可视化。</p><h3 id="Additive-color-mixing"><a href="#Additive-color-mixing" class="headerlink" title="Additive color mixing"></a>Additive color mixing</h3><p>通过添加颜色混合，您可以通过混合不同波长的光和改变亮度来创建一个新的颜色。</p><p>例如，如果你取一个波长为585 nm的光源(琥珀黄色)和另一个波长为485 nm的光源(明亮的天蓝色)，你可以在585 nm和485 nm之间复制任何颜色，通过改变两个光源的亮度。</p><p>这也意味着，如果一对色度单体之间的那条线与另一对色度单体之间的那条线相交，那么这两对色度单体就可以创造出一种对两对来说都是相同的颜色，但光谱分布不同。<strong>这种效应被称为异色现象，是彩色显示的基础:在不同的系统中使用不同的三原色来描述或再现被认为相同但光谱分布不同的颜色。</strong></p><h3 id="Subtractive-color-mixing"><a href="#Subtractive-color-mixing" class="headerlink" title="Subtractive color mixing"></a>Subtractive color mixing</h3><p>在减色法混色中，光不是由“光源”发出的，而是被反射回来的。我们所感知到的任何物体的颜色都是光源(通常是太阳，但也有人造光源)反射的物体的波长的组合。光源的所有其他波长都被物体吸收。</p><h2 id="Diffuse-reflection-vs-specular-reflection"><a href="#Diffuse-reflection-vs-specular-reflection" class="headerlink" title="Diffuse reflection vs. specular reflection"></a>Diffuse reflection vs. specular reflection</h2><p>不同的反射器，漫反射是反射颜色的，高光反射会反射光源颜色。减色法混色也对表面平滑度高度敏感。Pointer针对的是漫反射。高光反射会超过Pointer的颜色范围。</p><p><strong>金属工作流当中的PBR计算。</strong></p><h2 id="Pointer’s-gamut-in-CIE-1931-xy-chromaticity-diagram"><a href="#Pointer’s-gamut-in-CIE-1931-xy-chromaticity-diagram" class="headerlink" title="Pointer’s gamut in CIE 1931 xy chromaticity diagram"></a>Pointer’s gamut in CIE 1931 xy chromaticity diagram</h2><p><img src="https://www.tftcentral.co.uk/images/pointers_gamut/figure6_Pointer%20in%20CIE1931.jpg" alt="img"></p><h2 id="RGB-Color-spaces"><a href="#RGB-Color-spaces" class="headerlink" title="RGB Color spaces"></a>RGB Color spaces</h2><p>现在几乎所有的捕获或显示设备都使用RGB颜色模型来描述每个像素的颜色。</p><p><strong>每个通道8位颜色深度的像素，RGB值[255;0;0]显然是红色的。但是，如果没有指定的颜色空间，就无法知道红色的色度应该是多少。</strong>如果捕获设备的色域与显示设备的色域相同，并且两者是直接连接的，那么这就不是问题。不幸的是，事实并非如此。</p><h3 id="Rec-709-x2F-sRGB"><a href="#Rec-709-x2F-sRGB" class="headerlink" title="Rec. 709 &#x2F; sRGB"></a>Rec. 709 &#x2F; sRGB</h3><p>The ITU-R Recommendation BT. 709, or simply Rec. 709, 在1990年将高端显示器的格式标准化了。它指定了<strong>图像显示</strong>的许多方面，但我们感兴趣的是主色度。</p><table><thead><tr><th>Primary</th><th>CIE 1931 xy chromaticity diagram</th><th></th><th>CIE 1976 u’v’ chromaticity diagram</th><th></th></tr></thead><tbody><tr><td>x</td><td>y</td><td>u’</td><td>v’</td><td></td></tr><tr><td>Red</td><td>0.640</td><td>0.330</td><td>0.451</td><td>0.523</td></tr><tr><td>Green</td><td>0.300</td><td>0.600</td><td>0.125</td><td>0.563</td></tr><tr><td>Blue</td><td>0.150</td><td>0.060</td><td>0.175</td><td>0.158</td></tr></tbody></table><p>当在CIE 1931年的xy或CIE 1976年的u ‘ v色度图中绘制时，很明显，这是一个相当小的颜色空间。在CIE 1931年的xy色度图中，它只涵盖了33.5%的色度和69.4%的指针色域。在CIE 1976 u ‘ v中，这些值分别为33.2%和70.2%。</p><p><img src="https://www.tftcentral.co.uk/images/pointers_gamut/figure8_sRGB%20and%20pointer%20CIE1931.jpg" alt="img"></p><h3 id="BT-2020"><a href="#BT-2020" class="headerlink" title="BT .2020"></a>BT .2020</h3><p>Rec. 2020 defines a bit depth of either 10 bits per sample or 12 bits per sample.</p><h4 id="Resolution-edit-分辨率"><a href="#Resolution-edit-分辨率" class="headerlink" title="Resolution[edit] 分辨率"></a>Resolution[<a href="https://en.wikipedia.org/w/index.php?title=Rec._2020&action=edit&section=2">edit</a>] 分辨率</h4><p>Rec. 2020 defines two resolutions of <a href="https://en.wikipedia.org/wiki/4K_resolution#Ultra_HD">3840 × 2160</a> (“4K”) and <a href="https://en.wikipedia.org/wiki/8K_resolution#Resolutions">7680 × 4320</a> (“8K”).[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a> These resolutions have an <a href="https://en.wikipedia.org/wiki/Aspect_ratio_(image)">aspect ratio</a> of <a href="https://en.wikipedia.org/wiki/16:9">16:9</a> and use square <a href="https://en.wikipedia.org/wiki/Pixels">pixels</a>.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a></p><h4 id="Frame-rate-edit-帧率"><a href="#Frame-rate-edit-帧率" class="headerlink" title="Frame rate[edit] 帧率"></a>Frame rate[<a href="https://en.wikipedia.org/w/index.php?title=Rec._2020&action=edit&section=3">edit</a>] 帧率</h4><p>Rec. 2020 specifies the following frame rates: 120p, 119.88p, 100p, 60p, 59.94p, 50p, 30p, 29.97p, 25p, 24p, 23.976p.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a> Only <a href="https://en.wikipedia.org/wiki/Progressive_scan">progressive scan</a> frame rates are allowed.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a></p><h4 id="Digital-representation-数据表示"><a href="#Digital-representation-数据表示" class="headerlink" title="Digital representation 数据表示"></a>Digital representation 数据表示</h4><p>10-bits per sample Rec. 2020 uses video levels where the <a href="https://en.wikipedia.org/wiki/Black_level">black level</a> is defined as code 64 and the nominal peak is defined as code 940.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a> Codes 0–3 and 1,020–1,023 are used for the timing reference.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a> Codes 4 through 63 provide video data below the black level while codes 941 through 1,019 provide video data above the nominal peak.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a></p><p>12-bits per sample Rec. 2020 uses video levels where the black level is defined as code 256 and the nominal peak is defined as code 3760.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a> Codes 0–15 and 4,080–4,095 are used for the timing reference.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a> Codes 16 through 255 provide video data below the black level while codes 3,761 through 4,079 provide video data above the nominal peak.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-Recommendation2020-1">1]</a></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/300px-CIExy1931_Rec_2020.svg.png" alt="img"></p><table><thead><tr><th align="center"><a href="https://en.wikipedia.org/wiki/Color_space">Color space</a></th><th align="center"><a href="https://en.wikipedia.org/wiki/White_point">White point</a></th><th align="center"><a href="https://en.wikipedia.org/wiki/Primary_color">Primary colors</a></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th></th></tr></thead><tbody><tr><td align="center">xW</td><td align="center">yW</td><td align="center">xR</td><td align="center">yR</td><td align="center">xG</td><td align="center">yG</td><td align="center">xB</td><td align="center">yB</td><td></td></tr><tr><td align="center">ITU-R BT.2020</td><td align="center">0.3127</td><td align="center">0.3290</td><td align="center">0.708</td><td align="center">0.292</td><td align="center">0.17</td><td align="center">0.797</td><td align="center">0.131</td><td>0.046</td></tr></tbody></table><h3 id="sRGB"><a href="#sRGB" class="headerlink" title="sRGB"></a><strong>sRGB</strong></h3><p>sRGB是由惠普和微软在1996年创建的RGB彩色空间，用于显示器、打印机和互联网。sRGB颜色空间使用与Rec. 709相同的三原色和白点。这两者之间最大的区别是sRGB只是一个绝对的颜色空间，只指定基色和白点的色度和伽玛校正曲线。</p><h3 id="Adobe-Wide-Gamut-RGB（Wide-gamut-RGB-color-space）宽色域"><a href="#Adobe-Wide-Gamut-RGB（Wide-gamut-RGB-color-space）宽色域" class="headerlink" title="Adobe Wide Gamut RGB（Wide-gamut RGB color space）宽色域"></a>Adobe Wide Gamut RGB（Wide-gamut RGB color space）宽色域</h3><p>这就引出了下一个问题:这样大小的颜色空间需要高颜色深度来避免色调分离效果(颜色带)。</p><p><strong>大多数被指定为具有10位颜色深度的显示器实际上是常规的8位颜色深度面板，在显示电子设备中实现了frc模块。</strong></p><table><thead><tr><th align="center">Color</th><th align="center">CIE x</th><th align="center">CIE y</th><th align="center">Wavelength</th></tr></thead><tbody><tr><td align="center">Red</td><td align="center">0.7347</td><td align="center">0.2653</td><td align="center">700 nm</td></tr><tr><td align="center">Green</td><td align="center">0.1152</td><td align="center">0.8264</td><td align="center">525 nm</td></tr><tr><td align="center">Blue</td><td align="center">0.1566</td><td align="center">0.0177</td><td align="center">450 nm</td></tr><tr><td align="center">White point</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/325px-CIExy1931_AdobeWGRGB.png" alt="img"></p><h2 id="量子点显示器"><a href="#量子点显示器" class="headerlink" title="量子点显示器"></a>量子点显示器</h2><h2 id="接口规范"><a href="#接口规范" class="headerlink" title="接口规范"></a>接口规范</h2><p>接口规范：SMPTE 292M, SMPTE 372M, HDMI、没有说明EOTF、OETF和颜色的任何信息。</p><h2 id="TransferSystem"><a href="#TransferSystem" class="headerlink" title="TransferSystem"></a>TransferSystem</h2><p><a href="https://www.displaydaily.com/article/display-daily/hlg-vs-pq-systems-for-hdr-television">https://www.displaydaily.com/article/display-daily/hlg-vs-pq-systems-for-hdr-television</a></p><p><strong>One thing that must be understood is that both PQ and HLG are <em>Systems</em>, not simply transfer curves.</strong><br>Finally, there are three terms that must be used in trying to explain the difference between the PQ and HLG systems:</p><ul><li>OETF: Opto-Electronic Transfer Function. This is the <strong>non-linear relationship between</strong> the light falling on the camera sensor and the digital electronic signal generated by the camera.对于渲染来说没有这一部分。</li><li>EOTF: Electro-Optical Transfer Function. This is the non-linear relationship between the digital electronic signal received by the display and the light emitted by the display. </li><li>OOTF:  Optical-Optical Transfer Function. This is the overall relationship between the light falling on the image sensor and the light coming out of the display.</li></ul><p>The OOTF relationship is not normally linear in a camera-to-display signal chain and is often characterized by a Gamma value. One key to understanding the PQ vs HGL issue is the <strong>OOTF gamma value preferred by viewers and content creators varies with viewing conditions, which include both display brightness and the ambient surround light when the display is being viewed.</strong></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/BBC_Generic_End-to-end_resize.jpg" alt="BBC Generic End to end resize"></p><p> The goal of this accommodation is to preserve the artistic intent of the content creators even when the content is seen by <strong>the viewer under different conditions than used by the content creators.</strong></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/BBC_HLG_PQ_End-to-end_Labeled_2_resize.jpg" alt="BBC HLG PQ End to end Labeled 2 resize"></p><p>When a PQ signal is shown on a display where the display and display environment does not match the mastering display, the OOTF is adjusted using metadata from the mastering environment.</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/BBC_OOTF_PQ_resize.jpg" alt="BBC OOTF PQ resize"></p><h2 id="OETF"><a href="#OETF" class="headerlink" title="OETF"></a>OETF</h2><p>图像捕捉OETF标准：ITU-R Rec. BT.601, 709, 2020。</p><p>他只是一个相对设置。在拍摄过程中，相机曲线会根据个人喜好进行调整。</p><p>教科书中的Rec709函数几乎从未在实践中使用过。</p><h2 id="EOTF"><a href="#EOTF" class="headerlink" title="EOTF"></a>EOTF</h2><p><strong>但是图像的显示标准并不是图像捕捉标准的翻转（But image display ≠ inverse of image capture ）</strong> 因为：</p><ol><li>特殊渲染意图。</li><li>捕捉环境和渲染环境亮度不匹配。</li></ol><p>EOTF的意义：</p><ol><li>参考显示器上的图像才是真正定义信号的东西</li><li>描述了如何将数字代码转换成亮度信息。</li><li>在查看参考显示时，艺术家会对内容的外观做出创造性的决定.</li><li>所有的显示必须使用同一个标准。</li></ol><p>随着crt几乎绝迹，官方开始努力记录它们的响应曲线。</p><p>OETF函数(如Rec.709和类似的函数中所使用的)派生自display EOTF，而不是反过来：</p><ol><li>早起的EOTF是由于CRT物理硬件决定的。</li><li>OETF就是将EOTF反过来然后<strong>根据渲染环境进行调整。</strong></li></ol><p>目前的EOTF只针对了CRT显示器的亮度范围，但是目前我们有HDR所以需要更大的亮度和动态范围的EOTF曲线。</p><h3 id="构建EOTF曲线"><a href="#构建EOTF曲线" class="headerlink" title="构建EOTF曲线"></a>构建EOTF曲线</h3><ol><li>最大化利用数据。</li><li>符合人眼习惯。</li></ol><p>下面这张图是根据实际人眼感知的实验结论，他表示随着亮度变化。人眼对于亮度对比度的分辨能力，注意下图是指数坐标单位。</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584929902806.png" alt="1584929902806"></p><p>常见的曲线：</p><h4 id="OpenEXR"><a href="#OpenEXR" class="headerlink" title="OpenEXR"></a>OpenEXR</h4><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584930032370.png" alt="1584930032370"></p><h4 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h4><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1589776195725.png" alt="1589776195725"></p><h4 id="Gamma（Rec1886）"><a href="#Gamma（Rec1886）" class="headerlink" title="Gamma（Rec1886）"></a>Gamma（Rec1886）</h4><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584930055803.png" alt="1584930055803"></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584931609084.png" alt="1584931609084"></p><h4 id="PQ曲线"><a href="#PQ曲线" class="headerlink" title="PQ曲线"></a>PQ曲线</h4><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584931714881.png" alt="1584931714881"></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584931744448.png" alt="1584931744448"></p><h2 id="OOTF"><a href="#OOTF" class="headerlink" title="OOTF"></a>OOTF</h2><h2 id="CSF"><a href="#CSF" class="headerlink" title="CSF"></a>CSF</h2><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1589776858973.png" alt="1589776858973"></p><h1 id="色彩处理技术"><a href="#色彩处理技术" class="headerlink" title="色彩处理技术"></a>色彩处理技术</h1><h2 id="ToneMapping"><a href="#ToneMapping" class="headerlink" title="ToneMapping"></a>ToneMapping</h2><ol><li>Lut严重依赖于ToneMapping的效果。</li><li>原始的管线中，无法对高光部分进行精确ToneMapping。</li><li>这是一个固定的分布，不同的光照标准-&gt;不同的ToneMapping-&gt;不同的LUT</li><li>在luma&#x2F;chroma空间进行计算（hue preserving）：只在亮度空间附加shoulder，根据shoulder部位逐步降低饱和度。</li><li>tonemapping的hue preserving也会有问题 ：通过LUT模拟黑体颜色。</li></ol><p>For pixel values above the peak luminance of the display, a reference monitor should “clip” those values back to the maximum capabilities of the display. ，Tone mapping changes the luminance of the pixel to the maximum value of the display, but not the chromaticity of the pixel. Such a change just in luminance may change our perception of the pixel (a bright yellow pixel looks yellow but a dim yellow pixel looks brown). </p><p>Clipping can also mean adjusting the chromaticity of the pixel.  </p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1589968162850.png" alt="1589968162850"></p><h2 id="Gamut-mapping"><a href="#Gamut-mapping" class="headerlink" title="Gamut mapping"></a>Gamut mapping</h2><p>refers to the remapping of color values that exceed the capabilities of the display to the native gamut of the display.</p><p>​色彩学家讨论的问题之一是——在特定的电脑屏幕上可以显示的颜色范围是什么?或者在特定的打印机上可以复制到纸上的颜色范围是什么?这个范围称为显示或打印机的色域。他们问的另一个问题是——<strong>如果我想复制的颜色不在我的显示器或打印机的色域内，我应该如何修改它们，使它们可以显示，而不过度扭曲我的图像的整体设计</strong>。修改过程称为色域映射，在遗传算法中避免颜色失真的替代策略(有几种)</p><p><a href="https://graphics.stanford.edu/courses/cs178/applets/gamutmapping.html">https://graphics.stanford.edu/courses/cs178/applets/gamutmapping.html</a></p><h2 id="Reference-Monitors"><a href="#Reference-Monitors" class="headerlink" title="Reference Monitors"></a>Reference Monitors</h2><p>用于调节色彩数据的显示器。</p><p>显示器亮度范围达不到PQ，范围。These are supposed to be highly accurate monitors but they are not capable of displaying the full range of luminance in the PQ standard, nor the full range of colors in the BT.2020 color gamut. </p><p>显示器色彩范围达不到BT.2020 , Today, there are two practical reference monitors at 1000 and 4000 cd&#x2F;m² with each supporting the DCI-P3 color gamut, which is smaller than the BT.2020 color gamut. </p><p>对于HDR来说，BT.2020是必须的，但是不需要有2020的色彩基色，但是需要有2020的色度图. In the world of HDR for consumers, BT.2020 is mandatory. <strong>This does not mean that the display has to have 2020 primaries, but it should follow BT.2020 colorimetry.</strong></p><h3 id="System-colorimetry-edit"><a href="#System-colorimetry-edit" class="headerlink" title="System colorimetry[edit]"></a>System colorimetry[<a href="https://en.wikipedia.org/w/index.php?title=Rec._2020&action=edit&section=5">edit</a>]</h3><table><thead><tr><th align="center"><a href="https://en.wikipedia.org/wiki/Color_space">Color space</a></th><th align="center"><a href="https://en.wikipedia.org/wiki/White_point">White point</a></th><th align="center"><a href="https://en.wikipedia.org/wiki/Primary_color">Primary colors</a></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th></th></tr></thead><tbody><tr><td align="center">xW</td><td align="center">yW</td><td align="center">xR</td><td align="center">yR</td><td align="center">xG</td><td align="center">yG</td><td align="center">xB</td><td align="center">yB</td><td></td></tr><tr><td align="center">ITU-R BT.2020</td><td align="center">0.3127</td><td align="center">0.3290</td><td align="center">0.708</td><td align="center">0.292</td><td align="center">0.17</td><td align="center">0.797</td><td align="center">0.131</td><td>0.046</td></tr></tbody></table><p>The Rec. 2020 (UHDTV&#x2F;UHD-1&#x2F;UHD-2) color space can reproduce colors that cannot be shown with the <a href="https://en.wikipedia.org/wiki/Rec._709">Rec. 709</a> (HDTV) color space.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-TVTechnologyDecember2012SuperHiVision-6">6]</a>[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-NHKannualreport2010-7">7]</a> The RGB primaries used by Rec. 2020 are equivalent to monochromatic light sources on the <a href="https://en.wikipedia.org/wiki/CIE_1931_color_space#CIE_xy_chromaticity_diagram_and_the_CIE_xyY_color_space">CIE 1931 spectral locus</a>.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-NHKannualreport2010-7">7]</a>[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-NHKOpenHouse2013Exhibit20-8">8]</a></p><p>2020的物理亮度参数。The <a href="https://en.wikipedia.org/wiki/Wavelength">wavelength</a> of the Rec. 2020 <a href="https://en.wikipedia.org/wiki/Primary_color">primary colors</a> is 630 <a href="https://en.wikipedia.org/wiki/Nanometre">nm</a> for the red primary color, 532 nm for the green primary color, and 467 nm for the blue primary color.[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-NHKOpenHouse2013Exhibit20-8">8]</a>[<a href="https://en.wikipedia.org/wiki/Rec._2020#cite_note-DavidWoodDecidingTomorrowsTelevision-9">9]</a> </p><h2 id="Lut"><a href="#Lut" class="headerlink" title="Lut"></a>Lut</h2><h3 id="LUTspace"><a href="#LUTspace" class="headerlink" title="LUTspace"></a>LUTspace</h3><h2 id="在HDR显示器上还原"><a href="#在HDR显示器上还原" class="headerlink" title="在HDR显示器上还原"></a>在HDR显示器上还原</h2><p>Tonemapping  进行LUT还原Tonemap 变回hdr值。 因为Shoulder不是无限的，所以也有clip的值。</p><h2 id="卡通渲染的真实风格"><a href="#卡通渲染的真实风格" class="headerlink" title="卡通渲染的真实风格"></a>卡通渲染的真实风格</h2><p>饱和度和亮度的控制。</p><h2 id="Perceptual-Quantizer"><a href="#Perceptual-Quantizer" class="headerlink" title="Perceptual Quantizer"></a>Perceptual Quantizer</h2><p><strong>Perceptual Quantizer (PQ)</strong>, published by <a href="https://en.wikipedia.org/wiki/Society_of_Motion_Picture_and_Television_Engineers">SMPTE</a> as <strong>SMPTE ST 2084</strong>, is a transfer function that allows for the display of <a href="https://en.wikipedia.org/wiki/High_dynamic_range">high dynamic range</a> (HDR) video with a <a href="https://en.wikipedia.org/wiki/Luminance">luminance</a> level of up to 10,000 <a href="https://en.wikipedia.org/wiki/Cd/m2">cd&#x2F;m2</a> and can be used with the <a href="https://en.wikipedia.org/wiki/Rec._2020">Rec. 2020</a> color space.[<a href="https://en.wikipedia.org/wiki/High-dynamic-range_video#cite_note-HPATechFebruary2014-32">32]</a>[<a href="https://en.wikipedia.org/wiki/High-dynamic-range_video#cite_note-SMPTE2084HDR2014-33">33]</a>[<a href="https://en.wikipedia.org/wiki/High-dynamic-range_video#cite_note-HDRReportSMPTE2015MESA-34">34]</a>[<a href="https://en.wikipedia.org/wiki/High-dynamic-range_video#cite_note-GradingHDR2015studiodaily-35">35]</a> PQ is a non-linear <a href="https://en.wikipedia.org/wiki/Optical_transfer_function">electro-optical transfer function</a> (EOTF).</p><p><strong>L0表示的是压缩到0-1的亮度， 也就是1表示10000 nits 。所以要根据实际要显示的亮度，渲染我们的颜色亮度，所以还有隐含的一步就是从计算的颜色FP16 到L0，然后再从L0压缩到[0,1].</strong></p><p>对于Dolby Vsion来说，需要能够表达0-10000nis的亮度，目前的SDR显示器使用8bits表示0-100nits的数据，如果过使用相同的曲线，需要14bits，才能避免眼睛看到banding，但是这个时候亮度部分就浪费了，所以我们使用了12bits的 pq曲线。不给过大部分HDR方法，使用的是10bits。（10bit总是在可视曲线之上），但是噪声可以遮蔽掉banding效果。</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1590027884175.png" alt="1590027884175"></p><p>下面是PQ EOTF曲线（x的坐标时0-1024，深度是10 bit）：</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584935346381.png" alt="1584935346381"></p><p>一定要注意下面说的是<strong>PT Inverse EOTF！！！！</strong></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584499216410.png" alt="1584499216410"></p><p>Inverse EOTF曲线（OETF曲线）：</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1584935431610.png" alt="1584935431610"></p><h2 id="Hue-Preserving-and-Hue-shifts"><a href="#Hue-Preserving-and-Hue-shifts" class="headerlink" title="Hue Preserving and Hue shifts"></a>Hue Preserving and Hue shifts</h2><p>颜色从饱和色 转换到白色的时候（去饱和度），色相是否变化。</p><p>这一点也影响到ColorGrading的效果，所以ToneMapping 要放在最后。</p><h3 id="如何做到HuePreserving"><a href="#如何做到HuePreserving" class="headerlink" title="如何做到HuePreserving"></a>如何做到HuePreserving</h3><p> 分离亮度和饱和度，对亮度应用shoulder。对色度，应用降低饱和度（根据shoudler的位置，并且使用不同的速度）。</p><p>使用ICtcpya 空间</p><h2 id="tongMapping带来的改变"><a href="#tongMapping带来的改变" class="headerlink" title="tongMapping带来的改变"></a>tongMapping带来的改变</h2><p>Toe</p><p>Hue shits</p><p>对比度变化</p><h1 id="HDR-标准与文件格式"><a href="#HDR-标准与文件格式" class="headerlink" title="HDR 标准与文件格式"></a>HDR 标准与文件格式</h1><p>​      <strong>HDR技术通常使用不同的方法，来将数据转化成HDR显示器可以接受的格式。基本上是一个接近log函数的型号编码方式。然后对应的显示器将这些数据还原会标准信号。由于Log函数的原因，所以如果过直接在SDR显示器上观察（没有HDR显示器的还原功能）那么数据是低饱和度，很灰暗的。类似Log函数的编码标准有：</strong></p><ul><li><p>Dolby Vision</p></li><li><p>HDR10</p></li><li><p>HDR10 +</p></li><li><p>Hybird Log-Gamma(HLG)</p></li></ul><h3 id="HDR10"><a href="#HDR10" class="headerlink" title="HDR10"></a>HDR10</h3><p> wide-gamut <a href="https://en.wikipedia.org/wiki/Rec._2020">Rec. 2020</a> color space, </p><ul><li><p>EOTF: SMPTE ST 2084 (<a href="https://en.wikipedia.org/wiki/Perceptual_quantization">PQ</a>)</p></li><li><p><a href="https://en.wikipedia.org/wiki/Bit_depth_(computer_graphics)">Bit Depth</a>: 10-bit </p></li><li><p>static metadata</p></li></ul><h3 id="HDR10-1"><a href="#HDR10-1" class="headerlink" title="HDR10+"></a>HDR10+</h3><ul><li>EOTF: SMPTE ST 2084 (<a href="https://en.wikipedia.org/wiki/Perceptual_quantization">PQ</a>)</li><li>Resolution: Agnostic (2K&#x2F;4K&#x2F;8K[<a href="https://en.wikipedia.org/wiki/HDR10%2B#cite_note-10">10]</a>, etc.)</li><li><a href="https://en.wikipedia.org/wiki/Bit_depth_(computer_graphics)">Bit Depth</a>: 10-bit or more (up to 16-bit)</li><li>Color Primaries: <a href="https://en.wikipedia.org/wiki/Rec._2020">ITU-R BT.2020</a></li><li>Maximum linearized pixel value: 10,000 <a href="https://en.wikipedia.org/wiki/Candela_per_square_metre">cd&#x2F;m2</a> for each color R&#x2F;G&#x2F;B (content)</li><li>Metadata (Required): Mastering Display Color Volume Metadata[<a href="https://en.wikipedia.org/wiki/HDR10%2B#cite_note-11">11]</a></li><li>Metadata (Optional): MaxCLL, MaxFALL[<a href="https://en.wikipedia.org/wiki/HDR10%2B#cite_note-12">12]</a></li><li>dynamic metadata</li></ul><p>HDR10+ technology can support the full range of HDR standards to 10,000 cd&#x2F;m2, 8K and BT.2020 color gamut. Being resolution agnostic, metadata needs to be created only once and can be applied to any target resolution.</p><p>HDR10+ is applicable for HEVC and <a href="https://en.wikipedia.org/wiki/VP9">VP9</a> compatibility via WebM[<a href="https://en.wikipedia.org/wiki/HDR10%2B#cite_note-13">13]</a> as well as any codec that supports ITU-T T.35 metadata.</p><h3 id="Dolby-Vision"><a href="#Dolby-Vision" class="headerlink" title="Dolby Vision"></a>Dolby Vision</h3><h3 id="HLG"><a href="#HLG" class="headerlink" title="HLG"></a>HLG</h3><p>HDR编码标准允许更高的最大亮度，并使用至少10位动态范围。</p><p>虽然技术上“HDR”严格指的是最大和最小亮度之间的比例，但术语“HDR视频”通常被理解为也意味着广泛的色域</p><p>HDR video当中记录了一个亮度的等级，不同的HDR技术会把文件数据当中的亮度等级映射到“一种长得像指数的空间”，显示器会用对应的EOTF将这个数据正确的显示。</p><p>在DaVinCi当中颜色通常是10bit的数据。当使用HDR模式的时候，他就变成了绝对亮度。</p><p>亮度对应为：</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/2020320-160254.jpg" alt="2020320-160254"></p><p>同样也可以，开启“Enable HDR Scopes for ST.2084”选项来查看实际的nit亮度。</p><h2 id="HDR的文件格式"><a href="#HDR的文件格式" class="headerlink" title="HDR的文件格式"></a>HDR的文件格式</h2><h3 id="Raw"><a href="#Raw" class="headerlink" title="Raw"></a>Raw</h3><p>原始文件之所以这样命名，是因为它们还没有被处理，因此还不能使用位图图形编辑器打印或编辑。</p><p>传统CCD每个像素只能感光一种颜色，根据感光的强度不同转换成不同的数字，不同的CCD这一数字范围是不同的，早期的8bit，到10bit、12bit。8bit就是一个点感光从最暗到最亮分为256个层次，10bit就是1024个层次，以此类推。</p><p>RAW文件几乎是未经过处理而直接从CCD或CMOS上得到的信息,·也许RAW最大的优点就是可以将其转化为16位的图像。也就是有65536个层次可以被调整.</p><p><strong>·成像芯片是线性装置。这意味着当一个像素点的采光量是另一个的两倍时，也将会产生2倍的电压。</strong>曝光中止时，亮度值是以其对数来呈现的，这就是说一个未修正的照片会看起来比较暗，因此需要通过色调曲线来调整正确。</p><table><thead><tr><th>富士</th><th>*.raf</th></tr></thead><tbody><tr><td>佳能</td><td><em>.crw，</em>.cr2,*.cr3</td></tr><tr><td>柯达</td><td>*.kdc</td></tr><tr><td>美能达</td><td>*.mrw</td></tr><tr><td>尼康</td><td><em>.nef,</em>.cr2</td></tr><tr><td>奥林巴斯</td><td>*.orf</td></tr><tr><td>adobe</td><td>*.dng</td></tr><tr><td>宾得</td><td><em>.ptx，</em>.pef</td></tr><tr><td>索尼</td><td>*.arw</td></tr><tr><td>适马</td><td>*.x3f</td></tr><tr><td>松下</td><td>*.rw2</td></tr></tbody></table><p><a href="https://www.aftershotpro.com/en/pages/raw-file/">https://www.aftershotpro.com/en/pages/raw-file/</a></p><h3 id="Camera’s-CCD"><a href="#Camera’s-CCD" class="headerlink" title="Camera’s CCD"></a>Camera’s CCD</h3><p>参考资料：</p><p><a href="https://electronics.howstuffworks.com/cameras-photography/digital/digital-camera2.htm">https://electronics.howstuffworks.com/cameras-photography/digital/digital-camera2.htm</a></p><p>​<strong>数码相机的传感器可以将光线转换成电荷</strong>，而不是胶片。大多数数码相机采用的图像传感器是电荷耦合器件(CCD)。一些相机使用互补的金属氧化物半导体(CMOS)技术代替。CCD和CMOS图像传感器都能将光转换成电子。</p><p>接受光信号，（相机会重置CCD，将其暴露在光线下，产生电荷，直到快门关闭。）然后编码成二进制文件。（ADC测量电荷并创建数字信号，表示每个像素的电荷值。）</p><p>文件类型：No matter what type of storage they use, all digital cameras need lots of room for pictures. They usually store images in one of two formats – TIFF, which is uncompressed, and JPEG, which is compressed, but some use RAW format. </p><h3 id="Camera’s-ACD"><a href="#Camera’s-ACD" class="headerlink" title="Camera’s ACD"></a>Camera’s ACD</h3><p>参考资料：</p><p><a href="https://www.lifewire.com/the-adc-of-a-digital-camera-493714">https://www.lifewire.com/the-adc-of-a-digital-camera-493714</a></p><p>ADC是数码相机内部的一个芯片，模拟型号和电信号转换芯片（Analog to Digital Converter (variously called the <em>ADC</em>, <em>AD Converter</em>, and the <em>A&#x2F;D Converter</em>).）<strong>，它的工作是将像素的电压划分为亮度级别</strong>，并将每个级别指定为由0和1组成的二进制数。大多数消费级数码相机至少使用8位ADC，单个像素的亮度最多可达256个值。</p><p>ADC的最小比特率由**传感器的动态范围(精度)**决定（对电压的感受精度）。一个大的动态范围至少需要一个10位ADC来产生大量的tone并避免任何信息丢失。然而，相机制造商通常会过度指定ADC(比如12位而不是10位)，以避免任何错误。</p><p>多出来的数据防止<strong>色调映射（ tonal curves）</strong>时产生banding效果。</p><p>一个12位和14位的图像之间的差异将是非常轻微的，甚至可能在大多数照片是不明显的。同时，这一切都取决于传感器的动态范围。如果动态范围没有随着ADC的增大而增大，那么它就不能有效地改善图像质量。</p><h3 id="ACD-tonal-curve"><a href="#ACD-tonal-curve" class="headerlink" title="ACD tonal curve"></a>ACD tonal curve</h3><p>参考资料：</p><p><a href="https://www.dpreview.com/articles/5426898916/ins-and-outs-of-iso-where-iso-gets-complex">https://www.dpreview.com/articles/5426898916/ins-and-outs-of-iso-where-iso-gets-complex</a></p><p>过去针对不同的ISO，图片的亮度会变的不一样。这就是在调节模拟信号。他们使用的是同一个Tone Curve。</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/ISO_pre_2006_green-1590543885563.png" alt="img"></p><p>上图注意，模拟信号放大一倍，曝光级别降低一个曝光级别。所有图像都是用相同的ToneMapping，也就是中灰度亮度是固定的。数据分布也是一致的。</p><p>随后不同的ISO等级（模拟信号放大）使用的不同tone curve和模拟信号放大：</p><p>​<strong>模拟信号放大会减少噪声，但是会减少动态范围（亮度范围），使用较低的放大可以得到更大的亮度范围。</strong></p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/ISO_post_2006_green.png" alt="img"></p><h3 id="ISO"><a href="#ISO" class="headerlink" title="ISO"></a>ISO</h3><p>摄影中的流程，ISO是在特定的光照环境增强敏感度，以达到想要的亮度，但是ISO只是单纯的增加曝光么：</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/ISO_Flow_Chart.png" alt="img"></p><p>实际上ISO的处理包括了很多阶段：</p><ul><li><strong>Exposure</strong>：通过照明亮度、快门速度和光圈大小控制的曝光亮度。</li><li>CCD：传感器对光的响应，无法修改。光学元件决定的。</li><li><strong>Lightening</strong>：A&#x2F;D，从曝光当中获得期望的亮度，模拟型号放大和ToneCurve。</li></ul><p>很多摄像机有动态范围模式：佳能的高光调优先级和理光的高光校正DR模式都做到了这一点：</p><p>使用一个比标准模式小的停止放大来保存高光数据，否则会放大到剪切。</p><p><img src="/../../images/%E8%89%B2%E5%BD%A9%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/Fujfilm_DR_alt_green_rough.png" alt="img"></p><h3 id="EV"><a href="#EV" class="headerlink" title="EV"></a>EV</h3><p>EV值：</p><p>它的目的是通过将快门速度和f-数字(例如f&#x2F;16的1&#x2F;125 s)的组合替换为一个数字来简化相机曝光设置的选择</p><p>$$ &#x3D;log _{2}{\frac{N^{2}}{t}}$$</p><ul><li><em>N</em> is the <a href="https://en.wikipedia.org/wiki/F-number">f-number</a></li><li><em>t</em> is the exposure time (“<a href="https://en.wikipedia.org/wiki/Shutter_speed">shutter speed</a>“) in seconds[<a href="https://en.wikipedia.org/wiki/Exposure_value#cite_note-no_units-2">2]</a></li></ul><p>曝光值每增加1就相当于曝光值的一个“台阶”(或者更常见的是一个“停止”)的变化（也就是一个bit），即通过将曝光时间减半或将光圈面积减半，或将上述变化结合起来，可以减少一半的曝光量。更大的曝光值适用于在更明亮的情况下拍摄，或更高的ISO速度。</p><p>拍摄不同的环境通常需要参考的曝光.</p><p><strong>根据固定的曝光（EV）决定，光圈、快门、感光度。</strong></p><p><a href="https://en.wikipedia.org/wiki/Exposure_value">https://en.wikipedia.org/wiki/Exposure_value</a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="热度图的作用"><a href="#热度图的作用" class="headerlink" title="热度图的作用"></a>热度图的作用</h2>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>后处理ColorGrading</title>
      <link href="/2022/07/09/Art/%E5%90%8E%E5%A4%84%E7%90%86ColorGrading/"/>
      <url>/2022/07/09/Art/%E5%90%8E%E5%A4%84%E7%90%86ColorGrading/</url>
      
        <content type="html"><![CDATA[<h1 id="Why-Color-Grading"><a href="#Why-Color-Grading" class="headerlink" title="Why Color Grading"></a>Why Color Grading</h1><p>Color Grading（或者Color Correction）几乎是每一个游戏、视频必定会涉及的话题。但是我们的工作重点总是<strong>如何迁移一个算法</strong>，图程和TA的工作停留在算法层面就无法理解他在美术、设计中真正起到的作用。</p><p>这篇笔记主要来自于DaVinci的用户文档，解释了我们为什么需要这样的技术、不同的工具解决的问题是什么。</p><h2 id="Color-Correction的作用"><a href="#Color-Correction的作用" class="headerlink" title="Color Correction的作用"></a>Color Correction的作用</h2><p>Color Correction的作用是要保证每一个视频看起来是最佳的状态。</p><p>视频编辑人员的目的是通过艺术的风格呈现图像，以实现艺术化的效果，手段就是需要调整图片的色彩和对比度，最终的结果是尽可能接近导演和摄影师的想法。</p><ol><li>在处理的过程当中需要<strong>解决曝光异常、白平衡等问题</strong>，这些是在视频拍摄过程中不可避免的问题。此外，你可以做一些<strong>细微的调整来增加温暖感或对比度</strong>，这在拍摄过程中是没有的，但摄影师会喜欢的效果。</li><li>新一代的数字电影摄像机能够拍摄原始的色彩空间图像数据，或带有L指数曝光的RGB图像数据，以便在色彩校正过程中保留最大数量的图像数据以供操作。然而，当你以这种方式获取图像数据时，<strong>它必须通过颜色校正转换成可视图像</strong>，就像底片必须先冲洗并打印成正片一样。</li><li>色彩校正过程中另一个重要的方面是<strong>对视频内的特定元素进行强调或弱化的能力</strong>。它在概念上类似于音频混合中的均衡，因为您可以使用多种技术来选择要增强或抑制哪些颜色值。例如用一个Power窗口包围图像的特定部分，这可以引导观看者的视线。<span id="more"></span></li></ol><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>Color Corection的目的主要是调节色相、饱和度和对比度。我们有很多方式。</p><p>Color balance wheels能够通过调节三个颜色通道，在特定范围内改变场景的色温： lift, gamma, 和 gain。</p><p>这里简单的介绍一下Color Grading的使用方式。</p><p>在Nuke、DaVinCi之类的软件中经常会用到这些操作。</p><h2 id="色彩区域与操作"><a href="#色彩区域与操作" class="headerlink" title="色彩区域与操作"></a>色彩区域与操作</h2><p>high light：高亮度区域</p><p>mid tone: 中等亮度区域</p><p>shadow：暗部</p><p>DaVinCi软件的解释：</p><p><img src="/../../images/%E5%90%8E%E5%A4%84%E7%90%86ColorGrading/1584523933324.png" alt="1584523933324"></p><p>操作影响的强度曲线：</p><p><img src="/../../images/%E5%90%8E%E5%A4%84%E7%90%86ColorGrading/1584524629621.png" alt="1584524629621"></p><p>Lift操作主要用来定位图像的阴影区域。</p><p>Gamma操作主要用来定位图像的中灰度区域。</p><p>Gain操作主要用来定位图像的高亮区域。</p><p>下面操作的强度曲线：</p><p><img src="/../../images/%E5%90%8E%E5%A4%84%E7%90%86ColorGrading/1584524661341.png" alt="1584524661341"></p><p>Shadows 调节暗部的亮度分布。</p><p>Midtone 调节中灰度的亮度分布。</p><p>Highlights  调节高亮部分的亮度分布。</p><h2 id="操作的数学解释"><a href="#操作的数学解释" class="headerlink" title="操作的数学解释"></a>操作的数学解释</h2><p>下图是图示说明：</p><p><img src="/../../images/%E5%90%8E%E5%A4%84%E7%90%86ColorGrading/nuke_lift_gamma_gain.jpg" alt="img"></p><p>在软件当中的控制方式：</p><p><img src="/../../images/%E5%90%8E%E5%A4%84%E7%90%86ColorGrading/davinci_color_wheel.jpg" alt="img"></p><p>Gain:这个操作影响白点，而保持黑点不变。</p><p>$$ Output &#x3D; input * gain $$</p><p>Lift: 这个操作影响黑点，而保持白点不变。</p><p>$$ Output &#x3D; ( input * ( 1 – lift ) ) + lift $$</p><p>不同的处理实际上就是对颜色整体亮度或者单个通道进行数学操作。</p><p>Offset: 亮度整体偏移：</p><p>$$ Output &#x3D; input + offset  $$</p><p>Lift and Gain together：</p><p>$$ Output &#x3D; ( input * ( gain – lift ) ) + lift $$</p><p>Gamma：</p><p>$$ Output &#x3D; input^{(1&#x2F;gamma)} $$ </p><p>Contrast：</p><p>$$ Output &#x3D; – ( input * (1 + contrast ) ) – (contrast &#x2F; 2 ) $$</p><p>Greyscale :</p><p>$$ (R<em>0.299 + G</em>0.587 + B*0.114). $$</p><p>饱和度调整：</p><p>$$ Output &#x3D; Saturation * input + (1 – Saturation ) * Greyscale $$</p>]]></content>
      
      
      <categories>
          
          <category> Art </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vulkan Shader编译与加载过程</title>
      <link href="/2022/07/09/Vulkan_Shader/"/>
      <url>/2022/07/09/Vulkan_Shader/</url>
      
        <content type="html"><![CDATA[<h1 id="Vulkan-Shader编译与加载过程"><a href="#Vulkan-Shader编译与加载过程" class="headerlink" title="Vulkan Shader编译与加载过程"></a>Vulkan Shader编译与加载过程</h1><h2 id="间接"><a href="#间接" class="headerlink" title="间接"></a>间接</h2><p>参考了<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules">Vulkan教程</a></p><p>​和一般的图形API不同（GL\DX），Vulkan 的shader代码是通过字节码的格式保存的，而非具备可读性的HLSL和GLSL。字节码的格式交过SPIR-V，它设计出来和Vulkan和OpenCL一同使用。可以用来编写图形Shader和计算Shader，这部分专注于图形Shader。</p><p>使用字节码的优点是由GPU供应商提供的把Shader代码转换成本地代码的编译器能复杂度更低。</p><p>过去使用可读代码的风险，编译器实现灵活，尝试特性实现不同：The past has shown that with human-readable syntax like GLSL, some GPU vendors were rather flexible with their interpretation of the standard. If you happen to write non-trivial shaders with a GPU from one of these vendors, then you’d risk other vendor’s drivers rejecting your code due to syntax errors, or worse, your shader running differently because of compiler bugs. With a straightforward bytecode format like SPIR-V that will hopefully be avoided.</p><p>我们不需要手写字节码，而是需要用与供应商独立的编译器把GLSL转化成SPIR-V.编译器用来验证Shader代码是完全标准的，并且声称SPIR-V代码集成在程序中。编译器提供了library用来集成在程序中，也可以用现有编译好的程序工具。</p><p>我们可以直接使用编译器glslangValidator.exe，不过这里使用glslc工具，因为这个工具提供了includes功能，并且它的参数和gcc和Clang很相似。这些已经集成在了VulkanSDK当中。</p><p>后面先展示GLSL代码，然后转换成SPIR-V，并在运行时加载。</p><p>GLSL语法：<a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/">语法简介</a></p><span id="more"></span><h2 id="Shader基本使用"><a href="#Shader基本使用" class="headerlink" title="Shader基本使用"></a>Shader基本使用</h2><h3 id="编写GLSL代码"><a href="#编写GLSL代码" class="headerlink" title="编写GLSL代码"></a>编写GLSL代码</h3><p>首先先编写GLSL代码文件shader.vert：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#version 450</span><br><span class="hljs-meta">#extension GL_ARB_separate_shader_objects : enable</span><br><br>layout(location = <span class="hljs-number">0</span>) out vec3 fragColor;<br><br>vec2 positions[<span class="hljs-number">3</span>] = vec2[](<br>    vec2(<span class="hljs-number">0.0</span>, <span class="hljs-number">-0.5</span>),<br>    vec2(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>),<br>    vec2(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0.5</span>)<br>);<br><br>vec3 colors[<span class="hljs-number">3</span>] = vec3[](<br>    vec3(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>),<br>    vec3(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>),<br>    vec3(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>)<br>);<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    gl_Position = vec4(positions[gl_VertexIndex], <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fragColor = colors[gl_VertexIndex];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译成字节码"><a href="#编译成字节码" class="headerlink" title="编译成字节码"></a>编译成字节码</h3><p>代码写完后使用编译器的工具编译成字节码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">C:/VulkanSDK/x.x.x.x/Bin32/glslc.exe shader.vert -o vert.spv<br></code></pre></td></tr></table></figure><p>之后我们就得到了字节码文件vert.spv。</p><h3 id="程序运行时加载字节码文件"><a href="#程序运行时加载字节码文件" class="headerlink" title="程序运行时加载字节码文件"></a>程序运行时加载字节码文件</h3><p>需要用于渲染是加载字节码文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title function_">readFile</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; filename)</span> &#123;<br>    <span class="hljs-built_in">std</span>::ifstream <span class="hljs-title function_">file</span><span class="hljs-params">(filename, <span class="hljs-built_in">std</span>::ios::ate | <span class="hljs-built_in">std</span>::ios::binary)</span>;<br><br>    <span class="hljs-keyword">if</span> (!file.is_open()) &#123;<br>        throw <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">&quot;failed to open file!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-type">size_t</span> fileSize = (<span class="hljs-type">size_t</span>) file.tellg();<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title function_">buffer</span><span class="hljs-params">(fileSize)</span>;<br>    file.seekg(<span class="hljs-number">0</span>);<br>file.read(buffer.data(), fileSize);<br>    file.close();<br><br><span class="hljs-keyword">return</span> buffer;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="根据字节码数据穿件Shader-Modules"><a href="#根据字节码数据穿件Shader-Modules" class="headerlink" title="根据字节码数据穿件Shader Modules"></a>根据字节码数据穿件Shader Modules</h3><p>这部分内容就进入了图形API的部分。根据ShaderModule就可以吧这个Shader代码设置成渲染状态的一部分。</p><h2 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h2><p>SPIR-V是二进制的中间吗，优点是不需要考虑供应商特性。缺点是需要考虑如何将shader语言编译成SPIR-V.</p><p>最好的方案是：<a href="https://github.com/KhronosGroup/glslang">Khronos’ glslang library</a> 和 <a href="https://github.com/google/shaderc">Google’s shaderc</a>.</p><p>都是开源的Shader编译库。</p><p>使用GLSL到SPIR-V的优点是不需要在程序中发布Shader代码</p><h3 id="一种GLSL不同的版本"><a href="#一种GLSL不同的版本" class="headerlink" title="一种GLSL不同的版本"></a>一种GLSL不同的版本</h3><p>GLSL有很多不同的版本：</p><ul><li>Modern mobile (GLES3+)</li><li>Legacy mobile (GLES2)</li><li>Modern desktop (GL3+)</li><li>Legacy desktop (GL2)</li><li>Vulkan GLSL</li></ul><p>Vulkan当中有很多和其他变体不兼容的地方</p><ul><li>Descriptor sets, no such concept in OpenGL</li><li>Push constants, no such concept in OpenGL, but very similar to “uniform vec4 UsuallyRegisterMappedUniform;”</li><li>Subpass input attachments, maps well to <a href="https://community.arm.com/graphics/b/blog/posts/pixel-local-storage-on-arm-mali-gpus">Pixel Local Storage on ARM Mali GPUs</a></li><li>gl_InstanceIndex vs gl_InstanceID. Same, but Vulkan GLSL’s version InstanceIndex (finally!) adds base instance offset for you</li></ul><h2 id="变体策略"><a href="#变体策略" class="headerlink" title="变体策略"></a>变体策略</h2><p>等待补充</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LuaJIT的变量实现</title>
      <link href="/2022/07/09/luajit-value/"/>
      <url>/2022/07/09/luajit-value/</url>
      
        <content type="html"><![CDATA[<p>Lua是动态类型的编程语言，变量的值可以是数值、字符串、table等所有支持的数据类型。在Lua虚拟机中每个变量都是用一个TValue结构体表示。LuaJIT出于效率的考虑重新组织了TValue结构体。</p><h1 id="lua-5-1中的TValue结构"><a href="#lua-5-1中的TValue结构" class="headerlink" title="lua-5.1中的TValue结构"></a>lua-5.1中的TValue结构</h1><p>lua-5.1中TValue的结构定义在lobject.h中，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">typedef union &#123;<br>  GCObject *gc;<br>  void *p;<br>  lua_Number n;<br>  int b;<br>&#125; Value;<br><br>#define TValuefields Value value;<br>int tt;<br><br>typedef struct lua_TValue &#123;<br>  TValuefields;<br>&#125; TValue;<br></code></pre></td></tr></table></figure><p>TValue结构体包含了两个部分，int类型的成员tt表示类型，Value成员是一个union结构，依据类型，有不同的含义。</p><ul><li>当类型位nil时，nil本身不再需要其他标识，Value成员没有意义</li><li>当类型为boolean时，成员b为0或1表示false或true</li><li>当类型为number时，成员n表示，为double类型</li><li>当类型为lightuserdata时，成员p，表示指针</li><li>当类型为function&#x2F;string&#x2F;userdata&#x2F;table&#x2F;thread等需要GC管理的类型时，成员gc表示相应GC对象的指针。<br>这样一个变量只要对应一个TValue结构便可以表示Lua支持的所有类型。</li></ul><span id="more"></span><p>lua中所有的数值都是用double类型的浮点数来表示，需要占用64位的空间。再加上额外的int类型成员tt来表示类型，一个TValue结构至少需要64+32&#x3D;96位的空间，如果按照8字节对其的话就需要占用128位的空间。而LuaJIT中通过Nan-boxing技术，重组了TValue，只需要占用64位的空间。</p><p>Nan-boxing<br>ieee754是使用最广泛的浮点数编码格式，它将浮点数编码成三个部分，符号、指数和尾数。如下所示</p><p><img src="/../images/2022-07-09-17-19-13.png"></p><p>双精度类型即double类型，最高位为符号位，后面的11位表示指数，最低52位为尾数。三个组合表示浮点数的值。</p><p>浮点数有些特殊的值，其中之一就是NaN(Not a Number)。有些浮点数运算如0&#x2F;0得到的结果就是NaN。IEEE 754标准中，如果指数部分全为1，且尾数部分不全为0时，表示值为 NaN。double类型的浮点数尾数部分有52位，NaN只要求这52位不全为0即可，只要其中一个是1剩余的51位就可以编码表示其他的含义。</p><p>实际使用的浮点数运算单元也只会产生一种NaN表示，即0xfff8_0000_0000_0000，只用了最高的13位，剩余的的51位便可以表示Lua中其他的字符串、table等。</p><h1 id="内存地址的处理"><a href="#内存地址的处理" class="headerlink" title="内存地址的处理"></a>内存地址的处理</h1><p>TValue结构中有些成员是指针，64位系统中，指针的长度为64位，那么如何在剩下的51位中表示指针类型呢？为此LuaJIT对不同类型有两种处理方式。</p><h2 id="1-用47位地址表示指针"><a href="#1-用47位地址表示指针" class="headerlink" title="1. 用47位地址表示指针"></a>1. 用47位地址表示指针</h2><p>对于64位系统，理论上每个进程都有64位的线性地址空间，共有16,777,216TB。然而可预见的将来，操作系统和应用并不需要这么多的内存，支持如此大的地址会增加地址转换的复杂性和成本， 因此现在的实现并不允许使用全部的地址空间。</p><p>以率先实现64位架构的AMD为例，在进行内存地址转换时，只会使用地址的低48位，并且要求从第48到63的这16位需要与第47位相同。即地址必须在0到00007FFF’FFFFFFFF 和 FFFF8000’00000000 到 FFFFFFFF’FFFFFFFF这两个范围内，共有256TB的虚拟地址空间。</p><p>操作系统本身也会对内存使用进行限制，以Linux为例，将高128TB的空间划归内核使用，这样用户态进程只能低128TB的地址，如下图所示。地址的高17位皆为0，因此使用47位即可表示所有能够使用的地址。</p><p><img src="/../images/2022-07-09-17-22-39.png"></p><h2 id="2-只使用最低的2G的地址空间"><a href="#2-只使用最低的2G的地址空间" class="headerlink" title="2. 只使用最低的2G的地址空间"></a>2. 只使用最低的2G的地址空间</h2><p>以Linux为例，LuaJIT默认通过mmap系统调用来分配内存，对于x86_64平台的64位程序，mmap有一个MAP_32BIT标记选项，表示只分配虚拟地址空间的低2GB的空间，这样分配的内存地址，高33位皆为0, 相应的指针只需要32位的空间即可。</p><h2 id="3-LuaJIT的处理与GC64模式"><a href="#3-LuaJIT的处理与GC64模式" class="headerlink" title="3. LuaJIT的处理与GC64模式"></a>3. LuaJIT的处理与GC64模式</h2><p>对于lightuserdata类型的值，LuaJIT用47位表示，对于GC类型的对象，都是通过mmap加MAP_32BIT标记分配的，用32位表示，这限制了LuaJIT只能使用不超过2GB的内存。为了摆脱这个限制，LuaJIT增加了GC64模式，开启后，所有的指针类型，包括lightuserdata都使用47位指针来表示。</p><p>LuaJIT的TValue结构<br>默认模式下TValue布局<br>LuaJIT中的TValue布局如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C">**<br>** Format <span class="hljs-keyword">for</span> <span class="hljs-number">32</span> bit GC <span class="hljs-title function_">references</span> <span class="hljs-params">(!LJ_GC64)</span>:<br>**<br>** Internal tags overlap the MSW of a number <span class="hljs-title function_">object</span> <span class="hljs-params">(must be a <span class="hljs-type">double</span>)</span>.<br>** Interpreted as a <span class="hljs-type">double</span> these are special NaNs. The FPU only generates<br>** one type of <span class="hljs-title function_">NaN</span> <span class="hljs-params">(<span class="hljs-number">0xfff8</span>_0000_0000_0000)</span>. So MSWs &gt; 0xfff80000 are available<br>** <span class="hljs-keyword">for</span> use as internal tags. Small negative numbers are used to shorten the<br>** encoding of type <span class="hljs-title function_">comparisons</span> <span class="hljs-params">(reg/mem against sign-ext. <span class="hljs-number">8</span> bit immediate)</span>.<br>**<br>**                  ---MSW---.---LSW---<br>** primitive types |  itype  |         |<br>** lightuserdata   |  itype  |  <span class="hljs-type">void</span> * |  <span class="hljs-params">(<span class="hljs-number">32</span> bit platforms)</span><br>** lightuserdata   |ffff|    <span class="hljs-type">void</span> *    |  <span class="hljs-params">(<span class="hljs-number">64</span> bit platforms, <span class="hljs-number">47</span> bit pointers)</span><br>** GC objects      |  itype  |  GCRef  |<br>** <span class="hljs-title function_">int</span> <span class="hljs-params">(LJ_DUALNUM)</span>|  itype  |   <span class="hljs-type">int</span>   |<br>** number           -------<span class="hljs-type">double</span>------<br></code></pre></td></tr></table></figure><p>可以通过下面的步骤判断值的类型</p><p>如果最高的16位（即48到63位）不全为1，表示这是一个double类型的浮点数，<br>最高的16位全为1，如果第47位为0时表示一个lightuserdata类型，<br>其余情况下，高32位表示类型，低32位表示实际值。</p><h1 id="GC64模式下TValue布局"><a href="#GC64模式下TValue布局" class="headerlink" title="GC64模式下TValue布局"></a>GC64模式下TValue布局</h1><p>GC64模式开启后如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">**<br>** The upper <span class="hljs-number">13</span> bits must be <span class="hljs-number">1</span> (<span class="hljs-number">0xfff8</span>...) <span class="hljs-keyword">for</span> a special NaN. The next<br>** <span class="hljs-number">4</span> bits hold the internal tag. The lowest <span class="hljs-number">47</span> bits either hold a pointer,<br>** a zero-extended <span class="hljs-number">32</span> bit integer or all bits <span class="hljs-built_in">set</span> to <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> primitive types.<br>**<br>**                     ------MSW------.------LSW------<br>** primitive types    |<span class="hljs-number">1.</span><span class="hljs-number">.1</span>|itype|<span class="hljs-number">1.</span>................<span class="hljs-number">.1</span>|<br>** GC objects/lightud |<span class="hljs-number">1.</span><span class="hljs-number">.1</span>|itype|-------GCRef--------|<br>** <span class="hljs-type">int</span> (LJ_DUALNUM)   |<span class="hljs-number">1.</span><span class="hljs-number">.1</span>|itype|<span class="hljs-number">0.</span><span class="hljs-number">.0</span>|-----<span class="hljs-type">int</span>-------|<br>** number              ------------<span class="hljs-type">double</span>-------------<br></code></pre></td></tr></table></figure><p>这里比较特殊的是最高的13位全位1表double类型，itype表示类型，占4位，指针占用47位，总共仍是64位。</p><p>TValue结构<br>LuaJIT的TValue定义在lj_obj.h中，如下面所示，因为Nan-boxing的缘故，这里的TValue结构并没有直接反映实际的内存布局。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* Tagged value. */<br>typedef LJ_ALIGN(8) union TValue &#123;<br>  uint64_t u64;  /* 64 bit pattern overlaps number. */<br>  lua_Number n;  /* Number object overlaps split tag/value object. */<br>#if LJ_GC64<br>  GCRef gcr;  /* GCobj reference with tag. */<br>  int64_t it64;<br>  struct &#123;<br>    LJ_ENDIAN_LOHI(<br>      int32_t i; /* Integer value. */<br>    , uint32_t it; /* Internal object tag. Must overlap MSW of number. */<br>    )<br>  &#125;;<br>#else<br>  struct &#123;<br>    LJ_ENDIAN_LOHI(<br>      union &#123;<br>trueGCRef gcr; /* GCobj reference (if any). */<br>trueint32_t i; /* Integer value. */<br>      &#125;;<br>    , uint32_t it; /* Internal object tag. Must overlap MSW of number. */<br>    )<br>  &#125;;<br>#endif<br><br> ..........<br><br>&#125; TValue;<br></code></pre></td></tr></table></figure><h1 id="类型的定义"><a href="#类型的定义" class="headerlink" title="类型的定义"></a>类型的定义</h1><p>所有的数据类型定义中最高的几位均为1，方便与浮点数的区分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TNIL   (~0u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TFALSE  (~1u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TTRUE  (~2u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TLIGHTUD  (~3u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TSTR   (~4u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TUPVAL  (~5u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TTHREAD  (~6u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TPROTO  (~7u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TFUNC  (~8u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TTRACE  (~9u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TCDATA  (~10u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TTAB   (~11u)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TUDATA  (~12u)</span><br><span class="hljs-comment">/* This is just the canonical number type used in some places. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TNUMX  (~13u)</span><br><br><span class="hljs-comment">/* Integers have itype == LJ_TISNUM doubles have itype &lt; LJ_TISNUM */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LJ_64 &amp;&amp; !LJ_GC64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TISNUM  0xfffeffffu</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LJ_TISNUM  LJ_TNUMX</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>判断类型的宏定义<br>LuaJIT定义了一系列宏用来判断值的类型。<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LJ_GC64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> itype(o) ((uint32_t)((o)-&gt;it64 &gt;&gt; 47))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisnil(o) ((o)-&gt;it64 == -1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> itype(o) ((o)-&gt;it)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisnil(o) (itype(o) == LJ_TNIL)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisfalse(o) (itype(o) == LJ_TFALSE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvistrue(o) (itype(o) == LJ_TTRUE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisbool(o) (tvisfalse(o) || tvistrue(o))</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LJ_64 &amp;&amp; !LJ_GC64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvislightud(o) (((int32_t)itype(o) &gt;&gt; 15) == -2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvislightud(o) (itype(o) == LJ_TLIGHTUD)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisstr(o) (itype(o) == LJ_TSTR)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisfunc(o) (itype(o) == LJ_TFUNC)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisthread(o) (itype(o) == LJ_TTHREAD)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisproto(o) (itype(o) == LJ_TPROTO)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tviscdata(o) (itype(o) == LJ_TCDATA)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvistab(o) (itype(o) == LJ_TTAB)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisudata(o) (itype(o) == LJ_TUDATA)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisnumber(o) (itype(o) &lt;= LJ_TISNUM)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisint(o) (LJ_DUALNUM &amp;&amp; itype(o) == LJ_TISNUM)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tvisnum(o) (itype(o) &lt; LJ_TISNUM)</span><br>LJ_DUALNUM<br></code></pre></td></tr></table></figure><p>Lua中数值都是double类型的浮点数，而实际使用时经常会用到整数，而位操作等都需要将double类型转换成整数进行。为此LuaJIT提供了LJ_DUALNUM的选项，一些数值可以直接通过int类型存储，方便使用，相当于为Lua增加了整数这个数据类型。</p><p>LJ_DUALNUM的定义可以参考lj_arch.h，不过对常用的x86_64架构，默认并没有启用LJ_DUALNUM。</p><h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><p><a href="https://qlee.in/luajitde-bian-liang-shi-xian-tvalue/?tdsourcetag=s_pcqq_aiomsg">https://qlee.in/luajitde-bian-liang-shi-xian-tvalue/?tdsourcetag=s_pcqq_aiomsg</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>IEEE Standard for Floating-Point Arithmetic (IEEE 754)</li><li>X86_64 Virtual_address_space_details</li></ul>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Unity 符号表上传</title>
      <link href="/2019/09/27/bugly-symbol/"/>
      <url>/2019/09/27/bugly-symbol/</url>
      
        <content type="html"><![CDATA[<h2 id="Why-do-it"><a href="#Why-do-it" class="headerlink" title="Why do it"></a>Why do it</h2><p>最近游戏内测，发现不少崩溃的堆栈发生在libunity.so之中，而大部分仅仅给一个代码执行到的PC地址，查起来代码比较蛋疼。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-meta">#00 pc 00a6ac38 /data/app/.../libunity.so</span><br><span class="hljs-meta">#01 pc 00a6c128 /data/app/.../x86/libunity.so</span><br><span class="hljs-meta">#02 pc 003f1bf6 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#03 pc 003f0b4a /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#04 pc 0039ff68 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#05 pc 00396e77 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#06 pc 00398ce0 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#07 pc 00398149 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#08 pc 003980a2 /data/app/.../x86/libunity.so </span><br><span class="hljs-meta">#09 pc 004f2ca3 /data/app/.../x86/libunity.so </span><br></code></pre></td></tr></table></figure><span id="more"></span><p>这种一般没有符号表，不过我们可以使用addr2line这个经典的binutils工具将PC地址转换为函数名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./i686-linux-android-addr2line.exe -C -i -f -e libunity.sym.so 00a6ac38<br></code></pre></td></tr></table></figure><p>输出结果如下:</br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">mecanim::statemachine::EvaluateState(mecanim::ValueArrayConstant <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateConstant <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineInput <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineOutput&amp;, mecanim::statemachine::StateMachineMemory&amp;, mecanim::statemachine::StateOutput&amp;, mecanim::statemachine::StateWorkspace&amp;, <span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>)<br></code></pre></td></tr></table></figure><p>我们很快就可以定位到是一个动画状态机的问题，不过问题也接踵而至,BUG量有点多，然后一起看BUGLY的人也不少，客户端的其他人未必懂这些底层知识，那么其实就可以利用Bugly的符号表功能来做这件事情。</p><h2 id="How-to-do"><a href="#How-to-do" class="headerlink" title="How to do"></a>How to do</h2><p>首先去<a href="https://bugly.qq.com/v2/sdkDownload">Bugly官网</a>上下载最新的符号表导出工具</p><p>Android Unity的符号表路径在Editor\Data\PlaybackEngines\AndroidPlayer\Variations</p><p>搜索libunity.sym.so即可,注意MONO和IL2CPP要对应上传,输入导出和上传指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar buglySymbolAndroid.jar -i libunity.sym.so -u -<span class="hljs-built_in">id</span> <span class="hljs-variable">$yourappid</span> -key <span class="hljs-variable">$yourappkey</span> -package <span class="hljs-variable">$packagename</span> -version xx.xx.xx<br></code></pre></td></tr></table></figure><p>在BUGLY界面中打开界面，如果看到对应的符号表已上传就说明成功了</br><br><img src="/../images/symbol_success.png" alt="成功截图"></br><br>报错堆栈变成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">#<span class="hljs-number">00</span> pc <span class="hljs-number">00</span>a6ac38 libunity.so mecanim::statemachine::EvaluateState(mecanim::ValueArrayConstant <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateConstant <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineInput <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineOutput&amp;, mecanim::statemachine::StateMachineMemory&amp;, mecanim::statemachine::StateOutput&amp;, mecanim::statemachine::StateWorkspace&amp;, <span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>) [x86]<br>#<span class="hljs-number">01</span> pc <span class="hljs-number">00</span>a6c128 libunity.so mecanim::statemachine::SetStateMachineInInitialState(mecanim::statemachine::StateMachineConstant <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineInput <span class="hljs-type">const</span>&amp;, mecanim::statemachine::StateMachineOutput&amp;, mecanim::statemachine::StateMachineMemory&amp;, mecanim::statemachine::StateMachineWorkspace&amp;) [x86]<br>#<span class="hljs-number">02</span> pc <span class="hljs-number">003f</span>1bf6 libunity.so <span class="hljs-title function_">AnimatorControllerPlayable::GenerateGraph</span><span class="hljs-params">()</span> [x86]<br>#03 pc 003f0b4a libunity.so <span class="hljs-title function_">AnimatorControllerPlayable::SetAnimatorController</span><span class="hljs-params">(RuntimeAnimatorController*)</span> [x86]<br>#04 pc 0039ff68 libunity.so <span class="hljs-title function_">Animator::CreateInternalControllerPlayable</span><span class="hljs-params">()</span> [x86]<br>#05 pc 00396e77 libunity.so <span class="hljs-title function_">Animator::CreateObject</span><span class="hljs-params">()</span> [x86]<br>#06 pc 00398ce0 libunity.so <span class="hljs-title function_">Animator::Prepare</span><span class="hljs-params">()</span> [x86]<br></code></pre></td></tr></table></figure><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>将Addr2Line与IDA结合，定位报错汇编码</p>]]></content>
      
      
      <categories>
          
          <category> 汇编逆向 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编调用指令，堆栈操作详解</title>
      <link href="/2019/09/27/base-asm-calls/"/>
      <url>/2019/09/27/base-asm-calls/</url>
      
        <content type="html"><![CDATA[<h2 id="一些常用的汇编指令直观翻译"><a href="#一些常用的汇编指令直观翻译" class="headerlink" title="一些常用的汇编指令直观翻译"></a>一些常用的汇编指令直观翻译</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span> , <span class="hljs-built_in">ebx</span>            <span class="hljs-comment">; eax = ebx</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">eax</span> , [<span class="hljs-built_in">ebx</span> + <span class="hljs-number">30</span>]     <span class="hljs-comment">; eax = ebx + 30 </span><br>                         <span class="hljs-comment">; 不这样写就是两条指令 mov eax, ebx ;add eax 30</span><br><span class="hljs-keyword">push</span> <span class="hljs-keyword">pop</span>                 <span class="hljs-comment">; 入栈，出栈</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">5</span>               <span class="hljs-comment">; eax += 5</span><br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">5</span>               <span class="hljs-comment">; eax -= 5</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">eax</span>                  <span class="hljs-comment">; eax += 1</span><br><span class="hljs-keyword">mul</span>                      <span class="hljs-comment">; 乘法</span><br><span class="hljs-keyword">div</span>                      <span class="hljs-comment">; 除法</span><br></code></pre></td></tr></table></figure><h2 id="改变堆栈的操作"><a href="#改变堆栈的操作" class="headerlink" title="改变堆栈的操作"></a>改变堆栈的操作</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span>   // <span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span> , <span class="hljs-number">4</span>  <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span>] , <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span>    // <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span> , [<span class="hljs-built_in">esp</span>]   <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span> , <span class="hljs-number">4</span><br><span class="hljs-keyword">call</span> <span class="hljs-number">1234</span>  // <span class="hljs-keyword">push</span> <span class="hljs-built_in">eip</span>   <span class="hljs-keyword">jmp</span> <span class="hljs-number">1234</span><br><span class="hljs-keyword">retn</span> <span class="hljs-number">8</span>     // <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eip</span>   <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span> , <span class="hljs-number">8</span>   常用于 __stdcall,这种函数自己清理自己的参数的<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span> , xxx<br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span> , xxx<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="栈指针、帧指针的学习"><a href="#栈指针、帧指针的学习" class="headerlink" title="栈指针、帧指针的学习"></a>栈指针、帧指针的学习</h2><p>ESP栈指针,每一次push或者pop值会跟这变，永远指向栈顶 </br><br>EBP帧指针，其实有无无所谓，如果没有使用ESP取局部变量和参数的时候因为地址会一直改变，人的理解上比较麻烦，于是在call指令save 的 EIP后记录下来当前的ESP到EBP中，这样子取参数或者局部变量的时候回更方便。</br></p><p>以下面这个在32位x86计算机上编译的函数为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span>; <span class="hljs-comment">// a function to call</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">demo_stackframe</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, in c)</span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> z;<br>    bar(z, y);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../../images/only_esp.png" alt="&quot;&quot;"></p><p>调用bar函数的时候,如果没有设置 ebp传递参数汇编码如下:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; 假设为__cdecl,参数从右往左入栈，调用者清理堆栈</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">4</span>]    <span class="hljs-comment">; push y</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">4</span>]    <span class="hljs-comment">; push z</span><br><span class="hljs-keyword">call</span> bar              <span class="hljs-comment">; push eip,jmp bar</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">8</span>            <span class="hljs-comment">; 清理堆栈</span><br></code></pre></td></tr></table></figure><p>我们可以发现，如果根据esp来寻找地址，很不直观，第一次我们将 y push到堆栈中后，导致esp sub 4,然后取z的时候地址就会跟着改变，显然这样理解上比较麻烦，同一个参数获取的时候esp的偏移量总是不一样。</p><p>为了更好的计算偏移量，我们需要一个固定不变的堆栈地址，这样就不会出现同一个参数然后偏移不一样的情况。于是引入了ebp(帧指针)的概念,在call bar之后将esp地址记录下来，此时的堆栈情况如下。</p><p><img src="/../images/use_ebp.png" alt="&quot;&quot;"><br>注意调用前要把caller的ebp保存起来，不然到调用完成后，caller的ebp就找不到了。所以调用bar函数前要写上“序言”代码</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span>        <span class="hljs-comment">; 保存 caller的 ebp </span><br><span class="hljs-keyword">mov</span>  <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span>   <span class="hljs-comment">; 将bar函数的ebp设置为当前的esp</span><br><span class="hljs-keyword">sub</span>  <span class="hljs-built_in">esp</span>, <span class="hljs-number">76</span>    <span class="hljs-comment">; 提前扩容好局部变量</span><br></code></pre></td></tr></table></figure><p>注意这里仅仅保存了caller函数的ebp,如果想要保存caller函数的其他寄存器信息比如eax之类的，需要在序言这边push进去</p><p>现在调用bar函数的汇编指令差不多为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">72</span>]         <span class="hljs-comment">; push y</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">76</span>]         <span class="hljs-comment">; push z</span><br><span class="hljs-keyword">call</span> bar<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">8</span>                  <span class="hljs-comment">; 清栈</span><br></code></pre></td></tr></table></figure><p>使用了帧指针ebp后，所有的变量相对于ebp的偏移量都可以计算出来。许多时候，正偏移量用于访问函数参数，而负偏移量用于访问局部变量。使用ebp指针后，我们可以自由的更改esp指针而不用担心，其他变量的偏移地址</p><p>最后完成bar函数调用的时候：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>,<span class="hljs-built_in">ebp</span>          <span class="hljs-comment">; 清理局部变量</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span>              <span class="hljs-comment">; 恢复caller函数的ebp</span><br><span class="hljs-keyword">ret</span>                  <span class="hljs-comment">; pop eip</span><br></code></pre></td></tr></table></figure><p>由于 这种操作非常常见，因此x86体系提供了leave指令来缩短汇编指令长度</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">leave</span>                <span class="hljs-comment">; 相当于</span><br>                     <span class="hljs-comment">; mov esp,ebp</span><br>                     <span class="hljs-comment">; pop ebp</span><br><br><span class="hljs-keyword">ret</span>                  <span class="hljs-comment">; pop eip</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 汇编逆向 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
