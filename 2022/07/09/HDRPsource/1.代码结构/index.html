<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    
    <meta name="keywords" content="leinlin, ARIA, Hexo">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="leinlin的小笔记" type="application/atom+xml" />
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-light.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/clipboard.min.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    
    <script defer type="text/javascript" src="https://cdn.staticfile.org/MathJax/MathJax-2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code"]
      }
    });
    </script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += " has-jax";
      }
    });
    </script>
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var cb = null;
      var els = $(".post figure.highlight");
      if (els.length) {
        // Enabled Hexo highlight line number.
        $(els).each(function (i, e) {
          // $(e).before("<button class=\"copy button\">复制</button>");
          $(e).before([
            "<div class=\"code-titlebar\">",
              "<div class=\"titlebar-left\">",
                "<button class=\"copy\">复制</button>",
              "</div>",
            "</div>"
          ].join(""));
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              return trigger.parentNode.parentNode.nextElementSibling.firstChild.firstChild.firstChild.lastChild.firstChild.firstChild;
          }
        });
      } else {
        // Disabled Hexo highlight line number.
        els = $(".post pre code");
        $(els).each(function (i, e) {
          // Add button before pre, not code.
          // $(e).parent().before("<button class=\"copy button\">复制</button>");
          $(e).before([
            "<div class=\"code-titlebar\">",
              "<div class=\"titlebar-left\">",
                "<button class=\"copy\" >复制</button>",
              "</div>",
              "<div class=\"titlebar-right\">",
                "<button class=\"button-dot dot-minimize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-maximize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-close\" aria-label=\"Decoration\"></button>",
              "</div>",
            "</div>"
          ].join(""));
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              return trigger.parentNode.parentNode.nextElementSibling;
          }
        });
      }
      cb.on("success", function (e) {
        e.clearSelection();
        var trigger = e.trigger;
        // Change button text as a user tip.
        trigger.innerHTML = "已复制";
        $(trigger).addClass("copied");
        // Change button text back;
        setTimeout(function () {
          trigger.innerHTML = "复制";
          $(trigger).removeClass("copied");
        }, 1500);
      });
    });
    </script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>代码结构 | leinlin的小笔记</title>
  <meta name="generator" content="Hexo 6.2.0"></head>
  <body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"  data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">leinlin的小笔记</a></h1>
        <h2 class="subtitle"></h2>
      </div>
      
    </div>
    <nav id="nav" class="nav">
      <a id="nav-toggle" class="nav-toggle" aria-hidden="true"><i class="fas fa-bars" aria-label="切换导航栏"></i></a>
      <ul id="menu" role="menubar" aria-hidden="false">
        
        <li role="menuitem"><a href="/"><i class="fas fa-home"></i><span class="menu-text">首页</span></a></li>
        
        <li role="menuitem"><a href="/categories/"><i class="fas fa-th-list"></i><span class="menu-text">分类</span></a></li>
        
      </ul>
    </nav>
  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            
<div id="post" class="page">
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/HDRPsource/1.%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
       <meta itemprop="name" content="leinlin">
       <meta itemprop="description" content="">
       <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
       <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">代码结构</h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/HDRPSource/" itemprop="url" rel="index"><span itemprop="name">HDRPSource</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      <h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><p>hdrp的所有渲染过程描述在HDRenderPipeline类的Render方法当中：</p>
<figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">UnityEngine.Experimental.Rendering.HDPipeline</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HDRenderPipeline</span> &#123;<br>	...<br>		 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Render</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">		 	ScriptableRenderContext renderContext, Camera[] cameras</span></span><br><span class="hljs-params"><span class="hljs-function">		 	</span>)</span><br><span class="hljs-function">	...</span><br><span class="hljs-function">	&#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<h1 id="Render方法"><a href="#Render方法" class="headerlink" title="Render方法"></a>Render方法</h1><p>render方法当中的主要输入的ScriptableRenderContext和Camera列表：</p>
<p>ScriptableRenderContext：定义状态、收集渲染命令。</p>
<p>摄像机列表</p>
<h2 id="render主要过程"><a href="#render主要过程" class="headerlink" title="render主要过程"></a>render主要过程</h2><p>收件进行物体剪裁</p>
<p>然后调用一系列DrawRenderers和CommandBuffer</p>
<p>最终提交</p>
<figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Render</span>(<span class="hljs-params">ScriptableRenderContext renderContext, Camera[] cameras</span>)</span><br>&#123;<br>  	<span class="hljs-comment">//调用父类方法</span><br>  	<span class="hljs-keyword">base</span>.Render(renderContext, cameras);<br>  <br>  	<span class="hljs-comment">//渲染时间控制</span><br>    &#123;<br><br>    &#125;<br>  <br>  	<span class="hljs-comment">// 渲染平面反射 ：统计需要渲染的反射类型：反射探针 和 平面反射</span><br>  	<span class="hljs-comment">// 通过深层调用可以发现最终调用的是 renderCamera.Render();</span><br>    ReflectionSystem.RenderAllRealtimeProbes(probeTypeToRender);<br>  <br>  	<span class="hljs-comment">// 更新HDRP assets 设置</span><br>    m_Asset.UpdateDirtyFrameSettings();<br>  <br>    <span class="hljs-comment">// 为每个摄像机循环渲染</span><br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> camera <span class="hljs-keyword">in</span> cameras)<br>    &#123;<br>      RenderPipeline.BeginCameraRendering(camera);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="为每个摄像机循环渲染"><a href="#为每个摄像机循环渲染" class="headerlink" title="为每个摄像机循环渲染"></a>为每个摄像机循环渲染</h2><h3 id="准备设置参数"><a href="#准备设置参数" class="headerlink" title="准备设置参数"></a>准备设置参数</h3><figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (camera == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">// 首先从摄像机上获取摄像机设置。</span><br><span class="hljs-keyword">var</span> additionalCameraData = camera.GetComponent&lt;HDAdditionalCameraData&gt;();<br>FrameSettings srcFrameSettings;<br><span class="hljs-comment">// 如果有这个组件则从组件当中获取最新设置FrameSettings。</span><br><span class="hljs-keyword">if</span> (additionalCameraData)<br>&#123;                additionalCameraData.UpdateDirtyFrameSettings(assetFrameSettingsIsDirty, m_Asset.GetFrameSettings());<br> srcFrameSettings = additionalCameraData.GetFrameSettings();<br> &#125;<br><span class="hljs-comment">// 如果没有则从HDRenderPipelineAsset中获取设置</span><br><span class="hljs-keyword">else</span><br>&#123;<br>    srcFrameSettings = m_Asset.GetFrameSettings();<br>&#125;<br><br><span class="hljs-comment">//  根据各方面内容初始化帧设置。</span><br>   FrameSettings currentFrameSettings = <span class="hljs-keyword">new</span> FrameSettings();<br> FrameSettings.InitializeFrameSettings(camera, m_Asset.GetRenderPipelineSettings(), srcFrameSettings, <span class="hljs-keyword">ref</span> currentFrameSettings);<br><br><br></code></pre></td></tr></table></figure>



<figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//初始化commandbuffer来提交主要的渲染命令</span><br><span class="hljs-keyword">var</span> cmd = CommandBufferPool.Get(<span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-comment">// 完全自定义内容的摄像机，不进入渲染过程</span><br><span class="hljs-keyword">if</span> (additionalCameraData <br>&amp;&amp; additionalCameraData.renderingPath == HDAdditionalCameraData.RenderingPath.FullscreenPassthrough)<br>&#123;<br>  <span class="hljs-comment">// 直接提交一个空的command buffer执行</span><br>  <span class="hljs-comment">// 这里思考一下我们的Command在哪里起作用</span><br>  renderContext.ExecuteCommandBuffer(cmd);<br>  CommandBufferPool.Release(cmd);<br>  renderContext.Submit();<br>  <span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">// 渲染反射：如果注意就可以发现，上面也有一个RenderAllRealtimeViewerDependentProbes区别在于上面的没有提供摄像机，一个是静态的、一个是为当前摄像机渲染的动态的。</span><br><span class="hljs-keyword">if</span> (camera.cameraType != CameraType.Reflection &amp;&amp; camera.cameraType != CameraType.Preview &amp;&amp; !camera.orthographic) ReflectionSystem.RenderAllRealtimeViewerDependentProbesFor(ReflectionProbeType.PlanarReflection, camera);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">可以查看反射探针和镜面反射探针，都保存在下面的数组中</span><br><span class="hljs-comment">m_PlanarReflectionProbe_PerCamera_RealtimeUpdate</span><br><span class="hljs-comment">m_PlanarReflectionProbe_RealtimeUpdate_WorkArray</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 初始化材质资源，材质列表中每个材质需要的资源初始化。用cmd来申请</span><br><span class="hljs-comment">// m_MaterialList如何填充的？</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> material <span class="hljs-keyword">in</span> m_MaterialList)<br>   material.RenderInit(cmd);<br><br><span class="hljs-comment">// 使用ProfilingSamplig采样渲染</span><br><span class="hljs-comment">// 填充CommandBuffer来指定渲染过程</span><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;HDRenderPipeline::Render&quot;</span>, CustomSamplerId.HDRenderPipelineRender.GetSampler()))<br>&#123;<br>   <br>&#125;<br><br><span class="hljs-comment">// 执行组装好的CommandBuffer</span><br>renderContext.ExecuteCommandBuffer(cmd);<br><span class="hljs-comment">// 释放</span><br>CommandBufferPool.Release(cmd);<br><span class="hljs-comment">// 提交</span><br>renderContext.Submit();<br><br><span class="hljs-comment">// 和调试相关的内容暂时忽略</span><br><span class="hljs-keyword">if</span> (m_CurrentDebugDisplaySettings.fullScreenDebugMode == FullScreenDebugMode.ScreenSpaceTracing)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="填充CommandBuffer来指定渲染过程"><a href="#填充CommandBuffer来指定渲染过程" class="headerlink" title="填充CommandBuffer来指定渲染过程"></a>填充CommandBuffer来指定渲染过程</h4><figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-comment">// 初始化设置  @@</span><br>m_LightLoop.NewFrame(currentFrameSettings);<br><br><span class="hljs-comment">// 根据摄像机类型设置m_CurrentDebugDisplaySettings</span><br><span class="hljs-keyword">if</span> (camera.cameraType == CameraType.Reflection || camera.cameraType == CameraType.Preview)<br>&#123;<br>  m_CurrentDebugDisplaySettings = s_NeutralDebugDisplaySettings;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>  m_CurrentDebugDisplaySettings = m_DebugDisplaySettings;<br>&#125;<br><br><span class="hljs-comment">// Volume相关的处理</span><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;Volume Update&quot;</span>, CustomSamplerId.VolumeUpdate.GetSampler()))<br>&#123;<br>&#125;<br><br><span class="hljs-comment">// 或处理判断</span><br><span class="hljs-keyword">var</span> postProcessLayer = camera.GetComponent&lt;PostProcessLayer&gt;();<br><span class="hljs-comment">// Disable post process if we enable debug mode or if the post process layer is disabled</span><br><span class="hljs-keyword">if</span> (m_CurrentDebugDisplaySettings.IsDebugDisplayRemovePostprocess() || !HDUtils.IsPostProcessingActive(postProcessLayer))<br>&#123;<br>  currentFrameSettings.enablePostprocess = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// 摄像机HDCamera设置，体积光系统？</span><br><span class="hljs-keyword">var</span> hdCamera = HDCamera.Get(camera);<br><span class="hljs-keyword">if</span> (hdCamera == <span class="hljs-literal">null</span>)<br>&#123;<br>  	hdCamera = HDCamera.Create(camera, m_VolumetricLightingSystem);<br>&#125;<br>hdCamera.Update(currentFrameSettings, postProcessLayer, m_VolumetricLightingSystem);<br>Resize(hdCamera);<br>ApplyDebugDisplaySettings(hdCamera, cmd);<br>UpdateShadowSettings(hdCamera);<br>m_SkyManager.UpdateCurrentSkySettings(hdCamera);<br></code></pre></td></tr></table></figure>

<h4 id="剪裁"><a href="#剪裁" class="headerlink" title="剪裁"></a>剪裁</h4><figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">ScriptableCullingParameters cullingParams;<br><span class="hljs-keyword">if</span> (!CullResults.GetCullingParameters(camera, hdCamera.frameSettings.enableStereo, <span class="hljs-keyword">out</span> cullingParams))<br>&#123;<br>  renderContext.Submit();<br>  <span class="hljs-keyword">continue</span>;<br>&#125;<br>m_LightLoop.UpdateCullingParameters(<span class="hljs-keyword">ref</span> cullingParams);<br>hdCamera.UpdateStereoDependentState(<span class="hljs-keyword">ref</span> cullingParams);<br></code></pre></td></tr></table></figure>

<p>####一堆看不懂的设置</p>
<figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableDBuffer)<br>&#123;<br>  <span class="hljs-comment">// decal system needs to be updated with current camera, it needs it to set up culling and light list generation parameters</span><br>  DecalSystem.instance.CurrentCamera = camera;<br>  DecalSystem.instance.BeginCull();<br>&#125;<br><br>ReflectionSystem.PrepareCull(camera, m_ReflectionProbeCullResults);<br><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;CullResults.Cull&quot;</span>, CustomSamplerId.CullResultsCull.GetSampler()))<br>&#123;<br>  CullResults.Cull(<span class="hljs-keyword">ref</span> cullingParams, renderContext, <span class="hljs-keyword">ref</span> m_CullResults);<br>&#125;<br><br>m_ReflectionProbeCullResults.Cull();<br><br>m_DbufferManager.EnableDBUffer = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;DBufferPrepareDrawData&quot;</span>, CustomSamplerId.DBufferPrepareDrawData.GetSampler()))<br>&#123;<br>  <span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableDBuffer)<br>  &#123;<br>    DecalSystem.instance.EndCull();<br>    m_DbufferManager.EnableDBUffer = <span class="hljs-literal">true</span>;              <span class="hljs-comment">// mesh decals are renderers managed by c++ runtime and we have no way to query if any are visible, so set to true</span><br>    DecalSystem.instance.UpdateCachedMaterialData();    <span class="hljs-comment">// textures, alpha or fade distances could&#x27;ve changed</span><br>    DecalSystem.instance.CreateDrawData();              <span class="hljs-comment">// prepare data is separate from draw</span><br>    DecalSystem.instance.UpdateTextureAtlas(cmd);       <span class="hljs-comment">// as this is only used for transparent pass, would&#x27;ve been nice not to have to do this if no transparent renderers are visible, needs to happen after CreateDrawData</span><br>  &#125;<br>&#125;<br>renderContext.SetupCameraProperties(camera, hdCamera.frameSettings.enableStereo);<br><br>PushGlobalParams(hdCamera, cmd, diffusionProfileSettings);<br><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Find a correct place to bind these material textures</span><br><span class="hljs-comment">// We have to bind the material specific global parameters in this mode</span><br>m_MaterialList.ForEach(material =&gt; material.Bind());<br><br><span class="hljs-comment">// Frustum cull density volumes on the CPU. Can be performed as soon as the camera is set up.</span><br>DensityVolumeList densityVolumes = m_VolumetricLightingSystem.PrepareVisibleDensityVolumeList(hdCamera, cmd, m_Time);<br><br><span class="hljs-comment">// Note: Legacy Unity behave like this for ShadowMask</span><br><span class="hljs-comment">// When you select ShadowMask in Lighting panel it recompile shaders on the fly with the SHADOW_MASK keyword.</span><br><span class="hljs-comment">// However there is no C# function that we can query to know what mode have been select in Lighting Panel and it will be wrong anyway. Lighting Panel setup what will be the next bake mode. But until light is bake, it is wrong.</span><br><span class="hljs-comment">// Currently to know if you need shadow mask you need to go through all visible lights (of CullResult), check the LightBakingOutput struct and look at lightmapBakeType/mixedLightingMode. If one light have shadow mask bake mode, then you need shadow mask features (i.e extra Gbuffer).</span><br><span class="hljs-comment">// It mean that when we build a standalone player, if we detect a light with bake shadow mask, we generate all shader variant (with and without shadow mask) and at runtime, when a bake shadow mask light is visible, we dynamically allocate an extra GBuffer and switch the shader.</span><br><span class="hljs-comment">// So the first thing to do is to go through all the light: PrepareLightsForGPU</span><br><span class="hljs-built_in">bool</span> enableBakeShadowMask;<br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;TP_PrepareLightsForGPU&quot;</span>, CustomSamplerId.TPPrepareLightsForGPU.GetSampler()))<br>&#123;<br>  enableBakeShadowMask = m_LightLoop.PrepareLightsForGPU(cmd, hdCamera, m_ShadowSettings, m_CullResults, m_ReflectionProbeCullResults, densityVolumes);<br>&#125;<br>ConfigureForShadowMask(enableBakeShadowMask, cmd);<br><br></code></pre></td></tr></table></figure>

<h4 id="正式开始渲染-必要部分1"><a href="#正式开始渲染-必要部分1" class="headerlink" title="正式开始渲染:必要部分1"></a>正式开始渲染:必要部分1</h4><figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#">StartStereoRendering(renderContext, hdCamera);<br>ClearBuffers(hdCamera, cmd);<br><br><span class="hljs-comment">// 预先深度</span><br>RenderDepthPrepass(m_CullResults, hdCamera, renderContext, cmd);<br><br><span class="hljs-comment">// 渲染深度给Decal使用</span><br>RenderDBuffer(hdCamera, cmd, renderContext, m_CullResults);<br><br><span class="hljs-comment">// 渲染Gbuffer</span><br>RenderGBuffer(m_CullResults, hdCamera, enableBakeShadowMask, renderContext, cmd);<br><br><span class="hljs-comment">// 绑定NormalBuffer到某个外部纹理？？</span><br>m_NormalBufferManager.BindNormalBuffers(cmd);<br><br><span class="hljs-comment">// 渲染深度和深度金字塔</span><br>CopyDepthBufferIfNeeded(cmd);<br>RenderDepthPyramid(hdCamera, cmd, renderContext, FullScreenDebugMode.DepthPyramid);<br><br><span class="hljs-comment">// 渲染MotionVector？？</span><br>RenderObjectsVelocity(m_CullResults, hdCamera, renderContext, cmd);<br>RenderCameraVelocity(m_CullResults, hdCamera, renderContext, cmd);<br><br><span class="hljs-comment">// 设置全局的深度纹理</span><br>cmd.SetGlobalTexture(HDShaderIDs._CameraDepthTexture, GetDepthTexture());<br><br><span class="hljs-comment">// 天空盒更新</span><br>UpdateSkyEnvironment(hdCamera, cmd);<br><br>StopStereoRendering(renderContext, hdCamera);<br><br><span class="hljs-keyword">if</span> (m_CurrentDebugDisplaySettings.IsDebugMaterialDisplayEnabled())<br>&#123;<br>  RenderDebugViewMaterial(m_CullResults, hdCamera, renderContext, cmd);<br><br>  PushColorPickerDebugTexture(cmd, m_CameraColorBuffer, hdCamera);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>  <span class="hljs-comment">//正式开始渲染:必要部分2</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>####正式开始渲染:必要部分2 </p>
<figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#">StartStereoRendering(renderContext, hdCamera);<br><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;Render SSAO&quot;</span>, CustomSamplerId.RenderSSAO.GetSampler()))<br>&#123;<br>	<span class="hljs-comment">//渲染SSAO，屏幕空间环境光，这里需要PostProcessing？？？</span><br>  RenderSSAO(cmd, hdCamera, renderContext, postProcessLayer);<br>&#125;<br><br><br><span class="hljs-comment">// FeatureVariamts ??? 和Stencil相关</span><br><span class="hljs-keyword">if</span> (m_LightLoop.GetFeatureVariantsEnabled())<br>&#123;<br>  <span class="hljs-comment">// For material classification we use compute shader and so can&#x27;t read into the stencil, so prepare it.</span><br>  <span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;Clear and copy stencil texture&quot;</span>, CustomSamplerId.ClearAndCopyStencilTexture.GetSampler()))<br>  &#123;<br>    HDUtils.SetRenderTarget(cmd, hdCamera, m_CameraStencilBufferCopy, ClearFlag.Color, CoreUtils.clearColorAllBlack);<br><br>    <span class="hljs-comment">// In the material classification shader we will simply test is we are no lighting</span><br>    <span class="hljs-comment">// Use ShaderPassID 1 =&gt; &quot;Pass 1 - Write 1 if value different from stencilRef to output&quot;</span><br>    HDUtils.DrawFullScreen(cmd, hdCamera, m_CopyStencilForNoLighting, m_CameraStencilBufferCopy, m_CameraDepthStencilBuffer, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><br>StopStereoRendering(renderContext, hdCamera);<br><br><span class="hljs-comment">// 异步计算阴影？？</span><br>GPUFence buildGPULightListsCompleteFence = <span class="hljs-keyword">new</span> GPUFence();<br><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableAsyncCompute)<br>&#123;<br>  GPUFence startFence = cmd.CreateGPUFence();<br>  renderContext.ExecuteCommandBuffer(cmd);<br>  cmd.Clear();<br><br>  buildGPULightListsCompleteFence = m_LightLoop.BuildGPULightListsAsyncBegin(hdCamera, renderContext, m_CameraDepthStencilBuffer, m_CameraStencilBufferCopy, startFence, m_SkyManager.IsLightingSkyValid());<br>&#125;<br><br><span class="hljs-comment">//正式开始渲染:必要部分3 </span><br></code></pre></td></tr></table></figure>



<p>####正式开始渲染:必要部分3 </p>
<figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs c#"> <span class="hljs-comment">// 渲染阴影</span><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;Render shadows&quot;</span>, CustomSamplerId.RenderShadows.GetSampler()))<br>&#123;<br>  m_LightLoop.RenderShadows(renderContext, cmd, m_CullResults);<br><br>  <span class="hljs-comment">// Overwrite camera properties set during the shadow pass with the original camera properties.</span><br>  renderContext.SetupCameraProperties(camera, hdCamera.frameSettings.enableStereo);<br>  hdCamera.SetupGlobalParams(cmd, m_Time, m_LastTime, m_FrameCount);<br>  <span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableStereo)<br>    hdCamera.SetupGlobalStereoParams(cmd);<br>&#125;<br><br><span class="hljs-comment">// 渲染deffered直接阴影</span><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;Deferred directional shadows&quot;</span>, CustomSamplerId.RenderDeferredDirectionalShadow.GetSampler()))<br>&#123;<br>    <span class="hljs-comment">// When debug is enabled we need to clear otherwise we may see non-shadows areas with stale values.</span><br>    <span class="hljs-keyword">if</span> (m_CurrentDebugDisplaySettings.fullScreenDebugMode == FullScreenDebugMode.DeferredShadows)<br>    &#123;<br>      HDUtils.SetRenderTarget(cmd, hdCamera, m_DeferredShadowBuffer, ClearFlag.Color, CoreUtils.clearColorAllBlack);<br>    &#125;<br><br>    m_LightLoop.RenderDeferredDirectionalShadow(hdCamera, m_DeferredShadowBuffer, GetDepthTexture(), cmd);<br>    PushFullScreenDebugTexture(hdCamera, cmd, m_DeferredShadowBuffer, FullScreenDebugMode.DeferredShadows);<br>&#125;<br><br><span class="hljs-comment">// 异步计算阴影结束？</span><br><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableAsyncCompute)<br>&#123;<br>  m_LightLoop.BuildGPULightListAsyncEnd(hdCamera, cmd, buildGPULightListsCompleteFence);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>  <span class="hljs-comment">// 配置光照列表</span><br>  <span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;Build Light list&quot;</span>, CustomSamplerId.BuildLightList.GetSampler()))<br>  &#123;<br>    m_LightLoop.BuildGPULightLists(hdCamera, cmd, m_CameraDepthStencilBuffer, m_CameraStencilBufferCopy, m_SkyManager.IsLightingSkyValid());<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 和体积光相关的雾参数</span><br>&#123;<br>  <span class="hljs-comment">// Set fog parameters for volumetric lighting.</span><br>  <span class="hljs-keyword">var</span> visualEnv = VolumeManager.instance.stack.GetComponent&lt;VisualEnvironment&gt;();<br>  visualEnv.PushFogShaderParameters(hdCamera, cmd);<br>&#125;<br><br><span class="hljs-comment">// 体素化阶段</span><br>m_VolumetricLightingSystem.VolumeVoxelizationPass(hdCamera, cmd, m_FrameCount, densityVolumes);<br><br><span class="hljs-comment">// 渲染体积光</span><br>m_VolumetricLightingSystem.VolumetricLightingPass(hdCamera, cmd, m_FrameCount);<br><br><span class="hljs-comment">// 渲染延迟光照</span><br>RenderDeferredLighting(hdCamera, cmd);<br><br><span class="hljs-comment">// Might float this higher if we enable stereo w/ deferred</span><br>StartStereoRendering(renderContext, hdCamera);<br><br><span class="hljs-comment">// 渲染前向物体</span><br>RenderForward(m_CullResults, hdCamera, renderContext, cmd, ForwardPass.Opaque);<br><br><span class="hljs-comment">// SSS pass here handle both SSS material from deferred and forward</span><br>m_SSSBufferManager.SubsurfaceScatteringPass(hdCamera, cmd, diffusionProfileSettings,m_CameraColorBuffer, m_CameraSssDiffuseLightingBuffer, m_CameraDepthStencilBuffer, GetDepthTexture());<br><br><span class="hljs-comment">// 渲染天空</span><br>RenderSky(hdCamera, cmd);<br><br><span class="hljs-comment">// 渲染每一个反射物体</span><br>RenderForward(m_CullResults, hdCamera, renderContext, cmd, ForwardPass.PreRefraction);<br><br><span class="hljs-comment">// 渲染颜色金字塔</span><br>RenderColorPyramid(hdCamera, cmd, renderContext, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 渲染前向物体</span><br><span class="hljs-comment">// Render all type of transparent forward (unlit, lit, complex (hair...)) to keep the sorting between transparent objects.</span><br>RenderForward(m_CullResults, hdCamera, renderContext, cmd, ForwardPass.Transparent);<br><br><span class="hljs-comment">// 渲染错误</span><br><span class="hljs-comment">// Render All forward error</span><br>RenderForwardError(m_CullResults, hdCamera, renderContext, cmd);<br><br><span class="hljs-comment">// Fill depth buffer to reduce artifact for transparent object during postprocess</span><br><span class="hljs-comment">// 给后处理渲染透明物体的深度</span><br>RenderTransparentDepthPostpass(m_CullResults, hdCamera, renderContext, cmd, ForwardPass.Transparent);<br><br><span class="hljs-comment">// 渲染颜色金字塔2</span><br>RenderColorPyramid(hdCamera, cmd, renderContext, <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// ？？</span><br>AccumulateDistortion(m_CullResults, hdCamera, renderContext, cmd);<br>RenderDistortion(hdCamera, cmd, m_Asset.renderPipelineResources);<br><br>StopStereoRendering(renderContext, hdCamera);<br><br><span class="hljs-comment">// 测设相关</span><br>PushFullScreenDebugTexture(hdCamera, cmd, m_CameraColorBuffer, FullScreenDebugMode.NanTracker);<br>PushColorPickerDebugTexture(hdCamera, cmd, m_CameraColorBuffer);<br><br>StartStereoRendering(renderContext, hdCamera);<br><br><span class="hljs-comment">// 后处理</span><br><span class="hljs-comment">// Final blit</span><br><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enablePostprocess)<br>&#123;<br>  RenderPostProcess(hdCamera, cmd, postProcessLayer);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>  <span class="hljs-keyword">using</span> (<span class="hljs-keyword">new</span> ProfilingSample(cmd, <span class="hljs-string">&quot;Blit to final RT&quot;</span>, CustomSamplerId.BlitToFinalRT.GetSampler()))<br>  &#123;<br>    <span class="hljs-comment">// This Blit will flip the screen on anything other than openGL</span><br>    HDUtils.BlitCameraTexture(cmd, hdCamera, m_CameraColorBuffer, BuiltinRenderTextureType.CameraTarget);<br>  &#125;<br>&#125;<br><br>StopStereoRendering(renderContext, hdCamera);<br><span class="hljs-comment">// Pushes to XR headset and/or display mirror</span><br><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableStereo)<br>  renderContext.StereoEndRender(hdCamera.camera);<br></code></pre></td></tr></table></figure>



<h1 id="具体渲染方法"><a href="#具体渲染方法" class="headerlink" title="具体渲染方法"></a>具体渲染方法</h1><h2 id="RenderDepthPrepass"><a href="#RenderDepthPrepass" class="headerlink" title="RenderDepthPrepass"></a>RenderDepthPrepass</h2><p>渲染内容：根据渲染设置提前渲染深度。</p>
<p><strong>在Deferred渲染过程中，我们可以使用Forward不透明材质，这些材质需要渲染深度，来得到正确的灯光列表</strong></p>
<p><strong>之后再Deferred光照阶段（deferred lighting pass），不去渲染这些forward的不透明材质。</strong></p>
<p>在deferred模式下，默认是没有forward不透明物体的。但是如果有了，就需要ForwardOnly强行渲染不透明物体。这时候Forward没用，只有FOrwardOnly有用。同时也需要有DepthForwardOnly。</p>
<p>如果forward材质没有深度，则光照可能不正确。</p>
<p>  &#x2F;&#x2F; Forward material always output normal buffer (unless they don’t participate to shading)</p>
<p>&#x2F;&#x2F; Deferred material never output normal buffer</p>
<figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Asset当中开启了Forward Only，则只会渲染前向物体。则depthonly 和depthforwardonly都会渲染。</span><br><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableForwardRenderingOnly)<br>&#123;<br>  HDUtils.SetRenderTarget 设置渲染目标<br>  <span class="hljs-comment">// Full forward: Output normal buffer for both forward and forwardOnly</span><br> RenderOpaqueRenderList(cull, <span class="hljs-comment">// 剪裁结果保存了所有Render</span><br>                        hdCamera, <span class="hljs-comment">//摄像机参数</span><br>                        renderContext,  <span class="hljs-comment">// 渲染上下文</span><br>                        cmd, <br>                        <span class="hljs-comment">// 需要渲染的pass ，所有深度pass都会渲染</span><br>                        m_DepthOnlyAndDepthForwardOnlyPassNames,<br>                        <span class="hljs-number">0</span>, <br>                        <span class="hljs-comment">// 渲染队列</span><br>                        HDRenderQueue.k_RenderQueue_AllOpaque);<br>&#125;<br><span class="hljs-comment">// 如果是deferred render的物体（也就是没有开启Forward Only设置）开启了DepthPrepass,或者开启了深度DBuffer，就会给Deferred渲染的物体也进行prepass深度渲染，一般主需要渲染forward的深度就可以。</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableDepthPrepassWithDeferredRendering || m_DbufferManager.EnableDBUffer)<br>&#123;<br>  HDUtils.SetRenderTarget(cmd, hdCamera, m_CameraDepthStencilBuffer);<br>  <span class="hljs-comment">// 用DepthOnly写入deferred的深度</span><br>  RenderOpaqueRenderList(cull, hdCamera, renderContext, cmd, m_DepthOnlyPassNames, <span class="hljs-number">0</span>, HDRenderQueue.k_RenderQueue_AllOpaque);<br><br>  	<span class="hljs-comment">//与上面不同的是颜色缓存使用了法线 RTI（rendertexture index）也就是forward物体需要填充法线纹理。</span><br>  HDUtils.SetRenderTarget(cmd, hdCamera, <br>                          m_NormalBufferManager.GetBuffersRTI(),<br>                          m_CameraDepthStencilBuffer);<br><br>  <span class="hljs-comment">// 用DepthForwardOnly写入Forward物体的深度</span><br>  RenderOpaqueRenderList(cull, hdCamera, renderContext, cmd, m_DepthForwardOnlyPassNames, <span class="hljs-number">0</span>, HDRenderQueue.k_RenderQueue_AllOpaque);<br><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">// Deferred with partial depth prepass</span><br>&#123;<br>  cmd.DisableShaderKeyword(<span class="hljs-string">&quot;WRITE_NORMAL_BUFFER&quot;</span>);<br><span class="hljs-comment">// 给Deferred alpha tested materials必须渲染prepass。</span><br>  HDUtils.SetRenderTarget(cmd, hdCamera, m_CameraDepthStencilBuffer);<br>  <span class="hljs-keyword">var</span> renderQueueRange = <span class="hljs-keyword">new</span> RenderQueueRange &#123; min = (<span class="hljs-built_in">int</span>)RenderQueue.AlphaTest, max = (<span class="hljs-built_in">int</span>)RenderQueue.GeometryLast - <span class="hljs-number">1</span> &#125;;<br>  RenderOpaqueRenderList(cull, hdCamera, renderContext, cmd, m_DepthOnlyPassNames, <span class="hljs-number">0</span>, renderQueueRange);<br><br>  HDUtils.SetRenderTarget(cmd, hdCamera, m_NormalBufferManager.GetBuffersRTI(), m_CameraDepthStencilBuffer);<br><span class="hljs-comment">// 在deferred 模式下强行渲染Forward不透明物体，需要有DepthForwardonlyPath，否则光照错误。</span><br>  RenderOpaqueRenderList(cull, hdCamera, renderContext, cmd, m_DepthForwardOnlyPassNames, <span class="hljs-number">0</span>, HDRenderQueue.k_RenderQueue_AllOpaque);<br><br>&#125;<br><br><span class="hljs-comment">// 透明物体的Prepass</span><br><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableTransparentPrepass)<br>&#123;<br>	RenderTransparentRenderList(cull, hdCamera, <br>                                renderContext, <br>                                cmd, <br>                                m_TransparentDepthPrepassNames);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="RenderDBuffer"><a href="#RenderDBuffer" class="headerlink" title="RenderDBuffer"></a>RenderDBuffer</h2><p>如果需要深度贴图则绑定一个DBuffer，需要接受Decal的也在这里渲染</p>
<figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//如果开启Dbuffer</span><br><span class="hljs-keyword">if</span> (!hdCamera.frameSettings.enableDBuffer)<br>  <span class="hljs-keyword">return</span>;<br><br><br>  <span class="hljs-comment">// We need to copy depth buffer texture if we want to bind it at this stage</span><br><span class="hljs-comment">// 复制了一份CameraDepthStencil</span><br>  CopyDepthBufferIfNeeded(cmd);<br><br>  <span class="hljs-comment">// Depth texture is now ready, bind it. 把复制得到的深度设置成全局深度</span><br><span class="hljs-comment">// _CameraDepthTexture在这里生产</span><br>  cmd.SetGlobalTexture(HDShaderIDs._CameraDepthTexture, GetDepthTexture());<br>  m_DbufferManager.ClearTargets(cmd, hdCamera);<br>  HDUtils.SetRenderTarget(cmd, hdCamera, m_DbufferManager.GetBuffersRTI(), m_CameraDepthStencilBuffer); <span class="hljs-comment">// do not clear anymore</span><br>  m_DbufferManager.SetHTile(m_DbufferManager.bufferCount, cmd);<br>  renderContext.ExecuteCommandBuffer(cmd);<br>  cmd.Clear();<br><br><span class="hljs-comment">// 渲染空pass  绘制DBufferMesh Pass decal？</span><br><span class="hljs-comment">// 使用——MeshDecalsPass 渲染一个_DecalHTileTexture纹理</span><br>  DrawRendererSettings drawSettings = <span class="hljs-keyword">new</span> DrawRendererSettings(hdCamera.camera, HDShaderPassNames.s_EmptyName)<br>  &#123;<br>    rendererConfiguration = <span class="hljs-number">0</span>,<br>    sorting = &#123; flags = SortFlags.CommonOpaque &#125;<br>  &#125;;<br>  drawSettings.SetShaderPassName(<span class="hljs-number">0</span>, HDShaderPassNames.s_MeshDecalsName);<br>  FilterRenderersSettings filterRenderersSettings = <span class="hljs-keyword">new</span> FilterRenderersSettings(<span class="hljs-literal">true</span>)<br>  &#123;<br>    renderQueueRange = HDRenderQueue.k_RenderQueue_AllOpaque<br>  &#125;;<br><span class="hljs-comment">// 渲染需要接受decal的物体</span><br>  renderContext.DrawRenderers(cullResults.visibleRenderers, <span class="hljs-keyword">ref</span> drawSettings, filterRenderersSettings);<br><br><span class="hljs-comment">// 渲染Decal到Dbuffer  HtileDepth？</span><br>  DecalSystem.instance.RenderIntoDBuffer(cmd);<br>  m_DbufferManager.UnSetHTile(cmd);<br>  m_DbufferManager.SetHTileTexture(cmd);  <span class="hljs-comment">// mask per 8x8 tile used for optimization when looking up dbuffer values</span><br><br></code></pre></td></tr></table></figure>



<h2 id="RenderGBuffer"><a href="#RenderGBuffer" class="headerlink" title="RenderGBuffer"></a>RenderGBuffer</h2><figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 只渲染前向物体</span><br><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableForwardRenderingOnly)<br>  <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 设置Gbuffer目标，和深度</span><br>HDUtils.SetRenderTarget(cmd, hdCamera, m_GbufferManager.GetBuffersRTI(enableShadowMask), m_CameraDepthStencilBuffer);<br><span class="hljs-comment">// 进行渲染，渲染的过程填充深度</span><br>RenderOpaqueRenderList(cull, hdCamera, renderContext, cmd, HDShaderPassNames.s_GBufferName, m_currentRendererConfigurationBakedLighting, HDRenderQueue.k_RenderQueue_AllOpaque);<br><span class="hljs-comment">// 设置Gbuffer _GBufferTexture0 - 4</span><br>m_GbufferManager.BindBufferAsTextures(cmd);<br></code></pre></td></tr></table></figure>



<h2 id="RenderDepthPyramid"><a href="#RenderDepthPyramid" class="headerlink" title="RenderDepthPyramid"></a>RenderDepthPyramid</h2><p>computeShader计算深度金字塔</p>
<h2 id="RenderObjectsVelocity"><a href="#RenderObjectsVelocity" class="headerlink" title="RenderObjectsVelocity"></a>RenderObjectsVelocity</h2><p>渲染物体速度			</p>
<h2 id="RenderCameraVelocity"><a href="#RenderCameraVelocity" class="headerlink" title="RenderCameraVelocity"></a>RenderCameraVelocity</h2><p>渲染摄像机速度</p>
<p>##cmd.SetGlobalTexture();</p>
<p>设置全局深度贴图</p>
<h2 id="RenderSSAO"><a href="#RenderSSAO" class="headerlink" title="RenderSSAO"></a>RenderSSAO</h2><p>SSAO, Shadow, Build light list, deferred shadow, material and light classification can be parallelize with Async compute</p>
<p>同时计算各种效果</p>
<h2 id="m-VolumetricLightingSystem"><a href="#m-VolumetricLightingSystem" class="headerlink" title="m_VolumetricLightingSystem"></a>m_VolumetricLightingSystem</h2><p>和体积光相关的操作</p>
<h2 id="m-LightLoop-RenderShadows"><a href="#m-LightLoop-RenderShadows" class="headerlink" title="m_LightLoop.RenderShadows"></a>m_LightLoop.RenderShadows</h2><p>渲染阴影</p>
<h2 id="m-LightLoop-RenderDeferredDirectionalShadow"><a href="#m-LightLoop-RenderDeferredDirectionalShadow" class="headerlink" title="m_LightLoop.RenderDeferredDirectionalShadow"></a>m_LightLoop.RenderDeferredDirectionalShadow</h2><h2 id="RenderDeferredLighting"><a href="#RenderDeferredLighting" class="headerlink" title="RenderDeferredLighting"></a>RenderDeferredLighting</h2><p>计算deferred物体光照 </p>
<p>实现了ComputeShader和Shader两个版本的Deferred计算。</p>
<h2 id="RenderForward"><a href="#RenderForward" class="headerlink" title="RenderForward"></a>RenderForward</h2><p>ForwardPass.Opaque Pass</p>
<p>在不同模式下的渲染：</p>
<p>在RenderForward的过程中，渲染那个pass会根据设置不同发生改变。</p>
<p>如果启用ForwardOnly Rnedering，那么Forward和ForwardOnly就都会渲染，无论是不透明物体还是透明物体。</p>
<p>如果是Deferred模式，那么对于transparent Forward和ForwardOnly就都会渲染，对于opaque就只会渲染ForwardOnly。</p>
<p>所以ForwardOnly 和Forward是互斥的。</p>
<figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// Debug相关内容</span><br><span class="hljs-built_in">string</span> profileName;<br><span class="hljs-keyword">if</span> (m_CurrentDebugDisplaySettings.IsDebugDisplayEnabled())<br>&#123;<br>  profileName = k_ForwardPassDebugName[(<span class="hljs-built_in">int</span>)pass];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>  profileName = k_ForwardPassName[(<span class="hljs-built_in">int</span>)pass];<br>&#125;<br><br><br><span class="hljs-comment">// 获取摄像机</span><br><span class="hljs-keyword">var</span> camera = hdCamera.camera;<br><br><span class="hljs-comment">// ???????</span><br>m_LightLoop.RenderForward(camera, cmd, pass == ForwardPass.Opaque);<br><br><span class="hljs-comment">// 屏幕空间Tracing</span><br><span class="hljs-keyword">var</span> debugScreenSpaceTracing = m_CurrentDebugDisplaySettings.fullScreenDebugMode == FullScreenDebugMode.ScreenSpaceTracing;<br><br><span class="hljs-comment">// 不透明物体</span><br><span class="hljs-keyword">if</span> (pass == ForwardPass.Opaque)<br>&#123;<br>  <span class="hljs-comment">// 使用SSS效果</span><br>  <span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableSubsurfaceScattering)<br>  &#123;<br>    RenderTargetIdentifier[] m_MRTWithSSS = <span class="hljs-keyword">new</span> RenderTargetIdentifier[<span class="hljs-number">2</span> + m_SSSBufferManager.sssBufferCount];<br>    <span class="hljs-comment">// 准备所有的SSS需要的buffer</span><br>    m_MRTWithSSS[<span class="hljs-number">0</span>] = m_CameraColorBuffer; <span class="hljs-comment">// Store the specular color</span><br>    m_MRTWithSSS[<span class="hljs-number">1</span>] = m_CameraSssDiffuseLightingBuffer;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; m_SSSBufferManager.sssBufferCount; ++i)<br>    &#123;<br>      m_MRTWithSSS[i + <span class="hljs-number">2</span>] = m_SSSBufferManager.GetSSSBuffer(i);<br>    &#125;<br><br>    HDUtils.SetRenderTarget(cmd, hdCamera, m_MRTWithSSS, m_CameraDepthStencilBuffer);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>	<span class="hljs-comment">//不使用SSS效果，则就是用一般的Depth和COlorbuffer</span><br>    HDUtils.SetRenderTarget(cmd, hdCamera, m_CameraColorBuffer, m_CameraDepthStencilBuffer);<br>  &#125;<br><br>  <span class="hljs-comment">//根据渲染设置使用不同的Forwardpass  ： ForwardOnly Or Forward</span><br>  <span class="hljs-keyword">var</span> passNames = hdCamera.frameSettings.enableForwardRenderingOnly<br>    ? m_ForwardAndForwardOnlyPassNames<br>    : m_ForwardOnlyPassNames;<br>  <span class="hljs-comment">// 调试模式</span><br>  <span class="hljs-keyword">var</span> debugSSTThisPass = debugScreenSpaceTracing &amp;&amp; (m_CurrentDebugDisplaySettings.lightingDebugSettings.debugLightingMode == DebugLightingMode.ScreenSpaceTracingReflection);<br><br>  <span class="hljs-keyword">if</span> (debugSSTThisPass)<br>    cmd.SetRandomWriteTarget(<span class="hljs-number">7</span>, m_DebugScreenSpaceTracingData);<br>  <br>  <span class="hljs-comment">// 渲染不透明物体</span><br>  RenderOpaqueRenderList(cullResults, hdCamera, renderContext, cmd, passNames, m_currentRendererConfigurationBakedLighting);<br>  <br>  <span class="hljs-keyword">if</span> (debugSSTThisPass)<br>    cmd.ClearRandomWriteTargets();<br>&#125;<br><span class="hljs-comment">//渲染透明物体</span><br><span class="hljs-keyword">else</span><br>&#123;<br>  <span class="hljs-comment">// 设置透明物体渲染目标</span><br>  HDUtils.SetRenderTarget(cmd, hdCamera, m_CameraColorBuffer, m_CameraDepthStencilBuffer);<br>  <span class="hljs-comment">// 使用dbuffer 并且有Decal 则SetAtlas？？？？</span><br>  <span class="hljs-keyword">if</span> ((hdCamera.frameSettings.enableDBuffer) &amp;&amp; (DecalSystem.m_DecalDatasCount &gt; <span class="hljs-number">0</span>)) <br>  &#123;<br>    DecalSystem.instance.SetAtlas(cmd); <span class="hljs-comment">// for clustered decals</span><br>  &#125;<br><br>  <span class="hljs-keyword">var</span> debugSSTThisPass = debugScreenSpaceTracing &amp;&amp; (m_CurrentDebugDisplaySettings.lightingDebugSettings.debugLightingMode == DebugLightingMode.ScreenSpaceTracingRefraction);<br>  <span class="hljs-keyword">if</span> (debugSSTThisPass)<br>    cmd.SetRandomWriteTarget(<span class="hljs-number">7</span>, m_DebugScreenSpaceTracingData);<br>  <br>  <span class="hljs-comment">// 渲染透明物体</span><br>  RenderTransparentRenderList(cullResults, hdCamera, renderContext, cmd, m_AllTransparentPassNames, m_currentRendererConfigurationBakedLighting, pass == ForwardPass.PreRefraction ? HDRenderQueue.k_RenderQueue_PreRefraction : HDRenderQueue.k_RenderQueue_Transparent);<br>  <br>  <span class="hljs-keyword">if</span> (debugSSTThisPass)<br>    cmd.ClearRandomWriteTargets();<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//渲染的ShaderPass</span><br>   var passNames = hdCamera.frameSettings.enableForwardRenderingOnly<br>                        ? m_ForwardAndForwardOnlyPassNames<br>                        : m_ForwardOnlyPassNames;<br><br><span class="hljs-comment">// HDShaderPassNames.s_SRPDefaultUnlitName  是一个FallBack</span><br>ShaderPassName[] m_ForwardAndForwardOnlyPassNames = &#123; HDShaderPassNames.s_ForwardOnlyName, <br>                                                     HDShaderPassNames.s_ForwardName, <br>                                                     HDShaderPassNames.s_SRPDefaultUnlitName &#125;;<br>ShaderPassName[] m_ForwardOnlyPassNames = &#123; HDShaderPassNames.s_ForwardOnlyName, <br>                                           HDShaderPassNames.s_SRPDefaultUnlitName &#125;;<br><br><span class="hljs-comment">// 渲染队列</span><br>RenderQueueRange k_RenderQueue_AllOpaque = new RenderQueueRange &#123; <br>  min = (<span class="hljs-type">int</span>)Priority.Opaque,    <span class="hljs-number">2000</span><br>  max = (<span class="hljs-type">int</span>)Priority.OpaqueLast &#125;; <span class="hljs-number">2500</span><br></code></pre></td></tr></table></figure>



<h2 id="RenderSky"><a href="#RenderSky" class="headerlink" title="RenderSky"></a>RenderSky</h2><h2 id="RenderForward-1"><a href="#RenderForward-1" class="headerlink" title="RenderForward"></a>RenderForward</h2><p>forwardPass.PreRefraction Pass</p>
<figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//渲染的pass</span><br>ShaderPassName[] m_AllTransparentPassNames = &#123;  HDShaderPassNames.s_TransparentBackfaceName,<br>                                                        HDShaderPassNames.s_ForwardOnlyName,<br>                                                        HDShaderPassNames.s_ForwardName,<br>                                                        HDShaderPassNames.s_SRPDefaultUnlitName &#125;;<br><span class="hljs-comment">// 渲染队列</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> RenderQueueRange k_RenderQueue_Transparent = <span class="hljs-keyword">new</span> RenderQueueRange &#123; <br>   min = (<span class="hljs-built_in">int</span>)Priority.PreRefractionFirst,  <span class="hljs-number">2750</span> - <span class="hljs-number">100</span><br>   max = (<span class="hljs-built_in">int</span>)Priority.PreRefractionLast &#125;; <span class="hljs-number">2750</span> + <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure>





<h2 id="RenderColorPyramid"><a href="#RenderColorPyramid" class="headerlink" title="RenderColorPyramid"></a>RenderColorPyramid</h2><p>Gpu计算,会根据是否需要Bloom，Distortion，SSR等内容来判断是否使用。</p>
<figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">RenderColorPyramid(hdCamera, cmd, renderContext, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>





<h2 id="RenderForward-2"><a href="#RenderForward-2" class="headerlink" title="RenderForward"></a>RenderForward</h2><p>ForwardPass.Transparent Pass</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">ShaderPassName[] m_AllTransparentPassNames = &#123;  							HDShaderPassNames.s_TransparentBackfaceName,<br>                                                        HDShaderPassNames.s_ForwardOnlyName,<br>                                                        HDShaderPassNames.s_ForwardName,<br>                                                        HDShaderPassNames.s_SRPDefaultUnlitName &#125;;<br><br><span class="hljs-comment">//渲染队列</span><br> public <span class="hljs-type">static</span> readonly RenderQueueRange k_RenderQueue_PreRefraction = new RenderQueueRange &#123; min = (<span class="hljs-type">int</span>)Priority.TransparentFirst,     <span class="hljs-number">3000</span> - <span class="hljs-number">100</span><br>max = (<span class="hljs-type">int</span>)Priority. TransparentLast&#125;;    <span class="hljs-number">3000</span> + <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure>

<p>##RednerTransparentDepthPostpass</p>
<figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (!hdCamera.frameSettings.enableTransparentPostpass)<br><span class="hljs-keyword">return</span>;<br><br><br>HDUtils.SetRenderTarget(cmd, hdCamera, m_CameraDepthStencilBuffer);<br>RenderTransparentRenderList(cullResults, hdCamera, renderContext, cmd, m_TransparentDepthPostpassNames);<br><br><span class="hljs-comment">//使用Pass</span><br>TransparentDepthPostpass<br></code></pre></td></tr></table></figure>
<p>##RenderColorPyramid</p>
<figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">RenderColorPyramid(hdCamera, cmd, renderContext, <span class="hljs-literal">false</span>); <br></code></pre></td></tr></table></figure>



<h2 id="渲染错误的Pass"><a href="#渲染错误的Pass" class="headerlink" title="渲染错误的Pass"></a>渲染错误的Pass</h2><p>都是之前遗留的PassName</p>
<pre><code>    public static readonly ShaderPassName s_AlwaysName = new ShaderPassName(&quot;Always&quot;);
    public static readonly ShaderPassName s_ForwardBaseName = new ShaderPassName(&quot;ForwardBase&quot;);
    public static readonly ShaderPassName s_DeferredName = new ShaderPassName(&quot;Deferred&quot;);
    public static readonly ShaderPassName s_PrepassBaseName = new ShaderPassName(&quot;PrepassBase&quot;);
    public static readonly ShaderPassName s_VertexName = new ShaderPassName(&quot;Vertex&quot;);
    public static readonly ShaderPassName s_VertexLMRGBMName = new ShaderPassName(&quot;VertexLMRGBM&quot;);
    public static readonly ShaderPassName s_VertexLMName = new ShaderPassName(&quot;VertexLM&quot;);
</code></pre>
<h2 id="AccumulateDistortion-amp-RenderDistortion"><a href="#AccumulateDistortion-amp-RenderDistortion" class="headerlink" title="AccumulateDistortion &amp; RenderDistortion"></a>AccumulateDistortion &amp; RenderDistortion</h2><p>失真计算？</p>
<h2 id="RenderPostProcess"><a href="#RenderPostProcess" class="headerlink" title="RenderPostProcess"></a>RenderPostProcess</h2><p>后处理</p>
<h2 id="进一步调用"><a href="#进一步调用" class="headerlink" title="进一步调用"></a>进一步调用</h2><h3 id="RenderOpaqueRenderList"><a href="#RenderOpaqueRenderList" class="headerlink" title="RenderOpaqueRenderList"></a>RenderOpaqueRenderList</h3><figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderTransparentRenderList</span>(<span class="hljs-params">CullResults cull,</span></span><br><span class="hljs-params"><span class="hljs-function">            HDCamera hdCamera,</span></span><br><span class="hljs-params"><span class="hljs-function">            ScriptableRenderContext renderContext,</span></span><br><span class="hljs-params"><span class="hljs-function">            CommandBuffer cmd,</span></span><br><span class="hljs-params"><span class="hljs-function">            ShaderPassName passName,</span></span><br><span class="hljs-params"><span class="hljs-function">            RendererConfiguration rendererConfiguration = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            RenderQueueRange? inRenderQueueRange = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            RenderStateBlock? stateBlock = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            Material overrideMaterial = <span class="hljs-literal">null</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                 </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">void</span> RenderTransparentRenderList(CullResults cull,</span></span><br><span class="hljs-params"><span class="hljs-function">            HDCamera hdCamera,</span></span><br><span class="hljs-params"><span class="hljs-function">            ScriptableRenderContext renderContext,</span></span><br><span class="hljs-params"><span class="hljs-function">            CommandBuffer cmd, </span></span><br><span class="hljs-params"><span class="hljs-function">            ShaderPassName[] passName,   //  多个pass</span></span><br><span class="hljs-params"><span class="hljs-function">            RendererConfiguration rendererConfiguration = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            RenderQueueRange? inRenderQueueRange = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            RenderStateBlock? stateBlock = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            Material overrideMaterial = <span class="hljs-literal">null</span></span></span><br></code></pre></td></tr></table></figure>

<figure class="hljs highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 想要渲染不都名物体 </span><br><span class="hljs-keyword">if</span> (!hdCamera.frameSettings.enableOpaqueObjects)<br>     <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// DrawRender 不再Command当中渲染，所以想把之前的做完。</span><br>renderContext.ExecuteCommandBuffer(cmd);<br>cmd.Clear();<br><br><span class="hljs-comment">// 设置绘制参数，排序方式</span><br><span class="hljs-keyword">var</span> drawSettings = <span class="hljs-keyword">new</span> DrawRendererSettings(hdCamera.camera, HDShaderPassNames.s_EmptyName)<br>&#123;<br>  rendererConfiguration = rendererConfiguration,<br>  sorting = &#123; flags = SortFlags.CommonOpaque &#125;<br>&#125;;<br><br><span class="hljs-comment">// 收集需要渲染的pass Name</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; passNames.Length; ++i)<br>&#123;<br>  drawSettings.SetShaderPassName(i, passNames[i]);<br>&#125;<br><br><span class="hljs-comment">// 设置全局材质，渲染某些通用效果的时候使用</span><br><span class="hljs-keyword">if</span> (overrideMaterial != <span class="hljs-literal">null</span>)<br>  drawSettings.SetOverrideMaterial(overrideMaterial, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 渲染队列，指定还是范围</span><br><span class="hljs-keyword">var</span> filterSettings = <span class="hljs-keyword">new</span> FilterRenderersSettings(<span class="hljs-literal">true</span>)<br>&#123;<br>  renderQueueRange = inRenderQueueRange == <span class="hljs-literal">null</span> ? <br>    HDRenderQueue.k_RenderQueue_AllOpaque : inRenderQueueRange.Value<br>      <span class="hljs-comment">//2000 -  2500</span><br>&#125;;<br><br><span class="hljs-keyword">if</span> (stateBlock == <span class="hljs-literal">null</span>)<br>  renderContext.DrawRenderers(cull.visibleRenderers, <span class="hljs-keyword">ref</span> drawSettings, filterSettings);<br><span class="hljs-keyword">else</span><br>  renderContext.DrawRenderers(cull.visibleRenderers, <span class="hljs-keyword">ref</span> drawSettings, filterSettings, stateBlock.Value);<br></code></pre></td></tr></table></figure>



<p>###RenderTransparentRenderList</p>
<h1 id="初始化与HDRenderPipelineAsset"><a href="#初始化与HDRenderPipelineAsset" class="headerlink" title="初始化与HDRenderPipelineAsset"></a>初始化与HDRenderPipelineAsset</h1>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  
  <nav class="page-nav">
    <div class="page-nav-next page-nav-item">
      
      <a href="/2022/07/09/HDRPsource/3.%E6%B8%B2%E6%9F%93%E5%8F%82%E6%95%B0/" rel="next" title="渲染队列"><i class="fas fa-angle-left"></i><span class="nav-title">渲染队列</span></a>
      
    </div>
    <div class="page-nav-prev page-nav-item">
      
      <a href="/2022/07/09/HDRPsource/10.Lighting%E8%AE%BE%E7%BD%AE/" rel="prev" title="光照设置"><span class="nav-title">光照设置</span><i class="fas fa-angle-right"></i></a>
      
    </div>
  </nav>
  
  
  

<div class="comments" id="comments">
  
  
  <div class="commentjs" id="comment-thread"></div>
  <link rel="stylesheet" href="/css/commentjs.css">
  <script defer type="text/javascript" src="/js/marked.min.js"></script>
  <script defer type="text/javascript" src="/js/timeago.min.js"></script>
  <script defer type="text/javascript" src="/js/highlight.min.js"></script>
  <script defer type="text/javascript" src="/js/commentjs.js"></script>
  <script type="text/javascript">
  $(document).ready(function () {
    getComments({
      "type": "github",
      "user": "leinlin",
      "repo": "leinlin.github.io",
      "client_id": "aee134bdfb54c4ef5826",
      "client_secret": "4af1d3f2b82dccc028c49715becc01e611afbe43",
      "no_comment": "这个页面还没有评论，现在就去评论吧！",
      "go_to_comment": "去评论",
      "issue_title": "代码结构",
      "btn_class": "button",
      "comments_target": "#comment-thread"
    });
    marked.setOptions({
      "highlight": function (code, lang) {
        return hljs.highlightAuto(code).value;
      }
    });
    function mark() {
      var markdowns = document.getElementsByClassName("markdown");
      for (var i = 0; i < markdowns.length; ++i){
        if (markdowns[i].innerHTML) {
          markdowns[i].innerHTML = marked(markdowns[i].innerHTML);
        }
      }
    }
    window.addEventListener("DOMContentLoaded", mark, false);
    window.addEventListener("load", mark, false);
  });
  </script>
  
  
</div>



  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control"/>
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/avatar.jpg" alt="leinlin">
  
  <h1 class="author-name">leinlin</h1>
  <h2 class="author-description"></h2>
  <div class="site-count">
    
    
    
    
    <div class="categories-count count-block">
      <div class="site-count-title">分类</div>
      <div><a href="/categories/">17</a></div>
    </div>
    
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    
    
    
    <hr>
    <div class="post-toc sidebar-item" id="toc-div">
      <div><i class="fas fa-list-ol"></i>文章目录</div>
      <div class="post-toc-content"><ol class="list-group toc"><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84"><span class="toc-text">代码结构</span></a></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#Render%E6%96%B9%E6%B3%95"><span class="toc-text">Render方法</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#render%E4%B8%BB%E8%A6%81%E8%BF%87%E7%A8%8B"><span class="toc-text">render主要过程</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#%E4%B8%BA%E6%AF%8F%E4%B8%AA%E6%91%84%E5%83%8F%E6%9C%BA%E5%BE%AA%E7%8E%AF%E6%B8%B2%E6%9F%93"><span class="toc-text">为每个摄像机循环渲染</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#%E5%87%86%E5%A4%87%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">准备设置参数</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#%E5%A1%AB%E5%85%85CommandBuffer%E6%9D%A5%E6%8C%87%E5%AE%9A%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="toc-text">填充CommandBuffer来指定渲染过程</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#%E5%89%AA%E8%A3%81"><span class="toc-text">剪裁</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%A7%8B%E6%B8%B2%E6%9F%93-%E5%BF%85%E8%A6%81%E9%83%A8%E5%88%861"><span class="toc-text">正式开始渲染:必要部分1</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#%E5%85%B7%E4%BD%93%E6%B8%B2%E6%9F%93%E6%96%B9%E6%B3%95"><span class="toc-text">具体渲染方法</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#RenderDepthPrepass"><span class="toc-text">RenderDepthPrepass</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#RenderDBuffer"><span class="toc-text">RenderDBuffer</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#RenderGBuffer"><span class="toc-text">RenderGBuffer</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#RenderDepthPyramid"><span class="toc-text">RenderDepthPyramid</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#RenderObjectsVelocity"><span class="toc-text">RenderObjectsVelocity</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#RenderCameraVelocity"><span class="toc-text">RenderCameraVelocity</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#RenderSSAO"><span class="toc-text">RenderSSAO</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#m-VolumetricLightingSystem"><span class="toc-text">m_VolumetricLightingSystem</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#m-LightLoop-RenderShadows"><span class="toc-text">m_LightLoop.RenderShadows</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#m-LightLoop-RenderDeferredDirectionalShadow"><span class="toc-text">m_LightLoop.RenderDeferredDirectionalShadow</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#RenderDeferredLighting"><span class="toc-text">RenderDeferredLighting</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#RenderForward"><span class="toc-text">RenderForward</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#RenderSky"><span class="toc-text">RenderSky</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#RenderForward-1"><span class="toc-text">RenderForward</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#RenderColorPyramid"><span class="toc-text">RenderColorPyramid</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#RenderForward-2"><span class="toc-text">RenderForward</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#%E6%B8%B2%E6%9F%93%E9%94%99%E8%AF%AF%E7%9A%84Pass"><span class="toc-text">渲染错误的Pass</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#AccumulateDistortion-amp-RenderDistortion"><span class="toc-text">AccumulateDistortion &amp; RenderDistortion</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#RenderPostProcess"><span class="toc-text">RenderPostProcess</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%B0%83%E7%94%A8"><span class="toc-text">进一步调用</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#RenderOpaqueRenderList"><span class="toc-text">RenderOpaqueRenderList</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8EHDRenderPipelineAsset"><span class="toc-text">初始化与HDRenderPipelineAsset</span></a></li></ol></div>
    </div>
    
    
    
    <hr>
    <div class="social-link sidebar-item">
      <div><i class="far fa-address-card"></i>社交链接</p></div>
      <ul>
        
        <li><i class="fab fa-github"></i><a href="https://leinlin.github.com/" target="_blank">GitHub</a></li>
        
      </ul>
    </div>
    
    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <button id="back-to-top"><i class="fas fa-angle-double-up" aria-label="回到顶部"></i></button>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">leinlin</span><span class="year"><i class="far fa-copyright"></i>2022</span>
        </div>
        
        <div class="busuanzi">
          <span id="busuanzi_container_site_pv"><i class="fas fa-eye" aria-label="站点点击量" aria-hidden="false"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user" aria-label="站点用户数" aria-hidden="false"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv" aria-label="页面点击量" aria-hidden="false"></span></span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
