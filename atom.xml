<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>leinlin的小笔记</title>
  
  
  <link href="http://leinlin.github.io/atom.xml" rel="self"/>
  
  <link href="http://leinlin.github.io/"/>
  <updated>2022-07-13T06:47:49.855Z</updated>
  <id>http://leinlin.github.io/</id>
  
  <author>
    <name>leinlin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IDVS shader variants</title>
    <link href="http://leinlin.github.io/2022/07/13/ARM/IDVS-shader-variants/"/>
    <id>http://leinlin.github.io/2022/07/13/ARM/IDVS-shader-variants/</id>
    <published>2022-07-12T22:57:19.000Z</published>
    <updated>2022-07-13T06:47:49.855Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;IDVS-shader-variants&quot;&gt;&lt;a href=&quot;#IDVS-shader-variants&quot; class=&quot;headerlink&quot; title=&quot;IDVS shader variants&quot;&gt;&lt;/a&gt;IDVS shader</summary>
        
      
    
    
    
    <category term="mali gpu" scheme="http://leinlin.github.io/categories/mali-gpu/"/>
    
    
    <category term="mali" scheme="http://leinlin.github.io/tags/mali/"/>
    
    <category term="IDVS" scheme="http://leinlin.github.io/tags/IDVS/"/>
    
  </entry>
  
  <entry>
    <title>Mali Bifrost Family Performance Counters</title>
    <link href="http://leinlin.github.io/2022/07/11/ARM/mali-bifrost-family-performance-counters/"/>
    <id>http://leinlin.github.io/2022/07/11/ARM/mali-bifrost-family-performance-counters/</id>
    <published>2022-07-11T01:57:19.000Z</published>
    <updated>2022-07-13T06:43:36.040Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Mali-Bifrost-Family-Performance-Counters&quot;&gt;&lt;a href=&quot;#Mali-Bifrost-Family-Performance-Counters&quot; class=&quot;headerlink&quot; title=&quot;Mali Bifrost Family Performance Counters&quot;&gt;&lt;/a&gt;Mali Bifrost Family Performance Counters&lt;/h1&gt;&lt;p&gt;Analysis and optimization of graphics and compute content running on a GPU is an important task when trying to build a top quality system integration, or a compelling high performance application. For developers working with the public APIs, such as OpenGL ES and OpenCL, the GPU is a black box which is very difficult to analyze based solely on the API visible behaviors. Frame pipelining and asynchronous processing of submitted work effectively decouple the application’s visible performance from the API calls which define the workload being executed, making analysis of performance an activity based on expert knowledge and intuition rather than direct measurement.&lt;/p&gt;
&lt;p&gt;Tools such as ARM DS-5 Streamline provide developers access to the GPU hardware performance counters, the principle means to determine the behavior inside the black box beneath the API and identify any problem areas which need optimization. This work guide assumes that DS-5 Streamline is the tool being used for performance analysis, and follows the DS-5 naming conventions for the counters.&lt;/p&gt;
&lt;h2 id=&quot;1-Performance-Counter-Infrastructure&quot;&gt;&lt;a href=&quot;#1-Performance-Counter-Infrastructure&quot; class=&quot;headerlink&quot; title=&quot;1 Performance Counter Infrastructure&quot;&gt;&lt;/a&gt;1 Performance Counter Infrastructure&lt;/h2&gt;&lt;p&gt;The Bifrost GPU family supports many performance counters which can all be captured simultaneously. Performance counters are provided for each functional block in the design:&lt;/p&gt;
&lt;p&gt;Job Manager&lt;br&gt;Tiler&lt;br&gt;Shader core(s)&lt;br&gt;L2 cache(s)&lt;br&gt;See my earlier blog series for an introduction to the Bifrost GPU architecture - it introduces some of the fundamental concepts which are important to understand, and which place the more detailed information in this document in context.&lt;/p&gt;
&lt;p&gt;The Mali GPU: An Abstract Machine, Part 1 - Frame Pipelining&lt;br&gt;The Mali GPU: An Abstract Machine, Part 2 - Tile-based Rendering&lt;br&gt;The Mali GPU: An Abstract Machine, Part 4 - The Bifrost Shader Core&lt;/p&gt;
&lt;h3 id=&quot;1-1-Supported-Counters&quot;&gt;&lt;a href=&quot;#1-1-Supported-Counters&quot; class=&quot;headerlink&quot; title=&quot;1.1 Supported Counters&quot;&gt;&lt;/a&gt;1.1 Supported Counters&lt;/h3&gt;&lt;p&gt;The GPUs in the Bifrost family implement a large number of performance counters natively in the hardware, and it is also generally useful to generate some derived counters by combining one or more of the raw hardware counters in useful and interesting ways. This document will describe all of the counters exported from DS-5 Streamline, and some of the useful derived counters which can be derived from them. DS-5 Streamline allows custom performance counter graphs to be created using equations, so all of these performance counters can be directly visualized in the GUI.&lt;/p&gt;
&lt;h3 id=&quot;1-2-Counter-Implementation-Caveats&quot;&gt;&lt;a href=&quot;#1-2-Counter-Implementation-Caveats&quot; class=&quot;headerlink&quot; title=&quot;1.2 Counter Implementation Caveats&quot;&gt;&lt;/a&gt;1.2 Counter Implementation Caveats&lt;/h3&gt;&lt;p&gt;The hardware counter implementation in the GPU is designed to be low cost, such that it has minimal impact on performance and power. Many of the counters are close approximations of the behavior described in this document in order to minimize the amount of additional hardware logic required to generate the counter signals, so some small deviations from what you may expect may be encountered.&lt;/p&gt;</summary>
    
    
    
    <category term="mali gpu" scheme="http://leinlin.github.io/categories/mali-gpu/"/>
    
    
    <category term="mali" scheme="http://leinlin.github.io/tags/mali/"/>
    
    <category term="Gpu Counters" scheme="http://leinlin.github.io/tags/Gpu-Counters/"/>
    
    <category term="Bifrost" scheme="http://leinlin.github.io/tags/Bifrost/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://leinlin.github.io/2022/07/09/GPUAartch/%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%E5%9C%A8GPU%E4%B8%AD%E7%9A%84%E4%B8%80%E7%94%9F/"/>
    <id>http://leinlin.github.io/2022/07/09/GPUAartch/%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%E5%9C%A8GPU%E4%B8%AD%E7%9A%84%E4%B8%80%E7%94%9F/</id>
    <published>2022-07-09T11:34:20.502Z</published>
    <updated>2022-07-09T12:04:26.229Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;一个三角形在GPU中的一生&quot;&gt;&lt;a href=&quot;#一个三角形在GPU中的一生&quot; class=&quot;headerlink&quot; title=&quot;一个三角形在GPU中的一生&quot;&gt;&lt;/a&gt;一个三角形在GPU中的一生&lt;/h1&gt;&lt;p&gt;这篇笔记总结自&lt;a href=&quot;https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline&quot;&gt;Life of a triangle - NVIDIA’s logical pipeline&lt;/a&gt; 和知乎文章&lt;a href=&quot;https://blog.uwa4d.com/archives/USparkle_GPU.html&quot;&gt;渲染优化-从GPU的结构谈起&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;主要记录了GPU硬件是如何详细的工作的。另外附加了一些笔记和自己的理解。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;先进的Fermi架构已经发布十年了（2010年左右发布），现在是时候更新它的基础图形架构了。&lt;/p&gt;
&lt;p&gt;Fermi是Nvidia的第一个实现了完全可扩展的图形引擎（fully scalable graphics engine的概念请查阅wiki，有说明），在Kepler和Maxwell架构当中也能找到他的影子。&lt;/p&gt;
&lt;p&gt;下面的文章，特别是下面的“精简的管道知识”图片，应该作为各种学习材料的。这篇文章主要从图形的角度讨论GPU是如何工作的，尤其是一些原则，比如：着色程序代码是如何执行的，对于计算来说是一样的。&lt;/p&gt;
&lt;h2 id=&quot;GPU管线架构&quot;&gt;&lt;a href=&quot;#GPU管线架构&quot; class=&quot;headerlink&quot; title=&quot;GPU管线架构&quot;&gt;&lt;/a&gt;GPU管线架构&lt;/h2&gt;&lt;p&gt;下面是一张涵盖了整个GPU架构的图片，后面会详细分开讲解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../images/%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%E5%9C%A8GPU%E4%B8%AD%E7%9A%84%E4%B8%80%E7%94%9F/fermipipeline.png&quot; alt=&quot;NVIDIA&amp;#39;s logical pipeline&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://leinlin.github.io/2022/07/09/GPUAartch/%E7%BA%B9%E7%90%86%E7%BC%93%E5%AD%98/"/>
    <id>http://leinlin.github.io/2022/07/09/GPUAartch/%E7%BA%B9%E7%90%86%E7%BC%93%E5%AD%98/</id>
    <published>2022-07-09T11:34:20.499Z</published>
    <updated>2022-07-09T12:25:14.193Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;纹理缓存&quot;&gt;&lt;a href=&quot;#纹理缓存&quot; class=&quot;headerlink&quot; title=&quot;纹理缓存&quot;&gt;&lt;/a&gt;纹理缓存&lt;/h1&gt;&lt;p&gt;参考文献：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../images/%E7%BA%B9%E7%90%86%E7%BC%93%E5%AD%98/1574825701596.png&quot; alt=&quot;1574825701596&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;纹理缓存是现代GPU的基础组件，是实现实时渲染的性能的重要部分。&lt;/p&gt;
&lt;p&gt;纹理缓存对GPU来说是Read-Only的。主要在texture-mapping阶段由GPU程序读取。&lt;/p&gt;
&lt;p&gt;纹理缓存有很高的命中率，因为相邻像素之间有大量的重用，而且通常位于着色器处理器附近，所以纹理数据具有高吞吐量和低读延迟。&lt;/p&gt;
&lt;p&gt;GPU的架构对程序员是不可见的，特备隐藏在API之下，这些架构包括纹理缓存被频繁的更新，基础的架构如图所示,L1和L2共同构成了GPU的分级内存：&lt;img src=&quot;/../../images/%E7%BA%B9%E7%90%86%E7%BC%93%E5%AD%98/1573179467830.png&quot; alt=&quot;1573179467830&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于上图的描述：&lt;/p&gt;
&lt;p&gt;紫色的部分是Texture Cache。&lt;br&gt;从最上边开始看，Thread Scheduler为不同的图形处理阶段收集任务。然后把任务安排到不同的Graphic Core上。&lt;br&gt;Graphic Core有一些固定功能的图像逻辑（Geometr，Raster），包括了几个处理功能和光栅化功能。&lt;br&gt;接着是Shader，包括了逻辑控制和ALU单元阵列，用于以SIMD的方式处理shader程序。Shader执行阶段使用了L1 数据指令Cache、texture mapping和与其关联的L1Texture Cache。Shader的输出和L1和L2之间需要通过crossbar来传输。&lt;br&gt;Crossbar连接了各种内存单元，包括L2Cache、ROP和内存控制器。内存控制器链接在了保存了framebuffer的外部内存上。大部分相邻的blocks是彼此链接的。&lt;/p&gt;
&lt;p&gt;为了理解对纹理缓存的需求，我们首先要了解影响纹理缓存的功能：texture mapping和rasterization. &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://leinlin.github.io/2022/07/09/GPUAartch/%E8%B0%88%E8%B0%88%E9%82%A3%E4%BA%9Bearly_depth_testing%E6%8A%80%E6%9C%AF/"/>
    <id>http://leinlin.github.io/2022/07/09/GPUAartch/%E8%B0%88%E8%B0%88%E9%82%A3%E4%BA%9Bearly_depth_testing%E6%8A%80%E6%9C%AF/</id>
    <published>2022-07-09T11:34:20.496Z</published>
    <updated>2022-07-09T12:04:12.312Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;谈谈那些early-depth-testing技术（草拟）&quot;&gt;&lt;a href=&quot;#谈谈那些early-depth-testing技术（草拟）&quot; class=&quot;headerlink&quot; title=&quot;谈谈那些early_depth_testing技术（草拟）&quot;&gt;&lt;/a&gt;谈谈那些early_depth_testing技术（草拟）&lt;/h1&gt;&lt;h2 id=&quot;Early-Z（Immediate-Mode-Renderers-IMRs-：Nvidia-：-GeForces-and-Radeons）&quot;&gt;&lt;a href=&quot;#Early-Z（Immediate-Mode-Renderers-IMRs-：Nvidia-：-GeForces-and-Radeons）&quot; class=&quot;headerlink&quot; title=&quot;Early Z（Immediate Mode Renderers (IMRs) ：Nvidia ： GeForces and Radeons）&quot;&gt;&lt;/a&gt;Early Z（Immediate Mode Renderers (IMRs) ：Nvidia ： GeForces and Radeons）&lt;/h2&gt;&lt;p&gt;在OPengl 4.5 强制开启下面是原文。&lt;/p&gt;
&lt;h2 id=&quot;Optimization&quot;&gt;&lt;a href=&quot;#Optimization&quot; class=&quot;headerlink&quot; title=&quot;Optimization&quot;&gt;&lt;/a&gt;Optimization&lt;/h2&gt;&lt;p&gt;Early fragment tests, as an optimization, exist to prevent unnecessary executions of the &lt;a href=&quot;https://www.khronos.org/opengl/wiki/Fragment_Shader&quot;&gt;Fragment Shader&lt;/a&gt;. If a fragment will be discarded based on the &lt;a href=&quot;https://www.khronos.org/opengl/wiki/Depth_Test&quot;&gt;Depth Test&lt;/a&gt; (due perhaps to being behind other geometry), it saves performance to avoid executing the fragment shader. There is specialized hardware that makes this particularly efficient in many GPUs.&lt;/p&gt;
&lt;p&gt;The most effective way to use early depth test hardware is to run a depth-only pre-processing pass. This means to render all available geometry, using minimal shaders and a rendering pipeline that &lt;a href=&quot;https://www.khronos.org/opengl/wiki/Write_Mask&quot;&gt;only writes to the depth buffer&lt;/a&gt;. The &lt;a href=&quot;https://www.khronos.org/opengl/wiki/Vertex_Shader&quot;&gt;Vertex Shader&lt;/a&gt;should do nothing more than transform positions, and the &lt;a href=&quot;https://www.khronos.org/opengl/wiki/Fragment_Shader#Optional&quot;&gt;Fragment Shader does not even need to exist&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This provides the best performance gain if the fragment shader is expensive, or if you intend to use multiple passes across the geometry.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://leinlin.github.io/2022/07/09/GPUAartch/%E6%89%8B%E6%B8%B8GPU%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BC%98%E5%8C%96%E4%B9%8BUnifiedShaderCore/"/>
    <id>http://leinlin.github.io/2022/07/09/GPUAartch/%E6%89%8B%E6%B8%B8GPU%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BC%98%E5%8C%96%E4%B9%8BUnifiedShaderCore/</id>
    <published>2022-07-09T11:34:20.491Z</published>
    <updated>2022-07-09T04:53:34.647Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;手游GPU架构与优化之UnifiedShaderCore&quot;&gt;&lt;a href=&quot;#手游GPU架构与优化之UnifiedShaderCore&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://leinlin.github.io/2022/07/09/GPUAartch/%E6%89%8B%E6%9C%BAGPU%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://leinlin.github.io/2022/07/09/GPUAartch/%E6%89%8B%E6%9C%BAGPU%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BC%98%E5%8C%96/</id>
    <published>2022-07-09T11:34:20.488Z</published>
    <updated>2022-07-09T12:04:05.312Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;手机图形硬件工作方式&quot;&gt;&lt;a href=&quot;#手机图形硬件工作方式&quot; class=&quot;headerlink&quot; title=&quot;手机图形硬件工作方式&quot;&gt;&lt;/a&gt;手机图形硬件工作方式&lt;/h1&gt;&lt;p&gt;这部分内容参考SIGGRAPH 2016，Computer Graphics&amp;amp;Interactive Technique. Course.&lt;/p&gt;
&lt;p&gt;这部分主要是总结&lt;strong&gt;手机硬件的工作方式&lt;/strong&gt;以及&lt;strong&gt;如何来让手机硬件发挥出更高的性能&lt;/strong&gt;。由于没有做过手机开发，所以看完资料在总结上来可能不是很准确。这里只了解了一小部分，后面涉及到再补全。&lt;/p&gt;
&lt;p&gt;首先是在任何平台上面都适用的方法：减少在屏幕上绘制物体的数量：&lt;strong&gt;降低帧率、降低分辨率、只有在需要重新绘制的时候才绘制。这些不在这里讨论&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里讨论的是如何进行&lt;strong&gt;高性能的3D渲染。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;手机芯片&quot;&gt;&lt;a href=&quot;#手机芯片&quot; class=&quot;headerlink&quot; title=&quot;手机芯片&quot;&gt;&lt;/a&gt;手机芯片&lt;/h2&gt;&lt;p&gt;下面是手机架构的一个简介：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../images/img/MobleArchitecture.jpg&quot; alt=&quot;MobleArchitecture&quot;&gt;&lt;/p&gt;
&lt;p&gt;手机的GPU设计通常和PC完全不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手机的GPU通常来说是tiling的（也有例外），有多个Tilers（不知道怎么翻译），PC通常是立即渲染模式（Immediate-mode renderers）。&lt;/li&gt;
&lt;li&gt;手机使用的是系统RAM，而PC使用的是分离的local memory和一个链接到GPU的总线，应该是PCI。&lt;/li&gt;
&lt;li&gt;手机有多核处理器（但是没有太多的超线程技术），大部分为了低能耗做了优化而非高性能。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://leinlin.github.io/2022/07/09/GPUAartch/%E5%85%B3%E4%BA%8ECuda%E3%80%81Shader%E4%B8%ADif%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://leinlin.github.io/2022/07/09/GPUAartch/%E5%85%B3%E4%BA%8ECuda%E3%80%81Shader%E4%B8%ADif%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</id>
    <published>2022-07-09T11:34:20.485Z</published>
    <updated>2022-07-09T12:04:01.862Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;关于Cuda-Shader中if语句执行原理&quot;&gt;&lt;a href=&quot;#关于Cuda-Shader中if语句执行原理&quot; class=&quot;headerlink&quot; title=&quot;关于Cuda\Shader中if语句执行原理&quot;&gt;&lt;/a&gt;关于Cuda\Shader中if语句执行原理&lt;/h1&gt;&lt;p&gt;目前大部分人认为：shader当中动态if判断性能很低，只是用来做条件判断的，要避免使用。实际上if语句是可以用来做性能优化的。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;p&gt;主要来自于几个文档：&lt;/p&gt;
&lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://haifux.org/lectures/267/Introduction-to-GPUs.pdf&quot;&gt;http://haifux.org/lectures/267/Introduction-to-GPUs.pdf&lt;/a&gt; 直接说明了GPU分支是如何工作的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一个是GPU Gems 2当中提到的流控制&lt;a href=&quot;https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter34.html&quot;&gt;Chapter 34. GPU Flow-Control Idioms&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;里面提到了对于Z-cull来说分支和warp分布的关系。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;和GPU分支优化相关的文章：[Reducing_branch_divergence_in_GPU_programs]，上面也提到了分支发散，并且提到了：&lt;/p&gt;
&lt;p&gt;In the presence of a datadependent branch that causes diﬀerent threads in the same warp to follow diﬀerent paths (also known as branch divergence), the warp serially executes each branch path taken, disabling threads that are not on that path.&lt;/p&gt;
&lt;p&gt;说明如果一个Warp没有进行分支发散，是所有warp只走一个分支的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;手机部分GPU架构主要是高通和AMD，目前找到了高通的资料：&lt;a href=&quot;%5Bfile:///C:/Users/liangzhe/Desktop/80-nb295-11_a.pdf%5D(file:///C:/Users/liangzhe/Desktop/80-nb295-11_a.pdf)&quot;&gt;Qualcomm® Snapdragon™ Mobile Platform OpenCL General Programming and Optimization&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里面提到了避免分支发散（Avoid branch divergence）可以从文本中推测出，手机的GPU架构和PC是一样的，有同Warp优化功能，并不会两个分支都走。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;《GPU编程与优化》当中提到没有分支的Warp可以省略空跑分支。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://leinlin.github.io/2022/07/09/GPUAartch/TeraScale%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/"/>
    <id>http://leinlin.github.io/2022/07/09/GPUAartch/TeraScale%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/</id>
    <published>2022-07-09T11:34:20.482Z</published>
    <updated>2022-07-09T12:05:08.235Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;TeraScale&quot;&gt;&lt;a href=&quot;#TeraScale&quot; class=&quot;headerlink&quot; title=&quot;TeraScale&quot;&gt;&lt;/a&gt;TeraScale&lt;/h1&gt;&lt;p&gt;TeraScale架构是AMD公司在2011年之前的早期GPU架构。&lt;/p&gt;
&lt;p&gt;TeraScale使用超长指令字架构。&lt;/p&gt;
&lt;p&gt;使用TeraScale的图形显卡: HD 2000 - 6000 &lt;/p&gt;
&lt;h2 id=&quot;架构拆解&quot;&gt;&lt;a href=&quot;#架构拆解&quot; class=&quot;headerlink&quot; title=&quot;架构拆解&quot;&gt;&lt;/a&gt;架构拆解&lt;/h2&gt;&lt;p&gt;TeraScale的结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../images/img/TelascaleArch.jpg&quot; alt=&quot;TelascaleArch&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面的架构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;包含10个SIMD核心，每一个包括了32个32bit流处理单元，总共320个。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;包括4个纹理单元。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个SIMD core结构示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../images/img/SIMDcore.jpg&quot; alt=&quot;SIMDcore&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面的SIMD core：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;包括了16个Stream Processing Units（标量流处理单元），和16KB的本地数据共享存储器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有一组运行的线程共享一个逻辑控制单元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;四个专用纹理单元和L1 Cache。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是一组Stream Processing Units结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../images/img/StreamProcessingUnits.jpg&quot; alt=&quot;StreamProcessingUnits&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于Stream Processing Units：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有自己的通用寄存器&lt;/li&gt;
&lt;li&gt;我的猜测四个小的黄色格子应该就是ALU。产生指令流水。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://leinlin.github.io/2022/07/09/GPUAartch/Partial_Derivatives(DDX)%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E5%AE%9E%E7%8E%B0%E5%B7%AE%E5%BC%82/"/>
    <id>http://leinlin.github.io/2022/07/09/GPUAartch/Partial_Derivatives(DDX)%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E5%AE%9E%E7%8E%B0%E5%B7%AE%E5%BC%82/</id>
    <published>2022-07-09T11:34:20.476Z</published>
    <updated>2022-07-09T12:05:03.143Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Partial-Derivatives-DDX-原理与设备实现差异&quot;&gt;&lt;a href=&quot;#Partial-Derivatives-DDX-原理与设备实现差异&quot; class=&quot;headerlink&quot; title=&quot;Partial_Derivatives(DDX)原理与设备实现差异&quot;&gt;&lt;/a&gt;Partial_Derivatives(DDX)原理与设备实现差异&lt;/h1&gt;&lt;h2 id=&quot;DDX-DDY的硬件条件&quot;&gt;&lt;a href=&quot;#DDX-DDY的硬件条件&quot; class=&quot;headerlink&quot; title=&quot;DDX\DDY的硬件条件&quot;&gt;&lt;/a&gt;DDX\DDY的硬件条件&lt;/h2&gt;&lt;p&gt;​	“导数”意思是在某一点上“函数的变化”。在图形处理当中，指的是相邻像素之间的变化。&lt;/p&gt;
&lt;p&gt;​	ddx和ddy是常用的简单的图像导数，它们比较相邻的两个像素的垂直或水平值。具体的实现方法以及&lt;strong&gt;结果&lt;/strong&gt;依赖于GPU的特殊架构结构细节。&lt;/p&gt;
&lt;p&gt;​	在图形计算过程中，像素着色阶段的最小调度单元是一个warp，一个warp执行同一段程序，包括了最少32个线程。但是最小的执行单元是一个quad。也就是说一次最少需要执行一个2 * 2的像素，而不需要的像素会被丢弃掉。&lt;/p&gt;
&lt;p&gt;​	这4个像素也就对应了四个线程，他们共同申请使用设备上下文，也就是说可以在硬件上，方便的访问到隔壁像素的数据。&lt;/p&gt;
&lt;p&gt;​	根据硬件这一特性，我们可以利用ddx、ddy获取到更多的信息。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://leinlin.github.io/2022/07/09/GPUAartch/GPU%E6%9E%B6%E6%9E%84%E7%B1%BB%E5%9E%8B%E6%95%B4%E5%90%88/"/>
    <id>http://leinlin.github.io/2022/07/09/GPUAartch/GPU%E6%9E%B6%E6%9E%84%E7%B1%BB%E5%9E%8B%E6%95%B4%E5%90%88/</id>
    <published>2022-07-09T11:34:20.471Z</published>
    <updated>2022-07-09T12:04:53.008Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;GPU架构整合&quot;&gt;&lt;a href=&quot;#GPU架构整合&quot; class=&quot;headerlink&quot; title=&quot;GPU架构整合&quot;&gt;&lt;/a&gt;GPU架构整合&lt;/h1&gt;&lt;p&gt;AMD公司GPU芯片架构:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;Microarchitecture&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;GPUs&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;Graphic cards &amp;#x2F; SoCs&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;GCN 5th&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Vega 10&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Radeon Rx Vega series&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;GCN 4th&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Polaris 10, Polaris 11, Polaris 12&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Radeon Rx 400 series Radeon_500_series&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;GCN 3rd&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Tonga, Fiji, Carrizo&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Radeon R9 Series&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;GCN 2nd&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Bonaire, Hawaii, Kaveri, Kabini, Temash, Mullins, Beema, Carrizo-L&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Radeon HD 7790, &lt;strong&gt;PlayStation 4&lt;/strong&gt;, Xbox One&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;GCN 1st&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Oland, Cape Verde, Pitcairn, Tahiti&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Radeon HD 77xx–7900 Series&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;TeraScale 3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Cayman, Trinity&amp;#x2F;Richland&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Radeon HD 69xx Series, Radeon HD 7xxx–76xx Series&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;TeraScale 2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Cedar, Cypress, Juniper, Redwood, Palm, Sumo&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Radeon HD 5000 Series, Radeon HD 6350, Radeon HD 64xx–68xx Series&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;TeraScale 1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;R600, RV630, RV610, RV790, RV770, …&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Radeon HD 2000 Series, HD 3000, HD 4000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://leinlin.github.io/2022/07/09/GPUAartch/GPU%E6%9E%B6%E6%9E%84/"/>
    <id>http://leinlin.github.io/2022/07/09/GPUAartch/GPU%E6%9E%B6%E6%9E%84/</id>
    <published>2022-07-09T11:34:20.468Z</published>
    <updated>2022-07-09T12:04:48.250Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;GPU架构&quot;&gt;&lt;a href=&quot;#GPU架构&quot; class=&quot;headerlink&quot; title=&quot;GPU架构&quot;&gt;&lt;/a&gt;GPU架构&lt;/h1&gt;&lt;p&gt;参考资料:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://haifux.org/lectures/267/Introduction-to-GPUs.pdf&quot;&gt;Introduction to GPU Architecture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.amd.com/Documents/GCN_Architecture_whitepaper.pdf&quot;&gt;GCN_Architecture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://anteru.net/blog/2018/intro-to-compute-shaders/index.html&quot;&gt;Compute Shader&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;主要简单介绍GPU架构，已经架构带来的性能优化代码编写问题。&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;同过总结上面的资料，大概梳理了相关内容。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://leinlin.github.io/2022/07/09/GPUAartch/GPU%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E6%80%A7%E8%83%BD/"/>
    <id>http://leinlin.github.io/2022/07/09/GPUAartch/GPU%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E6%80%A7%E8%83%BD/</id>
    <published>2022-07-09T11:34:20.464Z</published>
    <updated>2022-07-09T12:04:35.672Z</updated>
    
    
    <summary type="html">&lt;p&gt;下面就是一组线程同时执行，*表示空跑，&amp;#x3D;表示执行。可以看到他们是同时完成的。一个计算单元的所有线程结束以后，可以开始下一组。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs c&quot;&gt;线程A:  =========&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;==============&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;**********endif===========&lt;br&gt;线程B:  =========&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;**************&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;==========endif===========&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;就可以理解为判断只会产生一个遮罩，这个遮罩会决定我这段代码是不是空跑。GPU的计算资源十分紧俏，空跑越多就是我们说的开销大。例如32个线程，每一个都跑不通的分支，那么就相当于性能下降到了1&amp;#x2F;32。这里的开销是利用率降低而不是时间变长。&lt;/p&gt;
&lt;p&gt;关于跑完会等待的。。。GPU一般不会阻塞等待别的线程的（有例外），假如w表示等待。下面的状态是不对的&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs c&quot;&gt;线程A:  =========&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;==============&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; endif===========&lt;br&gt;&lt;br&gt;线程B:  =========&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;=======endif===========wwwwwww&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://leinlin.github.io/2022/07/09/GPUAartch/GCN%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/"/>
    <id>http://leinlin.github.io/2022/07/09/GPUAartch/GCN%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/</id>
    <published>2022-07-09T11:34:20.461Z</published>
    <updated>2022-07-09T04:53:34.609Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Graphics-Core-Next&quot;&gt;&lt;a href=&quot;#Graphics-Core-Next&quot; class=&quot;headerlink&quot; title=&quot;Graphics Core Next&quot;&gt;&lt;/a&gt;Graphics Core</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://leinlin.github.io/2022/07/09/GPUAartch/HDR%E7%A1%AC%E4%BB%B6%E5%B1%82Framebuffer%E6%A0%BC%E5%BC%8F%E6%A0%87%E5%87%86%E4%B8%8E%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://leinlin.github.io/2022/07/09/GPUAartch/HDR%E7%A1%AC%E4%BB%B6%E5%B1%82Framebuffer%E6%A0%BC%E5%BC%8F%E6%A0%87%E5%87%86%E4%B8%8E%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5%E7%9A%84%E5%85%B3%E7%B3%BB/</id>
    <published>2022-07-09T11:21:00.755Z</published>
    <updated>2022-07-09T12:04:56.976Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;HDR硬件层Framebuffer格式标准与渲染阶段的关系&quot;&gt;&lt;a href=&quot;#HDR硬件层Framebuffer格式标准与渲染阶段的关系&quot; class=&quot;headerlink&quot; title=&quot;HDR硬件层Framebuffer格式标准与渲染阶段的关系&quot;&gt;&lt;/a&gt;HDR硬件层Framebuffer格式标准与渲染阶段的关系&lt;/h1&gt;&lt;p&gt;这里主要探讨的是&lt;strong&gt;SwapChain的格式&lt;/strong&gt;、&lt;strong&gt;写入其中的数据&lt;/strong&gt;以及&lt;strong&gt;屏幕实际亮度&lt;/strong&gt;之间的关系。&lt;/p&gt;
&lt;h2 id=&quot;SDR格式&quot;&gt;&lt;a href=&quot;#SDR格式&quot; class=&quot;headerlink&quot; title=&quot;SDR格式&quot;&gt;&lt;/a&gt;SDR格式&lt;/h2&gt;&lt;p&gt;对于SDR屏幕 Buffer主要有：&lt;/p&gt;
&lt;p&gt;R8G8B8A8_UNORM：首先屏幕的eotf曲线是始终存在的，这种格式输入的颜色，图像接口不会进行任何处理，需要我们自己在shader中进行sRGB编码。&lt;/p&gt;
&lt;p&gt;R8G8B8A8_SNORM：这种格式输入的颜色在显示之前会自动编码到SRGB空间（自动Gamma矫正），所以我们不需要进行处理，也就是说shader当中直接写出线性颜色即可。A通道是线性的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  Vulkan的解释：&lt;/p&gt;
&lt;p&gt;  specifies a four-component, 32-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit R component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3.&lt;/p&gt;
&lt;p&gt;  On the other hand, &lt;strong&gt;non-*_SRGB formats&lt;/strong&gt; will be very likely exposed in pair with a &lt;strong&gt;SRGB color space.&lt;/strong&gt; &lt;strong&gt;This means, the hardware will not apply any transfer function when reading from or writing to such images, yet they will still be presented on a device with sRGB display characteristics&lt;/strong&gt;。（即使使用非SRGB的format，仍然可以使用 SRGB的colorSpace），这意味着硬件不会帮助进行自动的空间转换（在读写buffer时），但是仍然使用srgb的eotf的显示特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SRGB的进一步说明：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.rs/vulkano/0.7.2/vulkano/swapchain/enum.ColorSpace.html&quot;&gt;https://docs.rs/vulkano/0.7.2/vulkano/swapchain/enum.ColorSpace.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../images/HDR%E7%A1%AC%E4%BB%B6%E5%B1%82Framebuffer%E6%A0%BC%E5%BC%8F%E6%A0%87%E5%87%86%E4%B8%8E%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5%E7%9A%84%E5%85%B3%E7%B3%BB/1590989148165.png&quot; alt=&quot;1590989148165&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>FBXFileFormat</title>
    <link href="http://leinlin.github.io/2022/07/09/3DBasic/FBXFileFormat/"/>
    <id>http://leinlin.github.io/2022/07/09/3DBasic/FBXFileFormat/</id>
    <published>2022-07-09T04:00:14.000Z</published>
    <updated>2022-07-09T12:12:37.846Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;FBX-test-version-file-format-specification&quot;&gt;&lt;a href=&quot;#FBX-test-version-file-format-specification&quot; class=&quot;headerlink&quot; title=&quot;FBX test version file format specification&quot;&gt;&lt;/a&gt;FBX test version file format specification&lt;/h1&gt;&lt;p&gt;&lt;em&gt;This post is extract from &lt;a href=&quot;https://archive.blender.org/wiki/index.php/User:Mont29/Foundation/FBX_File_Structure/&quot;&gt;blender Doc :FBX File Structure&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;Generalities&quot;&gt;&lt;a href=&quot;#Generalities&quot; class=&quot;headerlink&quot; title=&quot;Generalities&quot;&gt;&lt;/a&gt;Generalities&lt;/h2&gt;&lt;p&gt;FBX is a nodal format, with a root element (which is never explicitly written) and a tree of children.&lt;/p&gt;
&lt;p&gt;Each element has an id (byte string), and can have data and children elements.&lt;/p&gt;
&lt;p&gt;Data are a set of (values, type) tuples, available types are: bool, short, int, long, float, double, bytes, string, and arrays of those types.&lt;/p&gt;
&lt;p&gt;Here is a (JSON) representation of an element:&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs json&quot;&gt;&lt;span class=&quot;hljs-punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Element_ID&amp;quot;&lt;/span&gt;&lt;span class=&quot;hljs-punctuation&quot;&gt;,&lt;/span&gt;                         # ID&lt;br&gt;     &lt;span class=&quot;hljs-punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;data_string&amp;quot;&lt;/span&gt;&lt;span class=&quot;hljs-punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;hljs-punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;hljs-punctuation&quot;&gt;,&lt;/span&gt;              # Data&lt;br&gt;     &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;SI&amp;quot;&lt;/span&gt;&lt;span class=&quot;hljs-punctuation&quot;&gt;,&lt;/span&gt;                             # Data types&lt;span class=&quot;hljs-punctuation&quot;&gt;,&lt;/span&gt; as single-char codes (S for String&lt;span class=&quot;hljs-punctuation&quot;&gt;,&lt;/span&gt; I for Integer&lt;span class=&quot;hljs-punctuation&quot;&gt;,&lt;/span&gt; etc.)&lt;br&gt;     &lt;span class=&quot;hljs-punctuation&quot;&gt;[&lt;/span&gt;__other_children_elements__&lt;span class=&quot;hljs-punctuation&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-punctuation&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Everything is based on this simple schema.&lt;/p&gt;</summary>
    
    
    
    <category term="3DBasic" scheme="http://leinlin.github.io/categories/3DBasic/"/>
    
    
  </entry>
  
  <entry>
    <title>ColorGrading中LUT的生成与使用</title>
    <link href="http://leinlin.github.io/2022/07/09/Art/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://leinlin.github.io/2022/07/09/Art/ColorGrading%E4%B8%ADLUT%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2022-07-09T04:00:14.000Z</published>
    <updated>2022-07-09T12:11:02.308Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;ColorGrading中LUT的生成与使用&quot;&gt;&lt;a href=&quot;#ColorGrading中LUT的生成与使用&quot; class=&quot;headerlink&quot; title=&quot;ColorGrading中LUT的生成与使用&quot;&gt;&lt;/a&gt;ColorGrading中LUT的生成与使用&lt;/h1&gt;&lt;p&gt;场景的LUT贴图有两种生成方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通常DaVinCi生成的是.cube文件，需要用cube文件转换。&lt;/li&gt;
&lt;li&gt;直接在PS当中调整。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;PS直接调整&quot;&gt;&lt;a href=&quot;#PS直接调整&quot; class=&quot;headerlink&quot; title=&quot;PS直接调整&quot;&gt;&lt;/a&gt;PS直接调整&lt;/h2&gt;&lt;p&gt;对于用ps直接调整来说，只要把参考图片和Natural LUT一起调整即可，最终Natural LUT的结果就是我们要的LUT。&lt;/p&gt;</summary>
    
    
    
    <category term="Art" scheme="http://leinlin.github.io/categories/Art/"/>
    
    
  </entry>
  
  <entry>
    <title>PS颜色风格</title>
    <link href="http://leinlin.github.io/2022/07/09/Art/%E9%A2%9C%E8%89%B2%E9%A3%8E%E6%A0%BC/"/>
    <id>http://leinlin.github.io/2022/07/09/Art/%E9%A2%9C%E8%89%B2%E9%A3%8E%E6%A0%BC/</id>
    <published>2022-07-09T04:00:14.000Z</published>
    <updated>2022-07-09T12:10:45.022Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;PS颜色风格&quot;&gt;&lt;a href=&quot;#PS颜色风格&quot; class=&quot;headerlink&quot; title=&quot;PS颜色风格&quot;&gt;&lt;/a&gt;PS颜色风格&lt;/h1&gt;&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;日系，ins风格，低饱和度，平和。&lt;/p&gt;
&lt;p&gt;欧美系，高饱和，有侵略性。&lt;/p&gt;
&lt;p&gt;明度，轻盈舒适。&lt;/p&gt;
&lt;p&gt;低明度，压抑称重，有质感，金属—&amp;gt; 铁和铝箔的IBL。&lt;/p&gt;
&lt;p&gt;同类色-&amp;gt; 15%的色相环，-&amp;gt;靠明度和饱和度达到设计和层次感。–&amp;gt;ToneMapping。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../images/%E9%A2%9C%E8%89%B2%E9%A3%8E%E6%A0%BC/1592918191766.png&quot; alt=&quot;1592918191766&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Camera-Raw&quot;&gt;&lt;a href=&quot;#Camera-Raw&quot; class=&quot;headerlink&quot; title=&quot;Camera Raw&quot;&gt;&lt;/a&gt;Camera Raw&lt;/h2&gt;&lt;p&gt;Ctrl + Shift + A进入PS的Camera Raw风格。&lt;/p&gt;
&lt;p&gt; 主要用来编辑Raw文件的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../images/%E9%A2%9C%E8%89%B2%E9%A3%8E%E6%A0%BC/1592918699887.png&quot; alt=&quot;1592918699887&quot;&gt;&lt;/p&gt;
&lt;p&gt;自动白平衡和手动白平衡。&lt;/p&gt;
&lt;p&gt;下面的图像有没有色偏？可以有也可以没有，但是自动白平衡会去掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../images/%E9%A2%9C%E8%89%B2%E9%A3%8E%E6%A0%BC/1592919134345.png&quot; alt=&quot;1592919134345&quot;&gt;&lt;/p&gt;
&lt;p&gt;渲染当中白色光就没有色偏！！怎么做。&lt;/p&gt;</summary>
    
    
    
    <category term="Art" scheme="http://leinlin.github.io/categories/Art/"/>
    
    
  </entry>
  
  <entry>
    <title>BRDF与色彩与明暗</title>
    <link href="http://leinlin.github.io/2022/07/09/Art/BRDF%E4%B8%8E%E8%89%B2%E5%BD%A9%E4%B8%8E%E6%98%8E%E6%9A%97/"/>
    <id>http://leinlin.github.io/2022/07/09/Art/BRDF%E4%B8%8E%E8%89%B2%E5%BD%A9%E4%B8%8E%E6%98%8E%E6%9A%97/</id>
    <published>2022-07-09T04:00:14.000Z</published>
    <updated>2022-07-09T12:10:53.655Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;BRDF与色彩与明暗&quot;&gt;&lt;a href=&quot;#BRDF与色彩与明暗&quot; class=&quot;headerlink&quot; title=&quot;BRDF与色彩与明暗&quot;&gt;&lt;/a&gt;BRDF与色彩与明暗&lt;/h1&gt;&lt;p&gt;最近看了一些和色彩相关的文章。在美术当中，明暗变化和颜色的过度是紧紧关联起来的（例如：油画变暗并不是单纯地混入黑色），与BRDF模拟有一些差别（单纯考虑明暗，多个通道同样的明暗衰退过程），原画师、插画师一般是从HSV空间（色相环之类的）下手。&lt;/p&gt;
&lt;h2 id=&quot;BRDF明暗与美术明暗&quot;&gt;&lt;a href=&quot;#BRDF明暗与美术明暗&quot; class=&quot;headerlink&quot; title=&quot;BRDF明暗与美术明暗&quot;&gt;&lt;/a&gt;BRDF明暗与美术明暗&lt;/h2&gt;&lt;p&gt;在美术配色当中，颜色的变化并不只是混入黑色，现实世界同样是，&lt;strong&gt;亮度的降低往往伴随了饱和度的升高&lt;/strong&gt;（下图蓝色）。&lt;/p&gt;
&lt;p&gt;但是BRDF总是等比例降低RGB大小（下图黄色），饱和度没有变化。导致画面看起来暗部部分变脏。&lt;/p&gt;
&lt;p&gt;brdf和实际的明暗在拾色器中的变化如下图：&lt;br&gt;&lt;img src=&quot;/../../images/brdf.jpg&quot; alt=&quot;brdf&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Cel Shading当中，画面通常需要保证高饱和度，所以通常需要通过后期的Tone Mapping或者Ramp Map的方式调整暗部颜色。&lt;/p&gt;
&lt;p&gt;这里需要注意，BRDF符合正确的物理明暗变化，但是艺术处理上有所欠缺。&lt;/p&gt;</summary>
    
    
    
    <category term="Art" scheme="http://leinlin.github.io/categories/Art/"/>
    
    
  </entry>
  
  <entry>
    <title>DaVinCi色彩处理原理</title>
    <link href="http://leinlin.github.io/2022/07/09/Art/DaVinCi%E8%89%B2%E5%BD%A9%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/"/>
    <id>http://leinlin.github.io/2022/07/09/Art/DaVinCi%E8%89%B2%E5%BD%A9%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/</id>
    <published>2022-07-09T04:00:14.000Z</published>
    <updated>2022-07-09T12:11:13.919Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;DaVinCi色彩处理原理&quot;&gt;&lt;a href=&quot;#DaVinCi色彩处理原理&quot; class=&quot;headerlink&quot; title=&quot;DaVinCi色彩处理原理&quot;&gt;&lt;/a&gt;DaVinCi色彩处理原理&lt;/h1&gt;&lt;h2 id=&quot;Data-Level（pdf，P215）&quot;&gt;&lt;a href=&quot;#Data-Level（pdf，P215）&quot; class=&quot;headerlink&quot; title=&quot;Data Level（pdf，P215）&quot;&gt;&lt;/a&gt;Data Level（pdf，P215）&lt;/h2&gt;&lt;p&gt;不同的媒体数据文件使用不同范围的数据表示。通常来讲处理的是10bit的数据(0-1023)，有两种不同的data level用来保存图像数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Video：&lt;/strong&gt;所有的图像数据从0-1的颜色强度，会映射到64-940之间。Y通道[64-940]，CB和CR[64-960],小于64用于表示比黑色更黑的区域，941&amp;#x2F;961–1019 表示超过白色的区域。过低过高的数据称作：undershoots 和overshoots。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Full：&lt;/strong&gt;对于RGB444数据，数据强度0-1映射到4-1023。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论哪种数据类型，都有0-100的最大和最小亮度。当数据格式转换时，范围会重新映射：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(minimum Video Level) 64 &amp;#x3D; 4 (Data Level minimum) &lt;/li&gt;
&lt;li&gt;(maximum Video Level) 940 or 960 &amp;#x3D; 1023 (Data Level maximum）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​      数据格式的转换几乎不会有变化，因为合法数据会被被保存下来。区别是undershoots 和overshoots可能丢失，但是Resolve软件内部会记录下来，保证之后可以还原。&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;在DaVinci Resolve中，所有的图像格式都会以Full的格式进行处理。并且是未被压缩的32bit浮点数表示。&lt;/strong&gt;也就是说，每一个图片无论原始的bit-depth是多少，都会转换成32bit的数据。转换的质量依赖于原始数据，总之是无压缩的转换。&lt;/p&gt;</summary>
    
    
    
    <category term="Art" scheme="http://leinlin.github.io/categories/Art/"/>
    
    
  </entry>
  
</feed>
