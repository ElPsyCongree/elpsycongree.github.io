<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    
    <meta name="keywords" content="leinlin, ARIA, Hexo">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="leinlin的小笔记" type="application/atom+xml" />
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-light.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/clipboard.min.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    
    <script defer type="text/javascript" src="https://cdn.staticfile.org/MathJax/MathJax-2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code"]
      }
    });
    </script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += " has-jax";
      }
    });
    </script>
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var cb = null;
      var els = $(".post figure.highlight");
      if (els.length) {
        // Enabled Hexo highlight line number.
        $(els).each(function (i, e) {
          // $(e).before("<button class=\"copy button\">复制</button>");
          $(e).before([
            "<div class=\"code-titlebar\">",
              "<div class=\"titlebar-left\">",
                "<button class=\"copy\">复制</button>",
              "</div>",
            "</div>"
          ].join(""));
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              return trigger.parentNode.parentNode.nextElementSibling.firstChild.firstChild.firstChild.lastChild.firstChild.firstChild;
          }
        });
      } else {
        // Disabled Hexo highlight line number.
        els = $(".post pre code");
        $(els).each(function (i, e) {
          // Add button before pre, not code.
          // $(e).parent().before("<button class=\"copy button\">复制</button>");
          $(e).before([
            "<div class=\"code-titlebar\">",
              "<div class=\"titlebar-left\">",
                "<button class=\"copy\" >复制</button>",
              "</div>",
              "<div class=\"titlebar-right\">",
                "<button class=\"button-dot dot-minimize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-maximize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-close\" aria-label=\"Decoration\"></button>",
              "</div>",
            "</div>"
          ].join(""));
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              return trigger.parentNode.parentNode.nextElementSibling;
          }
        });
      }
      cb.on("success", function (e) {
        e.clearSelection();
        var trigger = e.trigger;
        // Change button text as a user tip.
        trigger.innerHTML = "已复制";
        $(trigger).addClass("copied");
        // Change button text back;
        setTimeout(function () {
          trigger.innerHTML = "复制";
          $(trigger).removeClass("copied");
        }, 1500);
      });
    });
    </script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>leinlin的小笔记</title>
  <meta name="generator" content="Hexo 6.2.0"></head>
  <body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"  data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">leinlin的小笔记</a></h1>
        <h2 class="subtitle"></h2>
      </div>
      
    </div>
    <nav id="nav" class="nav">
      <a id="nav-toggle" class="nav-toggle" aria-hidden="true"><i class="fas fa-bars" aria-label="切换导航栏"></i></a>
      <ul id="menu" role="menubar" aria-hidden="false">
        
        <li role="menuitem"><a href="/"><i class="fas fa-home"></i><span class="menu-text">首页</span></a></li>
        
        <li role="menuitem"><a href="/categories/"><i class="fas fa-th-list"></i><span class="menu-text">分类</span></a></li>
        
      </ul>
    </nav>
  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            

<div id="index" class="index page">
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/RTR/%E4%BD%93%E7%A7%AF%E4%BA%91/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/RTR/%E4%BD%93%E7%A7%AF%E4%BA%91/" itemprop="url">体积云光照部分相关理论</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RTR/" itemprop="url" rel="index"><span itemprop="name">RTR</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="体积云光照部分相关理论"><a href="#体积云光照部分相关理论" class="headerlink" title="体积云光照部分相关理论"></a>体积云光照部分相关理论</h1><p>阅读GPU Pro6当中的第4章体积云，主要为了记录其中和光相关的理论。《Real-Time Rendering  of Physical Based Clouds Using Precomputed Scattering》</p>
<p>这篇文章主要提出了一种refrence Particle。通过缩放和旋转同一个粒子得到云。云可以有动画。</p>
<p>在与计算部分, 计算光学深度已经单个和多个的散射积分，用来描述光在rp当中的传递，描述了所有可能的摄像机位置和观察方向，并且存储在查找表当中。</p>
<p>原文：</p>
<p>we precompute optical depth as well as single and multiple scattering integrals describing the light transport in the reference particle for all possible camera positions and<br>view directions and store the results in lookup tables. </p>
<p>在运行阶段，加载查找表，来估计光线在云当中的传递节省ray marching和slicing的开销。</p>
<p>主要原理来源于[Yusov 14b] </p>
<p>改进方案包括：</p>
<p>1.改进基于与计算查找表的着色模型。</p>
<p>2.使用3D网格来改进光线在云内部传递的衰减算分。</p>
<p>3.新的粒子生成算法</p>
<p>4.性能优化，包括给予GPU的粒子排序。</p>
<h2 id="Light-Transport-Theory"><a href="#Light-Transport-Theory" class="headerlink" title="Light Transport Theory"></a>Light Transport Theory</h2><p>这里介绍光线在粒子中传递的概念。</p>
<p>参考：More information can be found in [Riley et al. 04,Bouthors 08] </p>
<p>光在粒子当中有三个现象：</p>
<ol>
<li>散射：改变粒子在介质中传播方向。</li>
<li>吸收：光子能量转换成了其他形式</li>
<li>发光：与吸收相反。</li>
</ol>
<p>上述过程可以用Sc ，Ab，Em三个系数来描述。吸收散射 都是减少了光在介质中的强度。</p>
<p>消减系数：$$ Ex &#x3D; Ab + Sc $$。</p>
<p>在云内部 发散和吸收可以忽略 ： $$Em &#x3D; Ab &#x3D; 0$$, 所以散射和吸收可以用同一个系数描述：$$ Sc  &#x3D; Ex &#x3D; B $$</p>
<p> 光线在云内部，从A点到B点的衰减系数可以用下方公式描述:</p>
<p>$$ e^{-\tau(A,B)}$$</p>
<p>$ -\tau(A,B) $ 表示光学深度，是从A点到B点消散系数B的积分。</p>
<p>$$ -\tau(A,B) &#x3D;  \sum^A_B{\beta(P)ds}$$</p>
<p>$$ P&#x3D;A+\frac{B-A}{|{B-A}|}  $$<br>s表示当前积分的点。</p>
<p>为了知道一个散射光的强度，我们需要沿着视线积累太阳光在每一个点上朝摄像机散射的所有分量。</p>
<p>参数解释$C$表示摄像机位置，$\vec v$表示视线方向，$P_0$和$P_1$表示视线进入和离开云的位置，$P$表示某个散射位置的点，$Q$是光线到达散射位置的太阳光进入云的点。$L_{sun}$表示太阳光强度，$P(\theta)$表示入射方向到出射方向光损失的百分比。削减一共有两部分P到P0和Q到P.</p>
<p>上面描述的只是一个点。</p>
<p>同时P的近似函数：</p>
<p>$$ P(\theta) &#x3D; \frac{1}{4PI}\frac{3(1-g^2)}{2(2+g^2)}\frac{(1 + cos^2(\theta))}{(1+g^2-2gcos(\theta))^{\frac{3}{2}}} $$</p>
<p>把所有光线夹起来就是最终结果:</p>
<p>$$L^n_{In}(C,\vec v)&#x3D;\int_{P0}^{P1}J^{(n)}(P,\vec v)e^{-\tau(P,P0)}ds$$</p>
<p>其中$J^{(n)}$ 表示各个方向每个点想实现方向散射的强度。</p>
<h2 id="Precompute-Solutions"><a href="#Precompute-Solutions" class="headerlink" title="Precompute Solutions"></a>Precompute Solutions</h2><p>后面的部分用处不大，以后再研究。</p>

      
      <p align="right"><a class="morebtn" href="/2022/07/09/RTR/%E4%BD%93%E7%A7%AF%E4%BA%91/" title="体积云光照部分相关理论">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/RTR/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/RTR/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/" itemprop="url">主机渲染和优化技术概要</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RTR/" itemprop="url" rel="index"><span itemprop="name">RTR</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="主机渲染和优化技术概要"><a href="#主机渲染和优化技术概要" class="headerlink" title="主机渲染和优化技术概要"></a>主机渲染和优化技术概要</h1><!-- TOC --><br/><br/>- [主机渲染和优化技术概要](#主机渲染和优化技术概要)<br/>    - [1. 渲染流程](#1-渲染流程)<br/>        - [1.1. RenderPipeline](#11-renderpipeline)<br/>        - [1.2. 渲染参数](#12-渲染参数)<br/>        - [1.3. 常用光照模型](#13-常用光照模型)<br/>        - [1.4. 基础光照计算](#14-基础光照计算)<br/>            - [1.4.1. D项 ：GGX (Trowbridge-Reitz)](#141-d项-ggx-trowbridge-reitz)<br/>            - [1.4.2. G项：Schlick](#142-g项schlick)<br/>            - [1.4.3. F项：Schlick’s approximation](#143-f项schlicks-approximation)<br/>            - [1.4.4. IBL](#144-ibl)<br/>        - [1.5. 光照技术](#15-光照技术)<br/>            - [1.5.1. multipass forward](#151-multipass-forward)<br/>            - [1.5.2. multipass deferred](#152-multipass-deferred)<br/>            - [1.5.3. singlepass deferred](#153-singlepass-deferred)<br/>            - [1.5.4. Tiled-based  Shading](#154-tiled-based--shading)<br/>            - [1.5.5. Clustered Shading](#155-clustered-shading)<br/>            - [1.5.6. 效果对比](#156-效果对比)<br/>    - [2. 渲染技术](#2-渲染技术)<br/>        - [2.1. 基础材质](#21-基础材质)<br/>        - [2.2. 分层细节材质](#22-分层细节材质)<br/>        - [2.3. 分层材质系统](#23-分层材质系统)<br/>        - [2.4. 材质库系统](#24-材质库系统)<br/>        - [2.5. 特效材质](#25-特效材质)<br/>        - [2.6. 屏幕空间技术](#26-屏幕空间技术)<br/>            - [2.6.1. 主要涉及到屏幕空间的Ray Trace操作。](#261-主要涉及到屏幕空间的ray-trace操作)<br/>            - [2.6.2. Screen Space Contact Shadow](#262-screen-space-contact-shadow)<br/>            - [2.6.3. Screen Space Reflections](#263-screen-space-reflections)<br/>        - [2.7. 毛发](#27-毛发)<br/>            - [2.7.1. hairworks or TressFX：](#271-hairworks-or-tressfx)<br/>        - [2.8. 灯光方案](#28-灯光方案)<br/>        - [2.9. 阴影方案](#29-阴影方案)<br/>            - [2.9.1. 巫师3的CSM](#291-巫师3的csm)<br/>            - [2.9.2. 阴影代理](#292-阴影代理)<br/>        - [2.10. LOD方案](#210-lod方案)<br/>        - [2.11. 后处理：曝光与光照设定](#211-后处理曝光与光照设定)<br/>        - [2.12. 透明物体低分辨率渲染](#212-透明物体低分辨率渲染)<br/>        - [2.13. 后处理：HDR and ToneMapping](#213-后处理hdr-and-tonemapping)<br/>        - [2.14. 后处理：TAA](#214-后处理taa)<br/>    - [3. GPU架构](#3-gpu架构)<br/>        - [3.1. GPU存储架构](#31-gpu存储架构)<br/>        - [3.2. GPU渲染架构](#32-gpu渲染架构)<br/>            - [3.2.1. 存储和计算的关系](#321-存储和计算的关系)<br/>            - [3.2.2. Wrap与Wave Front](#322-wrap与wave-front)<br/>        - [3.3. 手游架构](#33-手游架构)<br/>    - [4. 程序优化性能关注的点](#4-程序优化性能关注的点)<br/>        - [4.1. Draw Call](#41-draw-call)<br/>        - [4.2. Early - z](#42-early---z)<br/>        - [4.3. Over Draw](#43-over-draw)<br/>        - [4.4. Quad OverDraw](#44-quad-overdraw)<br/>        - [4.5. Light](#45-light)<br/>        - [4.6. Vertex Count](#46-vertex-count)<br/>        - [4.7. Texture压缩与内存优化](#47-texture压缩与内存优化)<br/>        - [4.8. Baking](#48-baking)<br/>        - [4.9. MipMap](#49-mipmap)<br/>        - [4.10. Testure Streaming](#410-testure-streaming)<br/>        - [4.11. Shader预加载](#411-shader预加载)<br/>        - [4.12. Shader分支](#412-shader分支)<br/>    - [5. 美术资源可能带来的性能问题](#5-美术资源可能带来的性能问题)<br/>        - [5.1. 游戏性能瓶颈：模型](#51-游戏性能瓶颈模型)<br/>        - [5.2. 游戏性能优化：模型](#52-游戏性能优化模型)<br/>        - [5.3. 游戏性能瓶颈：贴图](#53-游戏性能瓶颈贴图)<br/>        - [5.4. 游戏性能优化：贴图](#54-游戏性能优化贴图)<br/>        - [5.5. 游戏性能瓶颈：材质](#55-游戏性能瓶颈材质)<br/>        - [5.6. 游戏性能优化：材质](#56-游戏性能优化材质)<br/>        - [5.7. 游戏性能瓶颈：Quad OverDraw 、OverDraw](#57-游戏性能瓶颈quad-overdraw-overdraw)<br/>        - [5.8. 游戏性能优化：Quad OverDraw 、OverDraw](#58-游戏性能优化quad-overdraw-overdraw)<br/><br/><!-- /TOC -->

<h2 id="1-渲染流程"><a href="#1-渲染流程" class="headerlink" title="1. 渲染流程"></a>1. 渲染流程</h2><h3 id="1-1-RenderPipeline"><a href="#1-1-RenderPipeline" class="headerlink" title="1.1. RenderPipeline"></a>1.1. RenderPipeline</h3><p>基础渲染流程。</p>
<p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961718383.png" alt="1568961718383"></p>
<p><img src="/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961632451.png" alt="1568961632451"></p>
<p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961793802.png" alt="1568961793802"></p>
<p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961811084.png" alt="1568961811084"></p>
<p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961840796.png" alt="1568961840796"></p>
<p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961874770.png" alt="1568961874770"></p>
<p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961884019.png" alt="1568961884019"></p>
<h3 id="1-2-渲染参数"><a href="#1-2-渲染参数" class="headerlink" title="1.2. 渲染参数"></a>1.2. 渲染参数</h3><p>Unity HDRP Deferred结构</p>
<table>
<thead>
<tr>
<th>G-Buffer Usage</th>
<th>Format</th>
<th>RGB</th>
<th>A</th>
</tr>
</thead>
<tbody><tr>
<td>GBuffer0</td>
<td>RGBA32</td>
<td>Albedo Color &#x2F;      SSS Color</td>
<td>Spacular Occlusiion &#x2F; SSS Parameter</td>
</tr>
<tr>
<td>GBuffer1</td>
<td>RGBA32</td>
<td>Packed Normal</td>
<td>Roughness</td>
</tr>
<tr>
<td>GBuffer2</td>
<td>RGBA32</td>
<td>BSDF Model Specific Parameters</td>
<td>Coat Mask + Material ID</td>
</tr>
<tr>
<td>GBuffer3</td>
<td>R11G11B10</td>
<td>GI + Emissive</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>GBuffer4 - Optional</td>
<td>RGBA32</td>
<td>R:&#x2F;             G:&#x2F;             B: AO</td>
<td>Light Layer</td>
</tr>
<tr>
<td>GBuffer5 - Optional</td>
<td>RGBA32</td>
<td>shadowmask0 - 2</td>
<td>shadowmask3</td>
</tr>
</tbody></table>
<h3 id="1-3-常用光照模型"><a href="#1-3-常用光照模型" class="headerlink" title="1.3. 常用光照模型"></a>1.3. 常用光照模型</h3><table>
<thead>
<tr>
<th>Clear Coat</th>
<th>车漆效果</th>
</tr>
</thead>
<tbody><tr>
<td>Specular</td>
<td>这个是和Standard（金属工作流）相对的高光工作流。区别只是金属度变成了高光颜色。其他计算没有区别。指定F0。</td>
</tr>
<tr>
<td>Anisotropy</td>
<td>计算高光时使用各项异性的高光计算。和Standard区别只在于高光的计算，同时多出了一张各向异性贴图和强度控制。例如：拉丝金属。</td>
</tr>
<tr>
<td>Iridescence</td>
<td>彩虹色是指：随着光照角度的变化光照颜色发生变化。例如：肥皂泡沫，昆虫翅膀。</td>
</tr>
<tr>
<td>Translucent</td>
<td>透光效果是指：在背光面可以看到光穿过物体的效果。主要用于半透明材质。例如：树叶。</td>
</tr>
<tr>
<td>Surface Scattering</td>
<td>SSS效果用来描述光线在表面多次散射的效果。可以用来描述灯光和半透物体的交互过程。可以用来制作：玉、冰、皮肤等物体。</td>
</tr>
<tr>
<td>Displacement</td>
<td>Unity支持高度图计算。Vertex Displacement:  在Vertex阶段直接移动顶点，高度图作为移动距离。Pixel displacement： 将高度图作为视差贴图。（POM）</td>
</tr>
<tr>
<td>Standard</td>
<td>标准材质</td>
</tr>
</tbody></table>
<h3 id="1-4-基础光照计算"><a href="#1-4-基础光照计算" class="headerlink" title="1.4. 基础光照计算"></a>1.4. 基础光照计算</h3><p>漫反射：</p>
<p>$$ f(l,v) &#x3D; \frac{c_{diff}}{\pi} $$</p>
<p>高光：</p>
<p>$$ f(l,v) &#x3D; \frac{D(h)G(l,v,h)F(v,h)}{4(nl)(nv)} $$</p>
<h4 id="1-4-1-D项-：GGX-Trowbridge-Reitz"><a href="#1-4-1-D项-：GGX-Trowbridge-Reitz" class="headerlink" title="1.4.1. D项 ：GGX (Trowbridge-Reitz)"></a>1.4.1. D项 ：GGX (Trowbridge-Reitz)</h4><p>$$ \alpha &#x3D; roughness^2 $$</p>
<p>$$ D_{GGX}(h)&#x3D;\frac{\alpha^2}{\pi((nh)^2(\alpha^2-1)+1)^2} $$</p>
<h4 id="1-4-2-G项：Schlick"><a href="#1-4-2-G项：Schlick" class="headerlink" title="1.4.2. G项：Schlick"></a>1.4.2. G项：Schlick</h4><p>Schlick-GGX（用在IBL上）</p>
<p>$$k &#x3D;\frac{\alpha} {2}$$  </p>
<p>$$ \alpha &#x3D; roughness^2 $$</p>
<p>根据Disney文章对其做了修改（这个修改只用在解析光源上，IBL在glancing angles会太暗）：</p>
<p>$$k &#x3D;\frac{(roughness + 1)^2} {8}$$  </p>
<p>$$ G_{GGX}(v) &#x3D; \frac{nv}{(nv)(1-k)+k} $$</p>
<h4 id="1-4-3-F项：Schlick’s-approximation"><a href="#1-4-3-F项：Schlick’s-approximation" class="headerlink" title="1.4.3. F项：Schlick’s approximation"></a>1.4.3. F项：Schlick’s approximation</h4><p>$$ F(v,h)&#x3D;F_0 + (1 - F_0) 2^{-5.55473(vh)-6.98316)(vh)} $$</p>
<h4 id="1-4-4-IBL"><a href="#1-4-4-IBL" class="headerlink" title="1.4.4. IBL"></a>1.4.4. IBL</h4><p>首先需要解决的是辐射度积分，通常使用重要度采样：</p>
<p>$$ \int_H L_i(l)f(l,v)cos(\theta_l)dl  &#x3D; \frac{1}{N}\sum^{N}_{k&#x3D;1}\frac{L_i(l_k)f(l_k,v)cos theta _{l_k} }{p(l_k,v)} $$</p>
<h3 id="1-5-光照技术"><a href="#1-5-光照技术" class="headerlink" title="1.5. 光照技术"></a>1.5. 光照技术</h3><h4 id="1-5-1-multipass-forward"><a href="#1-5-1-multipass-forward" class="headerlink" title="1.5.1. multipass forward"></a>1.5.1. multipass forward</h4><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Shaders:</span><br>Shader simpleShader<br><br><span class="hljs-comment">//Buffers:</span><br>Buffer display<br><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">for</span> light in scene<br>        display += simpleShader(mesh, light)<br></code></pre></td></tr></table></figure>

<h4 id="1-5-2-multipass-deferred"><a href="#1-5-2-multipass-deferred" class="headerlink" title="1.5.2. multipass deferred"></a>1.5.2. multipass deferred</h4><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Buffers:</span><br>Buffer display<br>Buffer GBuffer <br><br><span class="hljs-comment">//Shaders:</span><br>Shader simpleShader<br>Shader writeShadingAttributes<br><br><span class="hljs-comment">//Visibility &amp; materials</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth &lt; GBuffer.depth<br>       GBuffer = writeShadingAttributes(mesh)<br><br><span class="hljs-comment">//Shading &amp; lighting - Multi-pass</span><br><span class="hljs-keyword">for</span> light in scene<br>    display += simpleShader(GBuffer, light)<br></code></pre></td></tr></table></figure>

<h4 id="1-5-3-singlepass-deferred"><a href="#1-5-3-singlepass-deferred" class="headerlink" title="1.5.3. singlepass deferred"></a>1.5.3. singlepass deferred</h4><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Buffers:</span><br>Buffer display<br>Buffer GBuffer <br><br><span class="hljs-comment">//Shaders:</span><br>Shader manyLightShader<br>Shader writeShadingAttributes<br><br><span class="hljs-comment">//Visibility &amp; materials</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth &lt; GBuffer.depth<br>       GBuffer = writeShadingAttributes(mesh)<br><br><span class="hljs-comment">//Shading &amp; lighting - Single-pass</span><br>display = manyLightShader(GBuffer, scene.lights)<br></code></pre></td></tr></table></figure>

<h4 id="1-5-4-Tiled-based-Shading"><a href="#1-5-4-Tiled-based-Shading" class="headerlink" title="1.5.4. Tiled-based  Shading"></a>1.5.4. Tiled-based  Shading</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569236801768.png" alt="1569236801768"></p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">Buffer display<br>Buffer GBuffer <br>Buffer tileArray<br><br><span class="hljs-comment">//Shaders:</span><br>Shader manyLightShader<br>Shader writeShadingAttributes<br>CompShader lightInTile<br><br><span class="hljs-comment">//Visibility &amp; materials</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth &lt; GBuffer.depth<br>       GBuffer = writeShadingAttributes(mesh)<br><br><span class="hljs-comment">//Light culling</span><br><span class="hljs-keyword">for</span> tile in tileArray<br>   <span class="hljs-keyword">for</span> light in scene<br>      <span class="hljs-keyword">if</span> lightInTile(tile, light)<br>          tile += light<br>      <br><span class="hljs-comment">//Shading</span><br>display = manyLightShader(GBuffer, tileArray)<br></code></pre></td></tr></table></figure>

<h4 id="1-5-5-Clustered-Shading"><a href="#1-5-5-Clustered-Shading" class="headerlink" title="1.5.5. Clustered Shading"></a>1.5.5. Clustered Shading</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569237072424.png" alt="1569237072424"></p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569237086038.png" alt="1569237086038"></p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Buffers:</span><br>Buffer display<br>Buffer GBuffer<br>Buffer clusterArray<br><br><span class="hljs-comment">//Shaders:</span><br>Shader manyLightShader<br>Shader writeShadingAttributes<br>CompShader lightInCluster <br><br><span class="hljs-comment">//Visibility &amp; materials</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth &lt; GBuffer.depth<br>       GBuffer = writeShadingAttributes(mesh)<br><br><span class="hljs-comment">//Light culling</span><br><span class="hljs-keyword">for</span> cluster in clusterArray<br>   <span class="hljs-keyword">for</span> light in scene<br>      <span class="hljs-keyword">if</span> lightIncluster(cluster, light)<br>          cluster += light<br><br><span class="hljs-comment">//Shading</span><br>display = manyLightShader(GBuffer, clusterArray)<br></code></pre></td></tr></table></figure>

<h4 id="1-5-6-效果对比"><a href="#1-5-6-效果对比" class="headerlink" title="1.5.6. 效果对比"></a>1.5.6. 效果对比</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569237135439.png" alt="1569237135439"></p>
<h2 id="2-渲染技术"><a href="#2-渲染技术" class="headerlink" title="2. 渲染技术"></a>2. 渲染技术</h2><h3 id="2-1-基础材质"><a href="#2-1-基础材质" class="headerlink" title="2.1. 基础材质"></a>2.1. 基础材质</h3><table>
<thead>
<tr>
<th align="left"><strong>Property</strong></th>
<th align="left"><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Albedo Map</strong></td>
<td align="left">表示物体颜色，不应该包含任何明暗、AO、阴影信息。除了基础颜色外，还可以包含一些偏色、或者色相的变化。</td>
</tr>
<tr>
<td align="left"><strong>Mask Map</strong></td>
<td align="left">Assign a Texture that packs different Material maps into each of its RGBA channels. • <strong>Red</strong>: Stores the metallic map.  • <strong>Green</strong>: Stores the ambient occlusion map. • <strong>Blue</strong>: Stores the detail mask map. • <strong>Alpha</strong>: Stores the smoothness map.</td>
</tr>
<tr>
<td align="left"><strong>Normal  Map</strong></td>
<td align="left">法线，LitShader支持模型空间和切线空间的法线，使用模型空间法线，可以在LOD当中过度更好，使用切线空间法线，可以压缩纹理空间。</td>
</tr>
<tr>
<td align="left"><strong>Bent Normal</strong></td>
<td align="left">Bent normal实际上也是一个表面方向和Normal接近，主要用来优化AO效果，只对GI（lightmap&#x2F;lightprobe&#x2F;volume proxy）生效。shaer代码：builtinData.bakeDiffuseLighting &#x3D; SampleBakedGI(posInput.positionWS, bennormalWS, texCoord1.xy, texCoord2.xy);</td>
</tr>
<tr>
<td align="left"><strong>Detial Map</strong></td>
<td align="left"><strong>Red</strong>:  Smoothness的细节噪声 <strong>Green</strong>+<strong>Blue</strong>: 细节法线. • <strong>Alpha</strong>: Albede的明暗细节噪声.</td>
</tr>
</tbody></table>
<h3 id="2-2-分层细节材质"><a href="#2-2-分层细节材质" class="headerlink" title="2.2. 分层细节材质"></a>2.2. 分层细节材质</h3><p>用于秒回细致的角色。</p>
<p>1.多加了4&#x2F;8层Detial。</p>
<p>一次DrawCall 刻画精细的材质。</p>
<table>
<thead>
<tr>
<th align="left"><strong>Property</strong></th>
<th align="left"><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Albedo Map</strong></td>
<td align="left">表示物体颜色，不应该包含任何明暗、AO、阴影信息。除了基础颜色外，还可以包含一些偏色、或者色相的变化。</td>
</tr>
<tr>
<td align="left"><strong>Mask Map</strong></td>
<td align="left">• <strong>Red</strong>: Stores the metallic map.  • <strong>Green</strong>: Stores the ambient occlusion map. • <strong>Blue</strong>: Stores the detail mask map. • <strong>Alpha</strong>: Stores the smoothness map.</td>
</tr>
<tr>
<td align="left"><strong>Normal  Map</strong></td>
<td align="left">法线，LitShader支持模型空间和切线空间的法线，使用模型空间法线，可以在LOD当中过度更好，使用切线空间法线，可以压缩纹理空间。</td>
</tr>
<tr>
<td align="left"><strong>Bent Normal</strong></td>
<td align="left">Bent normal实际上也是一个表面方向和Normal接近，主要用来优化AO效果，只对GI（lightmap&#x2F;lightprobe&#x2F;volume proxy）生效。shaer代码：builtinData.bakeDiffuseLighting &#x3D; SampleBakedGI(posInput.positionWS, bennormalWS, texCoord1.xy, texCoord2.xy);</td>
</tr>
<tr>
<td align="left"><strong>Detial Map</strong>0</td>
<td align="left"><strong>Red</strong>:  Smoothness的细节噪声 <strong>Green</strong>+<strong>Blue</strong>: 细节法线. • <strong>Alpha</strong>: Albede的明暗细节噪声.</td>
</tr>
<tr>
<td align="left"><strong>Detial Map</strong>1</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left"><strong>Detial Map</strong>2</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left"><strong>Detial Map</strong>3</td>
<td align="left">…</td>
</tr>
</tbody></table>
<ol start="2">
<li>Mask Map中B通道均分4份，作为4层权重。</li>
</ol>
<h3 id="2-3-分层材质系统"><a href="#2-3-分层材质系统" class="headerlink" title="2.3. 分层材质系统"></a>2.3. 分层材质系统</h3><p>用于处理建筑：基础材质+脏（剥落材质）+ 旧（覆盖材质）+ 表面覆盖（雪，苔藓等）</p>
<p>贴图复用，材质球复用，Mesh合并。</p>
<p>1.参数变成4组。</p>
<table>
<thead>
<tr>
<th align="left"><strong>Property</strong></th>
<th align="left"><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Albedo Map1-4</strong></td>
<td align="left">表示物体颜色，不应该包含任何明暗、AO、阴影信息。除了基础颜色外，还可以包含一些偏色、或者色相的变化。</td>
</tr>
<tr>
<td align="left"><strong>Mask Map1-4</strong></td>
<td align="left">• <strong>Red</strong>: Stores the metallic map.  • <strong>Green</strong>: Stores the ambient occlusion map. • <strong>Blue</strong>:None. • <strong>Alpha</strong>: Stores the smoothness map.</td>
</tr>
<tr>
<td align="left"><strong>Normal  Map1-4</strong></td>
<td align="left">法线，LitShader支持模型空间和切线空间的法线，使用模型空间法线，可以在LOD当中过度更好，使用切线空间法线，可以压缩纹理空间。</td>
</tr>
<tr>
<td align="left">Mask</td>
<td align="left">四个通道对应四层。</td>
</tr>
</tbody></table>
<p>2.混合方式</p>
<p>从上层到下层的覆盖权重，而不是加权求和。</p>
<p>顶点色作为混合基调，Mask作为平铺细节。</p>
<p>材质混合：</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569313963924.png" alt="1569313963924"></p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569313995548.png" alt="1569313995548"></p>
<h3 id="2-4-材质库系统"><a href="#2-4-材质库系统" class="headerlink" title="2.4. 材质库系统"></a>2.4. 材质库系统</h3><p>刺客型条 GCD2017 Texturing the World of Assassin’s Creed Odyssey：</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569314751834.png" alt="1569314751834"></p>
<p>材质使用：</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569314652689.png" alt="1569314652689"></p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569314671739.png" alt="1569314671739"></p>
<h3 id="2-5-特效材质"><a href="#2-5-特效材质" class="headerlink" title="2.5. 特效材质"></a>2.5. 特效材质</h3><p>这里的特效主要指的是附着在模型上的效果：</p>
<ol>
<li><p>对模型产生修改的效果，直接通过宏开关加载模型上.</p>
<p>例如：溶解、顶点动画、透明化、AlphaTest类型的效果。</p>
</li>
<li><p>不会修改模型的效果，另外使用Unlit渲染一次：</p>
<p>例如：身体流光、边缘光、轮廓线、透明特效。</p>
</li>
</ol>
<h3 id="2-6-屏幕空间技术"><a href="#2-6-屏幕空间技术" class="headerlink" title="2.6. 屏幕空间技术"></a>2.6. 屏幕空间技术</h3><h4 id="2-6-1-主要涉及到屏幕空间的Ray-Trace操作。"><a href="#2-6-1-主要涉及到屏幕空间的Ray-Trace操作。" class="headerlink" title="2.6.1. 主要涉及到屏幕空间的Ray Trace操作。"></a>2.6.1. 主要涉及到屏幕空间的Ray Trace操作。</h4><h4 id="2-6-2-Screen-Space-Contact-Shadow"><a href="#2-6-2-Screen-Space-Contact-Shadow" class="headerlink" title="2.6.2. Screen Space Contact Shadow"></a>2.6.2. Screen Space Contact Shadow</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569392407631.png" alt="1569392407631"></p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569392417350.png" alt="1569392417350"></p>
<h4 id="2-6-3-Screen-Space-Reflections"><a href="#2-6-3-Screen-Space-Reflections" class="headerlink" title="2.6.3. Screen Space Reflections"></a>2.6.3. Screen Space Reflections</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569392453534.png" alt="1569392453534"></p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569392487449.png" alt="1569392487449"></p>
<h3 id="2-7-毛发"><a href="#2-7-毛发" class="headerlink" title="2.7. 毛发"></a>2.7. 毛发</h3><h4 id="2-7-1-hairworks-or-TressFX："><a href="#2-7-1-hairworks-or-TressFX：" class="headerlink" title="2.7.1. hairworks or TressFX："></a>2.7.1. hairworks or TressFX：</h4><p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569390840595.png" alt="1569390840595"></p>
<p>神秘海域4头发</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569144795134.png" alt="1569144795134"></p>
<p>怪物猎人世界宠物毛发</p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569144859044.png" alt="1569144859044"></p>
<p>Unity异教徒短片衣服毛领子：</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569144994165.png" alt="1569144994165"></p>
<p>Shell Model</p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569310477528.png" alt="1569310477528"></p>
<h3 id="2-8-灯光方案"><a href="#2-8-灯光方案" class="headerlink" title="2.8. 灯光方案"></a>2.8. 灯光方案</h3><ol>
<li>动态物体：</li>
</ol>
<p>PBR直接光照 + SH 间接光（Reflection Probe） + IBL环境光（Reflection Probe）</p>
<p>直接光照：所有实时光照的直接分量。</p>
<p>SH 间接光（Reflection Probe）：天光 + 实时光的间接分量 + 完整烘焙光直接和间接分量。</p>
<p>点云：记录了六个方向的光线，简化版的SH。</p>
<ol start="2">
<li>静态物体：</li>
</ol>
<p>PBR直接光照 + LightMap间接光计算 + IBL环境光 （Reflection Probe）</p>
<p>LightMap间接光计算 ：天光 + 实时光的间接分量 + 完整烘焙光直接和间接分量。</p>
<h3 id="2-9-阴影方案"><a href="#2-9-阴影方案" class="headerlink" title="2.9. 阴影方案"></a>2.9. 阴影方案</h3><p>动态物体：ShadowMap CSM 2(5,20) + 静态物体：ShadowMask</p>
<p>动态阴影边缘优化：PCF2*2 5*5 7*7 、PCSS</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569209076734.png" alt="1569209076734"></p>
<p>远处动态物体：</p>
<ol>
<li><p>使用第三级CSM，使用代理体阴影。</p>
</li>
<li><p>SDF</p>
</li>
</ol>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569220211656.png" alt="1569220211656"></p>
<h4 id="2-9-1-巫师3的CSM"><a href="#2-9-1-巫师3的CSM" class="headerlink" title="2.9.1. 巫师3的CSM"></a>2.9.1. 巫师3的CSM</h4><p>0级：3米</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569393594256.png" alt="1569393594256"></p>
<p>1级：20米</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569393483587.png" alt="1569393483587"></p>
<p>2级：200米</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569393547484.png" alt="1569393547484"></p>
<p>3级：动态物体无阴影</p>
<h4 id="2-9-2-阴影代理"><a href="#2-9-2-阴影代理" class="headerlink" title="2.9.2. 阴影代理"></a>2.9.2. 阴影代理</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569407455456.png" alt="1569407455456"></p>
<h3 id="2-10-LOD方案"><a href="#2-10-LOD方案" class="headerlink" title="2.10. LOD方案"></a>2.10. LOD方案</h3><p>Mesh Lod :LOD0 - N  + HLOD + IMPOSTER</p>
<p>特效LOD : 削减次要粒子 &gt; 降低粒子数量 &gt; 关闭Alpha Test，简化计算。</p>
<p>Shading LOD ：简化光照模型。</p>
<p>阴影LOD：Shadow Mask</p>
<h3 id="2-11-后处理：曝光与光照设定"><a href="#2-11-后处理：曝光与光照设定" class="headerlink" title="2.11. 后处理：曝光与光照设定"></a>2.11. 后处理：曝光与光照设定</h3><ol>
<li>白平衡场景和灯光设置：</li>
</ol>
<p>基本的资源检查场景，确定ShadingModel、贴图制作、光源方案没有问题。</p>
<p>包括：展览光源+反射球+反射探针。</p>
<ol start="2">
<li>风格化场景和灯光设置：</li>
</ol>
<p>结合后处理的风格化场景：夜晚，白天，洞穴，室内，森林等等，包括少量烘焙、参考资源。</p>
<p>制作标准亮度的cubemap,标准灯光参数，用于检查外包资源的场景。确定在各种环境下显示正常、</p>
<p>包括：展览光源+反射球+反射探针+lightmap+后处理。</p>
<ol start="3">
<li>AssetLibrary资源库。</li>
</ol>
<p>包括了所有资源的展览场景，游戏当中的各种复用场景资源集中排列摆放：树，石头。</p>
<p>游戏当中场景材质集中摆放。</p>
<p>检查所有材质模型合规。检查LOD效果。需要可以切换各个风格化设置。资源之间是否统一。</p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569405739260.png" alt="1569405739260"></p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569405759431.png" alt="1569405759431"></p>
<ol start="4">
<li>游戏场景。</li>
</ol>
<p>地标大型资源的游戏场景，地编从2中选取光照方案，从3中选取资源填充场景。</p>
<p>最终的游戏场景，进行最终游戏性能测试。</p>
<h3 id="2-12-透明物体低分辨率渲染"><a href="#2-12-透明物体低分辨率渲染" class="headerlink" title="2.12. 透明物体低分辨率渲染"></a>2.12. 透明物体低分辨率渲染</h3><p>通过在低分辨率上渲染透明物体直接减低overdraw。通常给烟雾使用。</p>
<h3 id="2-13-后处理：HDR-and-ToneMapping"><a href="#2-13-后处理：HDR-and-ToneMapping" class="headerlink" title="2.13. 后处理：HDR and ToneMapping"></a>2.13. 后处理：HDR and ToneMapping</h3><ol>
<li>渲染层的HDR: HDR和ToneMapping</li>
</ol>
<p>参考GDC2017 High Dynamic Range color grading and display in Frostbite</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568966737421.png" alt="1568966737421"></p>
<p>Tonemap之前的流程包括暗角，Flare Len，DoF，Bloom，自动曝光参数计算（部分参数用于ToneMaping）.</p>
<p>可以将ToneMap和Grading、Gamma矫正进行合并。</p>
<ol start="2">
<li>显示层的HDR：多ToneMapping曲线</li>
</ol>
<p>如果在LDR和HDR显示器上使用同一个ToneMapping曲线，会导致画面整体变亮。</p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569205929868.png" alt="1569205929868"></p>
<p><strong>FrameBuffer始终是0-1</strong>，（硬件层面，还会转换为1-65535或者1-255），而1对应的值变成了：100nits  200nits 1000nits,所以需要不同的曲线。</p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569204914339.png" alt="1569204914339"></p>
<p>寒霜策略：</p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569205757913.png" alt="1569205757913"></p>
<h3 id="2-14-后处理：TAA"><a href="#2-14-后处理：TAA" class="headerlink" title="2.14. 后处理：TAA"></a>2.14. 后处理：TAA</h3><p>参考：SIGGRAPH2016 Temporal Reprojection AA INSIDE</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/TAACompare.jpg" alt="TAACompare"></p>
<h2 id="3-GPU架构"><a href="#3-GPU架构" class="headerlink" title="3. GPU架构"></a>3. GPU架构</h2><h3 id="3-1-GPU存储架构"><a href="#3-1-GPU存储架构" class="headerlink" title="3.1. GPU存储架构"></a>3.1. GPU存储架构</h3><p>Registers:  [on-chip]5 clocks   </p>
<p>Shared Memory ： [on-chip]50 clocks</p>
<p>Local Memory ：  [logic  on-chip] 100 clocks</p>
<p>Constant Memory ：150 clocks +  conditional Cache.</p>
<p>Global Memory ：150 clocks</p>
<p>Texture Memory ：150 clocks  + Cache + Filter etc.</p>
<p>Host Memory :  Pageable And Pinned. </p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569141565643.png" alt="1569141565643"></p>
<h3 id="3-2-GPU渲染架构"><a href="#3-2-GPU渲染架构" class="headerlink" title="3.2. GPU渲染架构"></a>3.2. GPU渲染架构</h3><h4 id="3-2-1-存储和计算的关系"><a href="#3-2-1-存储和计算的关系" class="headerlink" title="3.2.1. 存储和计算的关系"></a>3.2.1. 存储和计算的关系</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569140686391.png" alt="1569140686391"></p>
<h4 id="3-2-2-Wrap与Wave-Front"><a href="#3-2-2-Wrap与Wave-Front" class="headerlink" title="3.2.2. Wrap与Wave Front"></a>3.2.2. Wrap与Wave Front</h4><p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569140550632.png" alt="1569140550632"></p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569140555815.png" alt="1569140555815"></p>
<h3 id="3-3-手游架构"><a href="#3-3-手游架构" class="headerlink" title="3.3. 手游架构"></a>3.3. 手游架构</h3><p>Memory And Tiled Based Rendering</p>
<p>参考：siggraph2016 Best practice for Mobile</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/5aa7a8c2a46f3.png" alt="5aa7a8c2a46f3"></p>
<h2 id="4-程序优化性能关注的点"><a href="#4-程序优化性能关注的点" class="headerlink" title="4. 程序优化性能关注的点"></a>4. 程序优化性能关注的点</h2><h3 id="4-1-Draw-Call"><a href="#4-1-Draw-Call" class="headerlink" title="4.1. Draw Call"></a>4.1. Draw Call</h3><p>略</p>
<h3 id="4-2-Early-z"><a href="#4-2-Early-z" class="headerlink" title="4.2. Early - z"></a>4.2. Early - z</h3><p>原本的深度测试是在Fragment Shader计算之后的，如果不通过深度测试，这部分Pixel计算就是浪费的。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Buffers:</span><br>Buffer display<br>Buffer depthBuffer<br><br><span class="hljs-comment">//Shaders:</span><br>Shader simpleShader<br>Shader writeDepth<br><br><span class="hljs-comment">//Visibility</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth &lt; depthBuffer.depth<br>       depthBuffer = writeDepth(mesh)<br><br><span class="hljs-comment">//Shading and lighting</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth == depthBuffer.depth<br>        <span class="hljs-keyword">for</span> light in scene<br>            display += simpleShader(mesh, light)<br></code></pre></td></tr></table></figure>

<p>Early-z可以假设PS不修改Depth状态，这样就能将深度测试提前。</p>
<p>Alpha Test会直接导致Early-z失效。也就是无论这个物体有没有被遮挡，一定会发生全部的PS计算。必定产生OverDraw开销，场景中要少用。</p>
<p>大部分引擎的优化策略：<strong>Z-Pre-Pass</strong>和Render Queue Sort。</p>
<p>Unity官方文档的描述：</p>
<p>The fixed-function <a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual//SL-AlphaTest.html">AlphaTest</a> - or its programmable equivalent, <code>clip()</code> - has different performance characteristics on different platforms:</p>
<ul>
<li>Generally you gain a small advantage when using it to remove totally transparent pixels on most platforms.优化了FrameBuffer的读取（Blend）写入，</li>
<li><strong>However, on PowerVR GPUs found in iOS and some Android devices, alpha testing is resource-intensive. Do not try to use it for performance optimization on these platforms, as it causes the game to run slower than usual.与手机架构有关</strong></li>
</ul>
<h3 id="4-3-Over-Draw"><a href="#4-3-Over-Draw" class="headerlink" title="4.3. Over Draw"></a>4.3. Over Draw</h3><p><strong>GPU计算开销主要是<em>warp</em>(或WaveFront或thread，对应一次像素计算（PS）或者一次顶点(VS)计算)的多线程并行计算：需要计算的<em>warp</em>越多开销越高，计算的<em>warp</em>越复杂开销越高。</strong></p>
<p>透明物体，程序可以通过实现，LowResolutionTransparent技术降低大范围覆盖的透明物体的OverDraw。开销分为两部分PS本身的计算和FrameBuffer的写出。</p>
<p>可以制作特效LOD策略降低特效和透明物体的OverDraw。</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569145360889.png" alt="1569145360889"></p>
<h3 id="4-4-Quad-OverDraw"><a href="#4-4-Quad-OverDraw" class="headerlink" title="4.4. Quad OverDraw"></a>4.4. Quad OverDraw</h3><p>warp以2*2形式提交计算，三角形边界有无效计算，三角形越小，无效计算比例越高。PS当中一般需要每个三角形有10个像素的占用。</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569145282601.png" alt="1569145282601"></p>
<h3 id="4-5-Light"><a href="#4-5-Light" class="headerlink" title="4.5. Light"></a>4.5. Light</h3><p>光照需要合理分布，Deferred阶段的灯光影响区域的重叠是变相的OverDraw（非Tiled和Clustered）：</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569145437672.png" alt="1569145437672"></p>
<h3 id="4-6-Vertex-Count"><a href="#4-6-Vertex-Count" class="headerlink" title="4.6. Vertex Count"></a>4.6. Vertex Count</h3><p>同一个模型顶点数过多-&gt;三角面增多-&gt;Quad OverDraw增加。</p>
<p>曲面细分在顶点带来的开销意外 还有大量的Quad OverDraw的开销。</p>
<h3 id="4-7-Texture压缩与内存优化"><a href="#4-7-Texture压缩与内存优化" class="headerlink" title="4.7. Texture压缩与内存优化"></a>4.7. Texture压缩与内存优化</h3><p>纹理是内存当中最主要的的资源，需要合理的进行Tiling和Packing策略，提升利用率。</p>
<h3 id="4-8-Baking"><a href="#4-8-Baking" class="headerlink" title="4.8. Baking"></a>4.8. Baking</h3><p>烘焙唯一的性能影响就是Lighmap的内存占用。必须要合理调节渲染参数。通常需要用一米面积多少个texel的限制。每个模型都需要具体调整。</p>
<h3 id="4-9-MipMap"><a href="#4-9-MipMap" class="headerlink" title="4.9. MipMap"></a>4.9. MipMap</h3><p>重要的远处物体反走样，提升效果的特性。但是内存占用会升高。</p>
<h3 id="4-10-Testure-Streaming"><a href="#4-10-Testure-Streaming" class="headerlink" title="4.10. Testure Streaming"></a>4.10. Testure Streaming</h3><p>解决Mipmap内存占用的问题。</p>
<h3 id="4-11-Shader预加载"><a href="#4-11-Shader预加载" class="headerlink" title="4.11. Shader预加载"></a>4.11. Shader预加载</h3><p>如果场景中Shader变体过多，需要考虑Shader的预加载。</p>
<h3 id="4-12-Shader分支"><a href="#4-12-Shader分支" class="headerlink" title="4.12. Shader分支"></a>4.12. Shader分支</h3><p>通常需要切换渲染效果：切换方式有3种：</p>
<ol>
<li>宏：</li>
</ol>
<p>通过#define关键字可以定义Shader的表现。不能游戏时切换，主要用来测试和调试，或者多平台兼容。</p>
<ol start="2">
<li>变体：</li>
</ol>
<p>通过Shader的变体宏控制分支开关，缺点是会生成大量变体。</p>
<ol start="3">
<li>if else 分支语句切换：</li>
</ol>
<p>如果没有合理使用可能导致性能降低，但是通常可以提升性能并且降低变体数量。</p>
<h2 id="5-美术资源可能带来的性能问题"><a href="#5-美术资源可能带来的性能问题" class="headerlink" title="5. 美术资源可能带来的性能问题"></a>5. 美术资源可能带来的性能问题</h2><ol>
<li>游戏内存： 场景当中要绘制的所有东西都需要保存到内存中，其中最重要的就是：<strong>模型、贴图</strong>。</li>
<li>drawcall：每绘制一种东西（不同的模型：即使是相同的材质球也算不同的模型，除非合并他们的mesh），<strong>内存都需要把相关的渲染参数、模型数据、贴图数据传递到GPU</strong>，这个速度非常慢，所以看到的模型越多，drawcall越多。</li>
<li>GPU渲染速度：模型的材质越复杂，渲染越慢。这个靠TA来制定标准即可。</li>
</ol>
<p>对应的美术资源优化主要有个以下方面：</p>
<ol>
<li>模型拆分，模型组件复用：美术制作场景时，复用模型资源进行摆放。<strong>只是为了提升工作效率，拆分之后还是需要尽可能使用相同材质，最终还是要合并。</strong></li>
<li>贴图Tiling，贴图复用：能够直接降低内存开销。<strong>为了效果可以使用更少、分辨率更高的贴图。</strong></li>
<li>材质复用：不同的模型使用同一个材质球（必须是同一个材质球，而不是不同的材质球同一个参数。）<strong>材质复用的目的，是最终要合并网格以减少drawcall，如果不合并那么材质复用就没有意义。</strong> <strong>Dynamic Batch</strong> 就是这个原理，但是他会在内存生成一份合并后的mesh，相当于内存占用翻倍，浪费内存。<strong>Static Batch</strong>也是一样，只不过是静态合并好。但是合并的物体覆盖全场景。还会导致遮挡剔除失效，同样占内存。</li>
<li>Prefab、Model复用（包括组件的Prefab，完整模型的Prefab）：直接提升资源利用率。这种服用就是一模一样的mesh和材质，可以直接合并。</li>
</ol>
<h3 id="5-1-游戏性能瓶颈：模型"><a href="#5-1-游戏性能瓶颈：模型" class="headerlink" title="5.1. 游戏性能瓶颈：模型"></a>5.1. 游戏性能瓶颈：模型</h3><p>由于场景资源复杂，可能遇到的性能瓶颈：</p>
<ol>
<li>模型数量：模型数量越多（ 一个submesh算一个模型 ）drawcall越多，成正比。</li>
<li>一个模型的面数：模型越大，越占内存。（不使用static batch的原因）。</li>
<li>模型属性太多（比如各个uv通道全部使用，normal、tangent全部使用）：属性使用的越多，越占内存。</li>
</ol>
<p><strong>模型的内存开销&#x3D;模型数量 * 一个模型的面数 * 模型属性</strong></p>
<p><strong>模型的drawcall 开销&#x3D; 场景中的模型数量。</strong></p>
<h3 id="5-2-游戏性能优化：模型"><a href="#5-2-游戏性能优化：模型" class="headerlink" title="5.2. 游戏性能优化：模型"></a>5.2. 游戏性能优化：模型</h3><ol>
<li>美术在3Dmax当中合并不同的mesh。（相同材质的合并，通过合理分布uv可以让大部分mesh复用同一个材质）。<strong>能够在模型总内存消耗不变的情况下降低drawcall。</strong></li>
<li>如果材质的属性不使用，就不要输出，例如：第二套uv，顶点色，切线信息。<strong>直接降低内存开销。</strong></li>
<li>控制模型面数，场景当中看不到的面裁切掉。<strong>直接降低内存开销。</strong></li>
</ol>
<h3 id="5-3-游戏性能瓶颈：贴图"><a href="#5-3-游戏性能瓶颈：贴图" class="headerlink" title="5.3. 游戏性能瓶颈：贴图"></a>5.3. 游戏性能瓶颈：贴图</h3><ol>
<li><strong>场景中涉及到的</strong>贴图数量越多，内存占用越大。（例如：一张1024*1024的三通道贴图，相当于一个100万点的只记录了顶点位置的模型，相当于10万顶点并记录了顶点色的模型），美术需要考虑模型和贴图之间的平衡。</li>
<li><strong>场景中涉及到的</strong>贴图越大，内存占用越多。</li>
<li><strong>场景中涉及到的</strong>贴图开启mipmap占用内存越多。</li>
<li>如果贴图不在场景中，那他就只是占用硬盘而已。</li>
</ol>
<p><strong>贴图内存开销&#x3D; 贴图数量 * 贴图大小。</strong></p>
<p><strong>贴图drawcall开销 &#x3D; 基本只和内存有关。</strong></p>
<p>*<strong>注：</strong>“场景当中涉及到的”指的是客户端从硬盘加载到内存的场景数据。</p>
<h3 id="5-4-游戏性能优化：贴图"><a href="#5-4-游戏性能优化：贴图" class="headerlink" title="5.4. 游戏性能优化：贴图"></a>5.4. 游戏性能优化：贴图</h3><p><strong>贴图内存开销&#x3D; 贴图数量 * 贴图大小。</strong></p>
<ol>
<li>使用Tiling方式的贴图。<strong>减小贴图大小。</strong></li>
<li>提高利用率。<strong>减少贴图数量。</strong></li>
<li>LightMap 一般会很占用内存，需要合理调整大小，和烘焙参数。</li>
</ol>
<h3 id="5-5-游戏性能瓶颈：材质"><a href="#5-5-游戏性能瓶颈：材质" class="headerlink" title="5.5. 游戏性能瓶颈：材质"></a>5.5. 游戏性能瓶颈：材质</h3><ol>
<li><strong>场景中涉及到的材质</strong>数量越多drawcall越多。</li>
<li><strong>场景中涉及到的材质</strong>使用的贴图越多占用内存越多。</li>
</ol>
<p>材质内存开销 &#x3D;  几乎不考虑。</p>
<p>材质drawcall开销&#x3D; 主要看mesh，因为如果同一个mesh 使用不同的材质，那么drawcall还是两个。</p>
<p><strong>材质复用的真正目的是为了能够合并场景中使用相同材质的mesh。以直接减少drawcall。</strong></p>
<h3 id="5-6-游戏性能优化：材质"><a href="#5-6-游戏性能优化：材质" class="headerlink" title="5.6. 游戏性能优化：材质"></a>5.6. 游戏性能优化：材质</h3><p><strong>材质复用的真正目的：为了能够合并场景中使用相同材质的mesh，以直接减少drawcall。</strong></p>
<ol>
<li><strong>使用相同的材质 + 不同的mesh</strong> 的策略来实现丰富的表现，方便合并。例如：用刷顶点色，代替mask贴图。</li>
<li>材质复用优先于mesh复用：如果mesh复用，而使用了不同的材质，那么drawcall不能再减少了。如果复用了材质（同一个材质球），而使用了不同的mesh，那么有很多方法来合并mesh以减少drawcall。</li>
</ol>
<h3 id="5-7-游戏性能瓶颈：Quad-OverDraw-、OverDraw"><a href="#5-7-游戏性能瓶颈：Quad-OverDraw-、OverDraw" class="headerlink" title="5.7. 游戏性能瓶颈：Quad OverDraw 、OverDraw"></a>5.7. 游戏性能瓶颈：Quad OverDraw 、OverDraw</h3><p><strong>GPU计算开销主要是<em>warp</em>(或WaveFront或thread，对应一次像素计算（PS）或者一次顶点(VS)计算)的多线程并行计算：需要计算的<em>warp</em>越多开销越高，计算的<em>warp</em>越复杂开销越高。</strong></p>
<p>在渲染管线当中主要是VS阶段计算（和顶点数相关）和PS阶段的计算（和物体覆盖像素有关）。其中PS开销最高。也就是说物体占用的像素越多，开销越高。</p>
<p>OverDraw：</p>
<p>​	1.可见透明物体，所有未遮挡像素都会计算。多层透明物体重叠，会导致PS阶段需要计算的Warp数提升。</p>
<p>​	2.Alpha Test物体：无论是否被遮挡，Early-Z完全失效，导致PS阶段计算的Warp数提升。</p>
<ol start="3">
<li>后处理：每一个后处理相当于全屏每个像素计算一次。</li>
</ol>
<p>Quad OverDraw：</p>
<p>​	PS阶段Warp实际上以2*2为单位计算，也就是说三角形的渲染边界会有很多无效的像素被计算。</p>
<ol>
<li>狭长三角形，对像素利用率过低。</li>
<li>距离过远的三角形，如果缩成一个像素点，开销为实际需要的4倍，如果占据8个限速点，大概为实际需要的2倍。</li>
</ol>
<h3 id="5-8-游戏性能优化：Quad-OverDraw-、OverDraw"><a href="#5-8-游戏性能优化：Quad-OverDraw-、OverDraw" class="headerlink" title="5.8. 游戏性能优化：Quad OverDraw 、OverDraw"></a>5.8. 游戏性能优化：Quad OverDraw 、OverDraw</h3><p>OverDraw：</p>
<ol>
<li>用更细化的网格秒回透明物体、或者AlphaTest物体。</li>
<li>场景中少用AlphaTest ：例如：蜘蛛网用AlphaBlend。铁丝网少用。</li>
<li>对后处理进行合并计算，去除不必要的后处理。</li>
</ol>
<p>Quad OverDarw</p>
<ol>
<li>美术布线避免使用狭长三角形。</li>
<li>使用LOD，保证每一个三角形的像素占用率。</li>
</ol>

      
      <p align="right"><a class="morebtn" href="/2022/07/09/RTR/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/" title="主机渲染和优化技术概要">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/RTR/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/RTR/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/" itemprop="url">大气散射</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RTR/" itemprop="url" rel="index"><span itemprop="name">RTR</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="大气散射"><a href="#大气散射" class="headerlink" title="大气散射"></a>大气散射</h1><p>翻译、摘录自GEMS2中的大气散射：<a target="_blank" rel="noopener" href="https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering">GEMS2：Accurate Atmosphere Scaterring</a>.</p>
<p>这里实现的方法来自于：Nishita et al. 1993。</p>
<p>我们假设摄像机在地平线上，这样就可以假设在各个角度观察大气的密度是固定的。这样就可以简化大气散射模型。</p>
<h2 id="求解大气散射模型"><a href="#求解大气散射模型" class="headerlink" title="求解大气散射模型"></a>求解大气散射模型</h2><p>散射模型有嵌套积分，没有解析解。幸运的是，可以用梯形法则计算( trapezoid rule)</p>
<blockquote>
<p>  Note:</p>
<p>  梯形法则计算：将该段分成n个样本段，并在每个样本段的中心点计算被积函数。将每个结果乘以样本段的长度并将它们全部加起来。样本数量越多，计算结果越准确，但也使积分计算成本较高。</p>
</blockquote>
<p>如果光线穿过大气层到达顶点，需要计算散射。每条射线都应该有两个确定的点，标记出<strong>射线开始穿过大气层的位置</strong>和<strong>停止穿过大气层的位置</strong>。如下图的A和B点。</p>
<p><img src="/../../images/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/16_atmospheric_02.jpg" alt="16_atmospheric_02.jpg"></p>
<p><strong>当相机在大气中，A是相机的位置</strong>。当顶点在大气中，B是顶点的位置。<strong>当任意一点在空间中时，我们执行一个球体交点检查来找出射线与外层大气交点，然后我们做交点A或B。</strong></p>
<p>当我们得到了两个交点，我们就可以开始计算AB之间的积分。我们在线段中间找到我们的采样点P1..P5。</p>
<p>每一个点的光线的变化：接受<strong>直接来自于太阳的光线</strong>和<strong>来气其他方向的散射光线</strong>，然后一部分光线向摄像机传递，一部分光线向其他方向散射。</p>
<h2 id="Rayleigh-Scattering-vs-Mie-Scattering"><a href="#Rayleigh-Scattering-vs-Mie-Scattering" class="headerlink" title="Rayleigh Scattering vs. Mie Scattering."></a>Rayleigh Scattering vs. Mie Scattering.</h2><p>知道了光线如何在一点散射，另一个重要的细节是关于如何模拟P点的光散射。大气中不同的粒子以不同的方式散射光线。大气中最常见的两种散射形式是瑞利散射和密散射。</p>
<p><strong>Rayleigh 散射</strong>是由空气中的小分子引起的，它在较短的波长(先是蓝色，然后是绿色，然后是红色)上对光线的散射更大。天空是蓝色的，<strong>因为蓝色的光到处反射，最终从各个方向到达你的眼睛</strong>。太阳的光线在日落时会变成黄色&#x2F;橙色&#x2F;红色，这是因为光线穿过大气层时，<strong>几乎所有的蓝光和大部分绿光在到达你面前就被散射掉了</strong>，只剩下红色。</p>
<p><strong>Mie 散射</strong>是由空气中称为气溶胶的较大粒子(如灰尘和污染)引起的，<strong>它倾向于均匀地散射所有波长的光</strong>。在一个雾蒙蒙的日子，Mie散射导致天空看起来有点灰色，并导致太阳有一个大的白色光晕围绕它Mie散射也可以用来模拟空气中水和冰的小粒子散射的光，以产生彩虹的效果，但这超出了本章的范围。(详情请参阅Brewer 2004。)</p>
<h2 id="Phase-Function相函数"><a href="#Phase-Function相函数" class="headerlink" title="Phase Function相函数"></a>Phase Function相函数</h2><p>这里主要描述光线在某一个点的散射和传递情况：</p>
<p><img src="/../../images/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/0256equ01.jpg" alt="0256equ01.jpg"></p>
<p><strong>相位函数描述了有多少光线散射到了相机方向</strong>，（从太阳方向到摄像机方向），还有常量g对散射量的影响。</p>
<p>相位函数有很多不同的版本。上面的函数是对Nishita等人1993年使用的Henyey-Greenstein函数的一种改编。</p>
<p>瑞利散射可<strong>近似地设g为0</strong>，这大大简化了方程，使<strong>其对正角和负角对称。当g为负值时，正向散射的光更多，当g为正值时，向光源反射的光更多</strong>。对于Mie气溶胶散射，g通常设置在**-0.75 ~ -0.999<strong>之间。</strong>永远不要将g设为1或-1，因为这会使等式简化为0。**</p>
<h2 id="The-Out-Scattering-Equation出散射方程"><a href="#The-Out-Scattering-Equation出散射方程" class="headerlink" title="The Out-Scattering Equation出散射方程"></a>The Out-Scattering Equation出散射方程</h2><p><img src="/../../images/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/0256equ02.jpg" alt="0256equ02.jpg"></p>
<p>外散射方程是前面提到的内积分：<strong>描述了从点Pa到点Pb的平均大气密度乘以射线的长度（光学深度、光学距离、光学厚度optical depth）。</strong></p>
<blockquote>
<p>  Note:</p>
<p>  可以把它看作是一个基于光线路径上空气粒子数量的加权因子。方程的其余部分由常数组成，它们决定了这些粒子从射线中散射出去的光的多少。</p>
</blockquote>
<p>为了计算这个积分的值，从Pa到Pb的射线将被分割成段，指数项将在每个采样点被计算。</p>
<p>变量h是采样点的高度。<strong>在我的实现中，高度被缩放，0代表海平面（地面），1代表大气的顶部。</strong>理论上，大气没有固定的顶部，但是为了实际的目的，我们必须选择一个高度来渲染天空穹顶。h0是比例尺高度，这是大气平均密度的高度。我的实现使用了0.25，所以从地面到天空穹顶的平均密度是25%。我的实现使用了0.25，所以从地面到天空穹顶的平均密度是25%。</p>
<p>常数是光的波长(或颜色)和K()是散射常数，它依赖于海平面的大气密度。<strong>瑞利散射和密散射有各自的散射常数，包括尺度高度h0。</strong></p>
<p>瑞利散射和密散射对波长的依赖也不同。瑞利散射常数通常除以4，在大多数计算机图形模型中，Mie散射常数与波长无关，但至少有一个实现将其除以0.84。</p>
<p><strong>外散射函数决定了有多少光被沿图的两条绿色射线散射掉了。</strong></p>
<h2 id="The-In-Scattering-Equation"><a href="#The-In-Scattering-Equation" class="headerlink" title="The In-Scattering Equation"></a>The In-Scattering Equation</h2><p><img src="/../../images/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/0257equ01.jpg" alt="0257equ01.jpg"></p>
<p>内散射方程描述了多少太阳的光线叠加到了大气当中。</p>
<p>对于每个从Pa到Pb中的点P，PPc是点到太阳的射线，PPa是点到相机的射线。外散射函数决定了有多少光被沿图的两条绿色射线散射掉了。剩下的光由<strong>相位函数</strong>（一个点一个相位函数–由实现和太阳光线夹角决定）、散射常数和阳光强度缩放。</p>
<p>阳光强度并不一定依赖于波长，但如果你想创建一个围绕紫色恒星旋转的外星世界，你就应该在这里应用颜色。</p>
<h2 id="The-Surface-Scattering-Equation"><a href="#The-Surface-Scattering-Equation" class="headerlink" title="The Surface-Scattering Equation"></a>The Surface-Scattering Equation</h2><p>这部分就是反射物体表面的颜色。这部分是渲染的选择不做讨论。</p>
<h2 id="实时计算"><a href="#实时计算" class="headerlink" title="实时计算"></a>实时计算</h2><p>如果使用上面的计算开销很高，计算点很多，需要进行简化。</p>
<p>GEMS的方法主要是将Outter Scattering 转换成一张二维LUT，简化计算。</p>

      
      <p align="right"><a class="morebtn" href="/2022/07/09/RTR/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/" title="大气散射">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/RTR/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/RTR/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/" itemprop="url">图像动态范围</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RTR/" itemprop="url" rel="index"><span itemprop="name">RTR</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <!-- TOC -->



<p>- <a href="#%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4">图像动态范围</a></p>
<p>​    - <a href="#dynamic-range">Dynamic Range</a></p>
<p>​    - <a href="#%E6%98%BE%E7%A4%BA%E5%99%A8%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4">显示器动态范围</a></p>
<p>​    - <a href="#%E6%9B%9D%E5%85%89%E6%93%8D%E4%BD%9C%E4%BA%AE%E5%BA%A6%E4%B9%98%E6%B3%95%E5%9C%A8ev-%E7%A9%BA%E9%97%B4%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84">曝光操作（亮度乘法）在EV 空间怎么样的？</a></p>
<p>​    - <a href="#gamma%E6%93%8D%E4%BD%9C%E6%8C%87%E6%95%B0%E6%93%8D%E4%BD%9C%E5%9C%A8ev%E7%A9%BA%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84">Gamma操作（指数操作）在EV空间是怎么样的？</a></p>
<p>​    - <a href="#%E5%AF%B9%E6%AF%94%E5%BA%A6contrast">对比度Contrast</a></p>
<p>​    - <a href="#%E8%BF%99%E4%BA%9B%E5%86%85%E5%AE%B9%E5%A6%82%E4%BD%95%E5%BA%94%E7%94%A8%E5%88%B0%E5%B1%80%E9%83%A8%E6%9B%9D%E5%85%89%E4%B8%8A%E5%8F%AF%E4%BB%A5%E7%95%A5%E8%BF%87">这些内容如何应用到局部曝光上（可以略过）</a></p>
<p>​    - <a href="#eotf%E5%92%8Coetf">EOTF和OETF</a></p>
<p>​    - <a href="#%E6%98%BE%E7%A4%BA%E5%99%A8oetf%E5%92%8Cgamma22%E7%BC%96%E7%A0%81">显示器OETF和gamma2.2编码</a></p>
<p>​    - <a href="#%E8%A7%82%E5%AF%9F%E6%9D%A1%E4%BB%B6">观察条件</a></p>
<p>​    - <a href="#eotf%E5%92%8Coetf%E7%9A%84%E8%A7%86%E8%A7%89%E6%9D%A1%E4%BB%B6">EOTF和OETF的视觉条件</a></p>
<p>​    - <a href="#adjust-gamma-until-logo-is-barely-visible">Adjust gamma until logo is barely visible</a></p>
<p>​    - <a href="#tonemapping%E6%93%8D%E4%BD%9C">ToneMapping操作</a></p>
<p>​    - <a href="#%E5%8F%82%E8%80%83">参考</a></p>
<p>​    - <a href="#%E9%87%8D%E8%A6%81%E6%80%BB%E7%BB%93">重要总结</a></p>
<!-- /TOC -->

<h1 id="图像动态范围"><a href="#图像动态范围" class="headerlink" title="图像动态范围"></a>图像动态范围</h1><p>​	这篇笔记主要为了解释什么是<strong>动态范围</strong>，引出sRGB、ToneMapping等内容的前因后果。</p>
<p>​	笔记摘录自<a target="_blank" rel="noopener" href="https://bartwronski.com/2016/09/01/dynamic-range-and-evs/">Image Dynamic Range</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dynamic_range">wiki Dynamic range</a>,同时根据自己的理解做了补充和注释说明。</p>
<h2 id="Dynamic-Range"><a href="#Dynamic-Range" class="headerlink" title="Dynamic Range"></a>Dynamic Range</h2><p>​		<strong>动态范围</strong>指的是媒体设备能够表示的最大值和最小值的比例（有人会疑问最小值是0怎么办，而实际上0通常表示没有信号，另外最大值和最小值描述的是<strong>设备能够表示的范围</strong>，和设备的硬件相关）。</p>
<p>​		动态范围通常用来描述<strong>信号</strong>：声音信号（播放器）、亮度信号（显示屏）。</p>
<p>​		它通常是一个比例，或者以10为基数的数(声音：分贝)、或者是用2为基数的对数值表示最小信号值和最大信号值的差值(doublings、bits或<strong>stops</strong>)。</p>
<pre><code>    &gt; bits:信号理论、计算、数字通信当中的**基本信号单位**。他的名字是**binary digit**的缩写。
    &gt;
    &gt; doublings:没有搜索到，在这篇笔记中不重要。
    &gt;
    &gt; stops：在摄影中,设备的曝光范围通常用**stops**来表示，相当于设备或者媒体常量比例（contrast ratio）的 $ \log _&#123;2&#125;(c) $ 表示形式。
    &gt;
    &gt; 例如：通常的DV机的拍摄的常量比例是45:1，他的曝光约为5.5stops。
    &gt;
    &gt; 曝光范围可以指几种动态范围中的任何一种:
    &gt;
    &gt; 1.  感光范围照相胶片、纸或数码相机传感器的感光范围.
    &gt; 2.  被拍摄场景的光度范围
    &gt; 3.  显影胶片图像的不透明度范围
    &gt; 4.  相纸上图像的反射率范围。
    &gt;
    &gt; 例如：胶片的曝光范围约为14stops。
</code></pre>
<p>​		（<strong>本段的扩展阅读有点复杂可以跳过</strong>）在模拟信号（模拟信号是指用连续变化的物理量表示的信息）的媒体设备上，他通常表示为信噪比（signal to noise ratio）。最小值是无法从噪声中区分出来的。在某种程度上，他和数字信号（数字信号指自变量是离散的、因变量也是离散的信号，这种信号的自变量用整数表示，因变量用有限数字中的一个数字来表示。）的媒体设备类似，在数字信号设备上，小于最小可表示数据的内容都是量化噪声（由增量调制原理可知，译码器恢复的信号是阶梯形电压经过低通滤波器平滑后的解调电压。它与编码器输入模拟信号的波形近似，但是存在失真，将这种失真称为<strong>量化噪声</strong>。）。</p>
<p>​		动态范围对<strong>模拟相机</strong>（在高亮度和中等亮度的区域的精度更高，黑暗的区域会显示颗粒噪声）、<strong>数字信号</strong>（白色信号被完全的剪裁、大量的信息被压缩到暗部，并且还掺杂着数字噪声）和<strong>数字信号文件</strong>（除了量化噪声、伪影还有0噪声）有不同的含义。</p>
<p>​		这里我们主要讨论在<strong>显示器上</strong>的<strong>动态范围</strong>（<strong>动态范围是stops的范围，可以理解成bit位数</strong>，也叫做曝光范围，也就是说用EV stops表示dynamic range）。我们使用EV stops &#x3D; exposure value stops.<strong>这是一个以2为底数的对数差值</strong>。</p>
<blockquote>
<p>  注意是<strong>对数差值</strong>，例如最大值亮度的曝光值是9，最小亮度的曝光是2，那么动态范围是7.</p>
</blockquote>
<h2 id="显示器动态范围"><a href="#显示器动态范围" class="headerlink" title="显示器动态范围"></a>显示器动态范围</h2><p>​		首先可以做一个简单的联想：<strong>如果我们的输出图像是8bits的，那么显示器的动态范围就是8 EV stop</strong>。<strong>这是错误的：</strong>因为所有在设备上保存的数据都是考虑了<strong>OETF</strong>（存储格式进行了Gamma之类的变换），为了能够在显示设备上正常显示。典型的OETF是gamma操作，常用的Gamma是2.2指数和sRGB（sRGB比2.2编码更加准确，可以参考wiki）</p>
<p>​		<strong>这里实际上就是提出了一个问题：为什么8bits不是对应8 EV stop的动态范围？这里参见后面的解释：OETF（Gamma操作）带来的什么影响</strong>？</p>
<p>​		首先，对于最简单的情况（没有OETF），直接存储8bit值数据。</p>
<p>​		<strong>因为0表示没有信号，所以使用1&#x2F;256（对数为 $ log_2(\frac{1}{258}) &#x3D; -8 $）表示最小可表示信号（小于这个值的都是噪声），1为最高可表示信号（对数为 $ log_2(1) &#x3D; 0 $）,所以动态范围是8。</strong></p>
<blockquote>
<p>  <strong>重要说明，一般来讲图像最大值就是1，关键就是最小值是多少！直接决定了曝光范围</strong></p>
<p>  对于只有8bit的数据来表示颜色情况下，Gamma空间的颜色值的最小值要比线性空间颜色的最小值要小！</p>
</blockquote>
<p>​		下面是动态范围的数值输出和亮度的关系：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/dynrange_linear2.png" alt="dynrange_linear.png"></p>
<p>​		图像说明：动态范围用8bits进行线性编码（没有开了OETF直接保存，即没有Gamma）. 红线 &#x3D; stops:曝光值. 蓝色线 &#x3D; 输出结果（亮度）. 绿色线&#x3D; 曝光值. 点&#x3D; <strong>曝光范围到线性亮度的映射</strong>.</p>
<p>​		线性空间中EV stops的表示显然是指数型的，您可以看到这种编码的问题。很多颜色曝光值压缩在暗部，包括了3&#x2F;4的范围。因此线性编码对于对数信号是极大的浪费。</p>
<blockquote>
<p>  <strong>重要：这幅图用来做什么？</strong></p>
<p>  ​		首先注意，他不是针对像素说的：不是指一个像素的亮度值和这个像素的曝光值的映射。</p>
<p>  ​		<strong>这幅图表达的是</strong>：当我确定一个曝光范围的时候，可以<strong>表示哪个线性范围的图像亮度</strong>。例如：曝光值范围是8的时候可以表示[0-1]的亮度。当曝光范围变成4,那么小于-4的值就是噪声了，这个时候我们发现图像的大部分亮度范围（观察线性亮度的范围）还在，只是丢失了很小一部分的颜色。<strong>这幅图要讨论的就是这个：用更少的编码位数（动态范围）表示图像大部分的亮度范围（线性亮度）。</strong></p>
</blockquote>
<p>​		<strong>重要：我们进行图像的亮度操作通常有两种：Gamma操作（指数操作）和亮度缩放（亮度乘法），下面我们讨论这两种操作在EV stops上会产生什么影响！</strong></p>
<h2 id="曝光操作（亮度乘法）在EV-空间怎么样的？"><a href="#曝光操作（亮度乘法）在EV-空间怎么样的？" class="headerlink" title="曝光操作（亮度乘法）在EV 空间怎么样的？"></a>曝光操作（亮度乘法）在EV 空间怎么样的？</h2><p>​		在EV空间的常见操作是调整曝光值（在我们的游戏开发过程中通常的方法是：<strong>亮度</strong>结果直接<strong>乘一个系数</strong>）。<strong>我们现在讨论这个直接进行亮度乘法会给曝光范围（EV stops）带来什么影响。</strong></p>
<p>​		很显然对数空间（EV空间，就是右上角的值）的加法相当于对应的线性空间（亮度空间）的乘法，亮度空间的乘法：</p>
<p>$$ 2^{x+y} &#x3D;&#x3D; 2^x * 2^y $$</p>
<p>​		从下图可以看出曝光的操作（亮度乘法）没有修改动态范围（EV的范围）：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/exposure.gif" alt="exposure.gif"></p>
<blockquote>
<p>  ​	为什么会是上图的样子呢？</p>
<p>  ​		因为图像在变化的过程中，有效位只有8位，当亮度乘一个系数的时候相当于乘了一个 pow(2,N)，在对数空间相当于做了整体的加法，也可以看做做了左右移位的操作。由于有效位数没有变，所以变化范围只能在这8位以内。也就是动态范围只有8。</p>
</blockquote>
<h2 id="Gamma操作（指数操作）在EV空间是怎么样的？"><a href="#Gamma操作（指数操作）在EV空间是怎么样的？" class="headerlink" title="Gamma操作（指数操作）在EV空间是怎么样的？"></a>Gamma操作（指数操作）在EV空间是怎么样的？</h2><p>​		这就是事情开始变得有趣的地方。Gamma操作（这里实际上泛指的就是幂函数**exp()**，而不是特指图像Gamma变化）通常被定义为线性空间中的一个简单幂函数。</p>
<p>​		Gamma操作：</p>
<p>$$ gamma(x,y) &#x3D; x^y $$   </p>
<p>​		<strong>对亮度进行Gamma操作：下面的公式x表示曝光范围，描述的是在亮度空间进行Gamma操作之后转换回EV空间后，看看EV stops(也就是x)发生了什么变化：</strong></p>
<p>$$ log_2(gamma(2^x,y)) &#x3D;&#x3D; log_2(2^{x*y}) $$  </p>
<p>​		<strong>进一步变化，说明亮度的Gamma操作相当于对动态范围（EV值）的乘法：</strong></p>
<p>$$ log2(2^{x<em>y}) &#x3D;&#x3D; x</em>y $$</p>
<p>​		Gamma的操作对应了<strong>EV值的乘法</strong>（乘法就是压缩或者拉伸）。这是一个被GPU利用的性质：通过一系列的exp2，madd和log2操作来表示power操作。</p>
<blockquote>
<p>  怎么理解？</p>
<p>  就是说Gamma空间的颜色值进行了指数运算，相当于对曝光空间（EV stop 曝光步长）进行了压缩或者拉长。见下图。</p>
</blockquote>
<p>​		<strong>因此伽玛操作本质上是动态范围压缩&#x2F;扩展操作!</strong></p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/gamma.gif" alt="gamma.gif"></p>
<p>​		<strong>你可以看到它对原来的8位动态范围发生了变化。所以Gamma操作（幂操作或者log操作）可以压缩或者增加动态范围。</strong></p>
<h2 id="对比度Contrast"><a href="#对比度Contrast" class="headerlink" title="对比度Contrast"></a>对比度Contrast</h2><blockquote>
<p>  这里的对比度Contrast指的是一种维持颜色明暗的类似Gamma的操作，不是指图像的对比度。</p>
</blockquote>
<p>​		Gamma操作是一个有用的操作，但是用作增加动态范围的时候，整个图像比原来亮了。压缩动态范围的时候，整个图像的颜色都变暗了。这是因为锚点定在了0，线性空间颜色的最大值不会因为EV空间的动态范围变化而变化。这并不是我们想要的属性。<strong>在调整动态范围的过程中（Gamma操作的时候），我们希望图像保证亮度一致性。我们可以补偿亮度！用到的策略就是修改锚点—-例如使用中间灰度作为中间锚点。</strong></p>
<p>​		对比度和gamma很像，但是希望在调整动态范围的时候，保证其他的某个点的颜色不变而不是亮度为1的点不变（<strong>这里还没有讨论到hdr，所以最亮的位置是1</strong>）。例如中间灰度点0.18。</p>
<p>​		对比度计算公式:</p>
<p>$$ contrast(x, y, midPoint) &#x3D; \frac{x^y * midPoint }{ midPoint^y} $$</p>
<h2 id="这些内容如何应用到局部曝光上（可以略过）"><a href="#这些内容如何应用到局部曝光上（可以略过）" class="headerlink" title="这些内容如何应用到局部曝光上（可以略过）"></a>这些内容如何应用到局部曝光上（可以略过）</h2><p>​		希望有了这些知识，我们就能明白为什么局部曝光相对于其他对比和Gamma操作能更好地保持局部对比、饱和度。他移动了部分的颜色直方图（颜色过亮或者过暗的区域）但是：</p>
<ol>
<li>只应用在了部分图像，没有影响中间调。</li>
<li>只移动值，没有想Gamma一样压缩或者缩放。</li>
</ol>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/gamma_vs_both.gif" alt="gamma_vs_both"></p>
<h2 id="EOTF和OETF"><a href="#EOTF和OETF" class="headerlink" title="EOTF和OETF"></a>EOTF和OETF</h2><p>​		在谈论输出函数的时候，显示设备使用的电信号转换函数（EOTF – Electro Optical Transfer Function）和他的逆转函数（OETF, Opto-Electrical Transfer Function）是很重要的。</p>
<p>​		EOTF已经存在了很长时间， 所有CRT显示器对于电压强度的响应方式在某些条件下被认为是一致的。</p>
<p>​		下图是CRT显示器对于输入电压和输出亮度的函数关系。</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/crt_gamma.gif" alt="crt_gamma.gif"></p>
<p>​		早期的渲染管线完全忽视了Gamma并且直接使用它的感知线性属性，直接输出被显示器进行Gamma Power编码后的值。<strong>当你开始认真对待线性空间时，我们才开始使用它的逆函数-OETF，这也是我们为显示器编码信号的策略，例如： sRGB or Rec709。</strong></p>
<p>​		<strong>重要：当我们不再使用CRT显示器的时候，这种指数编码同样被验证在现代显示器上是有用的，他允许我们能够编码更多的信号</strong>（参考前面的Gamma变化可以压缩动态范围）。现在我们使用BT1886标准（指的是EOTF）<strong>用来模拟老式CRT显示器的gamma电压响应。</strong></p>
<blockquote>
<p>  这里讨论的就是我们能够通过Gamma编码<strong>在文件当中保存更大的动态范围</strong>，随后再利用显示器自带的EOTF解码以得到正确的效果。</p>
</blockquote>
<p>​		<a target="_blank" rel="noopener" href="https://kb.portrait.com/help/bt-1886-10-questions-10-answers">BT1886问答</a></p>
<p>​		下面是BT1886标，注意他是在指数空间：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/1579405297828.png" alt="1579405297828"></p>
<h2 id="显示器OETF和gamma2-2编码"><a href="#显示器OETF和gamma2-2编码" class="headerlink" title="显示器OETF和gamma2.2编码"></a>显示器OETF和gamma2.2编码</h2><p>​		我们现在回顾显示器的2.2 Gamma。因为EOTF是2.2，所以OETF就是1&#x2F;2.2（大概就是0.45），这就是我们的Gamma函数，将颜色从线性空间转换到gamma空间，我们会得到一个2.2*8（&#x3D;17.6）的动态范围。（可以保存在文件中的）。</p>
<p> $$OETF &#x3D;  gamma(color, \frac{1}{2.2}) $$  </p>
<p> $$EV stops &#x3D; log_2(gamma(2^x, \frac{1}{2.2}))  &#x3D; 2.2*x$$   </p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/dynrange_gamma_2_21.png" alt="dynrange_gamma_2_2.png"></p>
<blockquote>
<p>  sRGB标准包括了很多内容，Gamma编码只是其中一部分。</p>
<p>  下图来源于wiki，sRGB标准中linear空间进入Gamma空间的公式。</p>
<p>  <img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/1579420987252.png" alt="1579420987252"></p>
</blockquote>
<p>​		现在有人会问，我以为显示器使用sRGB函数，（它在较小值的位置使用了线性函数，其他位置用了2.4的指数。）</p>
<p>​		为什么我不使用精确的sRGB? 在这篇文章中，<strong>我将直接使用gamma 2.2，为了简化说明。</strong></p>
<blockquote>
<p>  对于大部分制作软件，和显示器都依赖sRGB标准。在渲染当中我们通常用2.2进行编码解码。</p>
</blockquote>
<p>​		<strong>这里值得注意的是，仅仅是伽玛2.2的线性值编码在8位就有了很大的动态范围（翻倍）。那么17.6的曝光级别足够了么？</strong>我们得到了更大的分布，尤其是在y轴上变得更均匀了。但是现在仍然不完美，因为现在把太多的值放在了表示阴影上，更多的变化集中在高亮度区间（而不是中等亮度区间，<strong>也就是说高亮度区间对于数值的变化更敏感</strong>）。我们随后在处理。</p>
<p>​		另一方面，使用gamma2.2的OETF（使用了17.6的曝光级别）意味着我们不需要HDR显示和局部的tonemapping了？并不是！仔细想想在1&#x2F;256和2&#x2F;256之间有多少信息？2.2的 EV对于观察者意味着什么？他们可能根本注意不到，因为范围亮度变化太小了。<strong>不同的显示器有不同的曝光范围，并且依赖于观察环境（就是显示器周围的环境）</strong>。参考<a target="_blank" rel="noopener" href="http://gpuopen.com/gdc16-wrapup-presentations/">Presentation by Timothy Lottes</a> 。</p>
<blockquote>
<p>  有一个地方值得说明：</p>
<p>  EOTF 的标准只有一个BT1886</p>
<p>  但是为了这种显示器编码的OETF标准有各种各样。</p>
</blockquote>
<p>​		但是在我继续深入分析tonemapping是如何改变它的以及gamma真正做了什么之前，我做了一个关于观察条件的小实验。</p>
<h2 id="观察条件"><a href="#观察条件" class="headerlink" title="观察条件"></a>观察条件</h2><p>​		下面是一张iPhone照片，照片中的笔记本上显示了一张图片。这是对于笔记本来说完美的观察环境（拉上了窗帘），笔记本中的图片细节都看的很清楚。</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/2016-08-21-13-31-05.jpg" alt="2016-08-21 13.31.05.jpg"></p>
<p>由于手机没有捕获足够的动态范围，但是看着可以，所有的细节都捕获了，大量的细节在阴影当中。</p>
<p>有趣的是HDR的场景和影子看起来非常暗，但是充满了细节和亮点。在这样的完美观察环境中，我不要任何的调整就能够感觉到图像和显示器就是hdr的。</p>
<p>第二张图片在平均视觉条件当中：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/2016-08-21-13-29-59.jpg" alt="2016-08-21 13.29.59.jpg"></p>
<p>正常图片仍然是清晰可以观察到的，尽管暗处丢失的细节不可见。</p>
<p>图像看起来有了更强烈的明暗差别，但是Kratos的背部完全看不到了。</p>
<ul>
<li><strong>Bartleson–Breneman effect:</strong> 图像对比度(发光显示器的图像，如液晶显示器上的图像)随着周围照明的亮度增加。</li>
</ul>
<p>第三张我们在极强的亮度条件下</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/2016-08-21-13-30-31.jpg" alt="2016-08-21 13.30.31.jpg">条</p>
<p>这个时候超过的屏幕的亮度，屏幕内容已经变得不可见了。</p>
<p>增强亮度，可以看到屏幕细微的变化：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/2016-08-21-13-30-31_c.jpg" alt="2016-08-21 13.30.31_c.jpg"></p>
<p>​		图像不但不可见了，而且丢失了大量的细节，并且还被屏幕的反射覆盖了。几乎没有Gamma设置能够改善这样的情况。</p>
<p>​		实验的目的是为了说明：<strong>Timothy Lottes在他的演讲中所展示的——观看条件（看显示器的环境）定义了可感知（人眼的实际感受）的动态范围，和图像的清晰度。</strong></p>
<p>​		从数值上理解就是，由于亮度太高你无法分辨0.25以下的值。这就是这个场景动态范围的结果：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/poor_viewing_conditions2.png" alt="poor_viewing_conditions.png"></p>
<p>曝光范围在4.4EV的位置就停止了，所以我们需要做一些局部的tonemapping。</p>
<h2 id="EOTF和OETF的视觉条件"><a href="#EOTF和OETF的视觉条件" class="headerlink" title="EOTF和OETF的视觉条件"></a>EOTF和OETF的视觉条件</h2><p>​		<strong>观察环境</strong>和<strong>感知能力</strong>是存在不同的gamma EOTF曲线和OETF曲线的原因。Rec709 EOTF （给高清电视用的）和sRGB（给显示器和打印机用的）的转换曲线是不同的（<strong>2.4</strong> vs <strong>2.2</strong>），因为高清电视在较暗的观看条件下需要不同的对比度和人眼感知效果（2.4有更大的动态范围）。</p>
<blockquote>
<p>  Rec709和sRGB除了Gamma不同之外还有很多特性需要注意，还涉及到文件传输，保存，显示特性，这里不做详细讨论。值得注意的是，Rec. 709和sRGB具有相同的主色性。</p>
</blockquote>
<p>​		由于Bartleson-Breneman效应（<strong>当周围环境变得更明亮时，我们感知到更多的对比度，更少的动态范围</strong>，因为动态范围由最小可表示精度决定，太亮的地方，看暗处的感受就不明显了。），客厅在晚上和标准办公环境(sRGB)需要不同的EOTF。Rec709 EOTF伽马将意味着输出设备产生更多的对比度。（<strong>Gamma更大，图像亮度更亮</strong>）</p>
<p>​		因此使用，翻转函数，OETF of Rec709能够保存更大的曝光范围，并且TV支持他们的显示并且TV的使用环境我们认为偏暗，所以会足够好。</p>
<blockquote>
<p>  在比较暗的环境中，因为人感受到更少的对比度（明暗对比），更大的动态范围（暗处的细节），我们希望提高屏幕亮度，降低对比度，使用比较大的gamma值。（晚上的客厅）</p>
<p>  在比较亮的环境中，因为人感受到更多的对比度，更x小的动态范围，我们希望降低屏幕亮度，提升对比度，使用比较小的gamma值。（办公环境）</p>
</blockquote>
<p>​		下面是两个曲线的对比：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/gamma_2_2vs2_4.gif" alt="gamma_2_2vs2_4.gif"></p>
<p>​		Gamma2.2和2.4并不是唯一的标准，不同的软件和硬件还有不同的标准。你可以找到历史参考苹果Mac gammas 1.8或2.0。Gameboy使用了极限的gammas 3.0或4.0</p>
<h2 id="Adjust-gamma-until-logo-is-barely-visible"><a href="#Adjust-gamma-until-logo-is-barely-visible" class="headerlink" title="Adjust gamma until logo is barely visible"></a>Adjust gamma until logo is barely visible</h2><p>​		由于不同的观察条件（在不同的灯光环境看显示器），是我们看到下面这张图的原因：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/logo.png" alt="logo.png"></p>
<p>​		<strong>有的时候这个东西没有名字，有时候叫做Slider,有时候叫做Gamma，有时候叫做对比度、亮度，这些都是不对的，但是他们本质的功能是调节不完美的观察条件,以让人能够正确的观察到屏幕效果。</strong></p>
<p>​		在亮度环境范围，会造成一个对比度的降低了的环境，需要动态范围压缩的操作（降低Gamma值，让图像变暗），观察者能够感受到更强的对比度。</p>
<blockquote>
<p>  试想一下</p>
<p>  在特别亮的灯光环境下，应该把它调亮，这个时候相当于增加动态范围，增加Gamma，这个时候对比度降低了。</p>
<p>  当周围环境变得更明亮时，我们感知到更多的对比度，更少的动态范围。所以我们要增加动态范围降低对比度，以保证观察效果。</p>
</blockquote>
<p>这个设置通常是有用的，但是问题在于：</p>
<ol>
<li>通常用户值只设置一次，却在不同的环境玩游戏。设置一次但是在白天、晚上、晚上开灯的时候玩游戏。</li>
<li>这个功能的目的没有合理的表达出来。这个调节结果依赖于室内环境的亮度和内容被观察的环境。</li>
</ol>
<p>​		假设在一个很糟糕的观察条件下。环境特别亮，这个时候我们如何调整显示器的Gamma值?(在EOTF以外的操作)。</p>
<p>​		这个是时候我们需要提高动态范围，降低对比度。所以在输出之前的OETF编码需要进行修改，使用0.7的改变图像的动态范围（我们对于显示器的EOTF没有做任何事情）:</p>
<p>$$ (x^{0.7})^{1&#x2F;2.2} &#x3D;&#x3D; x^{0.7&#x2F;2.2} $$</p>
<p>注意下面的公式是编码到Gamma空间的编码方式，上面的内容就是保存更大的动态范围：</p>
<p>$$ x^{1&#x2F;2.2} $$</p>
<p>图示：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/poor_viewing_conditions1.gif" alt="poor_viewing_conditions.gif"></p>
<p>​		这样我们就增加了1.42左右的曝光范围。然而，在好的观察条件下（从特别明亮的环境，回到晚上），效果有会变的很差。</p>
<blockquote>
<p>  这部分需要注意了： 我们没有对显示器本身的EOTF做任何事情，只是单纯的修改了图像编码到Gamma空间的函数，也就是我们提升了这个图像保存时的动态范围。然后在显示出来。</p>
<p>  这个时候就有一个问题，Gamma的编码和解码不配套，而按照标准资源制作流程都是sRBG。这里需要注意两点：</p>
<ol>
<li>我们是在游戏渲染中常常用到这种策略。</li>
<li>修改原始图像的动态范围，表示我们的图像在动态范围做了伸缩，而显示器本身还有自己的动态范围的伸缩，并没有改变颜色，Gamma空间就是单纯的动态范围伸缩而已！另外，注意动态范围并不是数据精度的bit。</li>
</ol>
</blockquote>
<h2 id="ToneMapping操作"><a href="#ToneMapping操作" class="headerlink" title="ToneMapping操作"></a>ToneMapping操作</h2><p>​		从上面的分析来看我们不需要tonemapping的曲线。毕竟在适当的观测条件下，采用直接的线性编码可以获得较大的动态范围。</p>
<p>这里有两个问题：</p>
<ol>
<li><p>其一是非正规分布的数据，较高的曝光区域占据了很大的范围。我们希望更大的动态范围保存中等亮度的值。</p>
</li>
<li><p>通常1定义了一个白色点，但是在没有上限的HDR渲染上，曝光之后，我能够保证在中等范围有足够的值，我们也能够在亮度区域有足够的动态分布。这在PBR渲染当中是确实存在的。</p>
<p>​		目前提供的方法还没有为那些非常明亮的对象提供任何解决方案，我们不想降低对比度或改变曝光，我们不想让它们完全失去饱和度;我们仍然希望看到一些细节。</p>
</li>
</ol>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/proper_exp_linear.png" alt="proper_exp_linear"></p>
<p>​	上图的曝光效果完全剪裁掉了亮度区域。</p>
<p>​	这个时候就是tonemapping发挥作用的地方。一些常见的例子： Reinhard。我绝不推荐这条曲线，还有更好的选择。</p>
<p>可能每个引擎都实现了一个参考曲线： <a target="_blank" rel="noopener" href="http://filmicgames.com/archives/75">Hable Uncharted tonemapping curve</a>.</p>
<p>另一个选择是：<a target="_blank" rel="noopener" href="https://github.com/ampas/aces-dev">ACES</a></p>
<p>或者开销更低的：ACES RRT and ODT， <a target="_blank" rel="noopener" href="https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/">Kris Narkowicz proposed</a>.</p>
<p>最后，我个人认为非常方便的选择是精心设计的：<a target="_blank" rel="noopener" href="http://gpuopen.com/gdc16-wrapup-presentations/">generic filmic tonemapping operator from Timothy Lottes</a>.</p>
<p>我不在这里集中讨论它们，而是尝试用最简单的形式来解释:</p>
<p>$$  tonemap(x) &#x3D; x&#x2F;(1+x) $$</p>
<p>这是一条永远不会到达白点的曲线，因此通常使用重新调平校正因子（除以白点值）</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/reinhard.png" alt="reinhard.png"></p>
<p>上图是白点值定义为128的tonemapping曲线。</p>
<p>​		这看起来很棒——我们不仅获得了超过7个曝光点，在不影响中间色调和暗部的情况下，将它们紧紧地包裹在亮色中，而且在最终编码中EV的分布看起来几乎完美!</p>
<p>​		它还可以(在一定程度上)分辨出比EV 0(曝光后)的原始亮度高得多的物体的细节——比如发射物、发光粒子、火焰、明亮的镜面反射。任何没有比128更“热”的东西都会得到一些区别和表现。</p>
<p>​	最好的方案是 <a target="_blank" rel="noopener" href="http://graphicrants.blogspot.com/2013/12/tone-mapping.html">firefly fighting in post effects or general variance reduction</a>. 更好的解决方案，能想要在tonemapping上做更多的事情：在暗部添加一些饱和度和对比度的视觉矫正（filmic曲线的toe部分）等。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://renderwonk.com/publications/s2010-color-course/">http://renderwonk.com/publications/s2010-color-course/ </a>SIGGRAPH 2010 Course: Color Enhancement and Rendering in Film and Game Production</p>
<p><a target="_blank" rel="noopener" href="http://gpuopen.com/gdc16-wrapup-presentations/">http://gpuopen.com/gdc16-wrapup-presentations/</a>  “Advanced Techniques and Optimization of HDR Color Pipelines”, Timothy Lottes.</p>
<p><a target="_blank" rel="noopener" href="http://filmicgames.com/archives/75">http://filmicgames.com/archives/75</a> John Hable “Filmic Tonemapping Operators”</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ampas/aces-dev">https://github.com/ampas/aces-dev</a> Academy Color Encoding Standard</p>
<p><a target="_blank" rel="noopener" href="https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/">https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/</a> ACES filmic tonemapping curve</p>
<p><a target="_blank" rel="noopener" href="http://graphicrants.blogspot.com/2013/12/tone-mapping.html">http://graphicrants.blogspot.com/2013/12/tone-mapping.html</a> Brian Karis “Tone-mapping”</p>
<h2 id="重要总结"><a href="#重要总结" class="headerlink" title="重要总结"></a>重要总结</h2><ol>
<li>为什么要讨论动态范围？ 其实和软件无关，这是一个硬件上的内容，是为了描述硬件设备可表示信号的区分度。文中有一段话：</li>
</ol>
<p>​		<strong>因为0表示没有信号，所以使用1&#x2F;256（对数为 $ log_2(\frac{1}{258}) &#x3D; -8 $）表示最小可表示信号（小于这个值的都是噪声），1为最高可表示信号（对数为 $ log_2(1) &#x3D; 0 $）,所以动态范围是8。</strong></p>
<p>​		<strong>这完全是因为在8bit的数据格式下，我们能表达的最小亮度就是1&#x2F;256，我们无法表达更小的颜色了。</strong>所以亮度的范围就是[1&#x2F;256 ，1]。 在二进制上就是8个级别，就是我们的8 EV stops。</p>
<p>​		通过Gamma编码之后： 这个值变成了  $ {(2^{-8}) }^{\frac{1}{2.2}} $   &#x3D; $ {(2^{-3.6}) } $。</p>
<p>​		**最小值变大了！也就是说我们可以表示更暗的颜色了!**，但是数据还是8bits。我们能表示的亮度级别变成了17.6.也就是我们的sRGB能够表达17.6EV stops。</p>
<ol start="2">
<li><p>一定要记住，Dynamic Range(动态范围，8 EV stops)不是数据格式（8 bits的图像格式）。8bits的通道可以保存17.6 EV stops的动态范围。Gamma的作用就是在固定的数据量下，保存更多的亮度变化范围。</p>
</li>
<li><p>整个显示过程中存在两次动态范围的变化，一次是制作软件完成制作，保存到sRBG（17.6 EV stops的动态范围），用了OTEF。显示器显示时，自身的EOTF（CRT是自带的，最新显示器是专门附加的）从17.6 EV stops解码回正确的亮度值。</p>
</li>
<li><p>人眼对很高的动态范围感知，但是依赖于环境。嘈杂的环境听不到耳语。强光看不到暗处的细节。所以需要游戏中调节滑块的功能，修改显示器的显示动态范围大小。</p>
</li>
<li><p>一般的显示器本身的动态范围有限，过渡的拉伸会导致亮部被剪裁掉。所以HDR显示器就是有更大的动态范围。</p>
</li>
<li><p>游戏当中Gamma的编码和解码可能不配套，因为需要Gamma矫正。如果编码用了更大的动态范围（这个时候显示器的动态范围不变），相当于把整个图像变亮了。（提高动态范围会增加图像亮度，这是Gamma本身的特性）这一点很容易体现在数据大小上。</p>
</li>
</ol>

      
      <p align="right"><a class="morebtn" href="/2022/07/09/RTR/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/" title="图像动态范围">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/RTR/%E6%AF%9B%E5%8F%91%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/RTR/%E6%AF%9B%E5%8F%91%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/" itemprop="url">毛发方案分析</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RTR/" itemprop="url" rel="index"><span itemprop="name">RTR</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="怪物猎人世界中宠物的毛发与Fins-amp-Shells模型"><a href="#怪物猎人世界中宠物的毛发与Fins-amp-Shells模型" class="headerlink" title="怪物猎人世界中宠物的毛发与Fins&amp;Shells模型"></a>怪物猎人世界中宠物的毛发与Fins&amp;Shells模型</h1><p>最近策划决定项目中要使用怪物猎人世界中宠物的毛发方案。所以做了简单的分析。</p>
<p>目前发现怪物猎人当中的宠物，使用的是MotionBlur的方式来生成浓密毛发的。</p>
<p>经过实验大致实现步骤如下：</p>
<ol>
<li>有毛发部位需要一张<strong>毛发流向图</strong>或者<strong>将毛发流向写入顶点色</strong>来描述毛发走向。这个阶段需要在绘制毛发Gbuffer的过程中，<strong>将毛发走向填充到一张走向buffer当中</strong>或者<strong>单独进行一次流向渲染</strong>。</li>
<li>使用屏幕空间的毛发走向图，进行一次运动模糊。</li>
</ol>
<h2 id="毛发基础材质制作"><a href="#毛发基础材质制作" class="headerlink" title="毛发基础材质制作"></a>毛发基础材质制作</h2><p>毛发的基础材质就是基础的PBR材质即可。</p>
<p>包括diffuse、metallic、smoothness、normal。主要用来表述整个毛发的材质。</p>
<h2 id="毛发噪声纹理制作"><a href="#毛发噪声纹理制作" class="headerlink" title="毛发噪声纹理制作"></a>毛发噪声纹理制作</h2><p>毛发噪声直接作为一个噪声乘上diffuse，作为最终的diffuse。</p>
<p>下面是一张可用的噪声，</p>
<p><img src="/../../images/img/furnosie.png" alt="furnosie"></p>
<p>让后直接进行模糊即可。</p>
<p><strong>TODO：</strong></p>
<h1 id="Fins-amp-Shells模型"><a href="#Fins-amp-Shells模型" class="headerlink" title="Fins&amp;Shells模型"></a>Fins&amp;Shells模型</h1><p>标准的壳模型，</p>

      
      <p align="right"><a class="morebtn" href="/2022/07/09/RTR/%E6%AF%9B%E5%8F%91%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/" title="毛发方案分析">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/RTR/%E6%B3%95%E7%BA%BF%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/RTR/%E6%B3%95%E7%BA%BF%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/" itemprop="url">法线空间变换推导</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RTR/" itemprop="url" rel="index"><span itemprop="name">RTR</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="法线空间变换推导"><a href="#法线空间变换推导" class="headerlink" title="法线空间变换推导"></a>法线空间变换推导</h1><p>问题：法线在遇到非统一的缩放时会出现问题。</p>
<p>解决方案：使用变化矩阵的逆转矩阵进行变换。</p>
<p>推导：	$ M ​$ 为变换矩阵。$ t ​$ 切线。$ n ​$ 为法线。$ p $ 为模型坐标。</p>
<p>​	         正常的模型变换为：  $$ p’ &#x3D; M * p ​$$</p>
<p>​		 这个变换对切线也适用：$$ t’ &#x3D; M * t ​$$</p>
<p>​		 而法线不行$ n’  \neq  M * n $。对于法线我们通过 $$ dot(n, t) &#x3D;  n^{T}  * t &#x3D;  0 $$  这个条件来推到用于法线变换的矩阵$ S $。</p>
<p>*注：上面没有用$ dot ​$操作的$n​$和$t​$ 当做 $1 * 3​$的矩阵看待。</p>
<p>​		 $$ 0 &#x3D; (n’)^T * t’  &#x3D; (Sn)^T * (Mt) &#x3D; n^T * S^T * M * t &#x3D; n^T * (S*M)*t$$ </p>
<p>所以$I &#x3D; SM$ ,所以$S$是$M$的逆转矩阵.</p>
<p>​		操作 $$n’ &#x3D; (M^T )^{-1}  * n  ​$$  </p>
<p>​                       $$(n’)^t &#x3D; n^T * M^{-1}​$$ </p>
<p>在Unity当中$mul$操作结束以后$ n’  $ 和 $(n’)^t$都是$float3$ </p>
<p>所以：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">n_WorldSpace = mul(n_ObjectSpace, unity_WorldToObejct) ;<br></code></pre></td></tr></table></figure>


      
      <p align="right"><a class="morebtn" href="/2022/07/09/RTR/%E6%B3%95%E7%BA%BF%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/" title="法线空间变换推导">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/RTR/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/RTR/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/" itemprop="url">手机Tiled-BasedRender和GPU带宽</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RTR/" itemprop="url" rel="index"><span itemprop="name">RTR</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="手机Tiled-BasedRender和GPU带宽"><a href="#手机Tiled-BasedRender和GPU带宽" class="headerlink" title="手机Tiled-BasedRender和GPU带宽"></a>手机Tiled-BasedRender和GPU带宽</h1><h2 id="带宽的概念"><a href="#带宽的概念" class="headerlink" title="带宽的概念"></a>带宽的概念</h2><p>参考资料:</p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/metal/gpu_selection_in_macos/understanding_gpu_bandwidth">Apple官方文档</a></p>
<p><em>Bandwidth</em> refers to the external bandwidth between a GPU and its associated system. It’s a measure of the data transfer speed across the bus that connects the two (for example, PCIe or Thunderbolt). Bandwidth doesn’t refer to the internal bandwidth of a GPU, which is a measure of the data transfer speed between components within the GPU.</p>
<p>内存一共有两种，设备内存和系统内存：</p>
<p>资源使用方式：</p>
<p>1.所有数据都放在系统内存</p>
<p><img src="/../../images/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/d1b485f2-df04-403f-b665-44e91c8bec0b.png" alt="A system diagram showing two shared resources in the same system memory that can be accessed by a discrete GPU via a PCIe bus and by an external GPU via a Thunderbolt 3 bus."></p>
<p>2.所有数据放到设备内存</p>
<p><img src="/../../images/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/dd271bd5-dfd5-479a-80bb-67eb01405346.png" alt="A system diagram showing two private resources in separate video memory that can be accessed directly by a discrete GPU and an external GPU."></p>
<p>3.同时放到设备系统内存</p>
<p><img src="/../../images/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/f3cf8929-b6e6-47de-8cf3-307313202472.png" alt="A system diagram showing two managed resources with one copy in the same system memory and another copy in separate video memory. The resource copies in system memory can be accessed by a discrete GPU via a PCIe bus and by an external GPU via a Thunderbolt 3 bus. The resource copies in video memory can be accessed directly by a discrete GPU and an external GPU."></p>
<p>可以看到，经过PCIe访问的数据就会产生带宽。</p>
<p><a target="_blank" rel="noopener" href="https://developer.samsung.com/game/gpu-framebuffer">三星文档</a></p>
<h2 id="渲染模式的推导"><a href="#渲染模式的推导" class="headerlink" title="渲染模式的推导"></a>渲染模式的推导</h2><p>带宽和Cache导致了手机不得不使用Tiled Based Rendering。</p>
<h3 id="立即模式的渲染Immediate-Mode-Renderer-“IMR”"><a href="#立即模式的渲染Immediate-Mode-Renderer-“IMR”" class="headerlink" title="立即模式的渲染Immediate-Mode Renderer (“IMR”)"></a>立即模式的渲染Immediate-Mode Renderer (“IMR”)</h3><p>如下图所示可以看到，每次读取数据，写出数据，都占用大量带宽。</p>
<p><img src="/../../images/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/tech_GPUFramebuffer_03.svg" alt="Pipeline of an &#39;immediate-mode&#39; renderer"></p>
<p>IMR模式的渲染每次会有大量的栅格化写出，这部分内容是没有规律的。所以像素会反复写出。</p>
<p>这种状态下有一个Cache，是行级别的。</p>
<p><img src="/../../images/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/1569317001543.png" alt="1569317001543"></p>
<p>这里有一个极大的前提就是，Cache是有限的！！！</p>
<h3 id="Tiled-memory"><a href="#Tiled-memory" class="headerlink" title="Tiled memory"></a>Tiled memory</h3><p>第一个策略是把屏幕分块Cache，这样内存功能更加有规律。内存的传输不是太频繁了。</p>
<p><img src="/../../images/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/1569317024532.png" alt="1569317024532"></p>
<h3 id="Rasterizing-within-tiles"><a href="#Rasterizing-within-tiles" class="headerlink" title="Rasterizing within tiles"></a>Rasterizing within tiles</h3><p>上面的问题是，如果一个三角跨越整个屏幕的三角形会打破Cache。</p>
<p>进一步的优化，是基于Tiled进行光栅化：we can draw all the pixels that the triangle covers within one tile before moving on to the next tile.</p>
<h3 id="Binning"><a href="#Binning" class="headerlink" title="Binning"></a>Binning</h3><p>进一步优化，我们现在不只是基于Cache去光栅化，而是直接基于Tiled计算所有的三角形。</p>
<ol>
<li>第一步就是计算每个tile中的所有三角形。</li>
</ol>
<p> Note that this process involves vertex shading, since this affects the location of triangles, but not fragment shading.</p>
<p><img src="/../../images/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/1569318032142.png" alt="1569318032142"></p>
<h3 id="Tile-based-rasterization"><a href="#Tile-based-rasterization" class="headerlink" title="Tile-based rasterization"></a>Tile-based rasterization</h3><p>第二步就是基于Tile的栅格化。</p>
<p>Once the geometry has been sorted into bins, the rasterizer can process the scene one bin at a time, writing only to local tile memory until processing of the tile is finished.</p>
<p>由于一个一个处理所以Cache被压缩成了一个Tile,而不再需要多个Cache进行缓存了。</p>
<p>Since each tile is processed only once, the “cache” is now reduced to a single tile. </p>
<p>新的流程:</p>
<p><img src="/../../images/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/tech_GPUFramebuffer_16.svg" alt="Pipeline of a tiled renderer"></p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>Frame buffer memory bandwidth is greatly reduced, reducing power and increasing speed.<ul>
<li>Mobile memory is typically slower and lower power than desktop systems, and bandwidth is shared with the CPU, so access is very costly.</li>
</ul>
</li>
<li>With API support, off-chip memory requirements may also be reduced (it may not be necessary to allocate an off-chip Z buffer at all, for example).</li>
<li>Texture cache performance can be improved (textures covering multiple primitives may be accessed more coherently one tile at a time than one primitive at a time.</li>
<li>Much less on-chip space is needed for good performance compared with a general-purpose frame buffer cache.<ul>
<li>This means that more space can be dedicated to texture cache, further reducing bandwidth.</li>
</ul>
</li>
</ul>
<h3 id="Limitations-of-tile-based-rendering"><a href="#Limitations-of-tile-based-rendering" class="headerlink" title="Limitations of tile-based rendering"></a>Limitations of tile-based rendering</h3><p>While there are many performance advantages to tile-based rendering, there are some restrictions imposed by the technique:</p>
<ul>
<li>The two-stage binning and fragment passes introduce latency<ul>
<li>This latency should be hidden by pipelining and improved performance, but makes some operations relatively more costly</li>
<li>In pipelined tiled rendering, framebuffer and textures required for rendering should be double-buffered so as to avoid stalling the pipeline。</li>
</ul>
</li>
<li><strong>Framebuffer reads that might fall outside the current fragment are relatively more costly</strong><ul>
<li><strong>Operations such as screen-space ray tracing require writing all the framebuffer data - removing the ability to discard full-resolution images and depth values after use</strong></li>
</ul>
</li>
<li>There is a cost to traversing the geometry repeatedly<ul>
<li>Scenes that are vertex-shader bound may have increased overhead in a tiler</li>
</ul>
</li>
<li>The binning pass may have limitations<ul>
<li>Some implementations may run out of space for binning primitives in very complex scenes, or may have optimizations that are bypassed by unusual input (such as highly irregular geometry)</li>
</ul>
</li>
<li>Switching to a different render target and back involves flushing all working data to memory and later reading it back<ul>
<li>For a tiler, it is especially important that shadow and environment maps be generated before the main frame buffer, not “on demand” during final rendering (though this is good advice for most GPUs)</li>
</ul>
</li>
<li>Graphics state (such as shaders) may change more frequently and less predictably<ul>
<li>Geometry that is “skipped” means that states do not necessarily follow in turn, making incremental state updates hard to implement</li>
</ul>
</li>
</ul>
<p>In most cases, the behavior of a tile-based GPU should not be appreciably worse than for an immediate-mode renderer using similarly limited hardware (indeed, some hardware can choose whether or not to run in a tiled mode), but it is possible to remove the performance benefits of tile-based rendering with the wrong use pattern.</p>

      
      <p align="right"><a class="morebtn" href="/2022/07/09/RTR/%E6%89%8B%E6%9C%BATiled-BasedRender%E5%92%8CGPU%E5%B8%A6%E5%AE%BD/" title="手机Tiled-BasedRender和GPU带宽">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/RTR/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%96%B9%E6%B3%95/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/RTR/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%96%B9%E6%B3%95/" itemprop="url">蒙特卡洛方法</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RTR/" itemprop="url" rel="index"><span itemprop="name">RTR</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="蒙特卡洛方法"><a href="#蒙特卡洛方法" class="headerlink" title="蒙特卡洛方法"></a>蒙特卡洛方法</h1><p>wiki解释:<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%92%99%E5%9C%B0%E5%8D%A1%E7%BE%85%E6%96%B9%E6%B3%95">蒙特卡洛</a></p>
<p>重点在于：蒙特卡罗方法在数学中的应用，下面摘要了关键的部分。</p>
<h2 id="蒙特卡洛积分"><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a>蒙特卡洛积分</h2><p>非权重蒙特卡罗积分，也称<strong>确定性抽样</strong>，是对被积函数<strong>变量区间</strong>进行<strong>随机均匀抽样</strong>，然后对抽样点的<strong>函数值求平均</strong>，从而可以得到<strong>函数积分的近似值</strong>。</p>
<p>此种方法的正确性是基于<strong>概率论</strong>和<strong>中心极限定理</strong>)。</p>
<p>当抽样点数为m时，使用此种方法所得近似解的统计误差只与m有关（与 $$\frac{1}{\sqrt m}$$正相关），不随积分维数的改变而改变。因此当积分维度较高时，蒙特卡罗方法相对于其他数值解法更优。</p>
<h2 id="蒙脱卡洛方法推导"><a href="#蒙脱卡洛方法推导" class="headerlink" title="蒙脱卡洛方法推导"></a>蒙脱卡洛方法推导</h2><p>首先，有<strong>一组</strong>独立同分布的随机变量 $ { X_i } $ 。注意这是独立同分布的集合包括了多个随机变量。</p>
<p>每一个随机变量 $ X_i $ 在 $ [a,b] $ 上服从分布 $  f_x $ （概率密度函数PDF，积分为1）。  </p>
<p>我们构造一个新的函数 $ g^*(x) &#x3D; \frac{g(x)}{f_x{(x)}} $ ， 然后 $ g^*(X_i) $ 也是一个随机变量。</p>
<p><em><em>关键： $ g^</em>(X_i ) $  的概率为 $ f_x(X_i) $ !!!</em>*</p>
<p>我们现在计算这个新的随机变量的<strong>期望</strong>：</p>
<p> $$ E[g^*(X_i)] &#x3D; \int _a^b g^*(x)f_x(x) dx  &#x3D; \int _a^b  g(x) d x &#x3D; I $$ </p>
<p>根据<strong>强大数定理</strong>：</p>
<p>$$ Pr(\lim_{N \to \infty } \frac {1}{N} \sum_{i&#x3D;1}^{N} g^*(X_i) &#x3D; I )&#x3D; 1 $$</p>
<p>我们项构造一个平均值 $ \hat I  $ ，则 $ \hat I  $ 依1概率收敛到 $ I $ ：</p>
<p>$$ \hat I &#x3D; \frac {1}{N} \sum_{i&#x3D;1}^{N} g^*(X_i)  $$</p>
<p>在完成以上的准备条件之后，我们进行实际推导：</p>
<p><strong>问题：</strong> 我们希望求解积分：</p>
<p>$$  I &#x3D; \int_a^b g(x) dx $$</p>
<p><strong>求解：</strong></p>
<ol>
<li><p>假设函数 $ g(x) $ 分布在 $ [a,b] $ 内可积。</p>
</li>
<li><p>构造任意一个概率密度函数 $ f_x (x) $. 满足：</p>
<p>a.  当 $  g(x)  \neq 0 $ 时， $ f_x(x) \neq 0  $ , $ (a &lt; x &lt; b) $ .</p>
<p>b.  $ \int_a^b f_x(x) dx &#x3D; 1 $.</p>
</li>
</ol>
<p>引入上面条件,原积分（<strong>期望</strong>）可以写成：</p>
<p>$ I &#x3D; \int_a^b g^*(x)f_x(x) dx $</p>
<p>根据强大数定理得到的平均值（<strong>期望估计</strong>）变为：</p>
<p>$ \hat I &#x3D; \frac {1}{N} \sum_{i&#x3D;1}^{N} g^*(X_i)  $</p>
<p>根据之前的说明：随着采样次数增多 $ \hat I  $ 依概率1收敛到 $ I $ ：</p>
<p><strong>所以 $ \hat I  $  可以作为 $ I $ 的一个估计。</strong></p>
<p>如果 $ f_x $ 是 $ [a , b ] $ 上的一个<strong>均匀分布</strong>的话，那么积分就变成了:</p>
<p>$ I &#x3D; (b - a) \int_a^b g(x) \frac{1}{b - a} dx $</p>
<p>均值就变成了 （ $ f_x $ 消失了）：</p>
<p>$$ \hat I &#x3D; \frac {b - a}{N} \sum_{i&#x3D;1}^{N} g(X_i)  $$</p>
<p> $ \hat I  $ 就是 $ I $ 的估计，蒙特卡洛积分就是用<br> $$ \frac {b - a}{N} \sum_{i&#x3D;1}^{N} g(X_i) $$<br> 估计<br> $$  \int _a^b  g(x) d x  $$</p>
<h2 id="蒙特卡洛在渲染当中的应用"><a href="#蒙特卡洛在渲染当中的应用" class="headerlink" title="蒙特卡洛在渲染当中的应用"></a>蒙特卡洛在渲染当中的应用</h2><p>这里主要来自一本书：</p>
<p>《Monte Carlo Methods in Global Illumination - Photo-realistic Rendering with Randomization》</p>
<p>主要用来用随机采样的方法解决全局光照渲染的问题。</p>
<p>因为，全局光照的积分是一个难以求和的积分，刚好符合蒙特卡洛积分的思路。</p>

      
      <p align="right"><a class="morebtn" href="/2022/07/09/RTR/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%96%B9%E6%B3%95/" title="蒙特卡洛方法">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/RTR/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/RTR/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/" itemprop="url">渲染管线</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RTR/" itemprop="url" rel="index"><span itemprop="name">RTR</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h1><p>最近回顾了一下基础的图形学内容，发现很多都忘记了，现在认真的总结一下。主要内容都来自<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/direct3d11/overviews-direct3d-11-graphics-pipeline">d3d的官方文档当中提取的图形管线</a>当中。</p>
<p>下图是一个总览的流程，这个流程主要是针对D3D API可配置的阶段：</p>
<p><img src="/img/renderpipeline-d3d11-pipeline-stages.jpg" alt="d3d11-pipeline-stages"></p>
<h2 id="渲染管线总览"><a href="#渲染管线总览" class="headerlink" title="渲染管线总览"></a>渲染管线总览</h2><p>D3D 10和更高级的API支持将渲染管线 划分成不同的功能阶段，下面是每一个阶段的主要描述：</p>
<table>
<thead>
<tr>
<th align="left">Topic</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Input-Assembler Stage 输入装配阶段</td>
<td align="left">the first stage in the pipeline is the input-assembler (IA) stage.第一个阶段是输入装配阶段。</td>
</tr>
<tr>
<td align="left">Vertex Shader Stage</td>
<td align="left">The vertex-shader (VS) stage processes vertices from the input assembler, performing per-vertex operations such as transformations, skinning, morphing, and per-vertex lighting. （vertexShder阶段主要处理逐顶点操作，包括：transformation，顶点光照，变形，蒙皮等，他的数据来源于IA阶段。）Vertex shaders always operate on a single input vertex and produce a single output vertex（输入输出都是单独顶点）.</td>
</tr>
<tr>
<td align="left">Tessellation Stages</td>
<td align="left">曲面细分，处理的是表面：三角形。</td>
</tr>
<tr>
<td align="left">Geometry Shader Stage</td>
<td align="left">处理一系列顶点输入，产生一系列顶点输出。</td>
</tr>
<tr>
<td align="left">Stream-Output Stage</td>
<td align="left">The purpose of the stream-output stage is to continuously output (or stream) vertex data from the geometry-shader stage (or the vertex-shader stage if the geometry-shader stage is inactive) to one or more buffers in memory (see <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/direct3d11/d3d10-graphics-programming-guide-output-stream-stage-getting-started">Getting Started with the Stream-Output Stage</a>).  将顶点处理的数据传送到一个或者多个内存？</td>
</tr>
<tr>
<td align="left">Rasterizer Stage</td>
<td align="left">The rasterization stage converts vector information (composed of shapes or primitives) into a raster image (composed of pixels) for the purpose of displaying real-time 3D graphics.  从顶点到图像。</td>
</tr>
<tr>
<td align="left">Pixel Shader Stage</td>
<td align="left">The pixel-shader stage (PS) enables rich shading techniques such as per-pixel lighting and post-processing. <strong>A pixel shader is a program that combines constant variables, texture data, interpolated per-vertex values, and other data to produce per-pixel outputs.</strong> （pixel Shader主要将常量、纹理数据、逐顶点插值数据等内容来生成像素输出）The rasterizer stage invokes a pixel shader once for each pixel covered by a primitive, however, it is possible to specify a <strong>NULL</strong> shader to avoid running a shader. （光栅化阶段会为每一个被图元覆盖的像素执行一次pixelShader）</td>
</tr>
<tr>
<td align="left">Output-Merger Stage</td>
<td align="left">The output-merger (OM) stage generates the final rendered pixel color using a combination of pipeline state（OM阶段会根据渲染状态的组合生成最终的颜色：pixel Shader输出，渲染目标，深度&#x2F;stencil buffer内容）, the pixel data generated by the pixel shaders, the contents of the render targets, and the contents of the depth&#x2F;stencil buffers. The OM stage is the final step for determining which pixels are visible (with depth-stencil testing) and blending the final pixel colors**.(OM阶段决定哪个像素可见，深度和stencil测试和blend。）**</td>
</tr>
</tbody></table>
<h2 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h2><h3 id="Input-Assembler-Stage-IA-（未补全）"><a href="#Input-Assembler-Stage-IA-（未补全）" class="headerlink" title="Input-Assembler Stage(IA) （未补全）"></a>Input-Assembler Stage(IA) （未补全）</h3><p>简介：IA阶段的目的主要是从user-filled buffer当中读取图元数据（points, lines and&#x2F;or triangles），然后组合成在之后阶段需要使用的新的结构的图元数据。 AI阶段能够将顶点组合成不同的图元类型，组合过程需要读取相邻的数据，这部分数据只在Geometry Stage阶段可以。例如：如果一个几何着色器在三角形上被调用，那么他的输入就包括他自身的三个顶点，和相邻三角形的顶点数据。</p>
<h4 id="IA阶段步骤总结"><a href="#IA阶段步骤总结" class="headerlink" title="IA阶段步骤总结"></a>IA阶段步骤总结</h4><ol>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/direct3d11/d3d10-graphics-programming-guide-input-assembler-stage-getting-started#create-input-buffers">Create Input Buffers</a>：使用输入的vertex data初始化input buffer。</li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/direct3d11/d3d10-graphics-programming-guide-input-assembler-stage-getting-started#create-the-input-layout-object">Create the Input-Layout Object</a>：使用input layout object描述vertex buffer中的数据类型。</li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/direct3d11/d3d10-graphics-programming-guide-input-assembler-stage-getting-started#bind-objects-to-the-input-assembler-stage">Bind Objects to the Input-Assembler Stage</a>：将vertex data buffer和layout object 绑定到IA阶段。</li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/direct3d11/d3d10-graphics-programming-guide-input-assembler-stage-getting-started#specify-the-primitive-type">Specify the Primitive Type</a>：定义顶点数据如何组成图元。</li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/direct3d11/d3d10-graphics-programming-guide-input-assembler-stage-getting-started#call-draw-methods">Call Draw Methods</a>：调用绘制方法，将绑定到IA的数据传送到pipeline。</li>
</ol>
<h4 id="Create-Input-Buffers"><a href="#Create-Input-Buffers" class="headerlink" title="Create Input Buffers"></a>Create Input Buffers</h4><p>inpute buffer有两种：vertex buffer和index buffer。vertex buffer提供数据，index buffer提供数据索引，可以创建多个vertex buffer。可以创建一个index buffer。</p>
<h3 id="Vertex-Shader-Stage"><a href="#Vertex-Shader-Stage" class="headerlink" title="Vertex Shader Stage"></a>Vertex Shader Stage</h3><p>vertex Shader的输入最多为16 个 32-bit的4维向量，输出也是一样。一个vertex shader必须至少有一个输入和一个输出（一个标量）。</p>
<p>vertex Shader能够处理两个来自IA阶段的系统生成值：VertexID and InstanceID，他们只提供给vertex shader stage。</p>
<p>vertex Shader在所有顶点上运行，包括有邻接拓扑关系的图元的相邻顶点。</p>
<p>顶点着色器可以在不需要屏幕空间导数的情况下执行加载和纹理采样操作。（应该指的是类似Unity的Sample2D_Load操作）</p>
<h3 id="Tessellation-Stages（未补全）"><a href="#Tessellation-Stages（未补全）" class="headerlink" title="Tessellation Stages（未补全）"></a>Tessellation Stages（未补全）</h3><h3 id="Geometry-Shader-Stage"><a href="#Geometry-Shader-Stage" class="headerlink" title="Geometry Shader Stage"></a>Geometry Shader Stage</h3><p>这部分没有太多特殊的内容，见<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/direct3d11/geometry-shader-stage">官方文档</a>。</p>
<h3 id="Stream-Output-Stage"><a href="#Stream-Output-Stage" class="headerlink" title="Stream-Output Stage"></a>Stream-Output Stage</h3><p>连续的将顶点数据输出到内存的buffer当中。</p>
<p><img src="/../../images/img/renderpipeline-d3d10-depth-stencil-test.png" alt="renderpipeline-d3d10-depth-stencil-test"></p>
<p>When a triangle or line strip is bound to the input-assembler stage, each strip is converted into a list before they are streamed out。（<strong>所有的数据在输出之前，都是一个链表</strong>）The amount of data streamed out can vary（<strong>数据可以变化，例如：几何着色器会向链表插入数据</strong>，<em>几何、纹理、常量数据在整个渲染流程中如何存储需要研究一下</em>）。</p>
<h3 id="Rasterizer-Stage"><a href="#Rasterizer-Stage" class="headerlink" title="Rasterizer Stage"></a>Rasterizer Stage</h3><p>将图元数据转化成光栅图像（像素），每个像素根据顶点进行插值。</p>
<p>光栅化阶段包括：视椎体剪裁、透视变化（<strong>剪裁空间坐标除z（这里说的不是z分量，而是深度值，对应的是剪裁空间坐标中的w分量）</strong>）等。（Rasterization includes clipping vertices to the view frustum, performing a divide by z to provide perspective, mapping primitives to a 2D viewport, and determining how to invoke the pixel shader. ）</p>
<p><strong>重点：为什么不一步变换到NDC呢？因为，视椎体剪裁需要在Clip-Space进行。当完成视椎体剪裁之后，才会进行透视变化，这个时候才会进行透视除法。以上两步都在光栅化阶段进行。所以Unity在Vertex Shader阶段输出的是Clip-Space坐标，是提供给这个阶段使用的。</strong></p>
<p>进入光栅化阶段的顶点，被认为是在齐次坐标的剪裁空间的（x，y，z ，w），x正方向向右，Y正方向向上，Z正方向是摄像机前方。(Vertices (x,y,z,w), coming into the rasterizer stage are assumed to be in homogeneous clip-space. In this coordinate space the X axis points right, Y points up and Z points away from camera.)</p>
<p>齐次坐标和NDC：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"> [x y z w]   →   [x/w y/w z/w]<br>homogeneous     normalized device<br>clip space      <span class="hljs-title function_">coordinates</span> <span class="hljs-params">(NDC)</span><br></code></pre></td></tr></table></figure>

<p>Zbuffer优化：On hardware that implements <strong>hierarchical Z-buffer optimizations</strong>, you may enable preloading the z-buffer by setting the pixel shader stage to <strong>NULL</strong> while enabling depth and stencil testing.</p>
<h3 id="Pixel-Shader-Stage"><a href="#Pixel-Shader-Stage" class="headerlink" title="Pixel Shader Stage"></a>Pixel Shader Stage</h3><p>在这个阶段进行丰富的着色、光照和后处理计算。这个阶段使用常量、纹理数据、插值数据和其他顶点程序输出的数据。光栅化阶段会为每一个被图元覆盖的区域执行一次Pixel Shader。</p>
<p>Use the depth-write-enable state (in the output-merger stage) to control whether depth data gets written to a depth buffer (or use the discard instruction to discard data for that pixel). A pixel shader can also output an optional 32-bit, 1-component, floating-point, depth value for depth testing (using the SV_Depth semantic). The depth value is output in the oDepth register, and replaces the interpolated depth value for depth testing (assuming depth testing is enabled). There is no way to dynamically change between using fixed-function depth or shader oDepth。<strong>比较重要的部分是可以通过SV_Depth 语义来直接输出深度到深度贴图当中，这样可以直接代替来自Vertex Data的深度插值数据。不过这两种方式不能动态变化。目前没有在Unity当中尝试过。</strong></p>
<h3 id="Output-Merger-Stage"><a href="#Output-Merger-Stage" class="headerlink" title="Output-Merger Stage"></a>Output-Merger Stage</h3><p>OM阶段会根据渲染状态的组合生成最终的颜色：pixel Shader输出，渲染目标，深度&#x2F;stencil buffer内容。</p>
<h4 id="Depth-Stencil"><a href="#Depth-Stencil" class="headerlink" title="Depth-Stencil"></a>Depth-Stencil</h4><p>OM阶段的第一步就是Depth-Stencil Testing，这步骤依赖于一张Depth-Stencil buffer。Depth-Stencil是作为纹理资源创建的，他包括了深度信息和Stencil信息。</p>
<p>深度信息用来决定哪些像素距离摄像机更近，Stencil数据用来当做Mask使用。他们在这个阶段使用用来决定这个像素是否被绘制。下图描述了Depth-Stencil是如何被使用的。</p>
<p><img src="/../../images/img/renderpipeline-d3d10-depth-stencil-test.png" alt="renderpipeline-d3d10-depth-stencil-test"></p>
<p>Depth-Stencil的状态如果没有被配置，那么久会使用默认参数。<strong>如果没有开启multisampling那么混合操作逐像素进行，如果开启，混合就在多个采样结果上进行。（这个内容我理解的是MSAA之类的操作）。</strong></p>
<p>使用深度缓冲区来确定应该绘制哪个像素的过程称为depth-buffer，有时也称为z-buffer。</p>
<h4 id="Blending"><a href="#Blending" class="headerlink" title="Blending"></a>Blending</h4><p>Blending的作用就是将一个或者多个像素颜色值混合作为最终的颜色输出。</p>
<p><img src="/../../images/img/renderpipeline-d3d10-blend-state.png" alt="renderpipeline-d3d10-blend-state"></p>
<p><strong>D3D文档里面说：Blend values (including BlendFactor) are always clamped to the range of the render-target format before blending. 。就是说所有混合的值会再blending阶段进行Clamp，但是我发现Unity如果使用负数的Alpha(Blend Factor)时并没有被Clamp</strong></p>
<p><strong>另一个要点：When you use sRGB render targets, the runtime converts the render target color into linear space before it performs blending. The runtime converts the final blended value back into sRGB space before it saves the value back to the render target. 当使用sRGB的render targets的时候，在混合之前会转换到线性空间，混合结束之后再返回sRGB的render target。Unity当中的做法是只使用Linear的render targets。全部渲染完成之后再一次性转换会原始的sRGB。</strong></p>
<h4 id="Multiple-RenderTargets"><a href="#Multiple-RenderTargets" class="headerlink" title="Multiple RenderTargets"></a>Multiple RenderTargets</h4><p>多个渲染目标。一个Pixel Shader能够同时渲染8个render target。所有的render target需要是同一种类型(buffer, Texture1D, Texture1DArray, and so on)，同一种尺寸 (width, height, depth, array size, sample counts)。但是可以有不同的数据格式（Each render target may have a different data format.）。例如：多个G-buffer在一个Pass完成，但根据存储数据的不同，使用了不同的数据格式。</p>
<h4 id="Output-Write-Mask"><a href="#Output-Write-Mask" class="headerlink" title="Output-Write Mask"></a>Output-Write Mask</h4><p>Use an output-write mask to control (per component) what data can be written to a render target.</p>
<p>这个没有在Unity当中找到对应物。</p>
<h4 id="Sample-Mask"><a href="#Sample-Mask" class="headerlink" title="Sample Mask"></a>Sample Mask</h4><p>这个没有在Unity当中找到对应物。</p>

      
      <p align="right"><a class="morebtn" href="/2022/07/09/RTR/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/" title="渲染管线">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/RTR/%E7%90%83%E9%9D%A2%E8%B0%90%E6%B3%A2%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/RTR/%E7%90%83%E9%9D%A2%E8%B0%90%E6%B3%A2%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/" itemprop="url">球面谐波的理论与实践</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RTR/" itemprop="url" rel="index"><span itemprop="name">RTR</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="球面谐波的理论与实践"><a href="#球面谐波的理论与实践" class="headerlink" title="球面谐波的理论与实践"></a>球面谐波的理论与实践</h1><p>球谐光照就是用N个多项式拟合一个位置的低频光照函数。主要用到的就是球面谐波。</p>
<p>下面详细分析球谐函数的推导。</p>
<h2 id="球谐函数"><a href="#球谐函数" class="headerlink" title="球谐函数"></a>球谐函数</h2><p>下面先介绍几个和球谐相关的数学理论。</p>
<h3 id="期望："><a href="#期望：" class="headerlink" title="期望："></a>期望：</h3><h3 id="蒙特卡洛："><a href="#蒙特卡洛：" class="headerlink" title="蒙特卡洛："></a>蒙特卡洛：</h3><h3 id="大数定理："><a href="#大数定理：" class="headerlink" title="大数定理："></a>大数定理：</h3><h3 id="随机数与球面坐标："><a href="#随机数与球面坐标：" class="headerlink" title="随机数与球面坐标："></a>随机数与球面坐标：</h3><h3 id="正交基函数："><a href="#正交基函数：" class="headerlink" title="正交基函数："></a>正交基函数：</h3><h3 id="正交多项式："><a href="#正交多项式：" class="headerlink" title="正交多项式："></a>正交多项式：</h3><h3 id="球谐："><a href="#球谐：" class="headerlink" title="球谐："></a>球谐：</h3><h3 id="球谐函数："><a href="#球谐函数：" class="headerlink" title="球谐函数："></a>球谐函数：</h3><h3 id="球谐投影："><a href="#球谐投影：" class="headerlink" title="球谐投影："></a>球谐投影：</h3><h3 id="球谐光照："><a href="#球谐光照：" class="headerlink" title="球谐光照："></a>球谐光照：</h3><h3 id="采样与计算"><a href="#采样与计算" class="headerlink" title="采样与计算:"></a>采样与计算:</h3>
      
      <p align="right"><a class="morebtn" href="/2022/07/09/RTR/%E7%90%83%E9%9D%A2%E8%B0%90%E6%B3%A2%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/" title="球面谐波的理论与实践">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fas fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/13/"><i class="fas fa-angle-right" aria-label="下一页"></i></a>
  </nav>
  
  
  

<div class="comments" id="comments">
  
  
  
</div>



  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control"/>
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/avatar.jpg" alt="leinlin">
  
  <h1 class="author-name">leinlin</h1>
  <h2 class="author-description"></h2>
  <div class="site-count">
    
    
    
    
    <div class="categories-count count-block">
      <div class="site-count-title">分类</div>
      <div><a href="/categories/">20</a></div>
    </div>
    
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    <hr>
    <div class="social-link sidebar-item">
      <div><i class="far fa-address-card"></i>社交链接</p></div>
      <ul>
        
        <li><i class="fab fa-github"></i><a href="https://leinlin.github.com/" target="_blank">GitHub</a></li>
        
      </ul>
    </div>
    
    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <button id="back-to-top"><i class="fas fa-angle-double-up" aria-label="回到顶部"></i></button>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">leinlin</span><span class="year"><i class="far fa-copyright"></i>2023</span>
        </div>
        
        <div class="busuanzi">
          <span id="busuanzi_container_site_pv"><i class="fas fa-eye" aria-label="站点点击量" aria-hidden="false"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user" aria-label="站点用户数" aria-hidden="false"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv" aria-label="页面点击量" aria-hidden="false"></span></span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
