<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    
    <meta name="keywords" content="leinlin, ARIA, Hexo">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="leinlin的小笔记" type="application/atom+xml" />
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-light.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/clipboard.min.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    
    <script defer type="text/javascript" src="https://cdn.staticfile.org/MathJax/MathJax-2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code"]
      }
    });
    </script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += " has-jax";
      }
    });
    </script>
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var cb = null;
      var els = $(".post figure.highlight");
      if (els.length) {
        // Enabled Hexo highlight line number.
        $(els).each(function (i, e) {
          // $(e).before("<button class=\"copy button\">复制</button>");
          $(e).before([
            "<div class=\"code-titlebar\">",
              "<div class=\"titlebar-left\">",
                "<button class=\"copy\">复制</button>",
              "</div>",
            "</div>"
          ].join(""));
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              return trigger.parentNode.parentNode.nextElementSibling.firstChild.firstChild.firstChild.lastChild.firstChild.firstChild;
          }
        });
      } else {
        // Disabled Hexo highlight line number.
        els = $(".post pre code");
        $(els).each(function (i, e) {
          // Add button before pre, not code.
          // $(e).parent().before("<button class=\"copy button\">复制</button>");
          $(e).before([
            "<div class=\"code-titlebar\">",
              "<div class=\"titlebar-left\">",
                "<button class=\"copy\" >复制</button>",
              "</div>",
              "<div class=\"titlebar-right\">",
                "<button class=\"button-dot dot-minimize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-maximize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-close\" aria-label=\"Decoration\"></button>",
              "</div>",
            "</div>"
          ].join(""));
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              return trigger.parentNode.parentNode.nextElementSibling;
          }
        });
      }
      cb.on("success", function (e) {
        e.clearSelection();
        var trigger = e.trigger;
        // Change button text as a user tip.
        trigger.innerHTML = "已复制";
        $(trigger).addClass("copied");
        // Change button text back;
        setTimeout(function () {
          trigger.innerHTML = "复制";
          $(trigger).removeClass("copied");
        }, 1500);
      });
    });
    </script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>leinlin的小笔记</title>
  <meta name="generator" content="Hexo 6.2.0"></head>
  <body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"  data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">leinlin的小笔记</a></h1>
        <h2 class="subtitle"></h2>
      </div>
      
    </div>
    <nav id="nav" class="nav">
      <a id="nav-toggle" class="nav-toggle" aria-hidden="true"><i class="fas fa-bars" aria-label="切换导航栏"></i></a>
      <ul id="menu" role="menubar" aria-hidden="false">
        
        <li role="menuitem"><a href="/"><i class="fas fa-home"></i><span class="menu-text">首页</span></a></li>
        
        <li role="menuitem"><a href="/categories/"><i class="fas fa-th-list"></i><span class="menu-text">分类</span></a></li>
        
      </ul>
    </nav>
  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            

<div id="index" class="index page">
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/09/19/RTR/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/09/19/RTR/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/" itemprop="url"></a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-09-19T19:53:33+08:00">2022-09-19 19:53:33</time></span>
        </span>
        
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="大气散射"><a href="#大气散射" class="headerlink" title="大气散射"></a>大气散射</h1><p>翻译、摘录自GEMS2中的大气散射：<a target="_blank" rel="noopener" href="https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering">GEMS2：Accurate Atmosphere Scaterring</a>.</p>
<p>这里实现的方法来自于：Nishita et al. 1993。</p>
<p>我们假设摄像机在地平线上，这样就可以假设在各个角度观察大气的密度是固定的。这样就可以简化大气散射模型。</p>
<h2 id="求解大气散射模型"><a href="#求解大气散射模型" class="headerlink" title="求解大气散射模型"></a>求解大气散射模型</h2><p>散射模型有嵌套积分，没有解析解。幸运的是，可以用梯形法则计算( trapezoid rule)</p>
<blockquote>
<p>  Note:</p>
<p>  梯形法则计算：将该段分成n个样本段，并在每个样本段的中心点计算被积函数。将每个结果乘以样本段的长度并将它们全部加起来。样本数量越多，计算结果越准确，但也使积分计算成本较高。</p>
</blockquote>
<p>如果光线穿过大气层到达顶点，需要计算散射。每条射线都应该有两个确定的点，标记出<strong>射线开始穿过大气层的位置</strong>和<strong>停止穿过大气层的位置</strong>。如下图的A和B点。</p>
<p><img src="/../../images/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/16_atmospheric_02.jpg" alt="16_atmospheric_02.jpg"></p>
<p><strong>当相机在大气中，A是相机的位置</strong>。当顶点在大气中，B是顶点的位置。<strong>当任意一点在空间中时，我们执行一个球体交点检查来找出射线与外层大气交点，然后我们做交点A或B。</strong></p>
<p>当我们得到了两个交点，我们就可以开始计算AB之间的积分。我们在线段中间找到我们的采样点P1..P5。</p>
<p>每一个点的光线的变化：接受<strong>直接来自于太阳的光线</strong>和<strong>来气其他方向的散射光线</strong>，然后一部分光线向摄像机传递，一部分光线向其他方向散射。</p>
<h2 id="Rayleigh-Scattering-vs-Mie-Scattering"><a href="#Rayleigh-Scattering-vs-Mie-Scattering" class="headerlink" title="Rayleigh Scattering vs. Mie Scattering."></a>Rayleigh Scattering vs. Mie Scattering.</h2><p>知道了光线如何在一点散射，另一个重要的细节是关于如何模拟P点的光散射。大气中不同的粒子以不同的方式散射光线。大气中最常见的两种散射形式是瑞利散射和密散射。</p>
<p><strong>Rayleigh 散射</strong>是由空气中的小分子引起的，它在较短的波长(先是蓝色，然后是绿色，然后是红色)上对光线的散射更大。天空是蓝色的，<strong>因为蓝色的光到处反射，最终从各个方向到达你的眼睛</strong>。太阳的光线在日落时会变成黄色&#x2F;橙色&#x2F;红色，这是因为光线穿过大气层时，<strong>几乎所有的蓝光和大部分绿光在到达你面前就被散射掉了</strong>，只剩下红色。</p>
<p><strong>Mie 散射</strong>是由空气中称为气溶胶的较大粒子(如灰尘和污染)引起的，<strong>它倾向于均匀地散射所有波长的光</strong>。在一个雾蒙蒙的日子，Mie散射导致天空看起来有点灰色，并导致太阳有一个大的白色光晕围绕它Mie散射也可以用来模拟空气中水和冰的小粒子散射的光，以产生彩虹的效果，但这超出了本章的范围。(详情请参阅Brewer 2004。)</p>
<h2 id="Phase-Function相函数"><a href="#Phase-Function相函数" class="headerlink" title="Phase Function相函数"></a>Phase Function相函数</h2><p>这里主要描述光线在某一个点的散射和传递情况：</p>
<p><img src="/../../images/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/0256equ01.jpg" alt="0256equ01.jpg"></p>
<p><strong>相位函数描述了有多少光线散射到了相机方向</strong>，（从太阳方向到摄像机方向），还有常量g对散射量的影响。</p>
<p>相位函数有很多不同的版本。上面的函数是对Nishita等人1993年使用的Henyey-Greenstein函数的一种改编。</p>
<p>瑞利散射可<strong>近似地设g为0</strong>，这大大简化了方程，使<strong>其对正角和负角对称。当g为负值时，正向散射的光更多，当g为正值时，向光源反射的光更多</strong>。对于Mie气溶胶散射，g通常设置在**-0.75 ~ -0.999<strong>之间。</strong>永远不要将g设为1或-1，因为这会使等式简化为0。**</p>
<h2 id="The-Out-Scattering-Equation出散射方程"><a href="#The-Out-Scattering-Equation出散射方程" class="headerlink" title="The Out-Scattering Equation出散射方程"></a>The Out-Scattering Equation出散射方程</h2><p><img src="/../../images/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/0256equ02.jpg" alt="0256equ02.jpg"></p>
<p>外散射方程是前面提到的内积分：<strong>描述了从点Pa到点Pb的平均大气密度乘以射线的长度（光学深度、光学距离、光学厚度optical depth）。</strong></p>
<blockquote>
<p>  Note:</p>
<p>  可以把它看作是一个基于光线路径上空气粒子数量的加权因子。方程的其余部分由常数组成，它们决定了这些粒子从射线中散射出去的光的多少。</p>
</blockquote>
<p>为了计算这个积分的值，从Pa到Pb的射线将被分割成段，指数项将在每个采样点被计算。</p>
<p>变量h是采样点的高度。<strong>在我的实现中，高度被缩放，0代表海平面（地面），1代表大气的顶部。</strong>理论上，大气没有固定的顶部，但是为了实际的目的，我们必须选择一个高度来渲染天空穹顶。h0是比例尺高度，这是大气平均密度的高度。我的实现使用了0.25，所以从地面到天空穹顶的平均密度是25%。我的实现使用了0.25，所以从地面到天空穹顶的平均密度是25%。</p>
<p>常数是光的波长(或颜色)和K()是散射常数，它依赖于海平面的大气密度。<strong>瑞利散射和密散射有各自的散射常数，包括尺度高度h0。</strong></p>
<p>瑞利散射和密散射对波长的依赖也不同。瑞利散射常数通常除以4，在大多数计算机图形模型中，Mie散射常数与波长无关，但至少有一个实现将其除以0.84。</p>
<p><strong>外散射函数决定了有多少光被沿图的两条绿色射线散射掉了。</strong></p>
<h2 id="The-In-Scattering-Equation"><a href="#The-In-Scattering-Equation" class="headerlink" title="The In-Scattering Equation"></a>The In-Scattering Equation</h2><p><img src="/../../images/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/0257equ01.jpg" alt="0257equ01.jpg"></p>
<p>内散射方程描述了多少太阳的光线叠加到了大气当中。</p>
<p>对于每个从Pa到Pb中的点P，PPc是点到太阳的射线，PPa是点到相机的射线。外散射函数决定了有多少光被沿图的两条绿色射线散射掉了。剩下的光由<strong>相位函数</strong>（一个点一个相位函数–由实现和太阳光线夹角决定）、散射常数和阳光强度缩放。</p>
<p>阳光强度并不一定依赖于波长，但如果你想创建一个围绕紫色恒星旋转的外星世界，你就应该在这里应用颜色。</p>
<h2 id="The-Surface-Scattering-Equation"><a href="#The-Surface-Scattering-Equation" class="headerlink" title="The Surface-Scattering Equation"></a>The Surface-Scattering Equation</h2><p>这部分就是反射物体表面的颜色。这部分是渲染的选择不做讨论。</p>
<h2 id="实时计算"><a href="#实时计算" class="headerlink" title="实时计算"></a>实时计算</h2><p>如果使用上面的计算开销很高，计算点很多，需要进行简化。</p>
<p>GEMS的方法主要是将Outter Scattering 转换成一张二维LUT，简化计算。</p>

      
      <p align="right"><a class="morebtn" href="/2022/09/19/RTR/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/" title="">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/09/19/RTR/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/09/19/RTR/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/" itemprop="url"></a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-09-19T19:53:33+08:00">2022-09-19 19:53:33</time></span>
        </span>
        
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <!-- TOC -->



<p>- <a href="#%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4">图像动态范围</a></p>
<p>​    - <a href="#dynamic-range">Dynamic Range</a></p>
<p>​    - <a href="#%E6%98%BE%E7%A4%BA%E5%99%A8%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4">显示器动态范围</a></p>
<p>​    - <a href="#%E6%9B%9D%E5%85%89%E6%93%8D%E4%BD%9C%E4%BA%AE%E5%BA%A6%E4%B9%98%E6%B3%95%E5%9C%A8ev-%E7%A9%BA%E9%97%B4%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84">曝光操作（亮度乘法）在EV 空间怎么样的？</a></p>
<p>​    - <a href="#gamma%E6%93%8D%E4%BD%9C%E6%8C%87%E6%95%B0%E6%93%8D%E4%BD%9C%E5%9C%A8ev%E7%A9%BA%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84">Gamma操作（指数操作）在EV空间是怎么样的？</a></p>
<p>​    - <a href="#%E5%AF%B9%E6%AF%94%E5%BA%A6contrast">对比度Contrast</a></p>
<p>​    - <a href="#%E8%BF%99%E4%BA%9B%E5%86%85%E5%AE%B9%E5%A6%82%E4%BD%95%E5%BA%94%E7%94%A8%E5%88%B0%E5%B1%80%E9%83%A8%E6%9B%9D%E5%85%89%E4%B8%8A%E5%8F%AF%E4%BB%A5%E7%95%A5%E8%BF%87">这些内容如何应用到局部曝光上（可以略过）</a></p>
<p>​    - <a href="#eotf%E5%92%8Coetf">EOTF和OETF</a></p>
<p>​    - <a href="#%E6%98%BE%E7%A4%BA%E5%99%A8oetf%E5%92%8Cgamma22%E7%BC%96%E7%A0%81">显示器OETF和gamma2.2编码</a></p>
<p>​    - <a href="#%E8%A7%82%E5%AF%9F%E6%9D%A1%E4%BB%B6">观察条件</a></p>
<p>​    - <a href="#eotf%E5%92%8Coetf%E7%9A%84%E8%A7%86%E8%A7%89%E6%9D%A1%E4%BB%B6">EOTF和OETF的视觉条件</a></p>
<p>​    - <a href="#adjust-gamma-until-logo-is-barely-visible">Adjust gamma until logo is barely visible</a></p>
<p>​    - <a href="#tonemapping%E6%93%8D%E4%BD%9C">ToneMapping操作</a></p>
<p>​    - <a href="#%E5%8F%82%E8%80%83">参考</a></p>
<p>​    - <a href="#%E9%87%8D%E8%A6%81%E6%80%BB%E7%BB%93">重要总结</a></p>
<!-- /TOC -->

<h1 id="图像动态范围"><a href="#图像动态范围" class="headerlink" title="图像动态范围"></a>图像动态范围</h1><p>​	这篇笔记主要为了解释什么是<strong>动态范围</strong>，引出sRGB、ToneMapping等内容的前因后果。</p>
<p>​	笔记摘录自<a target="_blank" rel="noopener" href="https://bartwronski.com/2016/09/01/dynamic-range-and-evs/">Image Dynamic Range</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dynamic_range">wiki Dynamic range</a>,同时根据自己的理解做了补充和注释说明。</p>
<h2 id="Dynamic-Range"><a href="#Dynamic-Range" class="headerlink" title="Dynamic Range"></a>Dynamic Range</h2><p>​		<strong>动态范围</strong>指的是媒体设备能够表示的最大值和最小值的比例（有人会疑问最小值是0怎么办，而实际上0通常表示没有信号，另外最大值和最小值描述的是<strong>设备能够表示的范围</strong>，和设备的硬件相关）。</p>
<p>​		动态范围通常用来描述<strong>信号</strong>：声音信号（播放器）、亮度信号（显示屏）。</p>
<p>​		它通常是一个比例，或者以10为基数的数(声音：分贝)、或者是用2为基数的对数值表示最小信号值和最大信号值的差值(doublings、bits或<strong>stops</strong>)。</p>
<pre><code>    &gt; bits:信号理论、计算、数字通信当中的**基本信号单位**。他的名字是**binary digit**的缩写。
    &gt;
    &gt; doublings:没有搜索到，在这篇笔记中不重要。
    &gt;
    &gt; stops：在摄影中,设备的曝光范围通常用**stops**来表示，相当于设备或者媒体常量比例（contrast ratio）的 $ \log _&#123;2&#125;(c) $ 表示形式。
    &gt;
    &gt; 例如：通常的DV机的拍摄的常量比例是45:1，他的曝光约为5.5stops。
    &gt;
    &gt; 曝光范围可以指几种动态范围中的任何一种:
    &gt;
    &gt; 1.  感光范围照相胶片、纸或数码相机传感器的感光范围.
    &gt; 2.  被拍摄场景的光度范围
    &gt; 3.  显影胶片图像的不透明度范围
    &gt; 4.  相纸上图像的反射率范围。
    &gt;
    &gt; 例如：胶片的曝光范围约为14stops。
</code></pre>
<p>​		（<strong>本段的扩展阅读有点复杂可以跳过</strong>）在模拟信号（模拟信号是指用连续变化的物理量表示的信息）的媒体设备上，他通常表示为信噪比（signal to noise ratio）。最小值是无法从噪声中区分出来的。在某种程度上，他和数字信号（数字信号指自变量是离散的、因变量也是离散的信号，这种信号的自变量用整数表示，因变量用有限数字中的一个数字来表示。）的媒体设备类似，在数字信号设备上，小于最小可表示数据的内容都是量化噪声（由增量调制原理可知，译码器恢复的信号是阶梯形电压经过低通滤波器平滑后的解调电压。它与编码器输入模拟信号的波形近似，但是存在失真，将这种失真称为<strong>量化噪声</strong>。）。</p>
<p>​		动态范围对<strong>模拟相机</strong>（在高亮度和中等亮度的区域的精度更高，黑暗的区域会显示颗粒噪声）、<strong>数字信号</strong>（白色信号被完全的剪裁、大量的信息被压缩到暗部，并且还掺杂着数字噪声）和<strong>数字信号文件</strong>（除了量化噪声、伪影还有0噪声）有不同的含义。</p>
<p>​		这里我们主要讨论在<strong>显示器上</strong>的<strong>动态范围</strong>（<strong>动态范围是stops的范围，可以理解成bit位数</strong>，也叫做曝光范围，也就是说用EV stops表示dynamic range）。我们使用EV stops &#x3D; exposure value stops.<strong>这是一个以2为底数的对数差值</strong>。</p>
<blockquote>
<p>  注意是<strong>对数差值</strong>，例如最大值亮度的曝光值是9，最小亮度的曝光是2，那么动态范围是7.</p>
</blockquote>
<h2 id="显示器动态范围"><a href="#显示器动态范围" class="headerlink" title="显示器动态范围"></a>显示器动态范围</h2><p>​		首先可以做一个简单的联想：<strong>如果我们的输出图像是8bits的，那么显示器的动态范围就是8 EV stop</strong>。<strong>这是错误的：</strong>因为所有在设备上保存的数据都是考虑了<strong>OETF</strong>（存储格式进行了Gamma之类的变换），为了能够在显示设备上正常显示。典型的OETF是gamma操作，常用的Gamma是2.2指数和sRGB（sRGB比2.2编码更加准确，可以参考wiki）</p>
<p>​		<strong>这里实际上就是提出了一个问题：为什么8bits不是对应8 EV stop的动态范围？这里参见后面的解释：OETF（Gamma操作）带来的什么影响</strong>？</p>
<p>​		首先，对于最简单的情况（没有OETF），直接存储8bit值数据。</p>
<p>​		<strong>因为0表示没有信号，所以使用1&#x2F;256（对数为 $ log_2(\frac{1}{258}) &#x3D; -8 $）表示最小可表示信号（小于这个值的都是噪声），1为最高可表示信号（对数为 $ log_2(1) &#x3D; 0 $）,所以动态范围是8。</strong></p>
<blockquote>
<p>  <strong>重要说明，一般来讲图像最大值就是1，关键就是最小值是多少！直接决定了曝光范围</strong></p>
<p>  对于只有8bit的数据来表示颜色情况下，Gamma空间的颜色值的最小值要比线性空间颜色的最小值要小！</p>
</blockquote>
<p>​		下面是动态范围的数值输出和亮度的关系：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/dynrange_linear2.png" alt="dynrange_linear.png"></p>
<p>​		图像说明：动态范围用8bits进行线性编码（没有开了OETF直接保存，即没有Gamma）. 红线 &#x3D; stops:曝光值. 蓝色线 &#x3D; 输出结果（亮度）. 绿色线&#x3D; 曝光值. 点&#x3D; <strong>曝光范围到线性亮度的映射</strong>.</p>
<p>​		线性空间中EV stops的表示显然是指数型的，您可以看到这种编码的问题。很多颜色曝光值压缩在暗部，包括了3&#x2F;4的范围。因此线性编码对于对数信号是极大的浪费。</p>
<blockquote>
<p>  <strong>重要：这幅图用来做什么？</strong></p>
<p>  ​		首先注意，他不是针对像素说的：不是指一个像素的亮度值和这个像素的曝光值的映射。</p>
<p>  ​		<strong>这幅图表达的是</strong>：当我确定一个曝光范围的时候，可以<strong>表示哪个线性范围的图像亮度</strong>。例如：曝光值范围是8的时候可以表示[0-1]的亮度。当曝光范围变成4,那么小于-4的值就是噪声了，这个时候我们发现图像的大部分亮度范围（观察线性亮度的范围）还在，只是丢失了很小一部分的颜色。<strong>这幅图要讨论的就是这个：用更少的编码位数（动态范围）表示图像大部分的亮度范围（线性亮度）。</strong></p>
</blockquote>
<p>​		<strong>重要：我们进行图像的亮度操作通常有两种：Gamma操作（指数操作）和亮度缩放（亮度乘法），下面我们讨论这两种操作在EV stops上会产生什么影响！</strong></p>
<h2 id="曝光操作（亮度乘法）在EV-空间怎么样的？"><a href="#曝光操作（亮度乘法）在EV-空间怎么样的？" class="headerlink" title="曝光操作（亮度乘法）在EV 空间怎么样的？"></a>曝光操作（亮度乘法）在EV 空间怎么样的？</h2><p>​		在EV空间的常见操作是调整曝光值（在我们的游戏开发过程中通常的方法是：<strong>亮度</strong>结果直接<strong>乘一个系数</strong>）。<strong>我们现在讨论这个直接进行亮度乘法会给曝光范围（EV stops）带来什么影响。</strong></p>
<p>​		很显然对数空间（EV空间，就是右上角的值）的加法相当于对应的线性空间（亮度空间）的乘法，亮度空间的乘法：</p>
<p>$$ 2^{x+y} &#x3D;&#x3D; 2^x * 2^y $$</p>
<p>​		从下图可以看出曝光的操作（亮度乘法）没有修改动态范围（EV的范围）：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/exposure.gif" alt="exposure.gif"></p>
<blockquote>
<p>  ​	为什么会是上图的样子呢？</p>
<p>  ​		因为图像在变化的过程中，有效位只有8位，当亮度乘一个系数的时候相当于乘了一个 pow(2,N)，在对数空间相当于做了整体的加法，也可以看做做了左右移位的操作。由于有效位数没有变，所以变化范围只能在这8位以内。也就是动态范围只有8。</p>
</blockquote>
<h2 id="Gamma操作（指数操作）在EV空间是怎么样的？"><a href="#Gamma操作（指数操作）在EV空间是怎么样的？" class="headerlink" title="Gamma操作（指数操作）在EV空间是怎么样的？"></a>Gamma操作（指数操作）在EV空间是怎么样的？</h2><p>​		这就是事情开始变得有趣的地方。Gamma操作（这里实际上泛指的就是幂函数**exp()**，而不是特指图像Gamma变化）通常被定义为线性空间中的一个简单幂函数。</p>
<p>​		Gamma操作：</p>
<p>$$ gamma(x,y) &#x3D; x^y $$   </p>
<p>​		<strong>对亮度进行Gamma操作：下面的公式x表示曝光范围，描述的是在亮度空间进行Gamma操作之后转换回EV空间后，看看EV stops(也就是x)发生了什么变化：</strong></p>
<p>$$ log_2(gamma(2^x,y)) &#x3D;&#x3D; log_2(2^{x*y}) $$  </p>
<p>​		<strong>进一步变化，说明亮度的Gamma操作相当于对动态范围（EV值）的乘法：</strong></p>
<p>$$ log2(2^{x<em>y}) &#x3D;&#x3D; x</em>y $$</p>
<p>​		Gamma的操作对应了<strong>EV值的乘法</strong>（乘法就是压缩或者拉伸）。这是一个被GPU利用的性质：通过一系列的exp2，madd和log2操作来表示power操作。</p>
<blockquote>
<p>  怎么理解？</p>
<p>  就是说Gamma空间的颜色值进行了指数运算，相当于对曝光空间（EV stop 曝光步长）进行了压缩或者拉长。见下图。</p>
</blockquote>
<p>​		<strong>因此伽玛操作本质上是动态范围压缩&#x2F;扩展操作!</strong></p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/gamma.gif" alt="gamma.gif"></p>
<p>​		<strong>你可以看到它对原来的8位动态范围发生了变化。所以Gamma操作（幂操作或者log操作）可以压缩或者增加动态范围。</strong></p>
<h2 id="对比度Contrast"><a href="#对比度Contrast" class="headerlink" title="对比度Contrast"></a>对比度Contrast</h2><blockquote>
<p>  这里的对比度Contrast指的是一种维持颜色明暗的类似Gamma的操作，不是指图像的对比度。</p>
</blockquote>
<p>​		Gamma操作是一个有用的操作，但是用作增加动态范围的时候，整个图像比原来亮了。压缩动态范围的时候，整个图像的颜色都变暗了。这是因为锚点定在了0，线性空间颜色的最大值不会因为EV空间的动态范围变化而变化。这并不是我们想要的属性。<strong>在调整动态范围的过程中（Gamma操作的时候），我们希望图像保证亮度一致性。我们可以补偿亮度！用到的策略就是修改锚点—-例如使用中间灰度作为中间锚点。</strong></p>
<p>​		对比度和gamma很像，但是希望在调整动态范围的时候，保证其他的某个点的颜色不变而不是亮度为1的点不变（<strong>这里还没有讨论到hdr，所以最亮的位置是1</strong>）。例如中间灰度点0.18。</p>
<p>​		对比度计算公式:</p>
<p>$$ contrast(x, y, midPoint) &#x3D; \frac{x^y * midPoint }{ midPoint^y} $$</p>
<h2 id="这些内容如何应用到局部曝光上（可以略过）"><a href="#这些内容如何应用到局部曝光上（可以略过）" class="headerlink" title="这些内容如何应用到局部曝光上（可以略过）"></a>这些内容如何应用到局部曝光上（可以略过）</h2><p>​		希望有了这些知识，我们就能明白为什么局部曝光相对于其他对比和Gamma操作能更好地保持局部对比、饱和度。他移动了部分的颜色直方图（颜色过亮或者过暗的区域）但是：</p>
<ol>
<li>只应用在了部分图像，没有影响中间调。</li>
<li>只移动值，没有想Gamma一样压缩或者缩放。</li>
</ol>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/gamma_vs_both.gif" alt="gamma_vs_both"></p>
<h2 id="EOTF和OETF"><a href="#EOTF和OETF" class="headerlink" title="EOTF和OETF"></a>EOTF和OETF</h2><p>​		在谈论输出函数的时候，显示设备使用的电信号转换函数（EOTF – Electro Optical Transfer Function）和他的逆转函数（OETF, Opto-Electrical Transfer Function）是很重要的。</p>
<p>​		EOTF已经存在了很长时间， 所有CRT显示器对于电压强度的响应方式在某些条件下被认为是一致的。</p>
<p>​		下图是CRT显示器对于输入电压和输出亮度的函数关系。</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/crt_gamma.gif" alt="crt_gamma.gif"></p>
<p>​		早期的渲染管线完全忽视了Gamma并且直接使用它的感知线性属性，直接输出被显示器进行Gamma Power编码后的值。<strong>当你开始认真对待线性空间时，我们才开始使用它的逆函数-OETF，这也是我们为显示器编码信号的策略，例如： sRGB or Rec709。</strong></p>
<p>​		<strong>重要：当我们不再使用CRT显示器的时候，这种指数编码同样被验证在现代显示器上是有用的，他允许我们能够编码更多的信号</strong>（参考前面的Gamma变化可以压缩动态范围）。现在我们使用BT1886标准（指的是EOTF）<strong>用来模拟老式CRT显示器的gamma电压响应。</strong></p>
<blockquote>
<p>  这里讨论的就是我们能够通过Gamma编码<strong>在文件当中保存更大的动态范围</strong>，随后再利用显示器自带的EOTF解码以得到正确的效果。</p>
</blockquote>
<p>​		<a target="_blank" rel="noopener" href="https://kb.portrait.com/help/bt-1886-10-questions-10-answers">BT1886问答</a></p>
<p>​		下面是BT1886标，注意他是在指数空间：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/1579405297828.png" alt="1579405297828"></p>
<h2 id="显示器OETF和gamma2-2编码"><a href="#显示器OETF和gamma2-2编码" class="headerlink" title="显示器OETF和gamma2.2编码"></a>显示器OETF和gamma2.2编码</h2><p>​		我们现在回顾显示器的2.2 Gamma。因为EOTF是2.2，所以OETF就是1&#x2F;2.2（大概就是0.45），这就是我们的Gamma函数，将颜色从线性空间转换到gamma空间，我们会得到一个2.2*8（&#x3D;17.6）的动态范围。（可以保存在文件中的）。</p>
<p> $$OETF &#x3D;  gamma(color, \frac{1}{2.2}) $$  </p>
<p> $$EV stops &#x3D; log_2(gamma(2^x, \frac{1}{2.2}))  &#x3D; 2.2*x$$   </p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/dynrange_gamma_2_21.png" alt="dynrange_gamma_2_2.png"></p>
<blockquote>
<p>  sRGB标准包括了很多内容，Gamma编码只是其中一部分。</p>
<p>  下图来源于wiki，sRGB标准中linear空间进入Gamma空间的公式。</p>
<p>  <img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/1579420987252.png" alt="1579420987252"></p>
</blockquote>
<p>​		现在有人会问，我以为显示器使用sRGB函数，（它在较小值的位置使用了线性函数，其他位置用了2.4的指数。）</p>
<p>​		为什么我不使用精确的sRGB? 在这篇文章中，<strong>我将直接使用gamma 2.2，为了简化说明。</strong></p>
<blockquote>
<p>  对于大部分制作软件，和显示器都依赖sRGB标准。在渲染当中我们通常用2.2进行编码解码。</p>
</blockquote>
<p>​		<strong>这里值得注意的是，仅仅是伽玛2.2的线性值编码在8位就有了很大的动态范围（翻倍）。那么17.6的曝光级别足够了么？</strong>我们得到了更大的分布，尤其是在y轴上变得更均匀了。但是现在仍然不完美，因为现在把太多的值放在了表示阴影上，更多的变化集中在高亮度区间（而不是中等亮度区间，<strong>也就是说高亮度区间对于数值的变化更敏感</strong>）。我们随后在处理。</p>
<p>​		另一方面，使用gamma2.2的OETF（使用了17.6的曝光级别）意味着我们不需要HDR显示和局部的tonemapping了？并不是！仔细想想在1&#x2F;256和2&#x2F;256之间有多少信息？2.2的 EV对于观察者意味着什么？他们可能根本注意不到，因为范围亮度变化太小了。<strong>不同的显示器有不同的曝光范围，并且依赖于观察环境（就是显示器周围的环境）</strong>。参考<a target="_blank" rel="noopener" href="http://gpuopen.com/gdc16-wrapup-presentations/">Presentation by Timothy Lottes</a> 。</p>
<blockquote>
<p>  有一个地方值得说明：</p>
<p>  EOTF 的标准只有一个BT1886</p>
<p>  但是为了这种显示器编码的OETF标准有各种各样。</p>
</blockquote>
<p>​		但是在我继续深入分析tonemapping是如何改变它的以及gamma真正做了什么之前，我做了一个关于观察条件的小实验。</p>
<h2 id="观察条件"><a href="#观察条件" class="headerlink" title="观察条件"></a>观察条件</h2><p>​		下面是一张iPhone照片，照片中的笔记本上显示了一张图片。这是对于笔记本来说完美的观察环境（拉上了窗帘），笔记本中的图片细节都看的很清楚。</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/2016-08-21-13-31-05.jpg" alt="2016-08-21 13.31.05.jpg"></p>
<p>由于手机没有捕获足够的动态范围，但是看着可以，所有的细节都捕获了，大量的细节在阴影当中。</p>
<p>有趣的是HDR的场景和影子看起来非常暗，但是充满了细节和亮点。在这样的完美观察环境中，我不要任何的调整就能够感觉到图像和显示器就是hdr的。</p>
<p>第二张图片在平均视觉条件当中：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/2016-08-21-13-29-59.jpg" alt="2016-08-21 13.29.59.jpg"></p>
<p>正常图片仍然是清晰可以观察到的，尽管暗处丢失的细节不可见。</p>
<p>图像看起来有了更强烈的明暗差别，但是Kratos的背部完全看不到了。</p>
<ul>
<li><strong>Bartleson–Breneman effect:</strong> 图像对比度(发光显示器的图像，如液晶显示器上的图像)随着周围照明的亮度增加。</li>
</ul>
<p>第三张我们在极强的亮度条件下</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/2016-08-21-13-30-31.jpg" alt="2016-08-21 13.30.31.jpg">条</p>
<p>这个时候超过的屏幕的亮度，屏幕内容已经变得不可见了。</p>
<p>增强亮度，可以看到屏幕细微的变化：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/2016-08-21-13-30-31_c.jpg" alt="2016-08-21 13.30.31_c.jpg"></p>
<p>​		图像不但不可见了，而且丢失了大量的细节，并且还被屏幕的反射覆盖了。几乎没有Gamma设置能够改善这样的情况。</p>
<p>​		实验的目的是为了说明：<strong>Timothy Lottes在他的演讲中所展示的——观看条件（看显示器的环境）定义了可感知（人眼的实际感受）的动态范围，和图像的清晰度。</strong></p>
<p>​		从数值上理解就是，由于亮度太高你无法分辨0.25以下的值。这就是这个场景动态范围的结果：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/poor_viewing_conditions2.png" alt="poor_viewing_conditions.png"></p>
<p>曝光范围在4.4EV的位置就停止了，所以我们需要做一些局部的tonemapping。</p>
<h2 id="EOTF和OETF的视觉条件"><a href="#EOTF和OETF的视觉条件" class="headerlink" title="EOTF和OETF的视觉条件"></a>EOTF和OETF的视觉条件</h2><p>​		<strong>观察环境</strong>和<strong>感知能力</strong>是存在不同的gamma EOTF曲线和OETF曲线的原因。Rec709 EOTF （给高清电视用的）和sRGB（给显示器和打印机用的）的转换曲线是不同的（<strong>2.4</strong> vs <strong>2.2</strong>），因为高清电视在较暗的观看条件下需要不同的对比度和人眼感知效果（2.4有更大的动态范围）。</p>
<blockquote>
<p>  Rec709和sRGB除了Gamma不同之外还有很多特性需要注意，还涉及到文件传输，保存，显示特性，这里不做详细讨论。值得注意的是，Rec. 709和sRGB具有相同的主色性。</p>
</blockquote>
<p>​		由于Bartleson-Breneman效应（<strong>当周围环境变得更明亮时，我们感知到更多的对比度，更少的动态范围</strong>，因为动态范围由最小可表示精度决定，太亮的地方，看暗处的感受就不明显了。），客厅在晚上和标准办公环境(sRGB)需要不同的EOTF。Rec709 EOTF伽马将意味着输出设备产生更多的对比度。（<strong>Gamma更大，图像亮度更亮</strong>）</p>
<p>​		因此使用，翻转函数，OETF of Rec709能够保存更大的曝光范围，并且TV支持他们的显示并且TV的使用环境我们认为偏暗，所以会足够好。</p>
<blockquote>
<p>  在比较暗的环境中，因为人感受到更少的对比度（明暗对比），更大的动态范围（暗处的细节），我们希望提高屏幕亮度，降低对比度，使用比较大的gamma值。（晚上的客厅）</p>
<p>  在比较亮的环境中，因为人感受到更多的对比度，更x小的动态范围，我们希望降低屏幕亮度，提升对比度，使用比较小的gamma值。（办公环境）</p>
</blockquote>
<p>​		下面是两个曲线的对比：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/gamma_2_2vs2_4.gif" alt="gamma_2_2vs2_4.gif"></p>
<p>​		Gamma2.2和2.4并不是唯一的标准，不同的软件和硬件还有不同的标准。你可以找到历史参考苹果Mac gammas 1.8或2.0。Gameboy使用了极限的gammas 3.0或4.0</p>
<h2 id="Adjust-gamma-until-logo-is-barely-visible"><a href="#Adjust-gamma-until-logo-is-barely-visible" class="headerlink" title="Adjust gamma until logo is barely visible"></a>Adjust gamma until logo is barely visible</h2><p>​		由于不同的观察条件（在不同的灯光环境看显示器），是我们看到下面这张图的原因：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/logo.png" alt="logo.png"></p>
<p>​		<strong>有的时候这个东西没有名字，有时候叫做Slider,有时候叫做Gamma，有时候叫做对比度、亮度，这些都是不对的，但是他们本质的功能是调节不完美的观察条件,以让人能够正确的观察到屏幕效果。</strong></p>
<p>​		在亮度环境范围，会造成一个对比度的降低了的环境，需要动态范围压缩的操作（降低Gamma值，让图像变暗），观察者能够感受到更强的对比度。</p>
<blockquote>
<p>  试想一下</p>
<p>  在特别亮的灯光环境下，应该把它调亮，这个时候相当于增加动态范围，增加Gamma，这个时候对比度降低了。</p>
<p>  当周围环境变得更明亮时，我们感知到更多的对比度，更少的动态范围。所以我们要增加动态范围降低对比度，以保证观察效果。</p>
</blockquote>
<p>这个设置通常是有用的，但是问题在于：</p>
<ol>
<li>通常用户值只设置一次，却在不同的环境玩游戏。设置一次但是在白天、晚上、晚上开灯的时候玩游戏。</li>
<li>这个功能的目的没有合理的表达出来。这个调节结果依赖于室内环境的亮度和内容被观察的环境。</li>
</ol>
<p>​		假设在一个很糟糕的观察条件下。环境特别亮，这个时候我们如何调整显示器的Gamma值?(在EOTF以外的操作)。</p>
<p>​		这个是时候我们需要提高动态范围，降低对比度。所以在输出之前的OETF编码需要进行修改，使用0.7的改变图像的动态范围（我们对于显示器的EOTF没有做任何事情）:</p>
<p>$$ (x^{0.7})^{1&#x2F;2.2} &#x3D;&#x3D; x^{0.7&#x2F;2.2} $$</p>
<p>注意下面的公式是编码到Gamma空间的编码方式，上面的内容就是保存更大的动态范围：</p>
<p>$$ x^{1&#x2F;2.2} $$</p>
<p>图示：</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/poor_viewing_conditions1.gif" alt="poor_viewing_conditions.gif"></p>
<p>​		这样我们就增加了1.42左右的曝光范围。然而，在好的观察条件下（从特别明亮的环境，回到晚上），效果有会变的很差。</p>
<blockquote>
<p>  这部分需要注意了： 我们没有对显示器本身的EOTF做任何事情，只是单纯的修改了图像编码到Gamma空间的函数，也就是我们提升了这个图像保存时的动态范围。然后在显示出来。</p>
<p>  这个时候就有一个问题，Gamma的编码和解码不配套，而按照标准资源制作流程都是sRBG。这里需要注意两点：</p>
<ol>
<li>我们是在游戏渲染中常常用到这种策略。</li>
<li>修改原始图像的动态范围，表示我们的图像在动态范围做了伸缩，而显示器本身还有自己的动态范围的伸缩，并没有改变颜色，Gamma空间就是单纯的动态范围伸缩而已！另外，注意动态范围并不是数据精度的bit。</li>
</ol>
</blockquote>
<h2 id="ToneMapping操作"><a href="#ToneMapping操作" class="headerlink" title="ToneMapping操作"></a>ToneMapping操作</h2><p>​		从上面的分析来看我们不需要tonemapping的曲线。毕竟在适当的观测条件下，采用直接的线性编码可以获得较大的动态范围。</p>
<p>这里有两个问题：</p>
<ol>
<li><p>其一是非正规分布的数据，较高的曝光区域占据了很大的范围。我们希望更大的动态范围保存中等亮度的值。</p>
</li>
<li><p>通常1定义了一个白色点，但是在没有上限的HDR渲染上，曝光之后，我能够保证在中等范围有足够的值，我们也能够在亮度区域有足够的动态分布。这在PBR渲染当中是确实存在的。</p>
<p>​		目前提供的方法还没有为那些非常明亮的对象提供任何解决方案，我们不想降低对比度或改变曝光，我们不想让它们完全失去饱和度;我们仍然希望看到一些细节。</p>
</li>
</ol>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/proper_exp_linear.png" alt="proper_exp_linear"></p>
<p>​	上图的曝光效果完全剪裁掉了亮度区域。</p>
<p>​	这个时候就是tonemapping发挥作用的地方。一些常见的例子： Reinhard。我绝不推荐这条曲线，还有更好的选择。</p>
<p>可能每个引擎都实现了一个参考曲线： <a target="_blank" rel="noopener" href="http://filmicgames.com/archives/75">Hable Uncharted tonemapping curve</a>.</p>
<p>另一个选择是：<a target="_blank" rel="noopener" href="https://github.com/ampas/aces-dev">ACES</a></p>
<p>或者开销更低的：ACES RRT and ODT， <a target="_blank" rel="noopener" href="https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/">Kris Narkowicz proposed</a>.</p>
<p>最后，我个人认为非常方便的选择是精心设计的：<a target="_blank" rel="noopener" href="http://gpuopen.com/gdc16-wrapup-presentations/">generic filmic tonemapping operator from Timothy Lottes</a>.</p>
<p>我不在这里集中讨论它们，而是尝试用最简单的形式来解释:</p>
<p>$$  tonemap(x) &#x3D; x&#x2F;(1+x) $$</p>
<p>这是一条永远不会到达白点的曲线，因此通常使用重新调平校正因子（除以白点值）</p>
<p><img src="/../../images/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/reinhard.png" alt="reinhard.png"></p>
<p>上图是白点值定义为128的tonemapping曲线。</p>
<p>​		这看起来很棒——我们不仅获得了超过7个曝光点，在不影响中间色调和暗部的情况下，将它们紧紧地包裹在亮色中，而且在最终编码中EV的分布看起来几乎完美!</p>
<p>​		它还可以(在一定程度上)分辨出比EV 0(曝光后)的原始亮度高得多的物体的细节——比如发射物、发光粒子、火焰、明亮的镜面反射。任何没有比128更“热”的东西都会得到一些区别和表现。</p>
<p>​	最好的方案是 <a target="_blank" rel="noopener" href="http://graphicrants.blogspot.com/2013/12/tone-mapping.html">firefly fighting in post effects or general variance reduction</a>. 更好的解决方案，能想要在tonemapping上做更多的事情：在暗部添加一些饱和度和对比度的视觉矫正（filmic曲线的toe部分）等。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://renderwonk.com/publications/s2010-color-course/">http://renderwonk.com/publications/s2010-color-course/ </a>SIGGRAPH 2010 Course: Color Enhancement and Rendering in Film and Game Production</p>
<p><a target="_blank" rel="noopener" href="http://gpuopen.com/gdc16-wrapup-presentations/">http://gpuopen.com/gdc16-wrapup-presentations/</a>  “Advanced Techniques and Optimization of HDR Color Pipelines”, Timothy Lottes.</p>
<p><a target="_blank" rel="noopener" href="http://filmicgames.com/archives/75">http://filmicgames.com/archives/75</a> John Hable “Filmic Tonemapping Operators”</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ampas/aces-dev">https://github.com/ampas/aces-dev</a> Academy Color Encoding Standard</p>
<p><a target="_blank" rel="noopener" href="https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/">https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/</a> ACES filmic tonemapping curve</p>
<p><a target="_blank" rel="noopener" href="http://graphicrants.blogspot.com/2013/12/tone-mapping.html">http://graphicrants.blogspot.com/2013/12/tone-mapping.html</a> Brian Karis “Tone-mapping”</p>
<h2 id="重要总结"><a href="#重要总结" class="headerlink" title="重要总结"></a>重要总结</h2><ol>
<li>为什么要讨论动态范围？ 其实和软件无关，这是一个硬件上的内容，是为了描述硬件设备可表示信号的区分度。文中有一段话：</li>
</ol>
<p>​		<strong>因为0表示没有信号，所以使用1&#x2F;256（对数为 $ log_2(\frac{1}{258}) &#x3D; -8 $）表示最小可表示信号（小于这个值的都是噪声），1为最高可表示信号（对数为 $ log_2(1) &#x3D; 0 $）,所以动态范围是8。</strong></p>
<p>​		<strong>这完全是因为在8bit的数据格式下，我们能表达的最小亮度就是1&#x2F;256，我们无法表达更小的颜色了。</strong>所以亮度的范围就是[1&#x2F;256 ，1]。 在二进制上就是8个级别，就是我们的8 EV stops。</p>
<p>​		通过Gamma编码之后： 这个值变成了  $ {(2^{-8}) }^{\frac{1}{2.2}} $   &#x3D; $ {(2^{-3.6}) } $。</p>
<p>​		**最小值变大了！也就是说我们可以表示更暗的颜色了!**，但是数据还是8bits。我们能表示的亮度级别变成了17.6.也就是我们的sRGB能够表达17.6EV stops。</p>
<ol start="2">
<li><p>一定要记住，Dynamic Range(动态范围，8 EV stops)不是数据格式（8 bits的图像格式）。8bits的通道可以保存17.6 EV stops的动态范围。Gamma的作用就是在固定的数据量下，保存更多的亮度变化范围。</p>
</li>
<li><p>整个显示过程中存在两次动态范围的变化，一次是制作软件完成制作，保存到sRBG（17.6 EV stops的动态范围），用了OTEF。显示器显示时，自身的EOTF（CRT是自带的，最新显示器是专门附加的）从17.6 EV stops解码回正确的亮度值。</p>
</li>
<li><p>人眼对很高的动态范围感知，但是依赖于环境。嘈杂的环境听不到耳语。强光看不到暗处的细节。所以需要游戏中调节滑块的功能，修改显示器的显示动态范围大小。</p>
</li>
<li><p>一般的显示器本身的动态范围有限，过渡的拉伸会导致亮部被剪裁掉。所以HDR显示器就是有更大的动态范围。</p>
</li>
<li><p>游戏当中Gamma的编码和解码可能不配套，因为需要Gamma矫正。如果编码用了更大的动态范围（这个时候显示器的动态范围不变），相当于把整个图像变亮了。（提高动态范围会增加图像亮度，这是Gamma本身的特性）这一点很容易体现在数据大小上。</p>
</li>
</ol>

      
      <p align="right"><a class="morebtn" href="/2022/09/19/RTR/%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4/" title="">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/09/19/RTR/%E4%BD%93%E7%A7%AF%E4%BA%91/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/09/19/RTR/%E4%BD%93%E7%A7%AF%E4%BA%91/" itemprop="url"></a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-09-19T19:53:33+08:00">2022-09-19 19:53:33</time></span>
        </span>
        
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="体积云光照部分相关理论"><a href="#体积云光照部分相关理论" class="headerlink" title="体积云光照部分相关理论"></a>体积云光照部分相关理论</h1><p>阅读GPU Pro6当中的第4章体积云，主要为了记录其中和光相关的理论。《Real-Time Rendering  of Physical Based Clouds Using Precomputed Scattering》</p>
<p>这篇文章主要提出了一种refrence Particle。通过缩放和旋转同一个粒子得到云。云可以有动画。</p>
<p>在与计算部分, 计算光学深度已经单个和多个的散射积分，用来描述光在rp当中的传递，描述了所有可能的摄像机位置和观察方向，并且存储在查找表当中。</p>
<p>原文：</p>
<p>we precompute optical depth as well as single and multiple scattering integrals describing the light transport in the reference particle for all possible camera positions and<br>view directions and store the results in lookup tables. </p>
<p>在运行阶段，加载查找表，来估计光线在云当中的传递节省ray marching和slicing的开销。</p>
<p>主要原理来源于[Yusov 14b] </p>
<p>改进方案包括：</p>
<p>1.改进基于与计算查找表的着色模型。</p>
<p>2.使用3D网格来改进光线在云内部传递的衰减算分。</p>
<p>3.新的粒子生成算法</p>
<p>4.性能优化，包括给予GPU的粒子排序。</p>
<h2 id="Light-Transport-Theory"><a href="#Light-Transport-Theory" class="headerlink" title="Light Transport Theory"></a>Light Transport Theory</h2><p>这里介绍光线在粒子中传递的概念。</p>
<p>参考：More information can be found in [Riley et al. 04,Bouthors 08] </p>
<p>光在粒子当中有三个现象：</p>
<ol>
<li>散射：改变粒子在介质中传播方向。</li>
<li>吸收：光子能量转换成了其他形式</li>
<li>发光：与吸收相反。</li>
</ol>
<p>上述过程可以用Sc ，Ab，Em三个系数来描述。吸收散射 都是减少了光在介质中的强度。</p>
<p>消减系数：$$ Ex &#x3D; Ab + Sc $$。</p>
<p>在云内部 发散和吸收可以忽略 ： $$Em &#x3D; Ab &#x3D; 0$$, 所以散射和吸收可以用同一个系数描述：$$ Sc  &#x3D; Ex &#x3D; B $$</p>
<p> 光线在云内部，从A点到B点的衰减系数可以用下方公式描述:</p>
<p>$$ e^{-\tau(A,B)}$$</p>
<p>$ -\tau(A,B) $ 表示光学深度，是从A点到B点消散系数B的积分。</p>
<p>$$ -\tau(A,B) &#x3D;  \sum^A_B{\beta(P)ds}$$</p>
<p>$$ P&#x3D;A+\frac{B-A}{|{B-A}|}  $$<br>s表示当前积分的点。</p>
<p>为了知道一个散射光的强度，我们需要沿着视线积累太阳光在每一个点上朝摄像机散射的所有分量。</p>
<p>参数解释$C$表示摄像机位置，$\vec v$表示视线方向，$P_0$和$P_1$表示视线进入和离开云的位置，$P$表示某个散射位置的点，$Q$是光线到达散射位置的太阳光进入云的点。$L_{sun}$表示太阳光强度，$P(\theta)$表示入射方向到出射方向光损失的百分比。削减一共有两部分P到P0和Q到P.</p>
<p>上面描述的只是一个点。</p>
<p>同时P的近似函数：</p>
<p>$$ P(\theta) &#x3D; \frac{1}{4PI}\frac{3(1-g^2)}{2(2+g^2)}\frac{(1 + cos^2(\theta))}{(1+g^2-2gcos(\theta))^{\frac{3}{2}}} $$</p>
<p>把所有光线夹起来就是最终结果:</p>
<p>$$L^n_{In}(C,\vec v)&#x3D;\int_{P0}^{P1}J^{(n)}(P,\vec v)e^{-\tau(P,P0)}ds$$</p>
<p>其中$J^{(n)}$ 表示各个方向每个点想实现方向散射的强度。</p>
<h2 id="Precompute-Solutions"><a href="#Precompute-Solutions" class="headerlink" title="Precompute Solutions"></a>Precompute Solutions</h2><p>后面的部分用处不大，以后再研究。</p>

      
      <p align="right"><a class="morebtn" href="/2022/09/19/RTR/%E4%BD%93%E7%A7%AF%E4%BA%91/" title="">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/09/19/RTR/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/09/19/RTR/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/" itemprop="url"></a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-09-19T19:53:33+08:00">2022-09-19 19:53:33</time></span>
        </span>
        
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="主机渲染和优化技术概要"><a href="#主机渲染和优化技术概要" class="headerlink" title="主机渲染和优化技术概要"></a>主机渲染和优化技术概要</h1><!-- TOC --><br/><br/>- [主机渲染和优化技术概要](#主机渲染和优化技术概要)<br/>    - [1. 渲染流程](#1-渲染流程)<br/>        - [1.1. RenderPipeline](#11-renderpipeline)<br/>        - [1.2. 渲染参数](#12-渲染参数)<br/>        - [1.3. 常用光照模型](#13-常用光照模型)<br/>        - [1.4. 基础光照计算](#14-基础光照计算)<br/>            - [1.4.1. D项 ：GGX (Trowbridge-Reitz)](#141-d项-ggx-trowbridge-reitz)<br/>            - [1.4.2. G项：Schlick](#142-g项schlick)<br/>            - [1.4.3. F项：Schlick’s approximation](#143-f项schlicks-approximation)<br/>            - [1.4.4. IBL](#144-ibl)<br/>        - [1.5. 光照技术](#15-光照技术)<br/>            - [1.5.1. multipass forward](#151-multipass-forward)<br/>            - [1.5.2. multipass deferred](#152-multipass-deferred)<br/>            - [1.5.3. singlepass deferred](#153-singlepass-deferred)<br/>            - [1.5.4. Tiled-based  Shading](#154-tiled-based--shading)<br/>            - [1.5.5. Clustered Shading](#155-clustered-shading)<br/>            - [1.5.6. 效果对比](#156-效果对比)<br/>    - [2. 渲染技术](#2-渲染技术)<br/>        - [2.1. 基础材质](#21-基础材质)<br/>        - [2.2. 分层细节材质](#22-分层细节材质)<br/>        - [2.3. 分层材质系统](#23-分层材质系统)<br/>        - [2.4. 材质库系统](#24-材质库系统)<br/>        - [2.5. 特效材质](#25-特效材质)<br/>        - [2.6. 屏幕空间技术](#26-屏幕空间技术)<br/>            - [2.6.1. 主要涉及到屏幕空间的Ray Trace操作。](#261-主要涉及到屏幕空间的ray-trace操作)<br/>            - [2.6.2. Screen Space Contact Shadow](#262-screen-space-contact-shadow)<br/>            - [2.6.3. Screen Space Reflections](#263-screen-space-reflections)<br/>        - [2.7. 毛发](#27-毛发)<br/>            - [2.7.1. hairworks or TressFX：](#271-hairworks-or-tressfx)<br/>        - [2.8. 灯光方案](#28-灯光方案)<br/>        - [2.9. 阴影方案](#29-阴影方案)<br/>            - [2.9.1. 巫师3的CSM](#291-巫师3的csm)<br/>            - [2.9.2. 阴影代理](#292-阴影代理)<br/>        - [2.10. LOD方案](#210-lod方案)<br/>        - [2.11. 后处理：曝光与光照设定](#211-后处理曝光与光照设定)<br/>        - [2.12. 透明物体低分辨率渲染](#212-透明物体低分辨率渲染)<br/>        - [2.13. 后处理：HDR and ToneMapping](#213-后处理hdr-and-tonemapping)<br/>        - [2.14. 后处理：TAA](#214-后处理taa)<br/>    - [3. GPU架构](#3-gpu架构)<br/>        - [3.1. GPU存储架构](#31-gpu存储架构)<br/>        - [3.2. GPU渲染架构](#32-gpu渲染架构)<br/>            - [3.2.1. 存储和计算的关系](#321-存储和计算的关系)<br/>            - [3.2.2. Wrap与Wave Front](#322-wrap与wave-front)<br/>        - [3.3. 手游架构](#33-手游架构)<br/>    - [4. 程序优化性能关注的点](#4-程序优化性能关注的点)<br/>        - [4.1. Draw Call](#41-draw-call)<br/>        - [4.2. Early - z](#42-early---z)<br/>        - [4.3. Over Draw](#43-over-draw)<br/>        - [4.4. Quad OverDraw](#44-quad-overdraw)<br/>        - [4.5. Light](#45-light)<br/>        - [4.6. Vertex Count](#46-vertex-count)<br/>        - [4.7. Texture压缩与内存优化](#47-texture压缩与内存优化)<br/>        - [4.8. Baking](#48-baking)<br/>        - [4.9. MipMap](#49-mipmap)<br/>        - [4.10. Testure Streaming](#410-testure-streaming)<br/>        - [4.11. Shader预加载](#411-shader预加载)<br/>        - [4.12. Shader分支](#412-shader分支)<br/>    - [5. 美术资源可能带来的性能问题](#5-美术资源可能带来的性能问题)<br/>        - [5.1. 游戏性能瓶颈：模型](#51-游戏性能瓶颈模型)<br/>        - [5.2. 游戏性能优化：模型](#52-游戏性能优化模型)<br/>        - [5.3. 游戏性能瓶颈：贴图](#53-游戏性能瓶颈贴图)<br/>        - [5.4. 游戏性能优化：贴图](#54-游戏性能优化贴图)<br/>        - [5.5. 游戏性能瓶颈：材质](#55-游戏性能瓶颈材质)<br/>        - [5.6. 游戏性能优化：材质](#56-游戏性能优化材质)<br/>        - [5.7. 游戏性能瓶颈：Quad OverDraw 、OverDraw](#57-游戏性能瓶颈quad-overdraw-overdraw)<br/>        - [5.8. 游戏性能优化：Quad OverDraw 、OverDraw](#58-游戏性能优化quad-overdraw-overdraw)<br/><br/><!-- /TOC -->

<h2 id="1-渲染流程"><a href="#1-渲染流程" class="headerlink" title="1. 渲染流程"></a>1. 渲染流程</h2><h3 id="1-1-RenderPipeline"><a href="#1-1-RenderPipeline" class="headerlink" title="1.1. RenderPipeline"></a>1.1. RenderPipeline</h3><p>基础渲染流程。</p>
<p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961718383.png" alt="1568961718383"></p>
<p><img src="/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961632451.png" alt="1568961632451"></p>
<p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961793802.png" alt="1568961793802"></p>
<p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961811084.png" alt="1568961811084"></p>
<p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961840796.png" alt="1568961840796"></p>
<p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961874770.png" alt="1568961874770"></p>
<p><img src="/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568961884019.png" alt="1568961884019"></p>
<h3 id="1-2-渲染参数"><a href="#1-2-渲染参数" class="headerlink" title="1.2. 渲染参数"></a>1.2. 渲染参数</h3><p>Unity HDRP Deferred结构</p>
<table>
<thead>
<tr>
<th>G-Buffer Usage</th>
<th>Format</th>
<th>RGB</th>
<th>A</th>
</tr>
</thead>
<tbody><tr>
<td>GBuffer0</td>
<td>RGBA32</td>
<td>Albedo Color &#x2F;      SSS Color</td>
<td>Spacular Occlusiion &#x2F; SSS Parameter</td>
</tr>
<tr>
<td>GBuffer1</td>
<td>RGBA32</td>
<td>Packed Normal</td>
<td>Roughness</td>
</tr>
<tr>
<td>GBuffer2</td>
<td>RGBA32</td>
<td>BSDF Model Specific Parameters</td>
<td>Coat Mask + Material ID</td>
</tr>
<tr>
<td>GBuffer3</td>
<td>R11G11B10</td>
<td>GI + Emissive</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>GBuffer4 - Optional</td>
<td>RGBA32</td>
<td>R:&#x2F;             G:&#x2F;             B: AO</td>
<td>Light Layer</td>
</tr>
<tr>
<td>GBuffer5 - Optional</td>
<td>RGBA32</td>
<td>shadowmask0 - 2</td>
<td>shadowmask3</td>
</tr>
</tbody></table>
<h3 id="1-3-常用光照模型"><a href="#1-3-常用光照模型" class="headerlink" title="1.3. 常用光照模型"></a>1.3. 常用光照模型</h3><table>
<thead>
<tr>
<th>Clear Coat</th>
<th>车漆效果</th>
</tr>
</thead>
<tbody><tr>
<td>Specular</td>
<td>这个是和Standard（金属工作流）相对的高光工作流。区别只是金属度变成了高光颜色。其他计算没有区别。指定F0。</td>
</tr>
<tr>
<td>Anisotropy</td>
<td>计算高光时使用各项异性的高光计算。和Standard区别只在于高光的计算，同时多出了一张各向异性贴图和强度控制。例如：拉丝金属。</td>
</tr>
<tr>
<td>Iridescence</td>
<td>彩虹色是指：随着光照角度的变化光照颜色发生变化。例如：肥皂泡沫，昆虫翅膀。</td>
</tr>
<tr>
<td>Translucent</td>
<td>透光效果是指：在背光面可以看到光穿过物体的效果。主要用于半透明材质。例如：树叶。</td>
</tr>
<tr>
<td>Surface Scattering</td>
<td>SSS效果用来描述光线在表面多次散射的效果。可以用来描述灯光和半透物体的交互过程。可以用来制作：玉、冰、皮肤等物体。</td>
</tr>
<tr>
<td>Displacement</td>
<td>Unity支持高度图计算。Vertex Displacement:  在Vertex阶段直接移动顶点，高度图作为移动距离。Pixel displacement： 将高度图作为视差贴图。（POM）</td>
</tr>
<tr>
<td>Standard</td>
<td>标准材质</td>
</tr>
</tbody></table>
<h3 id="1-4-基础光照计算"><a href="#1-4-基础光照计算" class="headerlink" title="1.4. 基础光照计算"></a>1.4. 基础光照计算</h3><p>漫反射：</p>
<p>$$ f(l,v) &#x3D; \frac{c_{diff}}{\pi} $$</p>
<p>高光：</p>
<p>$$ f(l,v) &#x3D; \frac{D(h)G(l,v,h)F(v,h)}{4(nl)(nv)} $$</p>
<h4 id="1-4-1-D项-：GGX-Trowbridge-Reitz"><a href="#1-4-1-D项-：GGX-Trowbridge-Reitz" class="headerlink" title="1.4.1. D项 ：GGX (Trowbridge-Reitz)"></a>1.4.1. D项 ：GGX (Trowbridge-Reitz)</h4><p>$$ \alpha &#x3D; roughness^2 $$</p>
<p>$$ D_{GGX}(h)&#x3D;\frac{\alpha^2}{\pi((nh)^2(\alpha^2-1)+1)^2} $$</p>
<h4 id="1-4-2-G项：Schlick"><a href="#1-4-2-G项：Schlick" class="headerlink" title="1.4.2. G项：Schlick"></a>1.4.2. G项：Schlick</h4><p>Schlick-GGX（用在IBL上）</p>
<p>$$k &#x3D;\frac{\alpha} {2}$$  </p>
<p>$$ \alpha &#x3D; roughness^2 $$</p>
<p>根据Disney文章对其做了修改（这个修改只用在解析光源上，IBL在glancing angles会太暗）：</p>
<p>$$k &#x3D;\frac{(roughness + 1)^2} {8}$$  </p>
<p>$$ G_{GGX}(v) &#x3D; \frac{nv}{(nv)(1-k)+k} $$</p>
<h4 id="1-4-3-F项：Schlick’s-approximation"><a href="#1-4-3-F项：Schlick’s-approximation" class="headerlink" title="1.4.3. F项：Schlick’s approximation"></a>1.4.3. F项：Schlick’s approximation</h4><p>$$ F(v,h)&#x3D;F_0 + (1 - F_0) 2^{-5.55473(vh)-6.98316)(vh)} $$</p>
<h4 id="1-4-4-IBL"><a href="#1-4-4-IBL" class="headerlink" title="1.4.4. IBL"></a>1.4.4. IBL</h4><p>首先需要解决的是辐射度积分，通常使用重要度采样：</p>
<p>$$ \int_H L_i(l)f(l,v)cos(\theta_l)dl  &#x3D; \frac{1}{N}\sum^{N}_{k&#x3D;1}\frac{L_i(l_k)f(l_k,v)cos theta _{l_k} }{p(l_k,v)} $$</p>
<h3 id="1-5-光照技术"><a href="#1-5-光照技术" class="headerlink" title="1.5. 光照技术"></a>1.5. 光照技术</h3><h4 id="1-5-1-multipass-forward"><a href="#1-5-1-multipass-forward" class="headerlink" title="1.5.1. multipass forward"></a>1.5.1. multipass forward</h4><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Shaders:</span><br>Shader simpleShader<br><br><span class="hljs-comment">//Buffers:</span><br>Buffer display<br><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">for</span> light in scene<br>        display += simpleShader(mesh, light)<br></code></pre></td></tr></table></figure>

<h4 id="1-5-2-multipass-deferred"><a href="#1-5-2-multipass-deferred" class="headerlink" title="1.5.2. multipass deferred"></a>1.5.2. multipass deferred</h4><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Buffers:</span><br>Buffer display<br>Buffer GBuffer <br><br><span class="hljs-comment">//Shaders:</span><br>Shader simpleShader<br>Shader writeShadingAttributes<br><br><span class="hljs-comment">//Visibility &amp; materials</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth &lt; GBuffer.depth<br>       GBuffer = writeShadingAttributes(mesh)<br><br><span class="hljs-comment">//Shading &amp; lighting - Multi-pass</span><br><span class="hljs-keyword">for</span> light in scene<br>    display += simpleShader(GBuffer, light)<br></code></pre></td></tr></table></figure>

<h4 id="1-5-3-singlepass-deferred"><a href="#1-5-3-singlepass-deferred" class="headerlink" title="1.5.3. singlepass deferred"></a>1.5.3. singlepass deferred</h4><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Buffers:</span><br>Buffer display<br>Buffer GBuffer <br><br><span class="hljs-comment">//Shaders:</span><br>Shader manyLightShader<br>Shader writeShadingAttributes<br><br><span class="hljs-comment">//Visibility &amp; materials</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth &lt; GBuffer.depth<br>       GBuffer = writeShadingAttributes(mesh)<br><br><span class="hljs-comment">//Shading &amp; lighting - Single-pass</span><br>display = manyLightShader(GBuffer, scene.lights)<br></code></pre></td></tr></table></figure>

<h4 id="1-5-4-Tiled-based-Shading"><a href="#1-5-4-Tiled-based-Shading" class="headerlink" title="1.5.4. Tiled-based  Shading"></a>1.5.4. Tiled-based  Shading</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569236801768.png" alt="1569236801768"></p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">Buffer display<br>Buffer GBuffer <br>Buffer tileArray<br><br><span class="hljs-comment">//Shaders:</span><br>Shader manyLightShader<br>Shader writeShadingAttributes<br>CompShader lightInTile<br><br><span class="hljs-comment">//Visibility &amp; materials</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth &lt; GBuffer.depth<br>       GBuffer = writeShadingAttributes(mesh)<br><br><span class="hljs-comment">//Light culling</span><br><span class="hljs-keyword">for</span> tile in tileArray<br>   <span class="hljs-keyword">for</span> light in scene<br>      <span class="hljs-keyword">if</span> lightInTile(tile, light)<br>          tile += light<br>      <br><span class="hljs-comment">//Shading</span><br>display = manyLightShader(GBuffer, tileArray)<br></code></pre></td></tr></table></figure>

<h4 id="1-5-5-Clustered-Shading"><a href="#1-5-5-Clustered-Shading" class="headerlink" title="1.5.5. Clustered Shading"></a>1.5.5. Clustered Shading</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569237072424.png" alt="1569237072424"></p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569237086038.png" alt="1569237086038"></p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Buffers:</span><br>Buffer display<br>Buffer GBuffer<br>Buffer clusterArray<br><br><span class="hljs-comment">//Shaders:</span><br>Shader manyLightShader<br>Shader writeShadingAttributes<br>CompShader lightInCluster <br><br><span class="hljs-comment">//Visibility &amp; materials</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth &lt; GBuffer.depth<br>       GBuffer = writeShadingAttributes(mesh)<br><br><span class="hljs-comment">//Light culling</span><br><span class="hljs-keyword">for</span> cluster in clusterArray<br>   <span class="hljs-keyword">for</span> light in scene<br>      <span class="hljs-keyword">if</span> lightIncluster(cluster, light)<br>          cluster += light<br><br><span class="hljs-comment">//Shading</span><br>display = manyLightShader(GBuffer, clusterArray)<br></code></pre></td></tr></table></figure>

<h4 id="1-5-6-效果对比"><a href="#1-5-6-效果对比" class="headerlink" title="1.5.6. 效果对比"></a>1.5.6. 效果对比</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569237135439.png" alt="1569237135439"></p>
<h2 id="2-渲染技术"><a href="#2-渲染技术" class="headerlink" title="2. 渲染技术"></a>2. 渲染技术</h2><h3 id="2-1-基础材质"><a href="#2-1-基础材质" class="headerlink" title="2.1. 基础材质"></a>2.1. 基础材质</h3><table>
<thead>
<tr>
<th align="left"><strong>Property</strong></th>
<th align="left"><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Albedo Map</strong></td>
<td align="left">表示物体颜色，不应该包含任何明暗、AO、阴影信息。除了基础颜色外，还可以包含一些偏色、或者色相的变化。</td>
</tr>
<tr>
<td align="left"><strong>Mask Map</strong></td>
<td align="left">Assign a Texture that packs different Material maps into each of its RGBA channels. • <strong>Red</strong>: Stores the metallic map.  • <strong>Green</strong>: Stores the ambient occlusion map. • <strong>Blue</strong>: Stores the detail mask map. • <strong>Alpha</strong>: Stores the smoothness map.</td>
</tr>
<tr>
<td align="left"><strong>Normal  Map</strong></td>
<td align="left">法线，LitShader支持模型空间和切线空间的法线，使用模型空间法线，可以在LOD当中过度更好，使用切线空间法线，可以压缩纹理空间。</td>
</tr>
<tr>
<td align="left"><strong>Bent Normal</strong></td>
<td align="left">Bent normal实际上也是一个表面方向和Normal接近，主要用来优化AO效果，只对GI（lightmap&#x2F;lightprobe&#x2F;volume proxy）生效。shaer代码：builtinData.bakeDiffuseLighting &#x3D; SampleBakedGI(posInput.positionWS, bennormalWS, texCoord1.xy, texCoord2.xy);</td>
</tr>
<tr>
<td align="left"><strong>Detial Map</strong></td>
<td align="left"><strong>Red</strong>:  Smoothness的细节噪声 <strong>Green</strong>+<strong>Blue</strong>: 细节法线. • <strong>Alpha</strong>: Albede的明暗细节噪声.</td>
</tr>
</tbody></table>
<h3 id="2-2-分层细节材质"><a href="#2-2-分层细节材质" class="headerlink" title="2.2. 分层细节材质"></a>2.2. 分层细节材质</h3><p>用于秒回细致的角色。</p>
<p>1.多加了4&#x2F;8层Detial。</p>
<p>一次DrawCall 刻画精细的材质。</p>
<table>
<thead>
<tr>
<th align="left"><strong>Property</strong></th>
<th align="left"><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Albedo Map</strong></td>
<td align="left">表示物体颜色，不应该包含任何明暗、AO、阴影信息。除了基础颜色外，还可以包含一些偏色、或者色相的变化。</td>
</tr>
<tr>
<td align="left"><strong>Mask Map</strong></td>
<td align="left">• <strong>Red</strong>: Stores the metallic map.  • <strong>Green</strong>: Stores the ambient occlusion map. • <strong>Blue</strong>: Stores the detail mask map. • <strong>Alpha</strong>: Stores the smoothness map.</td>
</tr>
<tr>
<td align="left"><strong>Normal  Map</strong></td>
<td align="left">法线，LitShader支持模型空间和切线空间的法线，使用模型空间法线，可以在LOD当中过度更好，使用切线空间法线，可以压缩纹理空间。</td>
</tr>
<tr>
<td align="left"><strong>Bent Normal</strong></td>
<td align="left">Bent normal实际上也是一个表面方向和Normal接近，主要用来优化AO效果，只对GI（lightmap&#x2F;lightprobe&#x2F;volume proxy）生效。shaer代码：builtinData.bakeDiffuseLighting &#x3D; SampleBakedGI(posInput.positionWS, bennormalWS, texCoord1.xy, texCoord2.xy);</td>
</tr>
<tr>
<td align="left"><strong>Detial Map</strong>0</td>
<td align="left"><strong>Red</strong>:  Smoothness的细节噪声 <strong>Green</strong>+<strong>Blue</strong>: 细节法线. • <strong>Alpha</strong>: Albede的明暗细节噪声.</td>
</tr>
<tr>
<td align="left"><strong>Detial Map</strong>1</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left"><strong>Detial Map</strong>2</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left"><strong>Detial Map</strong>3</td>
<td align="left">…</td>
</tr>
</tbody></table>
<ol start="2">
<li>Mask Map中B通道均分4份，作为4层权重。</li>
</ol>
<h3 id="2-3-分层材质系统"><a href="#2-3-分层材质系统" class="headerlink" title="2.3. 分层材质系统"></a>2.3. 分层材质系统</h3><p>用于处理建筑：基础材质+脏（剥落材质）+ 旧（覆盖材质）+ 表面覆盖（雪，苔藓等）</p>
<p>贴图复用，材质球复用，Mesh合并。</p>
<p>1.参数变成4组。</p>
<table>
<thead>
<tr>
<th align="left"><strong>Property</strong></th>
<th align="left"><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Albedo Map1-4</strong></td>
<td align="left">表示物体颜色，不应该包含任何明暗、AO、阴影信息。除了基础颜色外，还可以包含一些偏色、或者色相的变化。</td>
</tr>
<tr>
<td align="left"><strong>Mask Map1-4</strong></td>
<td align="left">• <strong>Red</strong>: Stores the metallic map.  • <strong>Green</strong>: Stores the ambient occlusion map. • <strong>Blue</strong>:None. • <strong>Alpha</strong>: Stores the smoothness map.</td>
</tr>
<tr>
<td align="left"><strong>Normal  Map1-4</strong></td>
<td align="left">法线，LitShader支持模型空间和切线空间的法线，使用模型空间法线，可以在LOD当中过度更好，使用切线空间法线，可以压缩纹理空间。</td>
</tr>
<tr>
<td align="left">Mask</td>
<td align="left">四个通道对应四层。</td>
</tr>
</tbody></table>
<p>2.混合方式</p>
<p>从上层到下层的覆盖权重，而不是加权求和。</p>
<p>顶点色作为混合基调，Mask作为平铺细节。</p>
<p>材质混合：</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569313963924.png" alt="1569313963924"></p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569313995548.png" alt="1569313995548"></p>
<h3 id="2-4-材质库系统"><a href="#2-4-材质库系统" class="headerlink" title="2.4. 材质库系统"></a>2.4. 材质库系统</h3><p>刺客型条 GCD2017 Texturing the World of Assassin’s Creed Odyssey：</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569314751834.png" alt="1569314751834"></p>
<p>材质使用：</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569314652689.png" alt="1569314652689"></p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569314671739.png" alt="1569314671739"></p>
<h3 id="2-5-特效材质"><a href="#2-5-特效材质" class="headerlink" title="2.5. 特效材质"></a>2.5. 特效材质</h3><p>这里的特效主要指的是附着在模型上的效果：</p>
<ol>
<li><p>对模型产生修改的效果，直接通过宏开关加载模型上.</p>
<p>例如：溶解、顶点动画、透明化、AlphaTest类型的效果。</p>
</li>
<li><p>不会修改模型的效果，另外使用Unlit渲染一次：</p>
<p>例如：身体流光、边缘光、轮廓线、透明特效。</p>
</li>
</ol>
<h3 id="2-6-屏幕空间技术"><a href="#2-6-屏幕空间技术" class="headerlink" title="2.6. 屏幕空间技术"></a>2.6. 屏幕空间技术</h3><h4 id="2-6-1-主要涉及到屏幕空间的Ray-Trace操作。"><a href="#2-6-1-主要涉及到屏幕空间的Ray-Trace操作。" class="headerlink" title="2.6.1. 主要涉及到屏幕空间的Ray Trace操作。"></a>2.6.1. 主要涉及到屏幕空间的Ray Trace操作。</h4><h4 id="2-6-2-Screen-Space-Contact-Shadow"><a href="#2-6-2-Screen-Space-Contact-Shadow" class="headerlink" title="2.6.2. Screen Space Contact Shadow"></a>2.6.2. Screen Space Contact Shadow</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569392407631.png" alt="1569392407631"></p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569392417350.png" alt="1569392417350"></p>
<h4 id="2-6-3-Screen-Space-Reflections"><a href="#2-6-3-Screen-Space-Reflections" class="headerlink" title="2.6.3. Screen Space Reflections"></a>2.6.3. Screen Space Reflections</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569392453534.png" alt="1569392453534"></p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569392487449.png" alt="1569392487449"></p>
<h3 id="2-7-毛发"><a href="#2-7-毛发" class="headerlink" title="2.7. 毛发"></a>2.7. 毛发</h3><h4 id="2-7-1-hairworks-or-TressFX："><a href="#2-7-1-hairworks-or-TressFX：" class="headerlink" title="2.7.1. hairworks or TressFX："></a>2.7.1. hairworks or TressFX：</h4><p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569390840595.png" alt="1569390840595"></p>
<p>神秘海域4头发</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569144795134.png" alt="1569144795134"></p>
<p>怪物猎人世界宠物毛发</p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569144859044.png" alt="1569144859044"></p>
<p>Unity异教徒短片衣服毛领子：</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569144994165.png" alt="1569144994165"></p>
<p>Shell Model</p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569310477528.png" alt="1569310477528"></p>
<h3 id="2-8-灯光方案"><a href="#2-8-灯光方案" class="headerlink" title="2.8. 灯光方案"></a>2.8. 灯光方案</h3><ol>
<li>动态物体：</li>
</ol>
<p>PBR直接光照 + SH 间接光（Reflection Probe） + IBL环境光（Reflection Probe）</p>
<p>直接光照：所有实时光照的直接分量。</p>
<p>SH 间接光（Reflection Probe）：天光 + 实时光的间接分量 + 完整烘焙光直接和间接分量。</p>
<p>点云：记录了六个方向的光线，简化版的SH。</p>
<ol start="2">
<li>静态物体：</li>
</ol>
<p>PBR直接光照 + LightMap间接光计算 + IBL环境光 （Reflection Probe）</p>
<p>LightMap间接光计算 ：天光 + 实时光的间接分量 + 完整烘焙光直接和间接分量。</p>
<h3 id="2-9-阴影方案"><a href="#2-9-阴影方案" class="headerlink" title="2.9. 阴影方案"></a>2.9. 阴影方案</h3><p>动态物体：ShadowMap CSM 2(5,20) + 静态物体：ShadowMask</p>
<p>动态阴影边缘优化：PCF2*2 5*5 7*7 、PCSS</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569209076734.png" alt="1569209076734"></p>
<p>远处动态物体：</p>
<ol>
<li><p>使用第三级CSM，使用代理体阴影。</p>
</li>
<li><p>SDF</p>
</li>
</ol>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569220211656.png" alt="1569220211656"></p>
<h4 id="2-9-1-巫师3的CSM"><a href="#2-9-1-巫师3的CSM" class="headerlink" title="2.9.1. 巫师3的CSM"></a>2.9.1. 巫师3的CSM</h4><p>0级：3米</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569393594256.png" alt="1569393594256"></p>
<p>1级：20米</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569393483587.png" alt="1569393483587"></p>
<p>2级：200米</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569393547484.png" alt="1569393547484"></p>
<p>3级：动态物体无阴影</p>
<h4 id="2-9-2-阴影代理"><a href="#2-9-2-阴影代理" class="headerlink" title="2.9.2. 阴影代理"></a>2.9.2. 阴影代理</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569407455456.png" alt="1569407455456"></p>
<h3 id="2-10-LOD方案"><a href="#2-10-LOD方案" class="headerlink" title="2.10. LOD方案"></a>2.10. LOD方案</h3><p>Mesh Lod :LOD0 - N  + HLOD + IMPOSTER</p>
<p>特效LOD : 削减次要粒子 &gt; 降低粒子数量 &gt; 关闭Alpha Test，简化计算。</p>
<p>Shading LOD ：简化光照模型。</p>
<p>阴影LOD：Shadow Mask</p>
<h3 id="2-11-后处理：曝光与光照设定"><a href="#2-11-后处理：曝光与光照设定" class="headerlink" title="2.11. 后处理：曝光与光照设定"></a>2.11. 后处理：曝光与光照设定</h3><ol>
<li>白平衡场景和灯光设置：</li>
</ol>
<p>基本的资源检查场景，确定ShadingModel、贴图制作、光源方案没有问题。</p>
<p>包括：展览光源+反射球+反射探针。</p>
<ol start="2">
<li>风格化场景和灯光设置：</li>
</ol>
<p>结合后处理的风格化场景：夜晚，白天，洞穴，室内，森林等等，包括少量烘焙、参考资源。</p>
<p>制作标准亮度的cubemap,标准灯光参数，用于检查外包资源的场景。确定在各种环境下显示正常、</p>
<p>包括：展览光源+反射球+反射探针+lightmap+后处理。</p>
<ol start="3">
<li>AssetLibrary资源库。</li>
</ol>
<p>包括了所有资源的展览场景，游戏当中的各种复用场景资源集中排列摆放：树，石头。</p>
<p>游戏当中场景材质集中摆放。</p>
<p>检查所有材质模型合规。检查LOD效果。需要可以切换各个风格化设置。资源之间是否统一。</p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569405739260.png" alt="1569405739260"></p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569405759431.png" alt="1569405759431"></p>
<ol start="4">
<li>游戏场景。</li>
</ol>
<p>地标大型资源的游戏场景，地编从2中选取光照方案，从3中选取资源填充场景。</p>
<p>最终的游戏场景，进行最终游戏性能测试。</p>
<h3 id="2-12-透明物体低分辨率渲染"><a href="#2-12-透明物体低分辨率渲染" class="headerlink" title="2.12. 透明物体低分辨率渲染"></a>2.12. 透明物体低分辨率渲染</h3><p>通过在低分辨率上渲染透明物体直接减低overdraw。通常给烟雾使用。</p>
<h3 id="2-13-后处理：HDR-and-ToneMapping"><a href="#2-13-后处理：HDR-and-ToneMapping" class="headerlink" title="2.13. 后处理：HDR and ToneMapping"></a>2.13. 后处理：HDR and ToneMapping</h3><ol>
<li>渲染层的HDR: HDR和ToneMapping</li>
</ol>
<p>参考GDC2017 High Dynamic Range color grading and display in Frostbite</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1568966737421.png" alt="1568966737421"></p>
<p>Tonemap之前的流程包括暗角，Flare Len，DoF，Bloom，自动曝光参数计算（部分参数用于ToneMaping）.</p>
<p>可以将ToneMap和Grading、Gamma矫正进行合并。</p>
<ol start="2">
<li>显示层的HDR：多ToneMapping曲线</li>
</ol>
<p>如果在LDR和HDR显示器上使用同一个ToneMapping曲线，会导致画面整体变亮。</p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569205929868.png" alt="1569205929868"></p>
<p><strong>FrameBuffer始终是0-1</strong>，（硬件层面，还会转换为1-65535或者1-255），而1对应的值变成了：100nits  200nits 1000nits,所以需要不同的曲线。</p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569204914339.png" alt="1569204914339"></p>
<p>寒霜策略：</p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569205757913.png" alt="1569205757913"></p>
<h3 id="2-14-后处理：TAA"><a href="#2-14-后处理：TAA" class="headerlink" title="2.14. 后处理：TAA"></a>2.14. 后处理：TAA</h3><p>参考：SIGGRAPH2016 Temporal Reprojection AA INSIDE</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/TAACompare.jpg" alt="TAACompare"></p>
<h2 id="3-GPU架构"><a href="#3-GPU架构" class="headerlink" title="3. GPU架构"></a>3. GPU架构</h2><h3 id="3-1-GPU存储架构"><a href="#3-1-GPU存储架构" class="headerlink" title="3.1. GPU存储架构"></a>3.1. GPU存储架构</h3><p>Registers:  [on-chip]5 clocks   </p>
<p>Shared Memory ： [on-chip]50 clocks</p>
<p>Local Memory ：  [logic  on-chip] 100 clocks</p>
<p>Constant Memory ：150 clocks +  conditional Cache.</p>
<p>Global Memory ：150 clocks</p>
<p>Texture Memory ：150 clocks  + Cache + Filter etc.</p>
<p>Host Memory :  Pageable And Pinned. </p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569141565643.png" alt="1569141565643"></p>
<h3 id="3-2-GPU渲染架构"><a href="#3-2-GPU渲染架构" class="headerlink" title="3.2. GPU渲染架构"></a>3.2. GPU渲染架构</h3><h4 id="3-2-1-存储和计算的关系"><a href="#3-2-1-存储和计算的关系" class="headerlink" title="3.2.1. 存储和计算的关系"></a>3.2.1. 存储和计算的关系</h4><p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569140686391.png" alt="1569140686391"></p>
<h4 id="3-2-2-Wrap与Wave-Front"><a href="#3-2-2-Wrap与Wave-Front" class="headerlink" title="3.2.2. Wrap与Wave Front"></a>3.2.2. Wrap与Wave Front</h4><p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569140550632.png" alt="1569140550632"></p>
<p><img src="/../../images/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569140555815.png" alt="1569140555815"></p>
<h3 id="3-3-手游架构"><a href="#3-3-手游架构" class="headerlink" title="3.3. 手游架构"></a>3.3. 手游架构</h3><p>Memory And Tiled Based Rendering</p>
<p>参考：siggraph2016 Best practice for Mobile</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/5aa7a8c2a46f3.png" alt="5aa7a8c2a46f3"></p>
<h2 id="4-程序优化性能关注的点"><a href="#4-程序优化性能关注的点" class="headerlink" title="4. 程序优化性能关注的点"></a>4. 程序优化性能关注的点</h2><h3 id="4-1-Draw-Call"><a href="#4-1-Draw-Call" class="headerlink" title="4.1. Draw Call"></a>4.1. Draw Call</h3><p>略</p>
<h3 id="4-2-Early-z"><a href="#4-2-Early-z" class="headerlink" title="4.2. Early - z"></a>4.2. Early - z</h3><p>原本的深度测试是在Fragment Shader计算之后的，如果不通过深度测试，这部分Pixel计算就是浪费的。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Buffers:</span><br>Buffer display<br>Buffer depthBuffer<br><br><span class="hljs-comment">//Shaders:</span><br>Shader simpleShader<br>Shader writeDepth<br><br><span class="hljs-comment">//Visibility</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth &lt; depthBuffer.depth<br>       depthBuffer = writeDepth(mesh)<br><br><span class="hljs-comment">//Shading and lighting</span><br><span class="hljs-keyword">for</span> mesh in scene<br>    <span class="hljs-keyword">if</span> mesh.depth == depthBuffer.depth<br>        <span class="hljs-keyword">for</span> light in scene<br>            display += simpleShader(mesh, light)<br></code></pre></td></tr></table></figure>

<p>Early-z可以假设PS不修改Depth状态，这样就能将深度测试提前。</p>
<p>Alpha Test会直接导致Early-z失效。也就是无论这个物体有没有被遮挡，一定会发生全部的PS计算。必定产生OverDraw开销，场景中要少用。</p>
<p>大部分引擎的优化策略：<strong>Z-Pre-Pass</strong>和Render Queue Sort。</p>
<p>Unity官方文档的描述：</p>
<p>The fixed-function <a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual//SL-AlphaTest.html">AlphaTest</a> - or its programmable equivalent, <code>clip()</code> - has different performance characteristics on different platforms:</p>
<ul>
<li>Generally you gain a small advantage when using it to remove totally transparent pixels on most platforms.优化了FrameBuffer的读取（Blend）写入，</li>
<li><strong>However, on PowerVR GPUs found in iOS and some Android devices, alpha testing is resource-intensive. Do not try to use it for performance optimization on these platforms, as it causes the game to run slower than usual.与手机架构有关</strong></li>
</ul>
<h3 id="4-3-Over-Draw"><a href="#4-3-Over-Draw" class="headerlink" title="4.3. Over Draw"></a>4.3. Over Draw</h3><p><strong>GPU计算开销主要是<em>warp</em>(或WaveFront或thread，对应一次像素计算（PS）或者一次顶点(VS)计算)的多线程并行计算：需要计算的<em>warp</em>越多开销越高，计算的<em>warp</em>越复杂开销越高。</strong></p>
<p>透明物体，程序可以通过实现，LowResolutionTransparent技术降低大范围覆盖的透明物体的OverDraw。开销分为两部分PS本身的计算和FrameBuffer的写出。</p>
<p>可以制作特效LOD策略降低特效和透明物体的OverDraw。</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569145360889.png" alt="1569145360889"></p>
<h3 id="4-4-Quad-OverDraw"><a href="#4-4-Quad-OverDraw" class="headerlink" title="4.4. Quad OverDraw"></a>4.4. Quad OverDraw</h3><p>warp以2*2形式提交计算，三角形边界有无效计算，三角形越小，无效计算比例越高。PS当中一般需要每个三角形有10个像素的占用。</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569145282601.png" alt="1569145282601"></p>
<h3 id="4-5-Light"><a href="#4-5-Light" class="headerlink" title="4.5. Light"></a>4.5. Light</h3><p>光照需要合理分布，Deferred阶段的灯光影响区域的重叠是变相的OverDraw（非Tiled和Clustered）：</p>
<p><img src="/../../images/%5B%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB%5D%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/1569145437672.png" alt="1569145437672"></p>
<h3 id="4-6-Vertex-Count"><a href="#4-6-Vertex-Count" class="headerlink" title="4.6. Vertex Count"></a>4.6. Vertex Count</h3><p>同一个模型顶点数过多-&gt;三角面增多-&gt;Quad OverDraw增加。</p>
<p>曲面细分在顶点带来的开销意外 还有大量的Quad OverDraw的开销。</p>
<h3 id="4-7-Texture压缩与内存优化"><a href="#4-7-Texture压缩与内存优化" class="headerlink" title="4.7. Texture压缩与内存优化"></a>4.7. Texture压缩与内存优化</h3><p>纹理是内存当中最主要的的资源，需要合理的进行Tiling和Packing策略，提升利用率。</p>
<h3 id="4-8-Baking"><a href="#4-8-Baking" class="headerlink" title="4.8. Baking"></a>4.8. Baking</h3><p>烘焙唯一的性能影响就是Lighmap的内存占用。必须要合理调节渲染参数。通常需要用一米面积多少个texel的限制。每个模型都需要具体调整。</p>
<h3 id="4-9-MipMap"><a href="#4-9-MipMap" class="headerlink" title="4.9. MipMap"></a>4.9. MipMap</h3><p>重要的远处物体反走样，提升效果的特性。但是内存占用会升高。</p>
<h3 id="4-10-Testure-Streaming"><a href="#4-10-Testure-Streaming" class="headerlink" title="4.10. Testure Streaming"></a>4.10. Testure Streaming</h3><p>解决Mipmap内存占用的问题。</p>
<h3 id="4-11-Shader预加载"><a href="#4-11-Shader预加载" class="headerlink" title="4.11. Shader预加载"></a>4.11. Shader预加载</h3><p>如果场景中Shader变体过多，需要考虑Shader的预加载。</p>
<h3 id="4-12-Shader分支"><a href="#4-12-Shader分支" class="headerlink" title="4.12. Shader分支"></a>4.12. Shader分支</h3><p>通常需要切换渲染效果：切换方式有3种：</p>
<ol>
<li>宏：</li>
</ol>
<p>通过#define关键字可以定义Shader的表现。不能游戏时切换，主要用来测试和调试，或者多平台兼容。</p>
<ol start="2">
<li>变体：</li>
</ol>
<p>通过Shader的变体宏控制分支开关，缺点是会生成大量变体。</p>
<ol start="3">
<li>if else 分支语句切换：</li>
</ol>
<p>如果没有合理使用可能导致性能降低，但是通常可以提升性能并且降低变体数量。</p>
<h2 id="5-美术资源可能带来的性能问题"><a href="#5-美术资源可能带来的性能问题" class="headerlink" title="5. 美术资源可能带来的性能问题"></a>5. 美术资源可能带来的性能问题</h2><ol>
<li>游戏内存： 场景当中要绘制的所有东西都需要保存到内存中，其中最重要的就是：<strong>模型、贴图</strong>。</li>
<li>drawcall：每绘制一种东西（不同的模型：即使是相同的材质球也算不同的模型，除非合并他们的mesh），<strong>内存都需要把相关的渲染参数、模型数据、贴图数据传递到GPU</strong>，这个速度非常慢，所以看到的模型越多，drawcall越多。</li>
<li>GPU渲染速度：模型的材质越复杂，渲染越慢。这个靠TA来制定标准即可。</li>
</ol>
<p>对应的美术资源优化主要有个以下方面：</p>
<ol>
<li>模型拆分，模型组件复用：美术制作场景时，复用模型资源进行摆放。<strong>只是为了提升工作效率，拆分之后还是需要尽可能使用相同材质，最终还是要合并。</strong></li>
<li>贴图Tiling，贴图复用：能够直接降低内存开销。<strong>为了效果可以使用更少、分辨率更高的贴图。</strong></li>
<li>材质复用：不同的模型使用同一个材质球（必须是同一个材质球，而不是不同的材质球同一个参数。）<strong>材质复用的目的，是最终要合并网格以减少drawcall，如果不合并那么材质复用就没有意义。</strong> <strong>Dynamic Batch</strong> 就是这个原理，但是他会在内存生成一份合并后的mesh，相当于内存占用翻倍，浪费内存。<strong>Static Batch</strong>也是一样，只不过是静态合并好。但是合并的物体覆盖全场景。还会导致遮挡剔除失效，同样占内存。</li>
<li>Prefab、Model复用（包括组件的Prefab，完整模型的Prefab）：直接提升资源利用率。这种服用就是一模一样的mesh和材质，可以直接合并。</li>
</ol>
<h3 id="5-1-游戏性能瓶颈：模型"><a href="#5-1-游戏性能瓶颈：模型" class="headerlink" title="5.1. 游戏性能瓶颈：模型"></a>5.1. 游戏性能瓶颈：模型</h3><p>由于场景资源复杂，可能遇到的性能瓶颈：</p>
<ol>
<li>模型数量：模型数量越多（ 一个submesh算一个模型 ）drawcall越多，成正比。</li>
<li>一个模型的面数：模型越大，越占内存。（不使用static batch的原因）。</li>
<li>模型属性太多（比如各个uv通道全部使用，normal、tangent全部使用）：属性使用的越多，越占内存。</li>
</ol>
<p><strong>模型的内存开销&#x3D;模型数量 * 一个模型的面数 * 模型属性</strong></p>
<p><strong>模型的drawcall 开销&#x3D; 场景中的模型数量。</strong></p>
<h3 id="5-2-游戏性能优化：模型"><a href="#5-2-游戏性能优化：模型" class="headerlink" title="5.2. 游戏性能优化：模型"></a>5.2. 游戏性能优化：模型</h3><ol>
<li>美术在3Dmax当中合并不同的mesh。（相同材质的合并，通过合理分布uv可以让大部分mesh复用同一个材质）。<strong>能够在模型总内存消耗不变的情况下降低drawcall。</strong></li>
<li>如果材质的属性不使用，就不要输出，例如：第二套uv，顶点色，切线信息。<strong>直接降低内存开销。</strong></li>
<li>控制模型面数，场景当中看不到的面裁切掉。<strong>直接降低内存开销。</strong></li>
</ol>
<h3 id="5-3-游戏性能瓶颈：贴图"><a href="#5-3-游戏性能瓶颈：贴图" class="headerlink" title="5.3. 游戏性能瓶颈：贴图"></a>5.3. 游戏性能瓶颈：贴图</h3><ol>
<li><strong>场景中涉及到的</strong>贴图数量越多，内存占用越大。（例如：一张1024*1024的三通道贴图，相当于一个100万点的只记录了顶点位置的模型，相当于10万顶点并记录了顶点色的模型），美术需要考虑模型和贴图之间的平衡。</li>
<li><strong>场景中涉及到的</strong>贴图越大，内存占用越多。</li>
<li><strong>场景中涉及到的</strong>贴图开启mipmap占用内存越多。</li>
<li>如果贴图不在场景中，那他就只是占用硬盘而已。</li>
</ol>
<p><strong>贴图内存开销&#x3D; 贴图数量 * 贴图大小。</strong></p>
<p><strong>贴图drawcall开销 &#x3D; 基本只和内存有关。</strong></p>
<p>*<strong>注：</strong>“场景当中涉及到的”指的是客户端从硬盘加载到内存的场景数据。</p>
<h3 id="5-4-游戏性能优化：贴图"><a href="#5-4-游戏性能优化：贴图" class="headerlink" title="5.4. 游戏性能优化：贴图"></a>5.4. 游戏性能优化：贴图</h3><p><strong>贴图内存开销&#x3D; 贴图数量 * 贴图大小。</strong></p>
<ol>
<li>使用Tiling方式的贴图。<strong>减小贴图大小。</strong></li>
<li>提高利用率。<strong>减少贴图数量。</strong></li>
<li>LightMap 一般会很占用内存，需要合理调整大小，和烘焙参数。</li>
</ol>
<h3 id="5-5-游戏性能瓶颈：材质"><a href="#5-5-游戏性能瓶颈：材质" class="headerlink" title="5.5. 游戏性能瓶颈：材质"></a>5.5. 游戏性能瓶颈：材质</h3><ol>
<li><strong>场景中涉及到的材质</strong>数量越多drawcall越多。</li>
<li><strong>场景中涉及到的材质</strong>使用的贴图越多占用内存越多。</li>
</ol>
<p>材质内存开销 &#x3D;  几乎不考虑。</p>
<p>材质drawcall开销&#x3D; 主要看mesh，因为如果同一个mesh 使用不同的材质，那么drawcall还是两个。</p>
<p><strong>材质复用的真正目的是为了能够合并场景中使用相同材质的mesh。以直接减少drawcall。</strong></p>
<h3 id="5-6-游戏性能优化：材质"><a href="#5-6-游戏性能优化：材质" class="headerlink" title="5.6. 游戏性能优化：材质"></a>5.6. 游戏性能优化：材质</h3><p><strong>材质复用的真正目的：为了能够合并场景中使用相同材质的mesh，以直接减少drawcall。</strong></p>
<ol>
<li><strong>使用相同的材质 + 不同的mesh</strong> 的策略来实现丰富的表现，方便合并。例如：用刷顶点色，代替mask贴图。</li>
<li>材质复用优先于mesh复用：如果mesh复用，而使用了不同的材质，那么drawcall不能再减少了。如果复用了材质（同一个材质球），而使用了不同的mesh，那么有很多方法来合并mesh以减少drawcall。</li>
</ol>
<h3 id="5-7-游戏性能瓶颈：Quad-OverDraw-、OverDraw"><a href="#5-7-游戏性能瓶颈：Quad-OverDraw-、OverDraw" class="headerlink" title="5.7. 游戏性能瓶颈：Quad OverDraw 、OverDraw"></a>5.7. 游戏性能瓶颈：Quad OverDraw 、OverDraw</h3><p><strong>GPU计算开销主要是<em>warp</em>(或WaveFront或thread，对应一次像素计算（PS）或者一次顶点(VS)计算)的多线程并行计算：需要计算的<em>warp</em>越多开销越高，计算的<em>warp</em>越复杂开销越高。</strong></p>
<p>在渲染管线当中主要是VS阶段计算（和顶点数相关）和PS阶段的计算（和物体覆盖像素有关）。其中PS开销最高。也就是说物体占用的像素越多，开销越高。</p>
<p>OverDraw：</p>
<p>​	1.可见透明物体，所有未遮挡像素都会计算。多层透明物体重叠，会导致PS阶段需要计算的Warp数提升。</p>
<p>​	2.Alpha Test物体：无论是否被遮挡，Early-Z完全失效，导致PS阶段计算的Warp数提升。</p>
<ol start="3">
<li>后处理：每一个后处理相当于全屏每个像素计算一次。</li>
</ol>
<p>Quad OverDraw：</p>
<p>​	PS阶段Warp实际上以2*2为单位计算，也就是说三角形的渲染边界会有很多无效的像素被计算。</p>
<ol>
<li>狭长三角形，对像素利用率过低。</li>
<li>距离过远的三角形，如果缩成一个像素点，开销为实际需要的4倍，如果占据8个限速点，大概为实际需要的2倍。</li>
</ol>
<h3 id="5-8-游戏性能优化：Quad-OverDraw-、OverDraw"><a href="#5-8-游戏性能优化：Quad-OverDraw-、OverDraw" class="headerlink" title="5.8. 游戏性能优化：Quad OverDraw 、OverDraw"></a>5.8. 游戏性能优化：Quad OverDraw 、OverDraw</h3><p>OverDraw：</p>
<ol>
<li>用更细化的网格秒回透明物体、或者AlphaTest物体。</li>
<li>场景中少用AlphaTest ：例如：蜘蛛网用AlphaBlend。铁丝网少用。</li>
<li>对后处理进行合并计算，去除不必要的后处理。</li>
</ol>
<p>Quad OverDarw</p>
<ol>
<li>美术布线避免使用狭长三角形。</li>
<li>使用LOD，保证每一个三角形的像素占用率。</li>
</ol>

      
      <p align="right"><a class="morebtn" href="/2022/09/19/RTR/%E4%B8%BB%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A6%81/" title="">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/09/19/RTR/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/09/19/RTR/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/" itemprop="url"></a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-09-19T19:53:33+08:00">2022-09-19 19:53:33</time></span>
        </span>
        
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="不同图形API剪裁空间说明"><a href="#不同图形API剪裁空间说明" class="headerlink" title="不同图形API剪裁空间说明"></a>不同图形API剪裁空间说明</h1><h2 id="D3D剪裁空间"><a href="#D3D剪裁空间" class="headerlink" title="D3D剪裁空间"></a>D3D剪裁空间</h2><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/dxtecharts/the-direct3d-transformation-pipeline">官方链接</a></p>
<p>整体流程：</p>
<p><img src="/../../images/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/d3dxfrm61.gif" alt="model space to screen space transformation"></p>
<p>剪裁空间的矩阵是将摄像机空间的坐标转换到裁剪空间。剪裁空间矩阵最后一列最好是(0, 0, 1, 0)。</p>
<p>原文解释：The last column of the projection matrix should be (0, 0, 1, 0), or (0, 0, a, 0) for correct fog and lighting effects; (0, 0, 1, 0) form is preferred.</p>
<p>剪裁空间的坐标： (Xp, Yp, Zp, Wp)  ，剪裁的原则是：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">-Wp &lt; Xp &lt;= Wp <br>  -Wp &lt; Yp &lt;= Wp <br>  <span class="hljs-number">0</span> &lt; Zp &lt;= Wp <br></code></pre></td></tr></table></figure>

<p>所有不满足上面的点都会被剪裁。</p>
<p>假设摄像机空间的坐标满足：</p>
<p>Sw - 近剪裁平面屏幕宽度</p>
<p>Sh - 近剪裁平面屏幕高度</p>
<p>Zn - 近剪裁平面距离</p>
<p>Zf -  远剪裁平面距离</p>
<p><img src="/../../images/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/1575083272973.png" alt="1575083272973"></p>
<p>透视投影矩阵如下：</p>
<p><img src="/../../images/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/d3dxfrm62.gif" alt="perspective projection matrix"></p>
<p>Direct3D假设投影矩阵满足下面的形式，如果不满足会有一些不自然效果：</p>
<p><img src="/../../images/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/d3dxfrm64.gif" alt="perspective projection matrix"></p>
<p>Direct3D允许修改剪裁体以达到更高的精确度，这部分实际上就是对Proj空间进行变换得到Clip空间，实际上Proj就是Clip：</p>
<p><img src="/../../images/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/d3dxfrm67.gif" alt="mclip matrix"></p>
<p>默认参数：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">dvClipWidth = <span class="hljs-number">2</span>   <br>dvClipHeight = <span class="hljs-number">2</span>   <br>dvClipX = <span class="hljs-number">-1</span>   <br>dvClipY = <span class="hljs-number">1</span>   <br>dvMinZ = <span class="hljs-number">0</span>   <br>dvMaxZ = <span class="hljs-number">1</span>   <br></code></pre></td></tr></table></figure>

<p>从投影到剪裁空间：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(Xc, Yc, Zc, Wc) = (Xp, Yp, Zp, Wp) * Mclip<br></code></pre></td></tr></table></figure>

<p>视口缩放矩阵会把坐标缩放到窗口坐标中，并且把Y轴上下翻转。</p>
<p><img src="/../../images/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/d3dxfrm68.gif" alt="viewport scale matrix mvs"></p>
<p> dwX, dwY - 视口的像素偏移。</p>
<p> dwWidth, dwHeight视口的像素宽高。</p>
<p>最终的屏幕坐标是：</p>
<p><img src="/../../images/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/d3dxfrm69.gif" alt="screen coordinates computed and passed to the rasterizer"></p>
<p>注意：在D3D当中PS的输入语义SV_POSITION是屏幕坐标。而输出语义SV_POSITION的投影空间对应Glsl的<strong>gl_FragCoord</strong>。而Unity当中的SV_Position就是VS的输出。</p>
<h2 id="OpengGL"><a href="#OpengGL" class="headerlink" title="OpengGL"></a>OpengGL</h2><p><a target="_blank" rel="noopener" href="https://learnopengl.com/Getting-started/Coordinate-Systems">官方文档</a></p>
<p>OpenGl是投影空间提供剪裁范围：The projection matrix maps a given frustum range to clip space, but also manipulates the <code>w</code> value of each vertex coordinate in such a way that the further away a vertex coordinate is from the viewer, the higher this <code>w</code> component becomes.</p>
<p>越远w的值越大。剪裁范围是-w 和w之间,z坐标和D3D是有区别的 :Once the coordinates are transformed to clip space they are in the range <code>-w</code> to <code>w</code> (anything outside this range is clipped). </p>
<p>OpenGL requires that the visible coordinates fall between the range <code>-1.0</code> and <code>1.0</code> as the final vertex shader output, thus once the coordinates are in clip space, perspective division is applied to the clip space coordinates:</p>
<p>剪裁之后的结果进行透视除法。</p>
<p><img src="/../../images/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/1575085853893.png" alt="1575085853893"></p>

      
      <p align="right"><a class="morebtn" href="/2022/09/19/RTR/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2API%E5%89%AA%E8%A3%81%E7%A9%BA%E9%97%B4%E8%AF%B4%E6%98%8E/" title="">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/09/19/RTR/TAA/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/09/19/RTR/TAA/" itemprop="url"></a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-09-19T19:53:33+08:00">2022-09-19 19:53:33</time></span>
        </span>
        
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="Temporal-Anti-Aliasing"><a href="#Temporal-Anti-Aliasing" class="headerlink" title="Temporal Anti-Aliasing"></a>Temporal Anti-Aliasing</h1><p>这里主要根据论文和Unity HDRP的TAA算法进行简单的分析。</p>
<p>资料主要参考的是 <strong>2016 Temporal Reprojection AA INSIDE</strong>.</p>
<p>源代码主要来自Unity的两个shader文件：</p>
<p>TemporalAntiliasing.hlsl和TemporalAntialising.compute.</p>
<p>下面是TAA在INSIDE当中的效果比较：</p>
<p><img src="/../../images/img/TAACompare.jpg" alt="TAACompare"></p>
<h2 id="基础思路"><a href="#基础思路" class="headerlink" title="基础思路"></a>基础思路</h2><p>下面是TAA依赖的一些基本思路：</p>
<ol>
<li>一个表面的局部区域可能在视口当中存在很多帧。</li>
<li>观察者和物体的位置在变，光栅化结果也在变化。</li>
<li>如果能够向前获取一段时间的变化，那么可以根据变化调整当前帧的光栅化结果。</li>
</ol>
<p>记录之前的变化：</p>
<ol>
<li>为了根据之前几帧的结果调整当前帧。</li>
<li>能够通过reprojection获得之前的变化：依赖于深度，局限在最新写入的几帧。</li>
<li>有时会获取不到之前的结果（前几帧没有出现过）。</li>
</ol>
<h2 id="unity算法步骤"><a href="#unity算法步骤" class="headerlink" title="unity算法步骤"></a>unity算法步骤</h2><h3 id="Step1：Jitter"><a href="#Step1：Jitter" class="headerlink" title="Step1：Jitter"></a>Step1：Jitter</h3><p>在TAA算法当中，Jitter的作用实际上就是<strong>采样屏幕颜色的时候</strong>，对纹理坐标做一个offset。使得：实际采样的位置在目标位置附近伴随时间随机的变化。</p>
<p>在很多地方Jitter的这个offset使用了：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Halton_sequence">Halton Sequence</a>。</p>
<p>下面是一维度Halton Sequence的伪代码：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> <span class="hljs-title function_">HS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> b)</span> :<br>	<span class="hljs-type">float</span> f = <span class="hljs-number">1</span><br>    <span class="hljs-type">float</span> r = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">do</span><br>        f = f/b<br>        r = r + f * (i mod b)<br>        i = <span class="hljs-built_in">floor</span>(i/b)<br>    <span class="hljs-keyword">return</span> r<br>    <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">HS(1,2) = 1 / 2  HS(2,2) = 1 / 4  HS(3,2) = 3 / 4  ...</span><br><span class="hljs-comment">HS(1,3) = 1 / 3  HS(2,3) = 2 / 3  HS(3,3) = 1 / 9  ...</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>



<p>下面是2维Halton的分布：</p>
<p><img src="/../../images/img/halton.jpg" alt="halton"></p>
<p>上面的点集为：</p>
<p>(HS(1,2), HS(1,3) )   ，(HS(2,2), HS(2,3) )，(HS(3,2), HS(3,3) )，(HS(4,2), HS(4,3) )..</p>
<p>unity计算jitter的源代码，可以看出jitter如何被使用,TemporalAntialising.compute：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">...   <br>jitter = _TaaJitterStrength.zw;<br>...<br><span class="hljs-comment">// 这里是Unjitter,去掉了jitter，positionNDC是jitter</span><br>uv = posInputs.positionNDC - jitter;<br>color = Fetch(_InputTexture, uv, <span class="hljs-number">0.0</span>, _ScreenToTargetScale.xy);<br>...<br></code></pre></td></tr></table></figure>

<p>_TaaJitterStrength在C#代码中的设置位置，HDCamera.cs:</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>cmd.SetGlobalVector(HDShaderIDs._TaaJitterStrength,         taaJitter);<br>...<br></code></pre></td></tr></table></figure>

<p>计算方式，HDCamera.cs:</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br><span class="hljs-type">float</span> jitterX = HaltonSequence.Get((taaFrameIndex &amp; <span class="hljs-number">1023</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) - <span class="hljs-number">0.5f</span>;<br><span class="hljs-type">float</span> jitterY = HaltonSequence.Get((taaFrameIndex &amp; <span class="hljs-number">1023</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">3</span>) - <span class="hljs-number">0.5f</span>;<br>taaJitter = new Vector4(jitterX, jitterY, jitterX / camera.pixelWidth, jitterY / camera.pixelHeight);<br>...<br></code></pre></td></tr></table></figure>

<p>上面内容都属于HDCamera当中的一个重要的方法，就是：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c">Matrix4x4 <span class="hljs-title function_">GetJitteredProjectionMatrix</span><span class="hljs-params">(Matrix4x4 origProj)</span><br>&#123;<br>    <span class="hljs-type">float</span> jitterX = HaltonSequence.Get((taaFrameIndex &amp; <span class="hljs-number">1023</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) - <span class="hljs-number">0.5f</span>;<br>    <span class="hljs-type">float</span> jitterY = HaltonSequence.Get((taaFrameIndex &amp; <span class="hljs-number">1023</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">3</span>) - <span class="hljs-number">0.5f</span>;<br>    taaJitter = new Vector4(jitterX, jitterY, jitterX / camera.pixelWidth, jitterY / camera.pixelHeight);<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> kMaxSampleCount = <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">// taaFrameIndex 只在这里更新，kMaxSampleCount是8.</span><br>    <span class="hljs-keyword">if</span> (++taaFrameIndex &gt;= kMaxSampleCount)<br>        taaFrameIndex = <span class="hljs-number">0</span>;<br><br>    Matrix4x4 proj;<br><br>    <span class="hljs-keyword">if</span> (camera.orthographic)<br>    &#123;<br>        ...<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 得到多个分离的剪裁平面</span><br>        var planes = origProj.decomposeProjection;<br>		<br>        <span class="hljs-comment">// 计算观察范围</span><br>        <span class="hljs-type">float</span> vertFov = Math.Abs(planes.top) + Math.Abs(planes.bottom);<br>        <span class="hljs-type">float</span> horizFov = Math.Abs(planes.left) + Math.Abs(planes.right);<br>		<br>        <span class="hljs-comment">// 按比例缩放</span><br>        var planeJitter = new Vector2(jitterX * horizFov / camera.pixelWidth,<br>                                      jitterY * vertFov / camera.pixelHeight);<br>	<br>        <span class="hljs-comment">// 抖动平移整个视锥体</span><br>        planes.left += planeJitter.x;<br>        planes.right += planeJitter.x;<br>        planes.top += planeJitter.y;<br>        planes.bottom += planeJitter.y;<br>		<span class="hljs-comment">// 还原成投影矩阵</span><br>        proj = Matrix4x4.Frustum(planes);<br>    &#125;<br>    <span class="hljs-keyword">return</span> proj;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Matrix4x4.Frustum(planes)：</span><br><span class="hljs-comment">下面查看这个函数意义：</span><br><span class="hljs-comment">https://docs.unity3d.com/ScriptReference/Matrix4x4.Frustum.html</span><br><span class="hljs-comment">The coordinate of the near projection plane in view space.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p><strong>上面的方法主要是通过抖动近剪裁面来实现对整个视锥体的抖动。</strong></p>
<p>唯一对他的调用是下面的方法，这个方法主要用来更新摄像机的： </p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">internal <span class="hljs-type">void</span> <span class="hljs-title function_">UpdateViewConstants</span><span class="hljs-params">(<span class="hljs-type">bool</span> jitterProjectionMatrix)</span><br>&#123;<br>    <span class="hljs-comment">// If TAA is enabled projMatrix will hold a jittered projection matrix. The original,</span><br>    <span class="hljs-comment">// non-jittered projection matrix can be accessed via nonJitteredProjMatrix.</span><br>    var nonJitteredCameraProj = camera.projectionMatrix;<br>    var cameraProj = jitterProjectionMatrix<br>        ? GetJitteredProjectionMatrix(nonJitteredCameraProj)<br>        : nonJitteredCameraProj;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>制作后处理的时候关闭,HDRenderPipeline.cs:</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">using (new ProfilingSample(cmd, <span class="hljs-string">&quot;After Post-process&quot;</span>, CustomSamplerId.AfterPostProcessing.GetSampler()))<br>&#123;<br>    <span class="hljs-comment">// Note about AfterPostProcess and TAA:</span><br>    <span class="hljs-comment">// When TAA is enabled rendering is jittered and then resolved during the post processing pass.</span><br>    <span class="hljs-comment">// It means that any rendering done after post processing need to disable jittering. This is what we do with hdCamera.UpdateViewConstants(false);</span><br>    <span class="hljs-comment">// The issue is that the only available depth buffer is jittered so pixels would wobble around depth tested edges.</span><br>    <span class="hljs-comment">// In order to avoid that we decide that objects rendered after Post processes while TAA is active will not benefit from the depth buffer so we disable it.</span><br>    <span class="hljs-type">bool</span> taaEnabled = hdCamera.IsTAAEnabled();<br>    hdCamera.UpdateViewConstants(<span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>绘制物体的时候开启,HDCamera.cs:</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Pass all the systems that may want to update per-camera data here.</span><br><span class="hljs-comment">// That way you will never update an HDCamera and forget to update the dependent system.</span><br>public <span class="hljs-type">void</span> <span class="hljs-title function_">Update</span><span class="hljs-params">(FrameSettings currentFrameSettings, VolumetricLightingSystem vlSys, MSAASamples msaaSamples)</span><br>&#123;<br>    UpdateViewConstants(IsTAAEnabled());<br></code></pre></td></tr></table></figure>

<p>到此为止Jitter步骤结束，总结如下：</p>
<p><img src="/../../images/img/step1jitter.jpg" alt="step1jitter"></p>
<h3 id="Step2：-ReProjection"><a href="#Step2：-ReProjection" class="headerlink" title="Step2： ReProjection"></a>Step2： ReProjection</h3><p>Reprojection就是讲当前jitter的点还原到历史点的位置。</p>
<h4 id="动态场景历史点还原"><a href="#动态场景历史点还原" class="headerlink" title="动态场景历史点还原"></a>动态场景历史点还原</h4><p>示意图如下：</p>
<p>首先获取到了当前帧当前点的屏幕uv。</p>
<p><img src="/../../images/img/preprojection1.jpg" alt="preprojection1"></p>
<p>在视锥体中的示意图：</p>
<p><img src="/../../images/img/preprojection2.jpg" alt="preprojection2"></p>
<p>然后通过当前帧当前点的深度图还原其世界坐标：</p>
<p><img src="/../../images/img/preprojection3.jpg" alt="preprojection3"></p>
<p>然后通过记录的上一个摄像机机位的变换矩阵，还原当前点在上一帧的所在屏幕位置。</p>
<p><img src="/../../images/img/preprojection4.jpg" alt="preprojection4"></p>
<p>然后就可以在上一帧的colorbuffer采样上一帧的颜色：</p>
<p><img src="/../../images/img/preprojection5.jpg" alt="preprojection5"></p>
<h4 id="动态场景历史点还原-1"><a href="#动态场景历史点还原-1" class="headerlink" title="动态场景历史点还原"></a>动态场景历史点还原</h4><p>动态物体可以渲染velocity buffer，记录了其在屏幕上移动的向量：</p>
<p>通过减去速度可以恢复到上一帧的位置：</p>
<p><img src="/../../images/img/preprojection6.jpg" alt="preprojection6"></p>
<p><strong>VelocityBuffer一般是先通过摄像机运动计算场景中静态物体的运动速度，然后在上面继续绘制动态物体的运动速度</strong></p>
<p>Unity读取历史信息的代码：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>float2 motionVector;<br>DecodeMotionVector(LOAD_TEXTURE2D_X(_CameraMotionVectorsTexture, closest), motionVector);<br>float3 history = Fetch(_InputHistoryTexture, posInputs.positionNDC - motionVector, <span class="hljs-number">0.0</span>, _ScreenToTargetScaleHistory.xy);<br>...<br></code></pre></td></tr></table></figure>

<p><strong>上面可以看出unity的TAA依赖于VelocityBuffer的绘制。</strong></p>
<h3 id="Step3-Revisiting"><a href="#Step3-Revisiting" class="headerlink" title="Step3:  Revisiting"></a>Step3:  Revisiting</h3><p>上一步当中我们已经读取到了历史信息位置，那么现在就需要在历史纹理当中读取信息并且用于计算。</p>
<p><img src="/../../images/img/Revisiting1.jpg" alt="Revisiting1"></p>
<p>首先需要解决的是历史信息不正确的状态。</p>
<p>通过当前像素来控制历史信息的最大最小值，下面是Unity的做法:</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">...<br>float2 uv = posInputs.positionNDC - jitter;<br><br> float3 color = Fetch(_InputTexture, uv, 0.0, _ScreenToTargetScale.xy);<br> float3 history = Fetch(_InputHistoryTexture, posInputs.positionNDC - motionVector, 0.0, _ScreenToTargetScaleHistory.xy);<br><br> float3 topLeft = Fetch(_InputTexture, uv, -RADIUS, _ScreenToTargetScale.xy);<br> float3 bottomRight = Fetch(_InputTexture, uv, RADIUS, _ScreenToTargetScale.xy);<br><br> float3 corners = 4.0 * (topLeft + bottomRight) - 2.0 * color;<br><br> // Sharpen output<br> #if SHARPEN<br> float3 topRight = Fetch(_InputTexture, uv, float2(RADIUS, -RADIUS), _ScreenToTargetScale.xy);<br> float3 bottomLeft = Fetch(_InputTexture, uv, float2(-RADIUS, RADIUS), _ScreenToTargetScale.xy);<br> float3 blur = (topLeft + topRight + bottomLeft + bottomRight) * 0.25;<br> color += (color - blur) * SHARPEN_STRENGTH;<br> #endif<br> <br> color = clamp(color, 0.0, CLAMP_MAX);<br><br> float3 average = Map((corners + color) / 7.0);<br><br> topLeft = Map(topLeft);<br> bottomRight = Map(bottomRight);<br> color = Map(color);<br><br> float colorLuma = Luminance(color);<br> float averageLuma = Luminance(average);<br> float nudge = lerp(4.0, 0.25, saturate(motionVecLength * 100.0)) * abs(averageLuma - colorLuma);<br><br> float3 minimum = min(bottomRight, topLeft) - nudge;<br> float3 maximum = max(topLeft, bottomRight) + nudge;<br><br> history = Map(history);<br><br> // Clip history samples<br> #if CLIP_AABB<br> history = ClipToAABB(history, minimum, maximum);<br> #else<br> history = clamp(history, minimum, maximum);<br> #endif<br> ...<br></code></pre></td></tr></table></figure>

<p>下面进行TAA的核心操作：</p>
<p><img src="/../../images/img/Revisiting2.jpg" alt="Revisiting2"></p>
<p>进行颜色混合：<strong>经过约束的历史颜色和没有抖动的当前颜色</strong></p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">c_hist = ...<span class="hljs-comment">//constrained history sample</span><br>c_in = sample(buf_color, unjitter_uv);<br>c_feedback = lerp(c_in, c_hist, k_feedback);<br></code></pre></td></tr></table></figure>

<p>保留当前结果作为历史，并输出当前结果：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">rt_history = c_feedback<br>rt_output = rt_history<br></code></pre></td></tr></table></figure>

<p>k_feedback可以调整效果。</p>
<p>Unity 中的TAA是自动的来计算feedback值，TemporalAntialiasing.compute:</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br><span class="hljs-type">float</span> historyLuma = Luminance(history);<br><span class="hljs-type">float</span> diff = <span class="hljs-built_in">abs</span>(colorLuma - historyLuma) / Max3(colorLuma, historyLuma, <span class="hljs-number">0.2</span>);<br><span class="hljs-type">float</span> weight = <span class="hljs-number">1.0</span> - diff;<br><span class="hljs-type">float</span> feedback = lerp(FEEDBACK_MIN, FEEDBACK_MAX, weight * weight);<br>...<br></code></pre></td></tr></table></figure>

<p>Unity在计算之后，还会再次Clamp颜色：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>color = Unmap(lerp(color, history, feedback));<br>color = clamp(color, <span class="hljs-number">0.0</span>, CLAMP_MAX);<br>...<br></code></pre></td></tr></table></figure>

<p>然后是结果输出：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>_OutputTexture[COORD_TEXTURE2D_X(posInputs.positionSS)] = float4(color.xyz, <span class="hljs-number">1.0</span>);<br>_OutputHistoryTexture[COORD_TEXTURE2D_X(posInputs.positionSS)] = float4(color.xyz, <span class="hljs-number">1.0</span>);<br>...<br></code></pre></td></tr></table></figure>

<p>到此为止TAA就结束了，不过还可以加入MotionBlur，Unity没有加到TAA步骤当中，这个打算之后在研究。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <strong>2016 Temporal Reprojection AA INSIDE</strong>.</p>
<p>[2] Unity HDRP TAA 源代码：TemporalAntialising.compute.</p>

      
      <p align="right"><a class="morebtn" href="/2022/09/19/RTR/TAA/" title="">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/09/19/RTR/LOD%E7%AD%96%E7%95%A5/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/09/19/RTR/LOD%E7%AD%96%E7%95%A5/" itemprop="url"></a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-09-19T19:53:33+08:00">2022-09-19 19:53:33</time></span>
        </span>
        
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="LOD策略"><a href="#LOD策略" class="headerlink" title="LOD策略"></a>LOD策略</h1><h2 id="LOD常见策略"><a href="#LOD常见策略" class="headerlink" title="LOD常见策略"></a>LOD常见策略</h2><p>在计算LOD过程中，需要根据不同的策略切换模型的LOD级别，常见的策略：</p>
<ol>
<li>根据距离。</li>
<li>根据屏占比：Sphere和AABB</li>
</ol>
<p>根据距离的方式会导致远处的城堡用很低的LOD级别，导致看不清楚。近处的小石头用很高的LOD级别实际上看不到。</p>
<p>Unity和Unreal都是用了屏占比的策略，他们根据不同的屏占比切换LOD级别，同时屏占比过小就会直接剪裁掉：</p>
<p><img src="/../../images/LOD%E7%AD%96%E7%95%A5/1577155095470.png" alt="1577155095470"></p>
<p><img src="/../../images/LOD%E7%AD%96%E7%95%A5/1577155108259.png" alt="1577155108259"></p>
<h2 id="屏占比算法"><a href="#屏占比算法" class="headerlink" title="屏占比算法"></a>屏占比算法</h2><h3 id="球体屏占比"><a href="#球体屏占比" class="headerlink" title="球体屏占比"></a>球体屏占比</h3><p><a target="_blank" rel="noopener" href="http://iquilezles.org/www/articles/sphereproj/sphereproj.htm">http://iquilezles.org/www/articles/sphereproj/sphereproj.htm</a></p>
<h3 id="AABB屏占比"><a href="#AABB屏占比" class="headerlink" title="AABB屏占比"></a>AABB屏占比</h3><p>参考链接：<a target="_blank" rel="noopener" href="http://www.codersnotes.com/notes/projected-area-of-an-aabb/">http://www.codersnotes.com/notes/projected-area-of-an-aabb/</a></p>

      
      <p align="right"><a class="morebtn" href="/2022/09/19/RTR/LOD%E7%AD%96%E7%95%A5/" title="">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/09/19/RTR/IBL%E5%85%89%E7%85%A7%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/09/19/RTR/IBL%E5%85%89%E7%85%A7%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/" itemprop="url"></a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-09-19T19:53:33+08:00">2022-09-19 19:53:33</time></span>
        </span>
        
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <!-- TOC -->



<p>- <a href="#ibl%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8">IBL理论与应用</a></p>
<p>​    - <a href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">理论基础</a></p>
<p>​        - <a href="#%E5%85%89%E7%85%A7%E5%87%BD%E6%95%B0">光照函数</a></p>
<p>​        - <a href="#%E4%BB%A3%E7%A0%81">代码</a></p>
<p>​    - <a href="#ibl%E4%BC%98%E5%8C%96split-sum-approximation">IBL优化：Split Sum Approximation</a></p>
<p>​        - <a href="#ibl-mipmap%E6%9E%84%E9%80%A0%E4%B8%8Eprefilter">IBL MipMap构造与Prefilter</a></p>
<p>​        - <a href="#ibl%E5%85%89%E7%85%A7%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E4%BC%B0%E8%AE%A1">IBL光照函数积分估计</a></p>
<p>​            - <a href="#%E5%8E%9F%E5%A7%8B%E7%A7%AF%E5%88%86">原始积分</a></p>
<p>​            - <a href="#%E6%8B%9F%E5%90%88%E7%A7%AF%E5%88%86%E4%BC%98%E5%8C%96">拟合积分优化</a></p>
<p>​            - <a href="#%E9%A2%84%E7%A7%AF%E5%88%86%E8%B4%B4%E5%9B%BE">预积分贴图</a></p>
<!-- /TOC -->

<h1 id="IBL理论与应用"><a href="#IBL理论与应用" class="headerlink" title="IBL理论与应用"></a>IBL理论与应用</h1><p>这部分内容主要参自UE4的论文[Real Shading in Unreal Engine 4]</p>
<p>IBL主要指的就是环境贴图部分计算的光照。</p>
<h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h3 id="光照函数"><a href="#光照函数" class="headerlink" title="光照函数"></a>光照函数</h3><p>光源就是一个Cubemap，过去也会用到双剖面。实际的积分光照结果是：</p>
<p><img src="/../../images/IBL%E5%85%89%E7%85%A7%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/1574853586831.png" alt="1574853586831"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>这部分内容对应的代码就是下面的：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 根据一个随机Xi值和粗糙度、法线计算需要采样cubemap的方向，</span><br>float3 <span class="hljs-title function_">ImportanceSampleGGX</span><span class="hljs-params">( float2 Xi, <span class="hljs-type">float</span> Roughness, float3 N )</span> &#123; <br>   	<span class="hljs-type">float</span> a = Roughness * Roughness;<br>    <span class="hljs-type">float</span> Phi = <span class="hljs-number">2</span> * PI * Xi.x; <br>    <span class="hljs-type">float</span> CosTheta = <span class="hljs-built_in">sqrt</span>( (<span class="hljs-number">1</span> - Xi.y) / ( <span class="hljs-number">1</span> + (a*a - <span class="hljs-number">1</span>) * Xi.y ) ); <br>    <span class="hljs-type">float</span> SinTheta = <span class="hljs-built_in">sqrt</span>( <span class="hljs-number">1</span> - CosTheta * CosTheta );<br>    float3 H; <br>    H.x = SinTheta * <span class="hljs-built_in">cos</span>( Phi ); <br>    H.y = SinTheta * <span class="hljs-built_in">sin</span>( Phi ); <br>    H.z = CosTheta;<br>	float3 UpVector = <span class="hljs-built_in">abs</span>(N.z) &lt; <span class="hljs-number">0.999</span> ? float3(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) : float3(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>); <br>    float3 TangentX = normalize( cross( UpVector, N ) ); <br>    float3 TangentY = cross( N, TangentX ); <span class="hljs-comment">// Tangent to world space </span><br>    <span class="hljs-keyword">return</span> TangentX * H.x + TangentY * H.y + N * H.z;<br>&#125;<br><span class="hljs-comment">//N就是NumSamples，是进行采样估计得采样数，决定了积分准确度，可以看到和正常光照一样需要有FDG的计算</span><br>float3 <span class="hljs-title function_">SpecularIBL</span><span class="hljs-params">( float3 SpecularColor, <span class="hljs-type">float</span> Roughness, float3 N, float3 V )</span> <br>&#123; <br>    float3 SpecularLighting = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> uint NumSamples = <span class="hljs-number">1024</span>; <br>    <span class="hljs-keyword">for</span>( uint i = <span class="hljs-number">0</span>; i &lt; NumSamples; i++ ) <br>    &#123; <br>        float2 Xi = Hammersley( i, NumSamples );<br>		float3 H = ImportanceSampleGGX( Xi, Roughness, N ); <br>        float3 L = <span class="hljs-number">2</span> * dot( V, H ) * H - V;<br>		<span class="hljs-type">float</span> NoV = saturate( dot( N, V ) ); <br>        <span class="hljs-type">float</span> NoL = saturate( dot( N, L ) ); <br>        <span class="hljs-type">float</span> NoH = saturate( dot( N, H ) ); <br>        <span class="hljs-type">float</span> VoH = saturate( dot( V, H ) );<br>        <span class="hljs-keyword">if</span>( NoL &gt; <span class="hljs-number">0</span> ) <br>        &#123; <br>            float3 SampleColor = EnvMap.SampleLevel( EnvMapSampler, L, <span class="hljs-number">0</span> ).rgb;<br>        	<span class="hljs-type">float</span> G = G_Smith( Roughness, NoV, NoL ); <br>            <span class="hljs-type">float</span> Fc = <span class="hljs-built_in">pow</span>( <span class="hljs-number">1</span> - VoH, <span class="hljs-number">5</span> ); <br>            float3 F = (<span class="hljs-number">1</span> - Fc) * SpecularColor + Fc;<br>			<span class="hljs-comment">// Incident light = SampleColor * NoL </span><br>            <span class="hljs-comment">// Microfacet specular = D*G*F / (4*NoL*NoV) </span><br>            <span class="hljs-comment">// pdf = D * NoH / (4 * VoH) </span><br>            SpecularLighting += SampleColor * F * G * VoH / (NoH * NoV);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> SpecularLighting / NumSamples;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="IBL优化：Split-Sum-Approximation"><a href="#IBL优化：Split-Sum-Approximation" class="headerlink" title="IBL优化：Split Sum Approximation"></a>IBL优化：Split Sum Approximation</h2><p>由于上面内容如果实时计算的话，开销太高，所以对原始公式进行了一次估计。变成了：</p>
<p><img src="/../../images/IBL%E5%85%89%E7%85%A7%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/1574853973468.png" alt="1574853973468"></p>
<p>这个就叫做Split Sum Approximation。</p>
<p>优化之后的代码：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 <span class="hljs-title function_">ApproximateSpecularIBL</span><span class="hljs-params">( float3 SpecularColor, <span class="hljs-type">float</span> Roughness, float3 N, float3 V )</span> <br>&#123; <br>    <span class="hljs-type">float</span> NoV = saturate( dot( N, V ) ); <br>    float3 R = <span class="hljs-number">2</span> * dot( V, N ) * N - V;<br>    <span class="hljs-comment">// 第一项的优化结果：mipmap某一层</span><br>	float3 PrefilteredColor = PrefilterEnvMap( Roughness, R ); <br>    <span class="hljs-comment">// 第二项优化结果：真实的进行采样积分，或者使用估计值。</span><br>    float2 EnvBRDF = IntegrateBRDF( Roughness, NoV );<br>	<span class="hljs-keyword">return</span> PrefilteredColor * ( SpecularColor * EnvBRDF.x + EnvBRDF.y );<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>得到上面的公式之后进行两个积分项的分别化简。</p>
<h3 id="IBL-MipMap构造与Prefilter"><a href="#IBL-MipMap构造与Prefilter" class="headerlink" title="IBL MipMap构造与Prefilter"></a>IBL MipMap构造与Prefilter</h3><p>首先是第一项，实际上就是计算一个颜色的平均值。</p>
<p><img src="/../../images/IBL%E5%85%89%E7%85%A7%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/1574854041330.png" alt="1574854041330"></p>
<p>根据不同的粗糙度采样的范围有所区别。粗糙度越大，采样越分散，所以通常就使用了mipmap对应于不同的粗糙度（也就是模糊程度不同的平均值）。根据其他的一些数学推导，模糊用的filter有所区别。</p>
<p>UE4进行Prefilter的代码：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 <span class="hljs-title function_">PrefilterEnvMap</span><span class="hljs-params">( <span class="hljs-type">float</span> Roughness, float3 R )</span> <br>&#123; <br>    float3 N = R; float3 V = R;<br>    float3 PrefilteredColor = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> uint NumSamples = <span class="hljs-number">1024</span>; <br>    <span class="hljs-keyword">for</span>( uint i = <span class="hljs-number">0</span>; i &lt; NumSamples; i++ ) <br>    &#123; <br>        float2 Xi = Hammersley( i, NumSamples ); <br>        float3 H = ImportanceSampleGGX( Xi, Roughness, N ); <br>        float3 L = <span class="hljs-number">2</span> * dot( V, H ) * H - V;<br>        <span class="hljs-type">float</span> NoL = saturate( dot( N, L ) ); <br>        <span class="hljs-keyword">if</span>( NoL &gt; <span class="hljs-number">0</span> ) <br>        &#123; <br>            PrefilteredColor += EnvMap.SampleLevel( EnvMapSampler, L, <span class="hljs-number">0</span> ).rgb * NoL; <br>            TotalWeight += NoL; <br>        &#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> PrefilteredColor / TotalWeight;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="IBL光照函数积分估计"><a href="#IBL光照函数积分估计" class="headerlink" title="IBL光照函数积分估计"></a>IBL光照函数积分估计</h3><p>然后是第二项：</p>
<p><img src="/../../images/IBL%E5%85%89%E7%85%A7%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/1574854160210.png" alt="1574854160210"></p>
<p>这一项的优化方式是:</p>
<ol>
<li>先得到一个真实的曲线。然后创造一个函数去拟合这个积分结果。</li>
<li>或者不拟合直接用原始积分结果。</li>
<li>把准确的积分结果保存在贴图中：UE4的做法</li>
</ol>
<h4 id="原始积分"><a href="#原始积分" class="headerlink" title="原始积分"></a>原始积分</h4><p>真实的积分代码：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 真实的积分代码：</span><br>float2 <span class="hljs-title function_">IntegrateBRDF</span><span class="hljs-params">( <span class="hljs-type">float</span> Roughness, <span class="hljs-type">float</span> NoV )</span> <br>&#123; <br>    float3 V; V.x = <span class="hljs-built_in">sqrt</span>( <span class="hljs-number">1.0f</span> - NoV * NoV ); <span class="hljs-comment">// sin V.y = 0; V.z = NoV; // cos</span><br>	<span class="hljs-type">float</span> A = <span class="hljs-number">0</span>; <br>    <span class="hljs-type">float</span> B = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">const</span> uint NumSamples = <span class="hljs-number">1024</span>; <br>    <span class="hljs-keyword">for</span>( uint i = <span class="hljs-number">0</span>; i &lt; NumSamples; i++ ) <br>    &#123; <br>        float2 Xi = Hammersley( i, NumSamples ); <br>        float3 H = ImportanceSampleGGX( Xi, Roughness, N ); <br>        float3 L = <span class="hljs-number">2</span> * dot( V, H ) * H - V;<br>		<span class="hljs-type">float</span> NoL = saturate( L.z ); <span class="hljs-type">float</span> NoH = saturate( H.z ); <br>        <span class="hljs-type">float</span> VoH = saturate( dot( V, H ) );<br>		<span class="hljs-keyword">if</span>( NoL &gt; <span class="hljs-number">0</span> ) <br>        &#123; <br>            <span class="hljs-type">float</span> G = G_Smith( Roughness, NoV, NoL );<br>			<span class="hljs-type">float</span> G_Vis = G * VoH / (NoH * NoV); <br>            <span class="hljs-type">float</span> Fc = <span class="hljs-built_in">pow</span>( <span class="hljs-number">1</span> - VoH, <span class="hljs-number">5</span> ); <br>            A += (<span class="hljs-number">1</span> - Fc) * G_Vis; <br>            B += Fc * G_Vis;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> float2( A, B ) / NumSamples;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="拟合积分优化"><a href="#拟合积分优化" class="headerlink" title="拟合积分优化"></a>拟合积分优化</h4><p>拟合的方式可以参考文献:</p>
<p>[Summary of Physically Based Shading in Call of Duty: Black Ops ]</p>
<p>文献当中提到了真实曲线和如何构造出估计曲线。</p>
<p>估计拟合的brdf代码：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 <span class="hljs-title function_">EnvironmentBRDF</span><span class="hljs-params">( <span class="hljs-type">float</span> g, <span class="hljs-type">float</span> NoV, float3 rf0 )</span> <br>&#123; <br>    float4 t = float4( <span class="hljs-number">1</span>/<span class="hljs-number">0.96</span>, <span class="hljs-number">0.475</span>, (<span class="hljs-number">0.0275</span> - <span class="hljs-number">0.25</span> * <span class="hljs-number">0.04</span>)/<span class="hljs-number">0.96</span>, <span class="hljs-number">0.25</span> ); <br>    t *= float4( g, g, g, g );<br>    t += float4( <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (<span class="hljs-number">0.015</span> - <span class="hljs-number">0.75</span> * <span class="hljs-number">0.04</span>)/<span class="hljs-number">0.96</span>, <span class="hljs-number">0.75</span> ); <br>    <span class="hljs-type">float</span> a0 = t.x * min( t.y, exp2( <span class="hljs-number">-9.28</span> * NoV ) ) + t.z; <br>    <span class="hljs-type">float</span> a1 = t.w; <br>    <span class="hljs-keyword">return</span> saturate( a0 + rf0 * ( a1 - a0 ) ); <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="预积分贴图"><a href="#预积分贴图" class="headerlink" title="预积分贴图"></a>预积分贴图</h4><p>UE4Brdf的积分贴图：</p>
<p><img src="/../../images/IBL%E5%85%89%E7%85%A7%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/1574854766491.png" alt="1574854766491"></p>

      
      <p align="right"><a class="morebtn" href="/2022/09/19/RTR/IBL%E5%85%89%E7%85%A7%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/" title="">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/09/19/RTR/HDR%E4%B8%8EToneMapping%E7%90%86%E8%AE%BA/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/09/19/RTR/HDR%E4%B8%8EToneMapping%E7%90%86%E8%AE%BA/" itemprop="url"></a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-09-19T19:53:33+08:00">2022-09-19 19:53:33</time></span>
        </span>
        
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="HDR-与ToneMapping"><a href="#HDR-与ToneMapping" class="headerlink" title="HDR 与ToneMapping"></a>HDR 与ToneMapping</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>HDR详细的解释：<a target="_blank" rel="noopener" href="https://developer.nvidia.com/rendering-game-hdr-display">Rendering a Game for HDR Display</a></p>
<p>ToneMapping 讲解的比较详细的：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21983679">Tone mapping进化论</a></p>
<h2 id="HDR解释"><a href="#HDR解释" class="headerlink" title="HDR解释"></a>HDR解释</h2><h3 id="渲染层的HDR和ToneMapping"><a href="#渲染层的HDR和ToneMapping" class="headerlink" title="渲染层的HDR和ToneMapping"></a>渲染层的HDR和ToneMapping</h3><p>渲染层面的HDR主要是渲染阶段：</p>
<ol>
<li><p>由于<strong>系统默认的FrameBuffer只支持0-1数据</strong>，如果存储超过1，硬件会自动执行Clamp操作。</p>
</li>
<li><p>支持HDR渲染，实际上就是图形API(OPengl 等)支持自定义RenderBuffer。这个自定义的Renderbuffer可以支持，RGBA16 格式，保存超过1的值。</p>
</li>
<li><p>最后一个阶段，需要把RenderBuffer的内容（超过1），通过ToneMapping算法，压缩到系统默认的FrameBuffer中用于显示。</p>
</li>
</ol>
<p>下面是一个基础的HDR渲染阶段的流程</p>
<p>参考GDC2017 High Dynamic Range color grading and display in Frostbite</p>
<p><img src="/../../images/HDR%E4%B8%8EToneMapping%E7%90%86%E8%AE%BA/1568966737421.png" alt="1568966737421"></p>
<p>Tonemap之前的流程包括暗角，Flare Len，DoF，Bloom，自动曝光参数计算（部分参数用于ToneMaping）.</p>
<p>可以将ToneMap和Grading、Gamma矫正进行合并。</p>
<h3 id="显示层的HDR：多ToneMapping曲线"><a href="#显示层的HDR：多ToneMapping曲线" class="headerlink" title="显示层的HDR：多ToneMapping曲线"></a>显示层的HDR：多ToneMapping曲线</h3><ol>
<li><p>在进入显示器时，内容必定是FrameBuffer当中的0-1。</p>
</li>
<li><p>如果在LDR和HDR显示器上使用同一个ToneMapping曲线，会导致画面整体变亮。</p>
</li>
</ol>
<p><strong>FrameBuffer始终是0-1</strong>，而1对应的值变成了：100nits  200nits 1000nits.</p>
<p><img src="/../../images/HDR%E4%B8%8EToneMapping%E7%90%86%E8%AE%BA/1569205929868.png" alt="1569205929868"></p>
<p><img src="/../../images/HDR%E4%B8%8EToneMapping%E7%90%86%E8%AE%BA/1569205676107.png" alt="1569205676107"></p>
<p>寒霜策略：</p>
<p><img src="/../../images/HDR%E4%B8%8EToneMapping%E7%90%86%E8%AE%BA/1569205757913.png" alt="1569205757913"></p>

      
      <p align="right"><a class="morebtn" href="/2022/09/19/RTR/HDR%E4%B8%8EToneMapping%E7%90%86%E8%AE%BA/" title="">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/09/19/RTR/GPU%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AFInside_Geometry_Instancing/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/09/19/RTR/GPU%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AFInside_Geometry_Instancing/" itemprop="url"></a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-09-19T19:53:33+08:00">2022-09-19 19:53:33</time></span>
        </span>
        
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <!-- TOC -->

<ul>
<li><a href="#gpu%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AFinside-geometry-instancing">GPU渲染优化技术:Inside Geometry Instancing</a><ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#why-geometry-instancing">Why Geometry Instancing?</a></li>
<li><a href="#definitions">Definitions</a><ul>
<li><a href="#geometry-packet">Geometry Packet</a></li>
<li><a href="#instance-attributes">Instance Attributes</a></li>
<li><a href="#geometry-instance">Geometry Instance</a></li>
<li><a href="#render-and-texture-context">Render and Texture Context</a></li>
<li><a href="#geometry-batch">Geometry Batch</a></li>
</ul>
</li>
<li><a href="#implementation">Implementation</a><ul>
<li><a href="#static-batching">Static Batching</a></li>
<li><a href="#dynamic-batching">Dynamic Batching</a></li>
<li><a href="#vertex-constants-instancing">Vertex Constants Instancing</a></li>
<li><a href="#batching-with-the-geometry-instancing-api">Batching with the Geometry Instancing API</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="GPU渲染优化技术-Inside-Geometry-Instancing"><a href="#GPU渲染优化技术-Inside-Geometry-Instancing" class="headerlink" title="GPU渲染优化技术:Inside Geometry Instancing"></a>GPU渲染优化技术:Inside Geometry Instancing</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这里主要讨论对几何体的渲染优化技术：</p>
<p>参考内容为<a target="_blank" rel="noopener" href="http://developer.nvidia.com/gpugems2">GPU Gems 2</a></p>
<p>为了制作一个完整的、令人信服的游戏世界，地图当中可能存在大量的细小的、零碎的模型，这些模型可能彼此之间只有微小的差别：颜色、位置等。</p>
<p>但是渲染大量的小物体，每一个只使用面很少的多边形，会造成GPU的大量开销。<strong>现在的图形API的设计对于渲染大量的小物体（面数少）是非常低效的</strong>。（Graphics APIs such as Direct3D and OpenGL are not designed to efficiently render a small number of polygons thousands of times per frame）</p>
<p><strong>这部分内容主要处理渲染大量相同几何体的问题。</strong></p>
<h2 id="Why-Geometry-Instancing"><a href="#Why-Geometry-Instancing" class="headerlink" title="Why Geometry Instancing?"></a>Why Geometry Instancing?</h2><p><strong>将三角形提交到GPU进行渲染是相对缓慢的操作（drawcall）</strong>。原文中提到的渲染限制：（Wloka 2003 shows that a 1 GHz CPU can render only around 10,000 to 40,000 batches per second in Direct3D.  On a more modern CPU, we can expect this number to be between 30,000 and 120,000 batches per second (around 1,000 to 4,000 batches per frame at 30 frames&#x2F;sec). )  <strong>这就说明我们不能提交过多的次数，也就是Drawcall的范围需要在1000- 4000之间，无论一个batch当中有多少个三角形，因为CPU时间限制，否则他没有更多的时间做别的事情。</strong></p>
<p>为了渲染更多的东西，应该尽可能最小化贴图和渲染状态的变化。<strong>一个比较好的方案是在同一个Batch当中，渲染多次三角形。这样可以最小化批次提交的次数，释放更多的CPU时间给别的系统（物理系统，游戏逻辑）。</strong></p>
<h2 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h2><p>首先明确几个概念：</p>
<h3 id="Geometry-Packet"><a href="#Geometry-Packet" class="headerlink" title="Geometry Packet"></a>Geometry Packet</h3><p>Geometry Packet指的是一堆需要被Instance的几何体，包括了顶点和索引的集合。一个Geometry Packet包括：顶点数据（position, texture coordinates, normal, possibly tangent space and bones information for skinning, and per-vertex colors）和索引数据流。这些数据以最有效的方式提交到GPU。</p>
<p>Geometry Packet是对一段几何图形的抽象描述，其中几何实体在模型空间中表示，没有保存和渲染上下文相关的信息（世界坐标矩阵、渲染状态）。</p>
<p>下面是一段Geometry Packet的例子：包括物体的几何信息和它的边界球:</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GeometryPacket</span>  </span><br><span class="hljs-class">&#123;</span>    <br>    Primitive mPrimType;    <br>    <span class="hljs-type">void</span>* mVertices;   <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mVertexStride;      <span class="hljs-comment">//顶点列表</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>* mIndices;      <span class="hljs-comment">//索引列表</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mVertexCount;    <span class="hljs-comment">// 顶点数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mIndexCount;      <span class="hljs-comment">// 索引数 </span><br>    D3DXVECTOR3 mSphereCentre;   <span class="hljs-comment">// 包围球中心</span><br>    <span class="hljs-type">float</span> mSphereRadius;   <span class="hljs-comment">// 包围球半径</span><br>&#125;; <br></code></pre></td></tr></table></figure>

<h3 id="Instance-Attributes"><a href="#Instance-Attributes" class="headerlink" title="Instance Attributes"></a>Instance Attributes</h3><p>Instance Attributes是每个Instance物体的属性，可以包括:模型到世界的转换矩阵、实例颜色。（为了方便理解原文的其他属性省略了）</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InstanceAttributes</span>  &#123;</span>    <br>    D3DXMATRIX mModelMatrix;    <span class="hljs-comment">// 模型矩阵</span><br>    D3DCOLOR mInstanceColor;    <span class="hljs-comment">// Instance 颜色</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="Geometry-Instance"><a href="#Geometry-Instance" class="headerlink" title="Geometry Instance"></a>Geometry Instance</h3><p>Geometry Instance是一个 geometry packet加上其用于实例化成被渲染物体的属性。</p>
<p>结构体如下图：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GeometryInstance</span>  &#123;</span>    <br>    GeometryPacket* mGeometryPacket;    <br>    InstanceAttributes mInstanceAttributes;  <br>&#125;; <br></code></pre></td></tr></table></figure>

<h3 id="Render-and-Texture-Context"><a href="#Render-and-Texture-Context" class="headerlink" title="Render and Texture Context"></a>Render and Texture Context</h3><p>渲染上下文指的是渲染状态：AlphaTest之类的。纹理上下文指的是当前激活的纹理，渲染目标之类的。</p>
<h3 id="Geometry-Batch"><a href="#Geometry-Batch" class="headerlink" title="Geometry Batch"></a>Geometry Batch</h3><p><strong>一个Geometry Batch包括：一组需要渲染的Geometry Instances、他们需要的渲染状态和纹理上下文的集合。它总是直接对应一个DrawIndexedPrimitive()调用。</strong> </p>
<p><strong>也就是说一个Batch对应了一个Redner Content、一个纹理上下文和多个Geometry Instances，对应了一个DrawCall也就是一次DrawIndexedPrimitive()的调用</strong></p>
<p><strong>RenderContext</strong>和<strong>TextureContext</strong>的Class(为了方便理解和原文做了调整)：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 渲染下文</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RenderContext</span>  &#123;</span>  <br>public:     <br>    <span class="hljs-comment">// 开始设置 render context，使渲染状态激活</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">Begin</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;      <br>    <span class="hljs-comment">// 关闭 render context，还原之前的状态    </span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">End</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;    <br>private:      <br>    <span class="hljs-comment">// render state、pixel shader、vertex shader</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;    <br><br><span class="hljs-comment">// 需要用到的纹理</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextureContext</span>  &#123;</span>     <br>    Texture mDiffuseMap;    <br>    Texture mLightMap;      <br>    <span class="hljs-comment">// . . .    </span><br>&#125;; <br></code></pre></td></tr></table></figure>

<p>Geometry Batch类</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeometryBatch</span>  &#123;</span>  <br>public:      <br>    <span class="hljs-comment">// 清楚batch当中包含的全部Instance  </span><br>    virtual <span class="hljs-type">void</span> <span class="hljs-title function_">ClearInstances</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;      <br>    <span class="hljs-comment">// 添加一个Instance 返回Instance ID </span><br>    <span class="hljs-comment">// 如果不能在添加返回-1</span><br>    virtual <span class="hljs-type">int</span> <span class="hljs-title function_">AddInstance</span><span class="hljs-params">(GeometryInstance* instance)</span>;      <br>    <span class="hljs-comment">// 提交所有Instance, 渲染循环之前调用一次，或者Instance发生变化之后。  </span><br>    virtual <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Commit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = <span class="hljs-number">0</span>;      <br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">    更新Geometry batch, 最终会准备GPU数据提交给驱动程序，如果需要也回填充indexbuffer和vertexbuffer ，每帧调用一次。</span><br><span class="hljs-comment">	*/</span>     <br>    virtual <span class="hljs-type">void</span> <span class="hljs-title function_">Update</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = <span class="hljs-number">0</span>;     <br>    <span class="hljs-comment">// 将batch提交给驱动程序，通常就是一次drawcall，一次DrawIndexedPrimitive的调用。 </span><br>    virtual <span class="hljs-type">void</span> <span class="hljs-title function_">Render</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-type">const</span> = <span class="hljs-number">0</span>;    <br>    <br>private:   <br>    <span class="hljs-comment">// Instance的列表</span><br>    GeometryInstancesCollection mInstances;      <br>   <br>&#125;; <br></code></pre></td></tr></table></figure>

<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>引擎的渲染只能通过Geometry Batch看到Geometry Instance的抽象接口。隐藏了instancing技术的实现细节， GeometryBatch还提供了管理Instance物体，更新和渲染的服务。这样引擎能够专注于batch排序、以最小化渲染状态的变化。Geometry Batch关注实际的实现和图形API的交互。</p>
<p>下面是一个通过排序GeometryBatch以最小化渲染状态变化的渲染过程伪代码。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 遍历所有的drawcall，也就是所有的batch</span><br>Foreach GeometryBatch in ActiveBatchesList    <br>	<span class="hljs-comment">// 更新这个batch</span><br>    GeometryBatch.Update();    <br>    <span class="hljs-comment">// Render phase  </span><br>    Foreach RenderContext  <br>    Begin    <br>    	<span class="hljs-comment">// 渲染状态</span><br>        RenderContext.BeginRendering();    <br>        RenderContext.CommitStates();    <br>		<span class="hljs-comment">// 贴图状态</span><br>        Foreach TextureContext      <br>            Begin      <br>            	<span class="hljs-comment">//应用贴图</span><br>                TextureContext.Apply();    <br>			   <span class="hljs-comment">// 渲染Batch中的所有instance</span><br>                Foreach GeometryBatch in the texture context        <br>                	GeometryBatch.Render();    <br>            End  <br>    End <br></code></pre></td></tr></table></figure>

<p>更新操作和渲染阶段可以保持分离，如果我们希望一次性更新所有batch，渲染多次。例如渲染Shadowmap。</p>
<p>现在我们讨论四种GeometryBatch的实现并且分析他们的性能特性：内存和灵活性。</p>
<p>下面比较重要所以保留了原文：</p>
<ul>
<li><strong>Static batching.</strong> The fastest way to instance geometry. Each instance is transformed once to world space, its attributes are applied, and then it’s sent already transformed to the GPU with every frame. Although simple, static batching is the least flexible technique.</li>
<li><strong>Dynamic batching.</strong> The slowest way to instance geometry. Each instance is streamed to GPU memory every frame, already transformed and with attributes applied. Dynamic batching seamlessly supports skinning and provides the most flexible implementation.</li>
<li><strong>Vertex constants instancing.</strong> A hybrid implementation in which multiple copies of the geometry for each instance are copied once into GPU memory. Instance attributes are then set every frame through vertex constants, and a vertex shader completes geometry instancing.</li>
<li><strong>Batching with Geometry Instancing API.</strong> Using the Geometry Instancing API provided by DirectX 9 and fully supported in hardware by GeForce 6 Series GPUs, this implementation offers a flexible and fast solution to geometry instancing. Unlike all other methods, this does not require geometry packet replication in the Direct3D vertex stream.</li>
</ul>
<h3 id="Static-Batching"><a href="#Static-Batching" class="headerlink" title="Static Batching"></a>Static Batching</h3><p>这个策略中，我们希望一次性处理全部的Instance，所以需要把所有内容拷贝到一个静态的vertex buffer中。vertex buffer object要足够的大，以保存所有的instance。因为是提前合并所有instance数据，所以设置成D3DUSAGE_WRITEONLY和MAX_STATIC_BUFFER_SIZE即可</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">HRESULT res;    <br>res = lpDevice-&gt;CreateVertexBuffer(MAX_STATIC_BUFFER_SIZE,    <br>                                   D3DUSAGE_WRITEONLY,    <br>                                   <span class="hljs-number">0</span>,    <br>                                   D3DPOOL_MANAGED,    <br>                                   &amp;mStaticVertexStream,    <br>                                   <span class="hljs-number">0</span>);    <br>ENGINE_ASSERT(SUCCEEDED(res)); <br></code></pre></td></tr></table></figure>

<p>然后实现 <code>Commit()</code>的伪代码：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 遍历每一个Batch当中的instance</span><br>Foreach GeometryInstance in Instances  <br>Begin    <br>	<span class="hljs-comment">// 将所有的instance都转换到同一个空间。</span><br>    Transform geometry in mGeometryPacket to world space      with instance mModelMatrix    <br>    <span class="hljs-comment">// 应用所有的instance属性</span><br>    Apply other instance <span class="hljs-title function_">attributes</span> <span class="hljs-params">(like instance color)</span>    <br>    <span class="hljs-comment">// 将转换后的几何信息保存的vertex buffer</span><br>    Copy transformed geometry to the Vertex Buffer    <br>    <span class="hljs-comment">// 将索引根据不同instance增加一个offet保存到Indexbuffer</span><br>	Copy <span class="hljs-title function_">indices</span> <span class="hljs-params">(with the right offset)</span> to the Index Buffer  <br>End <br></code></pre></td></tr></table></figure>

<p>现在就可以调用 <code>DrawIndexedPrimitive()</code>方法。所有的物体都变成了一个几何体</p>
<p><strong>限制</strong>：</p>
<ol>
<li>Large memory footprint.</li>
<li>No support for different levels of detail</li>
<li>No support for skinning.</li>
<li>No direct support for moving instances.</li>
</ol>
<h3 id="Dynamic-Batching"><a href="#Dynamic-Batching" class="headerlink" title="Dynamic Batching"></a>Dynamic Batching</h3><p>Dynamic batching 克服了static batching的缺点，但是降低了渲染效率。主要的有优点是能够不需要可编程管线GPU的支持。</p>
<p>首先需要创建一个vertexbuffer，内存分布更好的支持动态的更新。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">HRESULT res;    <br>res = lpDevice-&gt;CreateVertexBuffer(MAX_DYNAMIC_BUFFER_SIZE,    <br>                                   D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY,    <br>                                   <span class="hljs-number">0</span>,    <br>                                   D3DPOOL_DEFAULT,    <br>                                   &amp;mDynamicVertexStream,    <br>                                   <span class="hljs-number">0</span>); <br></code></pre></td></tr></table></figure>

<p>设置一个 <code>MAX_DYNAMIC_BUFFER_SIZE</code>是很重要的，有两个方案：</p>
<ol>
<li>选择一个足够大的值能够保证每一帧的所有instance都足够。</li>
<li>选择一个满足一定数量instance数量。</li>
</ol>
<p>第一个策略能够保证几何体更新和渲染是分开的，更新一次batch，提交一次渲染。更新一个batch的意义是将所有的instances放置到一个vertexbuffer当中：渲染只是提交 <code>DrawIndexedPrimitive()</code>渲染操作。但是这个方法需要足够大的图形内存。他可能是不可靠的：如果我们没有办法保证buffer在应用程序运行期间总是足够的大。</p>
<p>第二个策略需要交错的进行更新batch和提交渲染，当dynamicbuffer填充满的时候，提交渲染，并且丢弃buffer内容。然后继续填充。为了性能优化，选择合适的协议很重要。</p>
<p>选择哪一种依赖于具体的应用程序。本章节，我们选择第一个策略，因为更直接更容易解释。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">Foreach GeometryInstance in Instances  <br>	Begin    <br> 		Transform geometry in mGeometryPacket to world space with      instance mModelMatrix    <br> 		If instance needs skinning, request a <span class="hljs-built_in">set</span> of bones from      mAnimationPlayer and skin geometry    <br> 		Apply other instance <span class="hljs-title function_">attributes</span> <span class="hljs-params">(like instance color)</span>    <br> 		Copy transformed geometry to the Vertex Buffer    <br> 		Copy <span class="hljs-title function_">indices</span> <span class="hljs-params">(with the right offset)</span> to the Index Buffer    <br>		Advance current pointer to the Vertex Buffer    <br>		Advance current pointer to the Index Buffer  <br>    End <br></code></pre></td></tr></table></figure>

<p>这里的渲染调用也是简单的：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">DrawIndexedPrimitive().<br></code></pre></td></tr></table></figure>

<h3 id="Vertex-Constants-Instancing"><a href="#Vertex-Constants-Instancing" class="headerlink" title="Vertex Constants Instancing"></a>Vertex Constants Instancing</h3><p>Vertex Constants Instance中，我们使用顶点常量来保存Instance数据。顶点常量的batching在渲染中速度非常快，并且它支持instance物体每帧移动，但是为了这样的灵活性需要有一定的代价。</p>
<p>限制：</p>
<ol>
<li>每一个batch的数量是有限制的，依赖于可用的常量数量；通常一个batch数量在50到100个。但是这个在降低CPU开销上是足够的。</li>
<li>无法进行蒙皮，顶点常量 已经用来存储instance属性。</li>
<li>需要图形硬件对于vertexshader的支持。</li>
</ol>
<p>下图是顶点数据的示意图，表示了VertexBuffer的布局：</p>
<p><img src="/../../images/GPU%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AFInside_Geometry_Instancing/03_instancing_02.jpg" alt="03_instancing_02.jpg"></p>
<p>原始的顶点格式需要增加一个整形的索引用来表示Constant用的是哪个Instance，指明所属的geometry patcket。这个和蒙皮一样，指定哪个顶点被哪几根骨骼影响。</p>
<p>顶点格式：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InstanceVertex</span>  &#123;</span>    <br>    D3DXVECTOR3  mPosition; <span class="hljs-comment">// Other vertex properties, such as normal and texture    </span><br>    <span class="hljs-comment">// coordinates      </span><br>    WORD  mInstanceIndex[<span class="hljs-number">4</span>]; <span class="hljs-comment">// Direct3D requires SHORT4  </span><br>&#125;; <br></code></pre></td></tr></table></figure>

<p>提交数据 <code>Commit()</code> ，当所有的Instance数据都加入到geometrybatch之后，提交修改后的顶点buffer(增加Instancebuffer)。</p>
<p>下一步就是为每一个instance更新渲染属性。假设我们只有模型矩阵，描述instance的位置和朝向和颜色。</p>
<p>当使用Dx9类的GPU时，我们最大使用256个常量数据，可以使用200用于Instance属性。在我们的例子当中，一个模型矩阵需要4个常量，一个颜色需要1个常量，那么对于一个Instance就需要5个常量，也就是一个batch最多支持40个Instance。</p>
<p>下面是Update()方法（用于更新顶点数据）的伪代码：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">D3DXVECTOR4 instancesData[MAX_NUMBER_OF_CONSTANTS];    <br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;    <br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; GetInstancesCount(); ++i)  &#123;    <br>    <span class="hljs-comment">// write model matrix    </span><br>    instancesData[count++] = *(D3DXVECTOR4*)        <br>    &amp;mInstances[i].mModelMatrix.m11;    <br>    instancesData[count++] = *(D3DXVECTOR4*)        <br>    &amp;mInstances[i].mModelMatrix.m21;    <br>    instancesData[count++] = *(D3DXVECTOR4*)        <br>    &amp;mInstances[i].mModelMatrix.m31;    <br>    instancesData[count++] = *(D3DXVECTOR4*)        <br>    &amp;mInstances[i].mModelMatrix.m41;      <br>    <span class="hljs-comment">// write instance color      </span><br>    instanceData[count++] = ConvertColorToVec4(mInstances[i].mColor));  <br>&#125;    <br>lpDevice-&gt;SetVertexConstants(    <br>    INSTANCES_DATA_FIRST_CONSTANT,    <br>    instancesData,    <br>    count); <br></code></pre></td></tr></table></figure>

<p>Render()方法设置视口矩阵和所有的instance，并通过<code>DrawIndexedPrimitive()</code> 提交渲染。</p>
<p>可能的优化方式：可以将模型矩阵以四元组的形式保存可以节省两个顶点常量，最大支持的instance数量增加到70个左右。一个统一的缩放值保存在位移的w通道。模型矩阵在顶点数组中进行重构，但是会增加顶点Shader的复杂程度和计算时间。</p>
<h3 id="Batching-with-the-Geometry-Instancing-API"><a href="#Batching-with-the-Geometry-Instancing-API" class="headerlink" title="Batching with the Geometry Instancing API"></a>Batching with the Geometry Instancing API</h3><p>最后一个技术是通过图形API直接暴露的硬件功能。越来越多的图形硬件开始支持Geometry Insancing API，这个技术优雅的解决了顶点数据Instancing 的数量限制，内存占用有限，CPU几乎不需要干预。唯一的缺点就是他只能处理相同的Geometry Packet。</p>
<p>DX9提供下面的调用用来访问Geometry Instancing API：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">HRESULT <span class="hljs-title function_">SetStreamSourceFreq</span><span class="hljs-params">(    UINT StreamNumber,    UINT FrequencyParameter)</span>; <br></code></pre></td></tr></table></figure>

<p><em>StreamNumber</em>表示了流数据的索引，<em>FrequencyParameter</em>表示了每一个顶点包含的Instance数量。</p>
<p>我们首先需要创造两个vertexbuffer，一个是静态的用于保存一个单一几何体的geometry packet ，这个几何体是我们想要进行多次Instance绘制的物体。还需要一个动态的buffer用于保存Instance 数据。两个vertex的stream如下图：</p>
<p><img src="/../../images/GPU%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AFInside_Geometry_Instancing/03_instancing_03.jpg" alt="03_instancing_03.jpg"></p>
<p><code>Commit()</code> 数据确保所有的Instance只使用同一个geometrypacket，并且把这个geometry拷贝到一个静态的buffer当中。</p>
<p> <code>Update()</code> 就简单的将所有的Instance的属性拷贝到第二个stream当中。这个方法看起来虽然和dynamic batch的策略很接近，但是CPU的介入和图形总线 (AGP or PCI Express)的带宽都是最小的。除此之外，我们能够分配一个足够大的内存给所有Instance的属性而不用担心图形内存，因为每一个Instance属性只使用一个几何体包的一小部分内存。</p>
<p> <code>Render()</code> 方法需要设置两个Stream和正确的Stream frequency和调用DrawIndexedPrimitive()来在一个batch中渲染全部Instance。</p>
<p>GPU会处理第一个stream的数据通过复制和第二个stream的数据打包。vertex shader会把模型空间的顶点用instance属性中的矩阵转换到世界空间。</p>
<p>下面是对两个stream的设置：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> instancesCount = GetInstancesCount();    <br><span class="hljs-comment">// set up stream source frequency for the first stream  </span><br><span class="hljs-comment">// to render instancesCount instances  </span><br><span class="hljs-comment">// D3DSTREAMSOURCE_INDEXEDDATA tells Direct3D we&#x27;ll use  </span><br><span class="hljs-comment">// indexed geometry for instancing  </span><br>lpDevice-&gt;SetStreamSourceFreq(    <span class="hljs-number">0</span>,    D3DSTREAMSOURCE_INDEXEDDATA | instancesCount);      <br><span class="hljs-comment">// set up first stream source with the vertex buffer  </span><br><span class="hljs-comment">// containing geometry for the geometry packet  </span><br>lpDevice-&gt;SetStreamSource(    <span class="hljs-number">0</span>,    mGeometryInstancingVB[<span class="hljs-number">0</span>],    <span class="hljs-number">0</span>,    mGeometryPacketDecl);    <br><span class="hljs-comment">// set up stream source frequency for the second stream;  </span><br><span class="hljs-comment">// each set of instance attributes describes one instance  </span><br><span class="hljs-comment">// to be rendered  </span><br>lpDevice-&gt;SetStreamSourceFreq(    <span class="hljs-number">1</span>,    D3DSTREAMSOURCE_INSTANCEDATA | <span class="hljs-number">1</span>);    <span class="hljs-comment">// set up second stream source with the vertex buffer    </span><br><span class="hljs-comment">// containing all instances&#x27; attributes  </span><br>pd3dDevice-&gt;SetStreamSource(    <span class="hljs-number">1</span>,    mGeometryInstancingVB[<span class="hljs-number">0</span>],    <span class="hljs-number">0</span>,    mInstancesDataVertexDecl); <br></code></pre></td></tr></table></figure>

<p>vertex shader的代码如图所示：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">// vertex input declaration  </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vsInput</span>  </span><br><span class="hljs-class">&#123;</span>    <br>    <span class="hljs-comment">// stream 0    </span><br>    float4 position : POSITION;    <br>    float3 normal   : NORMAL;      <br>    <span class="hljs-comment">// stream 1      </span><br>    float4 model_matrix0 : TEXCOORD0;    <br>    float4 model_matrix1 : TEXCOORD1;    <br>    float4 model_matrix2 : TEXCOORD2;    <br>    float4 model_matrix3 : TEXCOORD3;      <br>    float4 instance_color : D3DCOLOR;  <br>&#125;;      <br>vsOutput <span class="hljs-title function_">GeometryInstancingVS</span><span class="hljs-params">(    in vsInput input)</span>  <br>&#123;    <br>    <span class="hljs-comment">// construct the model matrix    </span><br>    float4x4 modelMatrix =    &#123;      <br>        input.model_matrix0,      <br>        input.model_matrix1,      <br>        input.model_matrix2,      <br>        input.model_matrix3    <br>    &#125;;      <br>    <span class="hljs-comment">// transform input position and normal to world space    </span><br>    <span class="hljs-comment">// with the instance model matrix      </span><br>    float4 worldPosition = mul(input.position, modelMatrix);    <br>    float3 worldNormal = mul(input.normal, modelMatrix);      <br>    <span class="hljs-comment">// output position, normal, and color    </span><br>    output.position = mul(worldPosition, ViewProjectionMatrix);    <br>    output.normal = mul(worldNormal, ViewProjectionMatrix);    <br>    output.color = input.instance_color;      <br>    <span class="hljs-comment">// output other vertex data    </span><br>&#125; <br></code></pre></td></tr></table></figure>

<p>伴随着最小的cpu开销和内存，这个技术能够高效的绘制大量的同种几何体，并且是很多场景的理想使用方式。唯一的缺点就是需要硬件支持并且不能简单的支持蒙皮。</p>
<p>为了实现蒙皮，可能需要为所有的instance把蒙皮骨骼信息保存在贴图上，需要为正确的instance获取正确的骨骼，并且要保证texture fectch技术可用（Geometry instancing API需要，ShaderModel 3.0支持）。这个方案看起来很有吸引力，但是性能有待测试。</p>

      
      <p align="right"><a class="morebtn" href="/2022/09/19/RTR/GPU%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AFInside_Geometry_Instancing/" title="">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fas fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/8/"><i class="fas fa-angle-right" aria-label="下一页"></i></a>
  </nav>
  
  
  

<div class="comments" id="comments">
  
  
  
</div>



  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control"/>
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/avatar.jpg" alt="leinlin">
  
  <h1 class="author-name">leinlin</h1>
  <h2 class="author-description"></h2>
  <div class="site-count">
    
    
    
    
    <div class="categories-count count-block">
      <div class="site-count-title">分类</div>
      <div><a href="/categories/">11</a></div>
    </div>
    
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    <hr>
    <div class="social-link sidebar-item">
      <div><i class="far fa-address-card"></i>社交链接</p></div>
      <ul>
        
        <li><i class="fab fa-github"></i><a href="https://leinlin.github.com/" target="_blank">GitHub</a></li>
        
      </ul>
    </div>
    
    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <button id="back-to-top"><i class="fas fa-angle-double-up" aria-label="回到顶部"></i></button>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">leinlin</span><span class="year"><i class="far fa-copyright"></i>2022</span>
        </div>
        
        <div class="busuanzi">
          <span id="busuanzi_container_site_pv"><i class="fas fa-eye" aria-label="站点点击量" aria-hidden="false"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user" aria-label="站点用户数" aria-hidden="false"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv" aria-label="页面点击量" aria-hidden="false"></span></span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
