<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    
    <meta name="keywords" content="leinlin, ARIA, Hexo">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="leinlin的小笔记" type="application/atom+xml" />
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-light.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/clipboard.min.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    
    <script defer type="text/javascript" src="https://cdn.staticfile.org/MathJax/MathJax-2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code"]
      }
    });
    </script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += " has-jax";
      }
    });
    </script>
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var cb = null;
      var els = $(".post figure.highlight");
      if (els.length) {
        // Enabled Hexo highlight line number.
        $(els).each(function (i, e) {
          // $(e).before("<button class=\"copy button\">复制</button>");
          $(e).before([
            "<div class=\"code-titlebar\">",
              "<div class=\"titlebar-left\">",
                "<button class=\"copy\">复制</button>",
              "</div>",
            "</div>"
          ].join(""));
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              return trigger.parentNode.parentNode.nextElementSibling.firstChild.firstChild.firstChild.lastChild.firstChild.firstChild;
          }
        });
      } else {
        // Disabled Hexo highlight line number.
        els = $(".post pre code");
        $(els).each(function (i, e) {
          // Add button before pre, not code.
          // $(e).parent().before("<button class=\"copy button\">复制</button>");
          $(e).before([
            "<div class=\"code-titlebar\">",
              "<div class=\"titlebar-left\">",
                "<button class=\"copy\" >复制</button>",
              "</div>",
              "<div class=\"titlebar-right\">",
                "<button class=\"button-dot dot-minimize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-maximize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-close\" aria-label=\"Decoration\"></button>",
              "</div>",
            "</div>"
          ].join(""));
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              return trigger.parentNode.parentNode.nextElementSibling;
          }
        });
      }
      cb.on("success", function (e) {
        e.clearSelection();
        var trigger = e.trigger;
        // Change button text as a user tip.
        trigger.innerHTML = "已复制";
        $(trigger).addClass("copied");
        // Change button text back;
        setTimeout(function () {
          trigger.innerHTML = "复制";
          $(trigger).removeClass("copied");
        }, 1500);
      });
    });
    </script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>leinlin的小笔记</title>
  <meta name="generator" content="Hexo 6.2.0"></head>
  <body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"  data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">leinlin的小笔记</a></h1>
        <h2 class="subtitle"></h2>
      </div>
      
    </div>
    <nav id="nav" class="nav">
      <a id="nav-toggle" class="nav-toggle" aria-hidden="true"><i class="fas fa-bars" aria-label="切换导航栏"></i></a>
      <ul id="menu" role="menubar" aria-hidden="false">
        
        <li role="menuitem"><a href="/"><i class="fas fa-home"></i><span class="menu-text">首页</span></a></li>
        
        <li role="menuitem"><a href="/categories/"><i class="fas fa-th-list"></i><span class="menu-text">分类</span></a></li>
        
      </ul>
    </nav>
  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            

<div id="index" class="index page">
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/HDRPsource/4.LitShader%E5%88%86%E6%9E%90/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/HDRPsource/4.LitShader%E5%88%86%E6%9E%90/" itemprop="url">Shader代码分析</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/HDRPSource/" itemprop="url" rel="index"><span itemprop="name">HDRPSource</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="Shader代码分析"><a href="#Shader代码分析" class="headerlink" title="Shader代码分析"></a>Shader代码分析</h1><p>unity HDRP的所有shader的内容都集中在了Lit Shader当中。Shader Graph等内容都是使用的相同的底层结构。</p>
<p>现在我对Lit的整个过程、内部结构和Shader参数进行分析，了解一下新的Shader是如何运作的。</p>
<p>在文档2当中我们看到了目前包括的所有的Shader Pass</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs hlsl">public static readonly string s_EmptyStr = &quot;&quot;;<br>public static readonly string s_ForwardStr = &quot;Forward&quot;;<br>public static readonly string s_DepthOnlyStr = &quot;DepthOnly&quot;;<br>public static readonly string s_DepthForwardOnlyStr = &quot;DepthForwardOnly&quot;;<br>public static readonly string s_ForwardOnlyStr = &quot;ForwardOnly&quot;;<br>public static readonly string s_GBufferStr = &quot;GBuffer&quot;;<br>public static readonly string s_GBufferWithPrepassStr = &quot;GBufferWithPrepass&quot;;<br>public static readonly string s_SRPDefaultUnlitStr = &quot;SRPDefaultUnlit&quot;;<br>public static readonly string s_MotionVectorsStr = &quot;MotionVectors&quot;;<br>public static readonly string s_DistortionVectorsStr = &quot;DistortionVectors&quot;;<br>public static readonly string s_TransparentDepthPrepassStr = &quot;TransparentDepthPrepass&quot;;<br>public static readonly string s_TransparentBackfaceStr = &quot;TransparentBackface&quot;;<br>public static readonly string s_TransparentDepthPostpassStr = &quot;TransparentDepthPostpass&quot;;<br>public static readonly string s_MetaStr = &quot;Meta&quot;;<br>public static readonly string s_ShadowCasterStr = &quot;ShadowCaster&quot;;<br>public static readonly string s_MeshDecalsStr = &quot;DBufferMesh&quot;;<br></code></pre></td></tr></table></figure>

<p>其中主要的包括GBuffer、Forward、DepthOnly、ShadowCaster。现在我们依次对着几个Pass进行分析。</p>
<p>上面每一个Pass的具体代码都在下面的目录中：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">\Packages\hrdp\Runtime\RenderPipeline\ShaderPass<br></code></pre></td></tr></table></figure>

<p>具体的代码结构基本一致，下面以GbufferPass 进行说明</p>
<h2 id="GBuffer-Pass"><a href="#GBuffer-Pass" class="headerlink" title="GBuffer Pass"></a>GBuffer Pass</h2><p>Gbuffer在Lit当中的完整内容：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">Pass<br>&#123;<br>    Name <span class="hljs-string">&quot;GBuffer&quot;</span>  <span class="hljs-comment">// Name is not used</span><br>    Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;GBuffer&quot;</span> &#125;<br>    <span class="hljs-comment">// 剪裁模式和深度测试可以进行设置</span><br>    <span class="hljs-comment">// 深入写入必然开启</span><br>    Cull [_CullMode]<br>    ZTest [_ZTestGBuffer]<br>    Stencil<br>    &#123;<br>        WriteMask [_StencilWriteMask]<br>        Ref  [_StencilRef]<br>        Comp Always<br>        Pass Replace<br>    &#125;<br><br>    HLSLPROGRAM<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ DEBUG_DISPLAY</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ LIGHTMAP_ON</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ DIRLIGHTMAP_COMBINED</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ DYNAMICLIGHTMAP_ON</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ SHADOWS_SHADOWMASK</span><br>    <span class="hljs-comment">// Setup DECALS_OFF so the shader stripper can remove variants</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile DECALS_OFF DECALS_3RT DECALS_4RT</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ LIGHT_LAYERS</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _ALPHATEST_ON</span><br>    <span class="hljs-comment">// When we have alpha test, we will force a depth prepass so we always bypass the clip instruction in the GBuffer</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> SHADERPASS SHADERPASS_GBUFFER</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl&quot;</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/ShaderPass/LitSharePass.hlsl&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitData.hlsl&quot;</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassGBuffer.hlsl&quot;</span></span><br><br>    ENDHLSL<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面Include的文件当中包括大量的函数和工具。其中和Gbuffer相关的主要Vert和Frag函数在<strong>ShaderPassGBuffer.hlsl</strong>文件当中。</p>
<p>这部分主要定义了<strong>Vert</strong>和<strong>Frag</strong>函数，以及<strong>曲面细分</strong>。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> SHADERPASS != SHADERPASS_GBUFFER</span><br><span class="hljs-meta">#<span class="hljs-keyword">error</span> SHADERPASS_is_not_correctly_define</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// 这个Include文件当中包括了顶点数据格式的转换。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/VertMesh.hlsl&quot;</span></span><br><br>PackedVaryingsType <span class="hljs-title function_">Vert</span><span class="hljs-params">(AttributesMesh inputMesh)</span><br>&#123;<br>    VaryingsType varyingsType;<br>  <span class="hljs-comment">//这里包括了坐标空间的转换。和一些必要的参数计算。世界坐标法线、世界坐标位置等等</span><br>    varyingsType.vmesh = VertMesh(inputMesh);<br>  	<span class="hljs-comment">// 调整传递用的结构体，节省空间</span><br>    <span class="hljs-keyword">return</span> PackVaryingsType(varyingsType);<br>&#125;<br><span class="hljs-comment">// 这部分主要是曲面细分</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> TESSELLATION_ON</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Frag</span><span class="hljs-params">(  PackedVaryingsToPS packedInput,</span><br><span class="hljs-params">            OUTPUT_GBUFFER(outGBuffer)</span><br><span class="hljs-params">            #ifdef _DEPTHOFFSET_ON</span><br><span class="hljs-params">            , out <span class="hljs-type">float</span> outputDepth : SV_Depth</span><br><span class="hljs-params">            #endif</span><br><span class="hljs-params">            )</span><br>&#123;<br>	<span class="hljs-comment">// 解析出数据</span><br>    FragInputs input = UnpackVaryingsMeshToFragInputs(packedInput.vmesh);<br><br>    <span class="hljs-comment">// input.positionSS is SV_Position</span><br>    PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> VARYINGS_NEED_POSITION_WS</span><br>    float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-comment">// Unused</span><br>    float3 V = float3(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// Avoid the division by 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    SurfaceData surfaceData;<br>    BuiltinData builtinData;<br>    GetSurfaceAndBuiltinData(input, V, posInput, surfaceData, builtinData);<br><br>    ENCODE_INTO_GBUFFER(surfaceData, builtinData, posInput.positionSS, outGBuffer);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _DEPTHOFFSET_ON</span><br>    outputDepth = posInput.deviceDepth;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>###VertMesh.hlsl</p>
<p>比较重要的内容为<strong>VertMesh.hlsl</strong>这个文件：主要定义了顶点片段着色器的输入输出和输入输出的拆包和解包。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">PackVaryingsType 、UnpackVaryingsMeshToFragInputs：<span class="hljs-comment">//输出的拆包和解包函数</span><br>VertMesh：设置顶点参数  包括：法线、切线、世界坐标、纹理坐标、剪裁空间坐标等<br></code></pre></td></tr></table></figure>

<h3 id="GetSurfaceAndBuiltinData"><a href="#GetSurfaceAndBuiltinData" class="headerlink" title="GetSurfaceAndBuiltinData"></a>GetSurfaceAndBuiltinData</h3><p>这个是对纹理的采样和计算。通过不同的宏，控制了纹理采样、顶点混合、视差、Lod等等内容。</p>
<p>##LitData.hlsl与LayeredLitData.hlsl</p>
<p>这两个文件中包括了纹理采样计算的主要内容：<strong>GetSurfaceAndBuiltinData函数</strong></p>
<p>重要的数据结构,根据宏来判断使用那种数据结构，记录了所有和纹理坐标相关的信息，包括Planar&#x2F;Triplanar&#x2F;Uv和多层UV，细节纹理等信息，每一层具体内容记录在：UVMapping结构中。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LayerTexCoord</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LAYERED_LIT_SHADER</span><br>    UVMapping base;<br>    UVMapping details;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    UVMapping base0;<br>	...<br>    UVMapping details0;<br>	...<br>    UVMapping blendMask;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    float3 vertexNormalWS; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> store also object normal map for object triplanar</span><br>    float3 triplanarWeights;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SURFACE_GRADIENT</span><br>    float3 vertexTangentWS0, vertexBitangentWS0;.<br>    ...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="GetSurfaceAndBuiltinData-1"><a href="#GetSurfaceAndBuiltinData-1" class="headerlink" title="GetSurfaceAndBuiltinData"></a>GetSurfaceAndBuiltinData</h3><p>这个函数主要作用是通过Frag的输入信息，计算纹理坐标。输出纹理采样和混合结果。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">GetSurfaceAndBuiltinData</span><span class="hljs-params">(FragInputs input, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData)</span><br>&#123;<br><span class="hljs-comment">// Lod CrossFade</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LOD_FADE_CROSSFADE </span><br>    uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); /<br>    LODDitheringTransition(fadeMaskSeed, unity_LODFade.x);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">//双面处理</span><br>    ApplyDoubleSidedFlipOrMirror(input); <span class="hljs-comment">// Apply double sided flip on the vertex normal</span><br><span class="hljs-comment">// 根据配置计算纹理坐标：Planer、Triplanar、Tiling\offset等内容。</span><br>    LayerTexCoord layerTexCoord;<br>    ZERO_INITIALIZE(LayerTexCoord, layerTexCoord);<br>    GetLayerTexCoord(input, layerTexCoord);<br>  <br><span class="hljs-comment">// 这里是视差贴图，计算纹理偏移</span><br>    <span class="hljs-type">float</span> depthOffset = ApplyPerPixelDisplacement(input, V, layerTexCoord);<br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _DEPTHOFFSET_ON</span><br>    ApplyDepthOffsetPositionInput(V, depthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">// 根据计算出的纹理坐标和视差编译对纹理进行采样。</span><br>    float3 normalTS;<br>    float3 bentNormalTS;<br>    float3 bentNormalWS;<br>    <span class="hljs-type">float</span> alpha = GetSurfaceData(input, layerTexCoord, surfaceData, normalTS, bentNormalTS);<br>    GetNormalWS(input, normalTS, surfaceData.normalWS);<br><br>    <span class="hljs-comment">// Use bent normal to sample GI if available</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _BENTNORMALMAP</span><br>    GetNormalWS(input, bentNormalTS, bentNormalWS);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    bentNormalWS = surfaceData.normalWS;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    surfaceData.geomNormalWS = input.worldToTangent[<span class="hljs-number">2</span>];<br><br><span class="hljs-comment">// 从采样的结果到处高光等内容的</span><br>...<br>  <br>  <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Caution: surfaceData must be fully initialize before calling GetBuiltinData</span><br>    GetBuiltinData(input, V, posInput, surfaceData, alpha, bentNormalWS, depthOffset, builtinData);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="GetSurfaceData"><a href="#GetSurfaceData" class="headerlink" title="GetSurfaceData"></a>GetSurfaceData</h3><h3 id="GetBuiltinData"><a href="#GetBuiltinData" class="headerlink" title="GetBuiltinData"></a>GetBuiltinData</h3>
      
      <p align="right"><a class="morebtn" href="/2022/07/09/HDRPsource/4.LitShader%E5%88%86%E6%9E%90/" title="Shader代码分析">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/HDRPsource/5.UnityHDRP%E5%85%89%E6%BA%90%E9%85%8D%E7%BD%AE/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/HDRPsource/5.UnityHDRP%E5%85%89%E6%BA%90%E9%85%8D%E7%BD%AE/" itemprop="url">Unity光源配置：Tiled And Cluster</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/HDRPSource/" itemprop="url" rel="index"><span itemprop="name">HDRPSource</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="Unity光源配置：Tiled-And-Cluster"><a href="#Unity光源配置：Tiled-And-Cluster" class="headerlink" title="Unity光源配置：Tiled And Cluster"></a>Unity光源配置：Tiled And Cluster</h1><p>unity最新的HDRP中采用了Cluster和Tiled的光源配置，这里主要记录光源是如何从Unity当中的Light配置设置到最终Shader的对应Pass当中的。</p>
<p>Cluster是把视锥体看做三维体素，每个体素当中计算影响这个体素的光线，就和Volumetric Fog一样的原理。</p>
<p>Tiled是把屏幕分成格子，对每个格子计算影响这个格子的光源。</p>
<p>Tiled光照列表的计算总共分为三步：</p>
<ol>
<li>计算光照列表的所有凸包</li>
<li>使用凸包，计算bigtile的光照列表的大致计算。</li>
<li>使用fplt进行更精细的光照列表计算。</li>
</ol>
<p>##Tile光照列表计算</p>
<p>下面是光源计算,为每一个Tile生成光照列表：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-type">void</span> <span class="hljs-title function_">BuildGPULightListsCommon</span><span class="hljs-params">(HDCamera hdCamera, CommandBuffer cmd, RenderTargetIdentifier cameraDepthBufferRT, RenderTargetIdentifier stencilTextureRT, <span class="hljs-type">bool</span> skyEnabled)</span><br>&#123;<br>  var camera = hdCamera.camera;<br>  <span class="hljs-comment">// 计算光照列表开始</span><br>  cmd.BeginSample(<span class="hljs-string">&quot;Build Light List&quot;</span>);<br><br>  var w = (<span class="hljs-type">int</span>)hdCamera.screenSize.x;<br>  var h = (<span class="hljs-type">int</span>)hdCamera.screenSize.y;<br>  s_TempScreenDimArray[<span class="hljs-number">0</span>] = w;<br>  s_TempScreenDimArray[<span class="hljs-number">1</span>] = h;<br>  <span class="hljs-comment">//首先设置Tile的大小  64,64</span><br>  var numBigTilesX = (w + <span class="hljs-number">63</span>) / <span class="hljs-number">64</span>;<br>  var numBigTilesY = (h + <span class="hljs-number">63</span>) / <span class="hljs-number">64</span>;<br><br>  <br>  <span class="hljs-comment">// 计算各种矩阵：</span><br>  m_LightListProjMatrices[<span class="hljs-number">0</span>] = <br>  m_LightListProjscrMatrices[<span class="hljs-number">0</span>] = <br>  m_LightListInvProjscrMatrices[<span class="hljs-number">0</span>] =<br>  m_LightListProjHMatrices[<span class="hljs-number">0</span>] = ;<br>  m_LightListInvProjHMatrices[<span class="hljs-number">0</span>] = ；<br>     <br>  <span class="hljs-comment">// 如果有光源 ，计算所有光源的AABB包围盒 ：见shader：lightlistbuild-bigtile.compute</span><br>   <span class="hljs-keyword">if</span> (m_lightCount != <span class="hljs-number">0</span>)<br>   &#123;<br>	<span class="hljs-comment">//第一步计算AABB</span><br>     var genAABBKernel = isProjectionOblique ? s_GenAABBKernel_Oblique : s_GenAABBKernel;<br><br>     <span class="hljs-comment">// 是否正交</span><br>     cmd.SetComputeIntParam(buildScreenAABBShader, HDShaderIDs.g_isOrthographic, isOrthographic ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>	 <span class="hljs-comment">// 光源数量</span><br>     cmd.SetComputeIntParam(buildScreenAABBShader, HDShaderIDs.g_iNrVisibLights, m_lightCount);<br>     <span class="hljs-comment">// 光源凸包数据</span><br>     cmd.SetComputeBufferParam(buildScreenAABBShader, genAABBKernel, HDShaderIDs.g_data, s_ConvexBoundsBuffer);<br>	<span class="hljs-comment">// 矩阵数组</span><br>     cmd.SetComputeMatrixArrayParam(buildScreenAABBShader, HDShaderIDs.g_mProjectionArr, m_LightListProjHMatrices);<br>     cmd.SetComputeMatrixArrayParam(buildScreenAABBShader, HDShaderIDs.g_mInvProjectionArr, m_LightListInvProjHMatrices);<br><br>     <span class="hljs-comment">// AABB结果</span><br>     cmd.SetComputeBufferParam(buildScreenAABBShader, genAABBKernel, HDShaderIDs.g_vBoundsBuffer, s_AABBBoundsBuffer);<br><br>     <span class="hljs-type">int</span> tgY = (<span class="hljs-type">int</span>)hdCamera.numEyes;<br>     <br>     <span class="hljs-comment">// 提交计算</span><br>     cmd.DispatchCompute(buildScreenAABBShader, genAABBKernel, (m_lightCount + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>, tgY, <span class="hljs-number">1</span>);<br>   &#125;<br>  <br>  <br>  <span class="hljs-comment">// 粗糙的Tile计算。</span><br>  <span class="hljs-comment">// enable coarse 2D pass on 64x64 tiles (used for both fptl and clustered).</span><br>  <span class="hljs-keyword">if</span> (m_FrameSettings.lightLoopSettings.enableBigTilePrepass)<br>  &#123;<br>    cmd.SetComputeIntParam(buildPerBigTileLightListShader, HDShaderIDs.g_iNrVisibLights, m_lightCount);<br>    cmd.SetComputeIntParam(buildPerBigTileLightListShader, HDShaderIDs.g_isOrthographic, isOrthographic ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>    cmd.SetComputeIntParams(buildPerBigTileLightListShader, HDShaderIDs.g_viDimensions, s_TempScreenDimArray);<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> These two aren&#x27;t actually used...</span><br>    cmd.SetComputeIntParam(buildPerBigTileLightListShader, HDShaderIDs._EnvLightIndexShift, m_lightList.lights.Count);<br>    cmd.SetComputeIntParam(buildPerBigTileLightListShader, HDShaderIDs._DecalIndexShift, m_lightList.lights.Count + m_lightList.envLights.Count);<br><br>    cmd.SetComputeMatrixArrayParam(buildPerBigTileLightListShader, HDShaderIDs.g_mScrProjectionArr, m_LightListProjscrMatrices);<br>    cmd.SetComputeMatrixArrayParam(buildPerBigTileLightListShader, HDShaderIDs.g_mInvScrProjectionArr, m_LightListInvProjscrMatrices);<br><br>    cmd.SetComputeFloatParam(buildPerBigTileLightListShader, HDShaderIDs.g_fNearPlane, camera.nearClipPlane);<br>    cmd.SetComputeFloatParam(buildPerBigTileLightListShader, HDShaderIDs.g_fFarPlane, camera.farClipPlane);<br>    cmd.SetComputeBufferParam(buildPerBigTileLightListShader, s_GenListPerBigTileKernel, HDShaderIDs.g_vLightList, s_BigTileLightList);<br>    cmd.SetComputeBufferParam(buildPerBigTileLightListShader, s_GenListPerBigTileKernel, HDShaderIDs.g_vBoundsBuffer, s_AABBBoundsBuffer);<br>    cmd.SetComputeBufferParam(buildPerBigTileLightListShader, s_GenListPerBigTileKernel, HDShaderIDs._LightVolumeData, s_LightVolumeDataBuffer);<br>    cmd.SetComputeBufferParam(buildPerBigTileLightListShader, s_GenListPerBigTileKernel, HDShaderIDs.g_data, s_ConvexBoundsBuffer);<br><br>    <span class="hljs-type">int</span> tgZ = (<span class="hljs-type">int</span>)hdCamera.numEyes;<br>    cmd.DispatchCompute(buildPerBigTileLightListShader, s_GenListPerBigTileKernel, numBigTilesX, numBigTilesY, tgZ);<br>  &#125;<br>  <br>  <br>  <span class="hljs-comment">// fplt计算</span><br>  <span class="hljs-comment">// optimized for opaques only</span><br>    <span class="hljs-keyword">if</span> (m_FrameSettings.lightLoopSettings.isFptlEnabled)<br>    &#123;<br>      var genListPerTileKernel = isProjectionOblique ? s_GenListPerTileKernel_Oblique : s_GenListPerTileKernel;<br><br>      cmd.SetComputeIntParam(buildPerTileLightListShader, HDShaderIDs.g_isOrthographic, isOrthographic ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>      cmd.SetComputeIntParams(buildPerTileLightListShader, HDShaderIDs.g_viDimensions, s_TempScreenDimArray);<br>      cmd.SetComputeIntParam(buildPerTileLightListShader, HDShaderIDs._EnvLightIndexShift, m_lightList.lights.Count);<br>      cmd.SetComputeIntParam(buildPerTileLightListShader, HDShaderIDs._DecalIndexShift, m_lightList.lights.Count + m_lightList.envLights.Count);<br>      cmd.SetComputeIntParam(buildPerTileLightListShader, HDShaderIDs.g_iNrVisibLights, m_lightCount);<br><br>      cmd.SetComputeBufferParam(buildPerTileLightListShader, genListPerTileKernel, HDShaderIDs.g_vBoundsBuffer, s_AABBBoundsBuffer);<br>      cmd.SetComputeBufferParam(buildPerTileLightListShader, genListPerTileKernel, HDShaderIDs._LightVolumeData, s_LightVolumeDataBuffer);<br>      cmd.SetComputeBufferParam(buildPerTileLightListShader, genListPerTileKernel, HDShaderIDs.g_data, s_ConvexBoundsBuffer);<br><br>      cmd.SetComputeMatrixParam(buildPerTileLightListShader, HDShaderIDs.g_mScrProjection, m_LightListProjscrMatrices[<span class="hljs-number">0</span>]);<br>      cmd.SetComputeMatrixParam(buildPerTileLightListShader, HDShaderIDs.g_mInvScrProjection, m_LightListInvProjscrMatrices[<span class="hljs-number">0</span>]);<br><br>      cmd.SetComputeTextureParam(buildPerTileLightListShader, genListPerTileKernel, HDShaderIDs.g_depth_tex, cameraDepthBufferRT);<br>      cmd.SetComputeBufferParam(buildPerTileLightListShader, genListPerTileKernel, HDShaderIDs.g_vLightList, s_LightList);<br>      <span class="hljs-keyword">if</span> (m_FrameSettings.lightLoopSettings.enableBigTilePrepass)<br>        cmd.SetComputeBufferParam(buildPerTileLightListShader, genListPerTileKernel, HDShaderIDs.g_vBigTileLightList, s_BigTileLightList);<br><br>      <span class="hljs-keyword">if</span> (enableFeatureVariants)<br>      &#123;<br>        uint baseFeatureFlags = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (m_lightList.directionalLights.Count &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>          baseFeatureFlags |= (uint)LightFeatureFlags.Directional;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (skyEnabled)<br>        &#123;<br>          baseFeatureFlags |= (uint)LightFeatureFlags.Sky;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!m_FrameSettings.lightLoopSettings.enableComputeMaterialVariants)<br>        &#123;<br>          baseFeatureFlags |= LightDefinitions.s_MaterialFeatureMaskFlags;<br>        &#125;<br>        cmd.SetComputeIntParam(buildPerTileLightListShader, HDShaderIDs.g_BaseFeatureFlags, (<span class="hljs-type">int</span>)baseFeatureFlags);<br>        cmd.SetComputeBufferParam(buildPerTileLightListShader, genListPerTileKernel, HDShaderIDs.g_TileFeatureFlags, s_TileFeatureFlags);<br>      &#125;<br><br>      cmd.DispatchCompute(buildPerTileLightListShader, genListPerTileKernel, numTilesX, numTilesY, <span class="hljs-number">1</span>);<br>    &#125;<br>  <br>  <span class="hljs-comment">// Cluster 计算</span><br>  VoxelLightListGeneration(cmd, hdCamera, m_LightListProjscrMatrices, m_LightListInvProjscrMatrices, cameraDepthBufferRT);<br><br>  <span class="hljs-comment">// 计算光照列表结束</span><br>  cmd.EndSample(<span class="hljs-string">&quot;Build Light List&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="光源包围盒计算"><a href="#光源包围盒计算" class="headerlink" title="光源包围盒计算"></a>光源包围盒计算</h3><p>计算屏幕空间光源包围盒的shader：scrbound.compute</p>
<p>原始代码中记录的包围盒的类型，中心和几个扩展方向</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SFiniteLightBound</span></span><br><span class="hljs-class">&#123;</span><br>    public Vector3 boxAxisX;<br>    public Vector3 boxAxisY;<br>    public Vector3 boxAxisZ;<br>    public Vector3 center;        <span class="hljs-comment">// a center in camera space inside the bounding volume of the light source.</span><br>    public Vector2 scaleXY;<br>    public <span class="hljs-type">float</span> radius;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>每个光源都有一个上面的结构体，从一个统一的结构体转换到屏幕对齐的AABB包围盒。</p>
<p>###BigTile光照列表计算</p>
<p>计算BigTile光照列表的compute shader：</p>
<p>使用了三种方法：</p>
<ol>
<li>包围盒相交。</li>
<li>球形相交。</li>
<li>CullByExactEdgeTests：这个还没有看。</li>
</ol>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 根据NR_THREADS作为不同线程的采样间隔，计算互斥的光源信息</span><br>[numthreads(NR_THREADS, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-type">void</span> <span class="hljs-title function_">BigTileLightListGen</span><span class="hljs-params">(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID)</span><br>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  这里的计算是每个Tile一次提交，每个提交，多个Thread并行。，每个Thread处理不想交的一组灯光。</span><br><span class="hljs-comment">  */</span><br>  	<span class="hljs-comment">// 这个是Tile的ID</span><br>    uint eyeIndex = u3GroupID.z;<br>    uint2 tileIDX = u3GroupID.xy;<br>  	<span class="hljs-comment">//  这个是每个Tile当中的threadID</span><br>    uint t=threadID;<br>  <br>	<span class="hljs-comment">// 计算每个Tile的实际大小。</span><br>    uint iWidth = g_viDimensions.x;<br>    uint iHeight = g_viDimensions.y;<br>    uint nrBigTilesX = (iWidth+<span class="hljs-number">63</span>)/<span class="hljs-number">64</span>;<br>    uint nrBigTilesY = (iHeight+<span class="hljs-number">63</span>)/<span class="hljs-number">64</span>;<br>	<br>  <span class="hljs-comment">// 线程共享，只让第一个线程进行初始化操作。</span><br>    <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>) lightOffs = <span class="hljs-number">0</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(SHADER_API_XBOXONE) &amp;&amp; !defined(SHADER_API_PSSL)</span><br>    GroupMemoryBarrierWithGroupSync();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// Raw pixel coordinates of tile</span><br>    uint2 viTilLL = <span class="hljs-number">64</span>*tileIDX;<br>    uint2 viTilUR = min( viTilLL+uint2(<span class="hljs-number">64</span>,<span class="hljs-number">64</span>), uint2(iWidth, iHeight) );            <span class="hljs-comment">// not width and height minus 1 since viTilUR represents the end of the tile corner.</span><br><br>    <span class="hljs-comment">// 每个tile的包围盒</span><br>    float2 vTileLL = float2(viTilLL.x/(<span class="hljs-type">float</span>) iWidth, viTilLL.y/(<span class="hljs-type">float</span>) iHeight);<br>    float2 vTileUR = float2(viTilUR.x/(<span class="hljs-type">float</span>) iWidth, viTilUR.y/(<span class="hljs-type">float</span>) iHeight);<br><br>    <span class="hljs-comment">// build coarse list using AABB</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=(<span class="hljs-type">int</span>) t; l&lt;(<span class="hljs-type">int</span>) g_iNrVisibLights; l += NR_THREADS)<br>    &#123;<br>      	<span class="hljs-comment">// 获取灯光包围盒信息</span><br>        <span class="hljs-type">const</span> ScreenSpaceBoundsIndices boundsIndices = GenerateScreenSpaceBoundsIndices(l, g_iNrVisibLights, eyeIndex);<br>      	<span class="hljs-comment">// 灯光的包围盒信息</span><br>        <span class="hljs-type">const</span> float2 vMi = g_vBoundsBuffer[boundsIndices.min].xy;<br>        <span class="hljs-type">const</span> float2 vMa = g_vBoundsBuffer[boundsIndices.max].xy;<br>		<br>  	    <span class="hljs-comment">// 灯光的包围盒和tile的包围盒是否相交</span><br>        <span class="hljs-keyword">if</span>( all(vMa&gt;vTileLL) &amp;&amp; all(vMi&lt;vTileUR))<br>        &#123;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> uInc = <span class="hljs-number">1</span>;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> uIndex;<br>          	<span class="hljs-comment">// 原子求和操作，让lightOffs加1.</span><br>            InterlockedAdd(lightOffs, uInc, uIndex);<br>			<span class="hljs-comment">// 通过加到当前Tile的灯光列表，uIndex是组间不同的。</span><br>            <span class="hljs-keyword">if</span>(uIndex&lt;MAX_NR_BIGTILE_LIGHTS) lightsListLDS[uIndex] = l;    <br>        &#125;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> <span class="hljs-comment">/*!defined(SHADER_API_XBOXONE) &amp;&amp; */</span>!defined(SHADER_API_PSSL)</span><br>    GroupMemoryBarrierWithGroupSync();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  	<span class="hljs-comment">// 计算实际的光照数。</span><br>    <span class="hljs-type">int</span> iNrCoarseLights = min(lightOffs,MAX_NR_BIGTILE_LIGHTS);<br><br>  <span class="hljs-comment">// 球形相交计算，如果球形没有相交， 则把lightlist中记录原来相交的id变成uint_max</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PERFORM_SPHERICAL_INTERSECTION_TESTS</span><br>    SphericalIntersectionTests( t, iNrCoarseLights, float2(min(viTilLL.xy+uint2(<span class="hljs-number">64</span>/<span class="hljs-number">2</span>,<span class="hljs-number">64</span>/<span class="hljs-number">2</span>), uint2(iWidth<span class="hljs-number">-1</span>, iHeight<span class="hljs-number">-1</span>))), eyeIndex );<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> EXACT_EDGE_TESTS</span><br>    CullByExactEdgeTests(t, iNrCoarseLights, viTilLL.xy, viTilUR.xy, eyeIndex);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 灯光按类型排序</span><br>    SORTLIST(lightsListLDS, iNrCoarseLights, MAX_NR_BIG_TILE_LIGHTS_PLUS_ONE, t, NR_THREADS);<br><br>    <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>) lightOffs = <span class="hljs-number">0</span>;<br>    GroupMemoryBarrierWithGroupSync();<br>  <span class="hljs-comment">// 重新计算光照数量</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=t; i&lt;iNrCoarseLights; i+=NR_THREADS) <br>      <span class="hljs-keyword">if</span>(lightsListLDS[i]&lt;(uint)g_iNrVisibLights) <br>        InterlockedAdd(lightOffs, <span class="hljs-number">1</span>);<br>    GroupMemoryBarrierWithGroupSync();<br>    iNrCoarseLights = lightOffs;<br><span class="hljs-comment">// 计算当前tile的索引</span><br>    <span class="hljs-type">int</span> offs = tileIDX.y*nrBigTilesX + tileIDX.x + (eyeIndex * nrBigTilesX * nrBigTilesY);<br>	<span class="hljs-comment">//最终的光照列表，放到记录光照的列表当中，所有的tile的光照列表存在一个大的tile当中。</span><br>    <span class="hljs-keyword">for</span>(i=t; i&lt;(iNrCoarseLights+<span class="hljs-number">1</span>); i+=NR_THREADS)<br>        g_vLightList[MAX_NR_BIG_TILE_LIGHTS_PLUS_ONE*offs + i] = i==<span class="hljs-number">0</span> ? iNrCoarseLights : lightsListLDS[max(i<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>)];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="FPTL"><a href="#FPTL" class="headerlink" title="FPTL"></a>FPTL</h3><p>精准的判断每个tile当中的光照列表,这里使用了更加精细的tile划分（16*16），相对于bigtile还会对Z值进行比较。原本的Bigtile 只是用了屏幕方向的xy。</p>
<p>同时加入了光源类型相关的操作。</p>
<p>shader使用:lightlistbuild.compute</p>
<p>compute Shader使用的kernel确定：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (GetFeatureVariantsEnabled())<br>&#123;<br>  s_GenListPerTileKernel = buildPerTileLightListShader.FindKernel(m_FrameSettings.lightLoopSettings.enableBigTilePrepass ? <span class="hljs-string">&quot;TileLightListGen_SrcBigTile_FeatureFlags&quot;</span> : <span class="hljs-string">&quot;TileLightListGen_FeatureFlags&quot;</span>);<br>  s_GenListPerTileKernel_Oblique = buildPerTileLightListShader.FindKernel(m_FrameSettings.lightLoopSettings.enableBigTilePrepass ? <span class="hljs-string">&quot;TileLightListGen_SrcBigTile_FeatureFlags_Oblique&quot;</span> : <span class="hljs-string">&quot;TileLightListGen_FeatureFlags_Oblique&quot;</span>);<br><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>  s_GenListPerTileKernel = buildPerTileLightListShader.FindKernel(m_FrameSettings.lightLoopSettings.enableBigTilePrepass ? <span class="hljs-string">&quot;TileLightListGen_SrcBigTile&quot;</span> : <span class="hljs-string">&quot;TileLightListGen&quot;</span>);<br>  s_GenListPerTileKernel_Oblique = buildPerTileLightListShader.FindKernel(m_FrameSettings.lightLoopSettings.enableBigTilePrepass ? <span class="hljs-string">&quot;TileLightListGen_SrcBigTile_Oblique&quot;</span> : <span class="hljs-string">&quot;TileLightListGen_Oblique&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>FPTLshader</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><code class="hljs c">[numthreads(NR_THREADS, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-type">void</span> <span class="hljs-title function_">LIGHTLISTGEN</span><span class="hljs-params">(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID)</span><br>&#123;<br>    uint2 tileIDX = u3GroupID.xy;<br>    uint t=threadID;<br><br>    <span class="hljs-keyword">if</span>(t&lt;MAX_NR_COARSE_ENTRIES)<br>        prunedList[t]=<span class="hljs-number">0</span>;<br><br>    uint iWidth = g_viDimensions.x;<br>    uint iHeight = g_viDimensions.y;<br>    uint nrTilesX = (iWidth+<span class="hljs-number">15</span>)/<span class="hljs-number">16</span>;<br>    uint nrTilesY = (iHeight+<span class="hljs-number">15</span>)/<span class="hljs-number">16</span>;<br>    uint nrTiles = nrTilesX * nrTilesY; <span class="hljs-comment">// Precompute?</span><br><br>    <span class="hljs-comment">// build tile scr boundary</span><br>    <span class="hljs-type">const</span> uint uFltMax = <span class="hljs-number">0x7f7fffff</span>;  <span class="hljs-comment">// FLT_MAX as a uint</span><br>    <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>)<br>    &#123;<br>        ldsZMin = uFltMax;<br>        ldsZMax = <span class="hljs-number">0</span>;<br>        lightOffs = <span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(SHADER_API_XBOXONE) &amp;&amp; !defined(SHADER_API_PSSL)</span><br>    GroupMemoryBarrierWithGroupSync();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    uint2 viTilLL = <span class="hljs-number">16</span>*tileIDX;<br><br>    <span class="hljs-comment">// establish min and max depth first</span><br>    <span class="hljs-type">float</span> dpt_mi=asfloat(uFltMax), dpt_ma=<span class="hljs-number">0.0</span>;<br>	<span class="hljs-comment">// 计算包含深度的包围盒。</span><br>    float4 vLinDepths;<br>    &#123;<br>        <span class="hljs-comment">// Fetch depths and calculate min/max</span><br>        UNITY_UNROLL<br>        <span class="hljs-title function_">for</span><span class="hljs-params">(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)</span><br>        &#123;<br>            <span class="hljs-type">int</span> idx = i * NR_THREADS + t;<br>            uint2 uCrd = min( uint2(viTilLL.x+(idx&amp;<span class="hljs-number">0xf</span>), viTilLL.y+(idx&gt;&gt;<span class="hljs-number">4</span>)), uint2(iWidth<span class="hljs-number">-1</span>, iHeight<span class="hljs-number">-1</span>) );<br>            <span class="hljs-type">const</span> <span class="hljs-type">float</span> fDepth = FetchDepth(g_depth_tex, uCrd);<br>            vLinDepths[i] = GetLinearDepth(uCrd+float2(<span class="hljs-number">0.5</span>,<span class="hljs-number">0.5</span>), fDepth);<br>            <span class="hljs-keyword">if</span>(fDepth&lt;VIEWPORT_SCALE_Z)     <span class="hljs-comment">// if not skydome</span><br>            &#123;<br>                dpt_mi = min(fDepth, dpt_mi);<br>                dpt_ma = max(fDepth, dpt_ma);<br>            &#125;<br>        &#125;<br><br>        InterlockedMax(ldsZMax, asuint(dpt_ma));<br>        InterlockedMin(ldsZMin, asuint(dpt_mi));<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(SHADER_API_XBOXONE) &amp;&amp; !defined(SHADER_API_PSSL)</span><br>        GroupMemoryBarrierWithGroupSync();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br><br><br>    float3 vTileLL = float3(viTilLL.x/(<span class="hljs-type">float</span>) iWidth, viTilLL.y/(<span class="hljs-type">float</span>) iHeight, asfloat(ldsZMin));<br>    float3 vTileUR = float3((viTilLL.x+<span class="hljs-number">16</span>)/(<span class="hljs-type">float</span>) iWidth, (viTilLL.y+<span class="hljs-number">16</span>)/(<span class="hljs-type">float</span>) iHeight, asfloat(ldsZMax));<br>    vTileUR.xy = min(vTileUR.xy,float2(<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>)).xy;<br><br>	<span class="hljs-comment">// 使用aabb计算粗糙的光照列表。</span><br>    <span class="hljs-comment">// build coarse list using AABB</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_TWO_PASS_TILED_LIGHTING</span><br>    <span class="hljs-type">const</span> uint log2BigTileToTileRatio = firstbithigh(<span class="hljs-number">64</span>) - firstbithigh(<span class="hljs-number">16</span>);<br><br>    <span class="hljs-type">int</span> NrBigTilesX = (nrTilesX+((<span class="hljs-number">1</span>&lt;&lt;log2BigTileToTileRatio)<span class="hljs-number">-1</span>))&gt;&gt;log2BigTileToTileRatio;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> bigTileIdx = (tileIDX.y&gt;&gt;log2BigTileToTileRatio)*NrBigTilesX + (tileIDX.x&gt;&gt;log2BigTileToTileRatio);       <span class="hljs-comment">// map the idx to 64x64 tiles</span><br>    <span class="hljs-type">int</span> nrBigTileLights = g_vBigTileLightList[MAX_NR_BIG_TILE_LIGHTS_PLUS_ONE*bigTileIdx+<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l0=(<span class="hljs-type">int</span>) t; l0&lt;(<span class="hljs-type">int</span>) nrBigTileLights; l0 += NR_THREADS)<br>    &#123;<br>        <span class="hljs-type">int</span> l = g_vBigTileLightList[MAX_NR_BIG_TILE_LIGHTS_PLUS_ONE*bigTileIdx+l0+<span class="hljs-number">1</span>];<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=(<span class="hljs-type">int</span>) t; l&lt;(<span class="hljs-type">int</span>) g_iNrVisibLights; l += NR_THREADS)<br>    &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-comment">// Skip density volumes (lights are sorted by category). <span class="hljs-doctag">TODO:</span> improve data locality</span><br>        <span class="hljs-keyword">if</span> (_LightVolumeData[l].lightCategory == LIGHTCATEGORY_DENSITY_VOLUME) &#123; <span class="hljs-keyword">break</span>; &#125;<br><br>        <span class="hljs-type">const</span> float3 vMi = g_vBoundsBuffer[l].xyz;<br>        <span class="hljs-type">const</span> float3 vMa = g_vBoundsBuffer[l+g_iNrVisibLights].xyz;<br>		<span class="hljs-comment">// 包围盒在xyz方向上同时判断相交。</span><br>        <span class="hljs-keyword">if</span>( all(vMa&gt;vTileLL) &amp;&amp; all(vMi&lt;vTileUR))<br>        &#123;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> uInc = <span class="hljs-number">1</span>;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> uIndex;<br>            InterlockedAdd(lightOffs, uInc, uIndex);<br>            <span class="hljs-keyword">if</span>(uIndex&lt;MAX_NR_COARSE_ENTRIES) coarseList[uIndex] = l;        <span class="hljs-comment">// add to light list</span><br>        &#125;<br>    &#125;<br>      <span class="hljs-comment">// 粗糙的光照列表计算结束</span><br><br>      <span class="hljs-comment">// FPTL进行精细调整。</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FINE_PRUNING_ENABLED</span><br>    <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">2</span>) ldsDoesLightIntersect[t] = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(SHADER_API_XBOXONE) &amp;&amp; !defined(SHADER_API_PSSL)</span><br>    GroupMemoryBarrierWithGroupSync();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<br>    <span class="hljs-type">int</span> iNrCoarseLights = min(lightOffs,MAX_NR_COARSE_ENTRIES);<br><br>      <span class="hljs-comment">// 球形相交和 bigtile类似</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PERFORM_SPHERICAL_INTERSECTION_TESTS</span><br>    iNrCoarseLights = SphericalIntersectionTests( t, iNrCoarseLights, float2(min(viTilLL.xy+uint2(<span class="hljs-number">16</span>/<span class="hljs-number">2</span>,<span class="hljs-number">16</span>/<span class="hljs-number">2</span>), uint2(iWidth<span class="hljs-number">-1</span>, iHeight<span class="hljs-number">-1</span>))) );<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> FINE_PRUNING_ENABLED</span><br>    &#123;<br>      <span class="hljs-comment">// 修改保存位置</span><br>        <span class="hljs-keyword">if</span>((<span class="hljs-type">int</span>)t&lt;iNrCoarseLights) prunedList[t] = coarseList[t];<br>        <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>) ldsNrLightsFinal=iNrCoarseLights;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    &#123;<br>        <span class="hljs-comment">// initializes ldsNrLightsFinal with the number of accepted lights.</span><br>        <span class="hljs-comment">// all accepted entries delivered in prunedList[].</span><br>        FinePruneLights(t, iNrCoarseLights, viTilLL, vLinDepths);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-comment">// 光照类型相关，t是线程号。每个线程对应一个类型。</span><br>    <span class="hljs-keyword">if</span>(t&lt;CATEGORY_LIST_SIZE) ldsCategoryListCount[t]=<span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_FEATURE_FLAGS</span><br>    <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>) ldsFeatureFlags=<span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(SHADER_API_XBOXONE) &amp;&amp; !defined(SHADER_API_PSSL)</span><br>    GroupMemoryBarrierWithGroupSync();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br>     <span class="hljs-comment">// 统计每种类型光源的数量</span><br>    <span class="hljs-type">int</span> nrLightsCombinedList = min(ldsNrLightsFinal,MAX_NR_COARSE_ENTRIES);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=t; i&lt;nrLightsCombinedList; i+=NR_THREADS)<br>    &#123;<br>        InterlockedAdd(ldsCategoryListCount[_LightVolumeData[prunedList[i]].lightCategory], <span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_FEATURE_FLAGS</span><br>        InterlockedOr(ldsFeatureFlags, _LightVolumeData[prunedList[i]].featureFlags);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br><br>      <span class="hljs-comment">// 光照排序，减少在计算光照过程中分支的情况</span><br>    <span class="hljs-comment">// sort lights (gives a more efficient execution in both deferred and tiled forward lighting).</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(SHADER_API_XBOXONE) &amp;&amp; !defined(SHADER_API_PSSL)</span><br>    SORTLIST(prunedList, nrLightsCombinedList, MAX_NR_COARSE_ENTRIES, t, NR_THREADS);<br>    <span class="hljs-comment">//MERGESORTLIST(prunedList, coarseList, nrLightsCombinedList, t, NR_THREADS);</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_FEATURE_FLAGS</span><br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-number">0</span>)<br>    &#123;<br>        uint featureFlags = ldsFeatureFlags | g_BaseFeatureFlags;<br>        <span class="hljs-comment">// In case of back</span><br>        <span class="hljs-keyword">if</span>(ldsZMax &lt; ldsZMin)   <span class="hljs-comment">// is background pixel</span><br>        &#123;<br>            <span class="hljs-comment">// There is no stencil usage with compute path, featureFlags set to 0 is use to have fast rejection of tile in this case. It will still execute but will do nothing</span><br>            featureFlags = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        g_TileFeatureFlags[tileIDX.y * nrTilesX + tileIDX.x] = featureFlags;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// write lights to global buffers</span><br>    <span class="hljs-type">int</span> localOffs=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> offs = tileIDX.y*nrTilesX + tileIDX.x;<br><br>    <span class="hljs-comment">// All our cull data are in the same list, but at render time envLights are separated so we need to shift the index</span><br>    <span class="hljs-comment">// to make it work correctly</span><br>    <span class="hljs-type">int</span> shiftIndex[CATEGORY_LIST_SIZE];<br>    ZERO_INITIALIZE_ARRAY(<span class="hljs-type">int</span>, shiftIndex, CATEGORY_LIST_SIZE);<br>    shiftIndex[CATEGORY_LIST_SIZE - <span class="hljs-number">2</span>] = _EnvLightIndexShift;<br>    shiftIndex[CATEGORY_LIST_SIZE - <span class="hljs-number">1</span>] = _DecalIndexShift;<br>	<br>      <span class="hljs-comment">//将光源按照类型顺序写入到全局结果中。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> category=<span class="hljs-number">0</span>; category&lt;CATEGORY_LIST_SIZE; category++)<br>    &#123;<br>        <span class="hljs-type">int</span> nrLightsFinal = ldsCategoryListCount[category];<br>        <span class="hljs-type">int</span> nrLightsFinalClamped = nrLightsFinal&lt;MAX_NR_PRUNED_ENTRIES ? nrLightsFinal : MAX_NR_PRUNED_ENTRIES;<br><br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> nrDWords = ((nrLightsFinalClamped+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=(<span class="hljs-type">int</span>) t; l&lt;(<span class="hljs-type">int</span>) nrDWords; l += NR_THREADS)<br>        &#123;<br>            <span class="hljs-comment">// We remap the prunedList index to the original LightData / EnvLightData indices</span><br>            uint uLow = l==<span class="hljs-number">0</span> ? nrLightsFinalClamped : prunedList[max(<span class="hljs-number">0</span>,<span class="hljs-number">2</span> * l - <span class="hljs-number">1</span> + localOffs)] - shiftIndex[category];<br>            uint uHigh = prunedList[<span class="hljs-number">2</span> * l + <span class="hljs-number">0</span> + localOffs] - shiftIndex[category];<br><br>            g_vLightList[<span class="hljs-number">16</span>*offs + l] = (uLow&amp;<span class="hljs-number">0xffff</span>) | (uHigh&lt;&lt;<span class="hljs-number">16</span>);<br>        &#125;<br><br>        localOffs += nrLightsFinal;<br>        offs += (nrTilesX*nrTilesY);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


      
      <p align="right"><a class="morebtn" href="/2022/07/09/HDRPsource/5.UnityHDRP%E5%85%89%E6%BA%90%E9%85%8D%E7%BD%AE/" title="Unity光源配置：Tiled And Cluster">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/HDRPsource/6.HDRPDecal/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/HDRPsource/6.HDRPDecal/" itemprop="url">HDRP Decal</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/HDRPSource/" itemprop="url" rel="index"><span itemprop="name">HDRPSource</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <p>#HDRP Decal</p>
<p>Unity提供了贴花功能，现在能够控制Decal具体要投射到哪些物体上。。</p>
<p>Decal 渲染最开始需要一个深度图：</p>
<p>需要透视Decal的物体会渲染</p>
<p>m_DepthOnlyPassNames ：渲染深度</p>
<p>m_DepthForwardOnlyPassNames：渲染法线</p>
<p>Decal需要进行可以进行异步剪裁</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableDecals)<br>&#123;<br>  <span class="hljs-comment">// decal system needs to be updated with current camera, it needs it to set up culling and light list generation parameters</span><br>  DecalSystem.instance.CurrentCamera = camera;<br>  DecalSystem.instance.BeginCull();<br>&#125;<br><br><span class="hljs-comment">// 其他计算。</span><br><br>m_DbufferManager.enableDecals = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (hdCamera.frameSettings.enableDecals)<br>&#123;<br>  using (new ProfilingSample(cmd, <span class="hljs-string">&quot;DBufferPrepareDrawData&quot;</span>, CustomSamplerId.DBufferPrepareDrawData.GetSampler()))<br>  &#123;<br>    DecalSystem.instance.EndCull();<br>    m_DbufferManager.enableDecals = <span class="hljs-literal">true</span>;              <span class="hljs-comment">// mesh decals are renderers managed by c++ runtime and we have no way to query if any are visible, so set to true</span><br>    DecalSystem.instance.UpdateCachedMaterialData();    <span class="hljs-comment">// textures, alpha or fade distances could&#x27;ve changed</span><br>    DecalSystem.instance.CreateDrawData();              <span class="hljs-comment">// prepare data is separate from draw</span><br>    DecalSystem.instance.UpdateTextureAtlas(cmd);       <span class="hljs-comment">// as this is only used for transparent pass, would&#x27;ve been nice not to have to do this if no transparent renderers are visible, needs to happen after CreateDrawData</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="关于Dbuffer"><a href="#关于Dbuffer" class="headerlink" title="关于Dbuffer"></a>关于Dbuffer</h2><p>如果没有Decals 则不需要Dbuffer，Decal是需要渲染到Dbuffer当中的，Dbuffer的结构类似Gbuffer.</p>
<p>下面是Dbuffer渲染代码：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">RenderDBuffer</span><span class="hljs-params">(HDCamera hdCamera, CommandBuffer cmd, ScriptableRenderContext renderContext, CullResults cullResults)</span><br>&#123;<br>  <span class="hljs-comment">// 不需要Decals 则不需要Dbuffer</span><br>  <span class="hljs-keyword">if</span> (!hdCamera.frameSettings.enableDecals)<br>    <span class="hljs-keyword">return</span>;<br><br><br>	<span class="hljs-comment">// 深度信息 放入Depth Buffer（从 m_SharedRTManager.GetDepthStencilBuffer() =&gt; m_SharedRTManager.GetDepthTexture()）</span><br>    CopyDepthBufferIfNeeded(cmd);<br><br>    <span class="hljs-type">bool</span> rtCount4 = m_Asset.GetRenderPipelineSettings().decalSettings.perChannelMask;<br>    <span class="hljs-comment">// Depth texture is now ready, bind it.</span><br>  <span class="hljs-comment">// 设置全局纹理</span><br>    cmd.SetGlobalTexture(HDShaderIDs._CameraDepthTexture, m_SharedRTManager.GetDepthTexture());<br>  <span class="hljs-comment">// 清理纹理设置成渲染目标，内部这只了多个渲染目标，m_SharedRTManager.GetDepthStencilBuffer()只是指定了深度用哪一个。</span><br>    m_DbufferManager.ClearAndSetTargets(cmd, hdCamera, rtCount4, m_SharedRTManager.GetDepthStencilBuffer());<br>    renderContext.ExecuteCommandBuffer(cmd);<br>  <br>  <span class="hljs-comment">// 这里cmd重置了</span><br>    cmd.Clear();<br><br>    DrawRendererSettings drawSettings = new DrawRendererSettings(hdCamera.camera, HDShaderPassNames.s_EmptyName)<br>    &#123;<br>      rendererConfiguration = <span class="hljs-number">0</span>,<br>      sorting = &#123; flags = SortFlags.CommonOpaque &#125;<br>    &#125;;<br><br>  <span class="hljs-comment">// 渲染目标数量 决定渲染方式，即需要绘制的pass名字</span><br>    <span class="hljs-keyword">if</span> (rtCount4)<br>    &#123;<br>      drawSettings.SetShaderPassName(<span class="hljs-number">0</span>, HDShaderPassNames.s_MeshDecalsMName);<br>      drawSettings.SetShaderPassName(<span class="hljs-number">1</span>, HDShaderPassNames.s_MeshDecalsAOName);<br>      drawSettings.SetShaderPassName(<span class="hljs-number">2</span>, HDShaderPassNames.s_MeshDecalsMAOName);<br>      drawSettings.SetShaderPassName(<span class="hljs-number">3</span>, HDShaderPassNames.s_MeshDecalsSName);<br>      drawSettings.SetShaderPassName(<span class="hljs-number">4</span>, HDShaderPassNames.s_MeshDecalsMSName);<br>      drawSettings.SetShaderPassName(<span class="hljs-number">5</span>, HDShaderPassNames.s_MeshDecalsAOSName);<br>      drawSettings.SetShaderPassName(<span class="hljs-number">6</span>, HDShaderPassNames.s_MeshDecalsMAOSName);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      drawSettings.SetShaderPassName(<span class="hljs-number">0</span>, HDShaderPassNames.s_MeshDecals3RTName);<br>    &#125;<br><br>  <span class="hljs-comment">// 所有不透明物体</span><br>    FilterRenderersSettings filterRenderersSettings = new FilterRenderersSettings(<span class="hljs-literal">true</span>)<br>    &#123;<br>      renderQueueRange = HDRenderQueue.k_RenderQueue_AllOpaque<br>    &#125;;<br>	<br>  <span class="hljs-comment">// 先绘制一次可见物体的decallpass，这个是说不用DecalProjector的方式的Decal？ 经过测试这句话即使注释掉也没反应。</span><br>    renderContext.DrawRenderers(cullResults.visibleRenderers, ref drawSettings, filterRenderersSettings);<br>  <br>  <span class="hljs-comment">// 这里再用cmd绘制是直接绘制到屏幕上了，收集相同材质的Decal，使用Instance绘制Decal，Shader是Decal，Dbuffer 有多个渲染目标和深度</span><br>    DecalSystem.instance.RenderIntoDBuffer(cmd);<br>    m_DbufferManager.UnSetHTile(cmd);<br>    m_DbufferManager.SetHTileTexture(cmd);  <span class="hljs-comment">// mask per 8x8 tile used for optimization when looking up dbuffer values</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


      
      <p align="right"><a class="morebtn" href="/2022/07/09/HDRPsource/6.HDRPDecal/" title="HDRP Decal">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/HDRPsource/8.LitShader/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/HDRPsource/8.LitShader/" itemprop="url">LitShader参数</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/HDRPSource/" itemprop="url" rel="index"><span itemprop="name">HDRPSource</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="LitShader参数"><a href="#LitShader参数" class="headerlink" title="LitShader参数"></a>LitShader参数</h1><p><strong>特殊设置：</strong></p>
<p>Alpha CutOff  ：  透明阈值， Alpha值使用BaseColor,a通道，小于这个Alpha值得的位置完全透明。</p>
<p>Use Alpha Test :  是否使用Alpha Test。</p>
<p>Use PIXEL DisPlacement: 是否使用高度图。</p>
<p>Height Min&#x2F;Max Samples  :  高度图最小&#x2F;大采样次数。（决定了效果）</p>
<p>Height Lod Threshold：高度图 Lod，决定效果。</p>
<p><strong>纹理设置：</strong></p>
<p>BaseColor ：基础颜色默认白色，会和BaseColorMap的颜色相乘。</p>
<p>BaseColorMap ：就是漫反射贴图，对应Albedo。</p>
<p>Tiling&#x2F;Offset :决定了所有贴图的便偏移和混合。</p>
<p>NormalMap：切线空间法线贴图。</p>
<p>HeightMAp：当Use PIXEL DisPlacement勾选的时候，这个高度贴图才会生效。使用r通道。</p>
<p>Height Amplitude：高度的强弱。和HeightMap的结果相乘。</p>
<p>MaskMap：分为四个通道，R(Metalness)G(AO)B(Detial)A(Smoothness).</p>
<p>Metallic : 和金属度相乘。</p>
<p>Smothness : 这个值目前无效。（在HDRP中如果使用MaskMap则Smothness无效，这里为了兼容HDRP）</p>
<p>SmoothnessRemapMin ：金属度映射下限</p>
<p>SmoothnessRemapMax ： 金属度映射上限</p>
<p>AORemapMin ：AO映射下限</p>
<p>AORemapMax：AO映射上限</p>
<h1 id="LayeredLit参数"><a href="#LayeredLit参数" class="headerlink" title="LayeredLit参数"></a>LayeredLit参数</h1><p><strong>特殊设置</strong></p>
<p>LayerMaskMap ：混合贴图。</p>
<p>Alpha CutOff：见LitShader，使用的Alpha值来自于所有BaseColor，a通道的混合结果。</p>
<p>Use Alpha Test :  是否使用Alpha Test。</p>
<p>Use PIXEL DisPlacement: 是否使用高度图。高度来自于高度图r通道混合的结果。</p>
<p>Use Mul VERTEX Color Blend： 使用乘法顶点色混合。权重&#x3D;顶点色和LayerMaskMap相乘</p>
<p>Use Add VERTEX Color Blend： 使用加法顶点色混合。权重&#x3D;（顶点色 - 0.5）和和LayerMaskMap相加</p>
<p><strong>注：权重a表示0层，rgb分别表示123层。</strong></p>
<p><strong>Use Mul VERTEX Color Blend&#x2F;Use Add VERTEX Color Blend:选择一个就可以，或者都不选。如果都选则第一个生效。</strong></p>
<p><strong>纹理设置</strong></p>
<p>这部分内容同LitShader一致，只不过最终的值是通过<strong>Mask和顶点色的权重</strong>混合的结果。</p>
<p><strong>纹理层设置</strong></p>
<p>Layer Number Three：使用三层。</p>
<p>Layer Number Four：使用四层。</p>
<p><strong>Layer Number Four&#x2F;Layer Number Three:选择一个就可以</strong></p>
<h1 id="TiledLayeredLit"><a href="#TiledLayeredLit" class="headerlink" title="TiledLayeredLit"></a>TiledLayeredLit</h1><p>和LayeredLit全部一致。只是多了一张纹理和两个参数：</p>
<p>Normal（RG）AO（B) Alpaha(A)：RG通道表示法线的两个通道，B表示AO，A是alpha通道。</p>
<p>注：这个纹理的alpha通道和各层的混合结果的aplpha同时生效。</p>
<p>Main Normal Fractor：各层纹理和这个主纹理的混合程度，0表示完全使用主纹理，1表示完全混合主纹理和细节纹理。</p>
<p>AOFractor：表示主纹理AO所占最终AO比例。0表示不适用主纹理AO。</p>

      
      <p align="right"><a class="morebtn" href="/2022/07/09/HDRPsource/8.LitShader/" title="LitShader参数">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/HDRPsource/7.%E5%85%89%E6%BA%90%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/HDRPsource/7.%E5%85%89%E6%BA%90%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/" itemprop="url">光源配置设置</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/HDRPSource/" itemprop="url" rel="index"><span itemprop="name">HDRPSource</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="光源配置设置"><a href="#光源配置设置" class="headerlink" title="光源配置设置"></a>光源配置设置</h1><p>由于HDRP使用了新的光源配置方式，所以一些设置会影响性能，这里介绍一下主要的设置。</p>
<p>主要的设置主要在HDRenderPipelineAsset</p>
<p>和光源配置相关的参数，主要三个：</p>
<p>Asumc Compute &#x2F; Build Light List in Async  光照列表和阴影同步计算。</p>
<p>Light Loop Settings &#x2F; FPTL For Forward Opaque 光照列表与Deferred相同,提供给前向物体 </p>
<p>BigTile Prepass  在FPTL(16<em>16)之前进行粗糙Tile计算 64</em>64。</p>

      
      <p align="right"><a class="morebtn" href="/2022/07/09/HDRPsource/7.%E5%85%89%E6%BA%90%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/" title="光源配置设置">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/HDRPsource/9.OcclusionProbe/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/HDRPsource/9.OcclusionProbe/" itemprop="url">Occlusion Probe Shader部分</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/HDRPSource/" itemprop="url" rel="index"><span itemprop="name">HDRPSource</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="Occlusion-Probe-Shader部分"><a href="#Occlusion-Probe-Shader部分" class="headerlink" title="Occlusion Probe Shader部分"></a>Occlusion Probe Shader部分</h1><p>OcclusionProbe主要是用来计算环境光遮挡的探针，基本的原理是生成一个体素划分的块区域，在体素中填充阴影遮挡情况。在后在Shader当中提取计算的体素信息。</p>
<p>有两个步骤需要实现：</p>
<p>1.需要使用Unity自带的Progressive烘焙工具，<strong>手动</strong>烘焙环境贴图。</p>
<p>2.需要保证产生遮挡的物体，开启lightmap static</p>
<p>3.需要保证Baked Global Illumination是选择的。</p>
<p>4.烘焙完成，需要修改Shader读取这些体素信息。</p>
<h2 id="Shader中SurfaceData的区别"><a href="#Shader中SurfaceData的区别" class="headerlink" title="Shader中SurfaceData的区别"></a>Shader中SurfaceData的区别</h2><p>HDRP中SurfaceData数据保存了遮挡信息</p>
<p>主要的区别是三个Occlusion值</p>
<ol>
<li>skyOcclusion </li>
<li>treeOcclusion</li>
<li>grassOcclusion</li>
</ol>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">struct SurfaceData<br>&#123;<br>    uint materialFeatures;<br>    float3 baseColor;<br>    float specularOcclusion;<br>    float3 normalWS;<br>    float perceptualSmoothness;<br>    float ambientOcclusion;<br>    float metallic;<br>    float coatMask;<br>    float3 specularColor;<br>    uint diffusionProfile;<br>    float subsurfaceMask;<br>    float thickness;<br>    float3 tangentWS;<br>    float anisotropy;<br>    float iridescenceThickness;<br>    float iridescenceMask;<br>    float ior;<br>    float3 transmittanceColor;<br>    float atDistance;<br>    float transmittanceMask;<br>    // (BofD)中的内容<br>    float skyOcclusion; // Occlusion Prode的遮挡信息<br>    float treeOcclusion;  // Occlusion Prode2的遮挡信息<br>    // 还有一个grassOcclusion 是一个临时变量没有出现<br>&#125;;<br>================================<br>struct SurfaceData<br>&#123;<br>    uint materialFeatures;<br>    float3 baseColor;<br>    float specularOcclusion;<br>    float3 normalWS;<br>    float perceptualSmoothness;<br>    float ambientOcclusion;<br>    float metallic;<br>    float coatMask;<br>    float3 specularColor;<br>    uint diffusionProfile;<br>    float subsurfaceMask;<br>    float thickness;<br>    float3 tangentWS;<br>    float anisotropy;<br>    float iridescenceThickness;<br>    float iridescenceMask;<br>    float3 geomNormalWS;<br>    float ior;<br>    float3 transmittanceColor;<br>    float atDistance;<br>    float transmittanceMask;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="Occlusion遮挡信息的读取"><a href="#Occlusion遮挡信息的读取" class="headerlink" title="Occlusion遮挡信息的读取"></a>Occlusion遮挡信息的读取</h2><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">主要获取到SurfaceData的位置是LitDaysIndividualLayer.  (BofD)<br>  ...<br><span class="hljs-comment">//forest-begin: sky occlusion</span><br>    <span class="hljs-type">float</span> grassOcclusion;<br>    surfaceData.skyOcclusion = SampleSkyOcclusion(input.positionRWS, grassOcclusion);<br><span class="hljs-comment">//forest-end</span><br><span class="hljs-comment">//forest-begin: Tree Occlusion</span><br>    float4 treeOcclusionInput = float4(input.texCoord2.xy, input.texCoord3.xy);<br>    surfaceData.treeOcclusion = GetTreeOcclusion(input.positionRWS, treeOcclusionInput);<br><span class="hljs-comment">//forest-end:</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">// #if !defined(LAYERED_LIT_SHADER)</span></span><br> 	...<br></code></pre></td></tr></table></figure>

<p>上面涉及到的具体的函数</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 _AtmosphericScatteringSunVector;<br><span class="hljs-comment">// 通过树的参数计算得到。</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">GetTreeOcclusion</span><span class="hljs-params">(float3 positionRWS, float4 treeOcclusionInput)</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_ANIM_SINGLE_PIVOT_COLOR) || defined(_ANIM_HIERARCHY_PIVOT)</span><br>	<span class="hljs-keyword">if</span>(_UseTreeOcclusion) &#123;<br>		float3 positionWS = GetAbsolutePositionWS(positionRWS);<br>		<span class="hljs-type">float</span> treeWidth = _Tree12Width == <span class="hljs-number">0</span> ? <span class="hljs-number">1.f</span> : saturate((positionWS.y - UNITY_MATRIX_M._m13) / _Tree12Width);<br>		<span class="hljs-type">float</span> treeDO = lerp(_TreeDO, _TreeDO2, treeWidth);<br>		<span class="hljs-type">float</span> treeAO = lerp(_TreeAO, _TreeAO2, treeWidth);<br>		float4 lightDir = float4(-_AtmosphericScatteringSunVector * treeDO, treeAO);<br>		<span class="hljs-type">float</span> treeDOBias = lerp(_TreeDOBias, _TreeDOBias2, treeWidth);<br>		<span class="hljs-type">float</span> treeAOBias = lerp(_TreeAOBias, _TreeAOBias2, treeWidth);<br>		<span class="hljs-keyword">return</span> saturate(dot(saturate(treeOcclusionInput + float4(treeDOBias.rrr, treeAOBias)), lightDir));<br>	&#125;<br>	<span class="hljs-keyword">else</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1.f</span>;<br>	&#125;<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">SampleOcclusionProbes</span><span class="hljs-params">(float3 positionWS)</span><br>&#123;<br>    <span class="hljs-type">float</span> occlusionProbes = <span class="hljs-number">1</span>;<br>	<span class="hljs-comment">// 世界坐标转换到探针坐标</span><br>    float3 pos = mul(_OcclusionProbesWorldToLocalDetail, float4(positionWS, <span class="hljs-number">1</span>)).xyz;<br>	<br>  	<span class="hljs-comment">// 这里有两个三维纹理。一个细节一个全局</span><br>    UNITY_BRANCH<br>	<span class="hljs-title function_">if</span><span class="hljs-params">(all(pos &gt; <span class="hljs-number">0</span>) &amp;&amp; all(pos &lt; <span class="hljs-number">1</span>))</span><br>    &#123;<br>      	<span class="hljs-comment">// 采样三维纹理</span><br>		occlusionProbes = tex3D(_OcclusionProbesDetail, pos).a;<br>	&#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>		pos = mul(_OcclusionProbesWorldToLocal, float4(positionWS, <span class="hljs-number">1</span>)).xyz;<br>		occlusionProbes = tex3D(_OcclusionProbes, pos).a;<br>	&#125;<br><br>    <span class="hljs-keyword">return</span> occlusionProbes;<br>&#125;<br><br><span class="hljs-comment">// 草的环境光遮挡，这是二维纹理。</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">SampleGrassOcclusion</span><span class="hljs-params">(float2 terrainUV)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> lerp(<span class="hljs-number">1.0</span>, tex2D(_GrassOcclusion, terrainUV).a, _GrassOcclusionAmountTerrain);<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">SampleGrassOcclusion</span><span class="hljs-params">(float3 positionWS)</span><br>&#123;<br>    float3 pos = mul(_GrassOcclusionWorldToLocal, float4(positionWS, <span class="hljs-number">1</span>)).xyz;<br>    <span class="hljs-type">float</span> terrainHeight = tex2D(_GrassOcclusionHeightmap, pos.xz).a;<br>    <span class="hljs-type">float</span> height = pos.y - terrainHeight * _GrassOcclusionHeightRange;<br><br>    UNITY_BRANCH<br>    <span class="hljs-title function_">if</span><span class="hljs-params">(height &lt; _GrassOcclusionCullHeight)</span><br>    &#123;<br>        <span class="hljs-type">float</span> xz = lerp(<span class="hljs-number">1.0</span>, tex2D(_GrassOcclusion, pos.xz).a, _GrassOcclusionAmountGrass);<br>        <span class="hljs-keyword">return</span> saturate(xz + smoothstep(_GrassOcclusionHeightFadeBottom, _GrassOcclusionHeightFadeTop, height));<br><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 这里会返回grassOcclusion和SkyOcclusion两个内容</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">SampleSkyOcclusion</span><span class="hljs-params">(float3 positionRWS, out <span class="hljs-type">float</span> grassOcclusion)</span><br>&#123;<br>  	<span class="hljs-comment">// 获取世界坐标</span><br>    float3 positionWS = GetAbsolutePositionWS(positionRWS);<br>  	<span class="hljs-comment">// 从世界坐标采样体素块</span><br>    grassOcclusion = SampleGrassOcclusion(positionWS);<br>  <br>    <span class="hljs-keyword">return</span> grassOcclusion * SampleOcclusionProbes(positionWS);<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">SampleSkyOcclusion</span><span class="hljs-params">(float3 positionRWS, float2 terrainUV, out <span class="hljs-type">float</span> grassOcclusion)</span><br>&#123;<br>    float3 positionWS = GetAbsolutePositionWS(positionRWS);<br>    grassOcclusion = SampleGrassOcclusion(terrainUV);<br>    <span class="hljs-keyword">return</span> grassOcclusion * SampleOcclusionProbes(positionWS);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在可以知道三个信息的来源：</p>
<ol>
<li>skyOcclusion  来自三维纹理</li>
<li>treeOcclusion  通过树的参数计算得到</li>
<li>grassOcclusion 来自二维纹理</li>
</ol>
<h2 id="Occlusion遮挡信息的使用"><a href="#Occlusion遮挡信息的使用" class="headerlink" title="Occlusion遮挡信息的使用"></a>Occlusion遮挡信息的使用</h2><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//BuildinData中获取环境烘焙信息是使用了上面的采样结果。</span><br>SampleBakedGI函数出现了区别<br><span class="hljs-comment">// 所有的基础烘焙信息：</span><br><span class="hljs-comment">// LightMap：fully baked lightmap (static lightmap) + enlighten realtime lightmap (dynamic lightmap) 可以组合使用</span><br><span class="hljs-comment">// for each case we can have directional lightmap or not.</span><br><span class="hljs-comment">// lightprobe for dynamic/moving entity：</span><br><span class="hljs-comment">//探针类型：Either SH9 per object lightprobe or SH4 per pixel per object volume probe</span><br>float3 <span class="hljs-title function_">SampleBakedGI</span><span class="hljs-params">(float3 positionRWS, float3 normalWS, float2 uvStaticLightmap, float2 uvDynamicLightmap)</span><br>&#123;<br><span class="hljs-comment">// If there is no lightmap, it assume lightprobe</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)</span><br><br>    <span class="hljs-keyword">if</span> (unity_ProbeVolumeParams.x == <span class="hljs-number">0.0</span>)<br>    &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> pass a tab of coefficient instead!</span><br>        real4 SHCoefficients[<span class="hljs-number">7</span>];<br>        SHCoefficients[<span class="hljs-number">0</span>] = unity_SHAr;<br>        SHCoefficients[<span class="hljs-number">1</span>] = unity_SHAg;<br>        SHCoefficients[<span class="hljs-number">2</span>] = unity_SHAb;<br>        SHCoefficients[<span class="hljs-number">3</span>] = unity_SHBr;<br>        SHCoefficients[<span class="hljs-number">4</span>] = unity_SHBg;<br>        SHCoefficients[<span class="hljs-number">5</span>] = unity_SHBb;<br>        SHCoefficients[<span class="hljs-number">6</span>] = unity_SHC;<br><br>        <span class="hljs-keyword">return</span> SampleSH9(SHCoefficients, normalWS);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> SampleProbeVolumeSH4(TEXTURE3D_PARAM(unity_ProbeVolumeSH, samplerunity_ProbeVolumeSH), positionRWS, normalWS, GetProbeVolumeWorldToObject(),<br>        unity_ProbeVolumeParams.y, unity_ProbeVolumeParams.z, unity_ProbeVolumeMin.xyz, unity_ProbeVolumeSizeInv.xyz);<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>	<span class="hljs-comment">//定义了光照贴图，进行贴图内容的读取</span><br>    float3 bakeDiffuseLighting = float3(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UNITY_LIGHTMAP_FULL_HDR</span><br>    <span class="hljs-type">bool</span> useRGBMLightmap = <span class="hljs-literal">false</span>;<br>    float4 decodeInstructions = float4(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); <span class="hljs-comment">// Never used but needed for the interface since it supports gamma lightmaps</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">bool</span> useRGBMLightmap = <span class="hljs-literal">true</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(UNITY_LIGHTMAP_RGBM_ENCODING)</span><br>        float4 decodeInstructions = float4(<span class="hljs-number">34.493242</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); <span class="hljs-comment">// range^2.2 = 5^2.2, gamma = 2.2</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        float4 decodeInstructions = float4(<span class="hljs-number">2.0</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); <span class="hljs-comment">// range = 2.0^2.2 = 4.59</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-comment">// 每一种Light都可以分成方向烘焙和单一烘焙两种</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LIGHTMAP_ON</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DIRLIGHTMAP_COMBINED</span><br>        bakeDiffuseLighting += SampleDirectionalLightmap(TEXTURE2D_PARAM(unity_Lightmap, samplerunity_Lightmap),<br>                                                        TEXTURE2D_PARAM(unity_LightmapInd, samplerunity_Lightmap),<br>                                                        uvStaticLightmap, unity_LightmapST, normalWS, useRGBMLightmap, decodeInstructions);<br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        bakeDiffuseLighting += SampleSingleLightmap(TEXTURE2D_PARAM(unity_Lightmap, samplerunity_Lightmap), uvStaticLightmap, unity_LightmapST, useRGBMLightmap, decodeInstructions);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DYNAMICLIGHTMAP_ON</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DIRLIGHTMAP_COMBINED</span><br>        bakeDiffuseLighting += SampleDirectionalLightmap(TEXTURE2D_PARAM(unity_DynamicLightmap, samplerunity_DynamicLightmap),<br>                                                        TEXTURE2D_PARAM(unity_DynamicDirectionality, samplerunity_DynamicLightmap),<br>                                                        uvDynamicLightmap, unity_DynamicLightmapST, normalWS, <span class="hljs-literal">false</span>, decodeInstructions);<br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        bakeDiffuseLighting += SampleSingleLightmap(TEXTURE2D_PARAM(unity_DynamicLightmap, samplerunity_DynamicLightmap), uvDynamicLightmap, unity_DynamicLightmapST, <span class="hljs-literal">false</span>, decodeInstructions);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  	<span class="hljs-comment">// 俩个lightmap是相加的关系</span><br>    <span class="hljs-keyword">return</span> bakeDiffuseLighting;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><br><span class="hljs-comment">// 修改后的烘焙信息获取。</span><br>float3 <span class="hljs-title function_">SampleBakedGI</span><span class="hljs-params">(float3 positionRWS, float3 normalWS, float2 uvStaticLightmap, float2 uvDynamicLightmap, <span class="hljs-type">float</span> skyOcclusion, <span class="hljs-type">float</span> grassOcclusion, <span class="hljs-type">float</span> treeOcclusion)</span><br><span class="hljs-comment">//forest-end</span><br>&#123;<br>    <span class="hljs-comment">// If there is no lightmap, it assume lightprobe</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)</span><br>    <span class="hljs-keyword">if</span> (unity_ProbeVolumeParams.x == <span class="hljs-number">0.0</span>)<br>    &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> pass a tab of coefficient instead!</span><br>        real4 SHCoefficients[<span class="hljs-number">7</span>];<br>        SHCoefficients[<span class="hljs-number">0</span>] = unity_SHAr;<br>        SHCoefficients[<span class="hljs-number">1</span>] = unity_SHAg;<br>        SHCoefficients[<span class="hljs-number">2</span>] = unity_SHAb;<br>        SHCoefficients[<span class="hljs-number">3</span>] = unity_SHBr;<br>        SHCoefficients[<span class="hljs-number">4</span>] = unity_SHBg;<br>        SHCoefficients[<span class="hljs-number">5</span>] = unity_SHBb;<br>        SHCoefficients[<span class="hljs-number">6</span>] = unity_SHC;<br>		<br>      <span class="hljs-comment">// 这个累加计算了一个环境光的探针。</span><br><span class="hljs-comment">//forest-begin: sky occlusion</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> SKY_OCCLUSION</span><br>			SHCoefficients[<span class="hljs-number">0</span>] += _AmbientProbeSH[<span class="hljs-number">0</span>] * skyOcclusion;<br>			SHCoefficients[<span class="hljs-number">1</span>] += _AmbientProbeSH[<span class="hljs-number">1</span>] * skyOcclusion;<br>			SHCoefficients[<span class="hljs-number">2</span>] += _AmbientProbeSH[<span class="hljs-number">2</span>] * skyOcclusion;<br>			SHCoefficients[<span class="hljs-number">3</span>] += _AmbientProbeSH[<span class="hljs-number">3</span>] * skyOcclusion;<br>			SHCoefficients[<span class="hljs-number">4</span>] += _AmbientProbeSH[<span class="hljs-number">4</span>] * skyOcclusion;<br>			SHCoefficients[<span class="hljs-number">5</span>] += _AmbientProbeSH[<span class="hljs-number">5</span>] * skyOcclusion;<br>			SHCoefficients[<span class="hljs-number">6</span>] += _AmbientProbeSH[<span class="hljs-number">6</span>] * skyOcclusion;<br>       <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">//forest-end</span><br><br>		<span class="hljs-comment">// 同时还积累的树的环境光遮挡</span><br><span class="hljs-comment">//forest-begin: Tree occlusion</span><br>        <span class="hljs-keyword">return</span> SampleSH9(SHCoefficients, normalWS) * treeOcclusion;<br><span class="hljs-comment">//forest-end</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-comment">//这里只是多了一个树木的遮挡</span><br>        <span class="hljs-keyword">return</span> SampleProbeVolumeSH4(TEXTURE3D_PARAM(unity_ProbeVolumeSH, samplerunity_ProbeVolumeSH), positionRWS, normalWS, GetProbeVolumeWorldToObject(),<br><span class="hljs-comment">//forest-begin: Tree occlusion</span><br>            unity_ProbeVolumeParams.y, unity_ProbeVolumeParams.z, unity_ProbeVolumeMin, unity_ProbeVolumeSizeInv) * treeOcclusion;<br><span class="hljs-comment">//forest-end</span><br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br>    float3 bakeDiffuseLighting = float3(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UNITY_LIGHTMAP_FULL_HDR</span><br>    <span class="hljs-type">bool</span> useRGBMLightmap = <span class="hljs-literal">false</span>;<br>    float4 decodeInstructions = float4(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); <span class="hljs-comment">// Never used but needed for the interface since it supports gamma lightmaps</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">bool</span> useRGBMLightmap = <span class="hljs-literal">true</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(UNITY_LIGHTMAP_RGBM_ENCODING)</span><br>        float4 decodeInstructions = float4(<span class="hljs-number">34.493242</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); <span class="hljs-comment">// range^2.2 = 5^2.2, gamma = 2.2</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        float4 decodeInstructions = float4(<span class="hljs-number">2.0</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); <span class="hljs-comment">// range = 2.0^2.2 = 4.59</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LIGHTMAP_ON</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DIRLIGHTMAP_COMBINED</span><br>        bakeDiffuseLighting += SampleDirectionalLightmap(TEXTURE2D_PARAM(unity_Lightmap, samplerunity_Lightmap),<br>                                                        TEXTURE2D_PARAM(unity_LightmapInd, samplerunity_Lightmap),<br>                                                        uvStaticLightmap, unity_LightmapST, normalWS, useRGBMLightmap, decodeInstructions);<br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        bakeDiffuseLighting += SampleSingleLightmap(TEXTURE2D_PARAM(unity_Lightmap, samplerunity_Lightmap), uvStaticLightmap, unity_LightmapST, useRGBMLightmap, decodeInstructions);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DYNAMICLIGHTMAP_ON</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DIRLIGHTMAP_COMBINED</span><br>        bakeDiffuseLighting += SampleDirectionalLightmap(TEXTURE2D_PARAM(unity_DynamicLightmap, samplerunity_DynamicLightmap),<br>                                                        TEXTURE2D_PARAM(unity_DynamicDirectionality, samplerunity_DynamicLightmap),<br>                                                        uvDynamicLightmap, unity_DynamicLightmapST, normalWS, <span class="hljs-literal">false</span>, decodeInstructions);<br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        bakeDiffuseLighting += SampleSingleLightmap(TEXTURE2D_PARAM(unity_DynamicLightmap, samplerunity_DynamicLightmap), uvDynamicLightmap, unity_DynamicLightmapST, <span class="hljs-literal">false</span>, decodeInstructions);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-comment">// 这里只是多积累了一个草的环境光遮挡，也就是说LightProbe是给动态物体使用的</span><br><span class="hljs-comment">//forest-begin: sky occlusion</span><br>    <span class="hljs-keyword">return</span> bakeDiffuseLighting * grassOcclusion;<br><span class="hljs-comment">//forest-end</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>从上面的代码中我发现skyOcclusion只在lightprobe计算的时候生效，也就是他是给动态物体使用的!!!!</strong></p>
<p>现在三个Occlusion的作用就清楚了</p>
<ol>
<li>grassOcclusion 用于乘到每一个烘焙信息上</li>
<li>treeOcclusion 用于乘到每一个光照探针结果上</li>
<li>skyOcclusion  用于乘到动态光照探针SH9上</li>
</ol>
<h2 id="Shader部分总结"><a href="#Shader部分总结" class="headerlink" title="Shader部分总结"></a>Shader部分总结</h2><p>上面的内容只是Book of Death的使用方式，而我们可以自己修改应用位置，计算方法。</p>
<p>下面需要讨论这些Occlusion的参数是如何传递到Shader当中的。</p>
<h1 id="Occlusion-Prob-Script部分"><a href="#Occlusion-Prob-Script部分" class="headerlink" title="Occlusion Prob Script部分"></a>Occlusion Prob Script部分</h1><p>上面介绍了如何在Shader当中使用prob三维纹理内容，现在看一下脚本当中如何生成这些。</p>
<p>在BofD当中主要的脚本就是OcclusionProbes以及他对应的Editor代码</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">首先最终要的内容就是传递到unity当中参数。<br>    static class Uniforms<br>    &#123;<br>        internal static readonly int _AmbientProbeSH = Shader.PropertyToID(&quot;_AmbientProbeSH&quot;);<br>        internal static readonly int _OcclusionProbes = Shader.PropertyToID(&quot;_OcclusionProbes&quot;);<br>        internal static readonly int _OcclusionProbesWorldToLocal = Shader.PropertyToID(&quot;_OcclusionProbesWorldToLocal&quot;);<br>        internal static readonly int _OcclusionProbesDetail = Shader.PropertyToID(&quot;_OcclusionProbesDetail&quot;);<br>        internal static readonly int _OcclusionProbesWorldToLocalDetail = Shader.PropertyToID(&quot;_OcclusionProbesWorldToLocalDetail&quot;);<br>        internal static readonly int _OcclusionProbesReflectionOcclusionAmount = Shader.PropertyToID(&quot;_OcclusionProbesReflectionOcclusionAmount&quot;);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>这些数据是通过Progressive烘焙lightmapping引擎烘焙出来的内容，相当于使用了引擎的特性。</strong></p>
<p><strong>要使用引擎的特性需要自己写一部分回调函数。BofD的代码在OcclusionProbes.Editor.cs文件中。</strong></p>
<h2 id="OcclusionProbes生成设置"><a href="#OcclusionProbes生成设置" class="headerlink" title="OcclusionProbes生成设置"></a>OcclusionProbes生成设置</h2><p>主要有两部分：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">Lightmapping.started += Started;<br>Lightmapping.completed += Completed;<br></code></pre></td></tr></table></figure>

<h3 id="Started"><a href="#Started" class="headerlink" title="Started"></a>Started</h3><p>在光照贴图开始烘焙之前调用</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Started</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 计算探针的数量：这里使用的是体素形式，我们也可以定义自己的形状。</span><br>    <span class="hljs-type">int</span> probeCount = m_XCount * m_YCount * m_ZCount;<br>    <span class="hljs-keyword">if</span> (probeCount == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span>;<br><br>  	<span class="hljs-comment">// 细节Probe数量统计</span><br>    <span class="hljs-type">int</span> detailSetCount = <span class="hljs-number">0</span>;<br>    foreach(OcclusionProbesDetail detail in m_OcclusionProbesDetail)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (detail == null || !detail.gameObject.activeSelf)<br>        <span class="hljs-keyword">continue</span>;<br><br>      probeCount += detail.m_XCount * detail.m_YCount * detail.m_ZCount;<br>      detailSetCount++;<br>    &#125;<br><br>  	<span class="hljs-comment">// 声明主探针位置数组,坐标矩阵等等</span><br>    Vector4[] positions = new Vector4[probeCount];<br><br>        <span class="hljs-comment">// Main</span><br>        Vector3 size = transform.localScale;<br>        Matrix4x4 localToWorld = Matrix4x4.TRS(transform.position - size * <span class="hljs-number">0.5f</span>, transform.rotation, size);<br>        m_WorldToLocal = localToWorld.inverse;<br>        m_CountBaked = new Vector3i(m_XCount, m_YCount, m_ZCount);<br><br>        <span class="hljs-type">int</span> indexOffset = <span class="hljs-number">0</span>;<br>        GenerateProbePositions(ref positions, ref indexOffset, m_CountBaked, localToWorld, CalculateRayOffset(m_RayOffset, size, m_CountBaked));<br><br>        <span class="hljs-comment">// Detail</span><br>        m_CountBakedDetail = new Vector3i[detailSetCount];<br>        m_WorldToLocalDetail = new Matrix4x4[detailSetCount];<br><br>  		<span class="hljs-comment">// 声明细节探针的位置，矩阵转化，大小等等</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        foreach(OcclusionProbesDetail detail in m_OcclusionProbesDetail)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (detail == null || !detail.gameObject.activeSelf)<br>                <span class="hljs-keyword">continue</span>;<br>            <br>            Transform t = detail.transform;<br>            Vector3 sizeDetail = t.localScale;<br>            Matrix4x4 localToWorldDetail = Matrix4x4.TRS(t.position - sizeDetail * <span class="hljs-number">0.5f</span>, t.rotation, sizeDetail);<br>            m_WorldToLocalDetail[i] = localToWorldDetail.inverse;<br>            m_CountBakedDetail[i] = new Vector3i(detail.m_XCount, detail.m_YCount, detail.m_ZCount);<br>            GenerateProbePositions(ref positions, ref indexOffset, m_CountBakedDetail[i], localToWorldDetail, CalculateRayOffset(detail.m_RayOffset, sizeDetail, m_CountBakedDetail[i]));<br>            i++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> sampleCount = <span class="hljs-number">1024</span>;<br><br>  <br>  	<span class="hljs-comment">//这两句话才是核心内容，传入顶点数量和顶点位置，上面的内容实际上都是逻辑层的东西。</span><br>  UnityEditor.Experimental.Lightmapping.SetCustomBakeInputs(positions, sampleCount);<br>        m_SampleCountBaked = sampleCount;<br><br>        UnityEditor.Experimental.Lightmapping.probesIgnoreDirectEnvironment = <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="Completed"><a href="#Completed" class="headerlink" title="Completed"></a>Completed</h3><p>光照烘焙计算之后保存数据</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-type">void</span> <span class="hljs-title function_">Completed</span><span class="hljs-params">()</span><br>  &#123;<br><span class="hljs-comment">// 从烘焙管线当中提取所有的探针生成三维纹理。</span><br>    	<span class="hljs-comment">// 同样也可以生成别的list之类的结构</span><br>    	<span class="hljs-comment">// ...</span><br><br>      <span class="hljs-comment">// Ambient probe</span><br>      <span class="hljs-comment">// 这个只是一个SH9 用于记录全局的光线                              </span><br>      BakeAmbientProbe();<br><span class="hljs-comment">// 把所有资源保存</span><br>      AssetDatabase.SaveAssets();<br><br>      m_CountBaked = new Vector3i(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>经过上面两步的计算所有的内容都会保存在和Lightmap相同的目录当中，需要自己通过代码设置到Shader当中来使用。</p>
<p>剩下的工作就是把这些点传递到Shader当中就可以了，主要代码在OcclusionProbes当中。</p>
<p>注：在BofD当中OcclusionProbes主要用来削减BakeAmbientProbe，然后削减的值叠加到原始的光照探针上。</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>1.在场景中新建一个Occlusion Probes，设置大小，体素纹理分辨率，细节纹理个数及其分辨率。</p>
<p>2.将烘焙方式设置为<strong>手动</strong>，烘焙引擎设置为Progressive。</p>
<p>3.点击烘焙，就会生成资源了。</p>
<p>4.通过Occlusion Probes脚本，设置全局的Shader参数。</p>
<p>5.在所有Shader当中就可以读取多个三维纹理，根据矩阵等位置的计算，就可以提去出各个点的环境光明暗情况。</p>

      
      <p align="right"><a class="morebtn" href="/2022/07/09/HDRPsource/9.OcclusionProbe/" title="Occlusion Probe Shader部分">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/HDRPsource/HDRPShader%E5%86%85%E7%BD%AE%E7%9F%A9%E9%98%B5%E5%A4%87%E6%9F%A5/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/HDRPsource/HDRPShader%E5%86%85%E7%BD%AE%E7%9F%A9%E9%98%B5%E5%A4%87%E6%9F%A5/" itemprop="url">HDRP当中设置矩阵的代码</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/HDRPSource/" itemprop="url" rel="index"><span itemprop="name">HDRPSource</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="HDRP当中设置矩阵的代码："><a href="#HDRP当中设置矩阵的代码：" class="headerlink" title="HDRP当中设置矩阵的代码："></a>HDRP当中设置矩阵的代码：</h1><p>HDCamera.cs</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123;<br>    <span class="hljs-type">bool</span> taaEnabled = m_frameSettings.IsEnabled(FrameSettingsField.Postprocess)<br>        &amp;&amp; antialiasing == AntialiasingMode.TemporalAntialiasing<br>        &amp;&amp; camera.cameraType == CameraType.Game;<br><br>    cmd.SetGlobalMatrix(HDShaderIDs._ViewMatrix,                viewMatrix);<br>    cmd.SetGlobalMatrix(HDShaderIDs._InvViewMatrix,             viewMatrix.inverse);<br>    cmd.SetGlobalMatrix(HDShaderIDs._ProjMatrix,                projMatrix);<br>    cmd.SetGlobalMatrix(HDShaderIDs._InvProjMatrix,             projMatrix.inverse);<br>    cmd.SetGlobalMatrix(HDShaderIDs._ViewProjMatrix,            viewProjMatrix);<br>    cmd.SetGlobalMatrix(HDShaderIDs._InvViewProjMatrix,         viewProjMatrix.inverse);<br>    cmd.SetGlobalMatrix(HDShaderIDs._NonJitteredViewProjMatrix, nonJitteredViewProjMatrix);<br>    cmd.SetGlobalMatrix(HDShaderIDs._PrevViewProjMatrix,        prevViewProjMatrix);<br>    cmd.SetGlobalMatrix(HDShaderIDs._CameraViewProjMatrix,      viewProjMatrix);<br>    cmd.SetGlobalVector(HDShaderIDs._WorldSpaceCameraPos,       worldSpaceCameraPos);<br>    cmd.SetGlobalVector(HDShaderIDs._PrevCamPosRWS,             prevWorldSpaceCameraPos);<br>    cmd.SetGlobalVector(HDShaderIDs._ScreenSize,                screenSize);<br>    cmd.SetGlobalVector(HDShaderIDs._ScreenToTargetScale,       doubleBufferedViewportScale);<br>    cmd.SetGlobalVector(HDShaderIDs._ScreenToTargetScaleHistory, doubleBufferedViewportScaleHistory);<br>    cmd.SetGlobalVector(HDShaderIDs._ZBufferParams,             zBufferParams);<br>    cmd.SetGlobalVector(HDShaderIDs._ProjectionParams,          projectionParams);<br>    cmd.SetGlobalVector(HDShaderIDs.unity_OrthoParams,          unity_OrthoParams);<br>    cmd.SetGlobalVector(HDShaderIDs._ScreenParams,              screenParams);<br>    cmd.SetGlobalVector(HDShaderIDs._TaaFrameInfo,              new Vector4(taaFrameRotation.x, taaFrameRotation.y, taaFrameIndex, taaEnabled ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>));<br>    cmd.SetGlobalVector(HDShaderIDs._TaaJitterStrength,         taaJitter);<br>    cmd.SetGlobalVectorArray(HDShaderIDs._FrustumPlanes,        frustumPlaneEquations);<br></code></pre></td></tr></table></figure>

<p>矩阵在Shader当中的代码:</p>
<p>ShaderVariables.hlsl</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// Define that before including all the sub systems ShaderVariablesXXX.hlsl files in order to include constant buffer properties.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHADER_VARIABLES_INCLUDE_CB</span><br><br><span class="hljs-comment">// Important: please use macros or functions to access the CBuffer data.</span><br><span class="hljs-comment">// The member names and data layout can (and will) change!</span><br>CBUFFER_START(UnityGlobal)<br>    <span class="hljs-comment">// ================================</span><br>    <span class="hljs-comment">//     PER VIEW CONSTANTS</span><br>    <span class="hljs-comment">// ================================</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> all affine matrices should be 3x4.</span><br>    float4x4 _ViewMatrix;<br>float4x4 _InvViewMatrix;<br>float4x4 _ProjMatrix;<br>float4x4 _InvProjMatrix;<br>float4x4 _ViewProjMatrix;<br>float4x4 _CameraViewProjMatrix;<br>float4x4 _InvViewProjMatrix;<br>float4x4 _NonJitteredViewProjMatrix;<br>float4x4 _PrevViewProjMatrix;       <span class="hljs-comment">// non-jittered</span><br><br>float4 _TextureWidthScaling; <span class="hljs-comment">// 0.5 for SinglePassDoubleWide (stereo) and 1.0 otherwise</span><br><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> put commonly used vars together (below), and then sort them by the frequency of use (descending).</span><br><span class="hljs-comment">// Note: a matrix is 4 * 4 * 4 = 64 bytes (1x cache line), so no need to sort those.</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> USING_STEREO_MATRICES</span><br>float3 _WorldSpaceCameraPos;<br><span class="hljs-type">float</span>  _Pad0;<br>float3 _PrevCamPosRWS;<br><span class="hljs-type">float</span>  _Pad1;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>float4 _ScreenSize;                 <span class="hljs-comment">// &#123; w, h, 1 / w, 1 / h &#125;</span><br><br><span class="hljs-comment">// Those two uniforms are specific to the RTHandle system</span><br>float4 _ScreenToTargetScale;        <span class="hljs-comment">// &#123; w / RTHandle.maxWidth, h / RTHandle.maxHeight &#125; : xy = currFrame, zw = prevFrame</span><br>float4 _ScreenToTargetScaleHistory; <span class="hljs-comment">// Same as above but the RTHandle handle size is that of the history buffer</span><br><br></code></pre></td></tr></table></figure>

<p>上面矩阵的宏定义:</p>
<p>ShaderVariablesMatrixDefsHDCamera.hlsl</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UNITY_SHADER_VARIABLES_MATRIX_DEFS_LEGACY_UNITY_INCLUDED</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">error</span> Mixing HDCamera and legacy Unity matrix definitions</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> UNITY_SHADER_VARIABLES_MATRIX_DEFS_HDCAMERA_INCLUDED</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_SHADER_VARIABLES_MATRIX_DEFS_HDCAMERA_INCLUDED</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(USING_STEREO_MATRICES)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_V     _ViewMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_V   _InvViewMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_P     OptimizeProjectionMatrix(_ProjMatrixStereo[unity_StereoEyeIndex])</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_P   _InvProjMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_VP    _ViewProjMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_VP  _InvViewProjMatrixStereo[unity_StereoEyeIndex]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_UNJITTERED_VP _ViewProjMatrixStereo[unity_StereoEyeIndex] <span class="hljs-comment">// Since VR doesn&#x27;t need to add jitter, just use normal VP matrix</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_PREV_VP _PrevViewProjMatrixStereo[unity_StereoEyeIndex]</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_V     _ViewMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_V   _InvViewMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_P     OptimizeProjectionMatrix(_ProjMatrix)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_P   _InvProjMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_VP    _ViewProjMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_I_VP  _InvViewProjMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_UNJITTERED_VP _NonJitteredViewProjMatrix</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNITY_MATRIX_PREV_VP _PrevViewProjMatrix</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// USING_STEREO_MATRICES</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// UNITY_SHADER_VARIABLES_MATRIX_DEFS_HDCAMERA_INCLUDED</span></span><br></code></pre></td></tr></table></figure>


      
      <p align="right"><a class="morebtn" href="/2022/07/09/HDRPsource/HDRPShader%E5%86%85%E7%BD%AE%E7%9F%A9%E9%98%B5%E5%A4%87%E6%9F%A5/" title="HDRP当中设置矩阵的代码">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/HDRPsource/new2.HDRPShader%E5%BC%80%E5%8F%91%E8%AF%B4%E6%98%8E/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/HDRPsource/new2.HDRPShader%E5%BC%80%E5%8F%91%E8%AF%B4%E6%98%8E/" itemprop="url">Shader开发说明</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/HDRPSource/" itemprop="url" rel="index"><span itemprop="name">HDRPSource</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h2 id="Shader开发说明"><a href="#Shader开发说明" class="headerlink" title="Shader开发说明"></a>Shader开发说明</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p><strong>CoreRPLibrary&#x2F;ShaderLibrary:</strong></p>
<p>保存了大量的工具函数：光照计算工具函数，随机数计算，矩阵工具，坐标转换工具，风场，ParallaxOcclusionMapping等。</p>
<p><strong>CoreRPLibrary&#x2F;ShaderLibrary&#x2F;API:</strong></p>
<p>保存了跨平台函数的定义。</p>
<p><strong>HDRP&#x2F;Runtime&#x2F;Material:</strong></p>
<p>保存了HDRP中默认支持的材质Shader：Lit，LayeredLit，Stacklit等，都是和各自材质相关的计算。不同的材质中包含了不同的BSDF函数的实现、不同的BuiltinData的组织方式。</p>
<p><strong>HDRP&#x2F;Runtime&#x2F;PostProcessing&#x2F;Shaders:</strong></p>
<p>后处理的Shader，HDRP中后处理全部使用ComputeShader。</p>
<p><strong>HDRP&#x2F;Runtime&#x2F;RenderPipeline&#x2F;ShaderPass:</strong></p>
<p>ShaderPass的定义：包括了Vertex和Fragment程序的定义。</p>
<p><strong>HDRP&#x2F;Runtime&#x2F;RenderPipeline&#x2F;ShaderLibrary:</strong></p>
<p>从C#当中设置的Shader参数，包括：各种变换矩阵、获取矩阵的函数、摄像机参数、场景参数、全部buffer、全局纹理、shader控制参数等。</p>
<h3 id="Shader-Pass"><a href="#Shader-Pass" class="headerlink" title="Shader Pass"></a>Shader Pass</h3><p>RenderPiple的代码中，在不同的时机会渲染不同的ShaderPass（通过lightmode区分）。<strong>如果要看更详细的Pass绘制时机，以及Pass之间如何组合成正确的Shader，需要看Pipeline的代码，如果随意组合会得到无法预知的结果</strong>，主要的Pass如下：</p>
<h4 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h4><p>前向渲染物体使用这个Pass，正常情况下使用Deferred。透明物体可以使用Forward Pass， StackLit也是Forward Pass。</p>
<h4 id="ForwardOnly"><a href="#ForwardOnly" class="headerlink" title="ForwardOnly"></a>ForwardOnly</h4><p>ForwardOnly的用处是：渲染透明物体或<strong>在Deferred模式下强制使用Forward模式渲染不透明物体</strong>。 例如：StackLit就是使用了{ForwardOnly和DepthForwardOnly}组合的Shader。</p>
<h4 id="DepthForwardOnly"><a href="#DepthForwardOnly" class="headerlink" title="DepthForwardOnly"></a>DepthForwardOnly</h4><p>和ForwardOnly对应使用。</p>
<h4 id="DepthOnly"><a href="#DepthOnly" class="headerlink" title="DepthOnly"></a>DepthOnly</h4><p>渲染深度，Forward和Deferred必须有一个深度，使用这个Pass。</p>
<h4 id="TransparentDepthPrepass"><a href="#TransparentDepthPrepass" class="headerlink" title="TransparentDepthPrepass"></a>TransparentDepthPrepass</h4><p>透明物体Prepass深度</p>
<h4 id="TransparentDepthPostpass"><a href="#TransparentDepthPostpass" class="headerlink" title="TransparentDepthPostpass"></a>TransparentDepthPostpass</h4><p>透明物体Postpass深度</p>
<p><strong>注意：</strong>上面所有的Pass需要正确的组合在一个Shader当中，不然会出错。例如：自己写的Shader中可以包括：{ForwardOnly，DepthForwardOnly}。 如果出现：{ForwardOnly，DepthOnly}就会出现不可预知的结果。</p>
<h4 id="ShadowCaster"><a href="#ShadowCaster" class="headerlink" title="ShadowCaster"></a>ShadowCaster</h4><p>用于渲染阴影的Pass，和老版本不同的是：HDRP的阴影和深度使用了两个不同的Pass。</p>
<h4 id="DistortionVectors"><a href="#DistortionVectors" class="headerlink" title="DistortionVectors"></a>DistortionVectors</h4><p>扭曲向量</p>
<h4 id="DistortionVectors-1"><a href="#DistortionVectors-1" class="headerlink" title="DistortionVectors"></a>DistortionVectors</h4><p>屏幕运动向量</p>
<h3 id="Shader编写"><a href="#Shader编写" class="headerlink" title="Shader编写"></a>Shader编写</h3><h4 id="定义LightMode和ShaderPass"><a href="#定义LightMode和ShaderPass" class="headerlink" title="定义LightMode和ShaderPass"></a>定义LightMode和ShaderPass</h4><p>如果要实现自己的Shader，第一步需要正确的定义ShaderPass：</p>
<p>不透明物体:主要需要基本的光照渲染Forward或者Deferred、阴影ShadowCaster，深度DepthOnly：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;HDRP&quot;</span><br>&#123;<br><br>    SubShader<br>    &#123;<br>        Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;Forward&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;Forward&quot;</span> &#125;<br>        &#125;<br>         Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;Deferred&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;Deferred&quot;</span> &#125;<br>        &#125;<br>        Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;DepthOnly&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;DepthOnly&quot;</span> &#125;<br>        &#125;<br>        Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;ShadowCaster&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;ShadowCaster&quot;</span> &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不透明物体也可以是（类似StackLit方式）：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;HDRP&quot;</span><br>&#123;<br>    SubShader<br>    &#123;<br>        Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;ForwardOnly&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;ForwardOnly&quot;</span> &#125;<br>        &#125;<br>        Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;DepthForwardOnly&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;DepthForwardOnly&quot;</span> &#125;<br>            HLSLPROGRAM<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex Vert</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment Frag</span><br>            ENDHLSL<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>透明物体,需要基本的光照Pass（也可以不计算光照）ForwardOnly或者Forward，深度TransparentDepthPrepass、TransparentDepthPostpass</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;HDRP&quot;</span><br>&#123;<br><br>    SubShader<br>    &#123;<br>        Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;ForwardOnly&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;Forward&quot;</span> &#125;<br>            HLSLPROGRAM<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex Vert</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment Frag</span><br>            ENDHLSL<br>        &#125;<br>        Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;TransparentDepthPrepass&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;TransparentDepthPrepass&quot;</span> &#125;<br>        &#125;<br>        Pass<br>        &#123;<br>            Name <span class="hljs-string">&quot;TransparentDepthPostpass&quot;</span><br>            Tags&#123; <span class="hljs-string">&quot;LightMode&quot;</span> = <span class="hljs-string">&quot;TransparentDepthPostpass&quot;</span> &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以根据自己的需求组合不同的Pass达到不同的效果。例如：一个物体如果不想要阴影，可以直接去掉ShadowCaster Pass，这样对深度没有任何影响。<strong>还有一个重要的问题就是：所有ShaderGraph或者HDRP内置的Shader都包括了ShadowCaster Pass和Depth Pass。所以，需要之后应该需要我们根据需求手动去除这个Pass。</strong></p>
<h4 id="设置Queue"><a href="#设置Queue" class="headerlink" title="设置Queue"></a>设置Queue</h4><p>控制渲染时机的除了LightMode之外，另一个是Queue。</p>
<p>HDRP的Queue和原本不同，现在只能定义到SubShader级别.</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Shader &quot;&quot;<br>&#123;<br>     SubShader<br>     &#123;<br>        Tags &#123; &quot;Queue&quot; = &quot;Transparent&quot; &#125;<br>        Pass<br>        &#123;<br>            // rest of the shader body...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>HDRP使用了Priority定义Queue，具体参考HDMaterialTags.cs文件。</p>
<p>完成了Queue和LightMode的设置就算是完成一个完整的Shader设置。</p>
<h4 id="Material参数"><a href="#Material参数" class="headerlink" title="Material参数"></a>Material参数</h4><p>HDRP的自定义参数设置和原始版本的使用方式是一样的。</p>
<p>不同的是内置参数。HDRP的内置参数全部通过可查看的C#代码设置。需要包括以下两个文件。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl&quot;</span></span><br><br></code></pre></td></tr></table></figure>

<p>这两个文件包括了：版本相关的变量关键字、摄像机矩阵、场景参数、摄像机参数等内容。矩阵类型和原本也有所差异。</p>
<h4 id="灯光设置"><a href="#灯光设置" class="headerlink" title="灯光设置"></a>灯光设置</h4><p>HDRP和原始版本最大的区别就是灯光计算，HDPR在一个Pass当中会计算完所有的灯光（包括区域光、环境光、雾、LightMap、LightProbe）。需要从LightList当中读取各种信息。</p>
<p>下面是读取灯光信息的基本形式：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CustomLighting.hlsl&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">LightLoop</span><span class="hljs-params">(...)</span><br>&#123;<br><br>    <span class="hljs-type">float</span> NdotV = dot(bsdfData.normalWS, V);<br>    LightLoopContext context;<br>    context.shadowContext    = InitShadowContext();<br>    <span class="hljs-comment">// 计算基于屏幕的细节阴影</span><br>    context.contactShadow    = InitContactShadow(posInput);<br>    context.shadowValue      = <span class="hljs-number">1</span>;<br>    context.sampleReflection = <span class="hljs-number">0</span>;<br><br>    uint lightCount, lightStart;<br><br>    <span class="hljs-comment">// ===================  读取点光、聚光灯  ===================== </span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    struct LightData</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        float3 positionRWS;</span><br><span class="hljs-comment">        uint lightLayers;</span><br><span class="hljs-comment">        float lightDimmer;</span><br><span class="hljs-comment">        float volumetricLightDimmer;</span><br><span class="hljs-comment">        float angleScale;</span><br><span class="hljs-comment">        float angleOffset;</span><br><span class="hljs-comment">        float3 forward;</span><br><span class="hljs-comment">        int lightType;</span><br><span class="hljs-comment">        float3 right;</span><br><span class="hljs-comment">        float range;</span><br><span class="hljs-comment">        float3 up;</span><br><span class="hljs-comment">        float rangeAttenuationScale;</span><br><span class="hljs-comment">        float3 color;</span><br><span class="hljs-comment">        float rangeAttenuationBias;</span><br><span class="hljs-comment">        int cookieIndex;</span><br><span class="hljs-comment">        int tileCookie;</span><br><span class="hljs-comment">        int shadowIndex;</span><br><span class="hljs-comment">        int contactShadowMask;</span><br><span class="hljs-comment">        int rayTracedAreaShadowIndex;</span><br><span class="hljs-comment">        float shadowDimmer;</span><br><span class="hljs-comment">        float volumetricShadowDimmer;</span><br><span class="hljs-comment">        int nonLightMappedOnly;</span><br><span class="hljs-comment">        float minRoughness;</span><br><span class="hljs-comment">        float4 shadowMaskSelector;</span><br><span class="hljs-comment">        float2 size;</span><br><span class="hljs-comment">        float diffuseDimmer;</span><br><span class="hljs-comment">        float specularDimmer;</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    根据世界坐标位置和灯光类型，返回灯光索引的开始索引和数量.</span><br><span class="hljs-comment">    */</span><br>    GetCountAndStart(posInput, LIGHTCATEGORY_PUNCTUAL, lightStart, lightCount);<br>    uint i = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; lightCount; ++i)<br>    &#123;<br>        LightData lightData = FetchLight(lightStart, i);<br>        <span class="hljs-comment">// 计算光照</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ===================  读取直线光  =====================</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    _DirectionalLightCount：直线光个数</span><br><span class="hljs-comment">    _DirectionalLightDatas：所有直线光数组.</span><br><span class="hljs-comment">    直线光保存在CB当中，不参与FPTL,所以直接通过数组计算。</span><br><span class="hljs-comment">    _DirectionalLightDatas的数据结构：</span><br><span class="hljs-comment">    struct DirectionalLightData</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        float3 positionRWS;</span><br><span class="hljs-comment">        uint lightLayers;</span><br><span class="hljs-comment">        float lightDimmer;</span><br><span class="hljs-comment">        float volumetricLightDimmer;</span><br><span class="hljs-comment">        float angleScale;</span><br><span class="hljs-comment">        float angleOffset;</span><br><span class="hljs-comment">        float3 forward;</span><br><span class="hljs-comment">        int cookieIndex;</span><br><span class="hljs-comment">        float3 right;</span><br><span class="hljs-comment">        int tileCookie;</span><br><span class="hljs-comment">        float3 up;</span><br><span class="hljs-comment">        int shadowIndex;</span><br><span class="hljs-comment">        float3 color;</span><br><span class="hljs-comment">        int contactShadowMask;</span><br><span class="hljs-comment">        float shadowDimmer;</span><br><span class="hljs-comment">        float volumetricShadowDimmer;</span><br><span class="hljs-comment">        int nonLightMappedOnly;</span><br><span class="hljs-comment">        float minRoughness;</span><br><span class="hljs-comment">        float4 shadowMaskSelector;</span><br><span class="hljs-comment">        float diffuseDimmer;</span><br><span class="hljs-comment">        float specularDimmer;</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">    */</span><br>    uint i = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; _DirectionalLightCount; ++i)<br>    &#123;<br>        _DirectionalLightDatas[i];<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">// ====================== 读取区域光 =====================</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">   	LightData定义同读取点光、聚光灯。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     在Lit当中Loop当中可以看到用了两个while，主要是为了GPU优化。</span><br><span class="hljs-comment">    */</span><br>    GetCountAndStart(posInput, LIGHTCATEGORY_AREA, lightStart, lightCount);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; lightCount; i++)<br>    &#123;<br>        LightData lightData = FetchLight(lightStart, i);<br>       	<span class="hljs-comment">// 计算光照</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 读取环境光，主要处理反射和折射光的分量 =====================</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    这里有个重要的内容，就是反射和折射信息和光照计算不同，不是叠加，而是反射的上限应该是1。所以具体如何处理不同的反射和折射的关系需要参考Lit。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    struct EnvLightData</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        uint lightLayers;</span><br><span class="hljs-comment">        float3 capturePositionRWS;</span><br><span class="hljs-comment">        int influenceShapeType;</span><br><span class="hljs-comment">        float3 proxyExtents;</span><br><span class="hljs-comment">        float minProjectionDistance;</span><br><span class="hljs-comment">        float3 proxyPositionRWS;</span><br><span class="hljs-comment">        float3 proxyForward;</span><br><span class="hljs-comment">        float3 proxyUp;</span><br><span class="hljs-comment">        float3 proxyRight;</span><br><span class="hljs-comment">        float3 influencePositionRWS;</span><br><span class="hljs-comment">        float3 influenceForward;</span><br><span class="hljs-comment">        float3 influenceUp;</span><br><span class="hljs-comment">        float3 influenceRight;</span><br><span class="hljs-comment">        float3 influenceExtents;</span><br><span class="hljs-comment">        float unused00;</span><br><span class="hljs-comment">        float3 blendDistancePositive;</span><br><span class="hljs-comment">        float3 blendDistanceNegative;</span><br><span class="hljs-comment">        float3 blendNormalDistancePositive;</span><br><span class="hljs-comment">        float3 blendNormalDistanceNegative;</span><br><span class="hljs-comment">        float3 boxSideFadePositive;</span><br><span class="hljs-comment">        float3 boxSideFadeNegative;</span><br><span class="hljs-comment">        float weight;</span><br><span class="hljs-comment">        float multiplier;</span><br><span class="hljs-comment">        int envIndex;</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">//Lit当中首先定义了反射和折射的成分，初始化为0.</span><br>    <span class="hljs-type">float</span> reflectionHierarchyWeight = <span class="hljs-number">0.0</span>; <span class="hljs-comment">// Max: 1.0</span><br>    <span class="hljs-type">float</span> refractionHierarchyWeight = _EnableSSRefraction ? <span class="hljs-number">0.0</span> : <span class="hljs-number">1.0</span>; <span class="hljs-comment">// Max: 1.0</span><br>    <span class="hljs-comment">// 读取环境光照信息</span><br>    GetCountAndStart(posInput, LIGHTCATEGORY_ENV, envLightStart, envLightCount);<br>    <br>    <span class="hljs-comment">// 先计算屏幕空间反射：叠加reflectionHierarchyWeight。这部分信息不再Tile当中</span><br>    &#123;<br>        IndirectLighting indirect = EvaluateBSDF_ScreenSpaceReflection(posInput, preLightData, bsdfData,                                     reflectionHierarchyWeight);<br>        AccumulateIndirectLighting(indirect, aggregateLighting);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 计算屏幕折射。</span><br>    <span class="hljs-keyword">if</span> ((featureFlags &amp; LIGHTFEATUREFLAGS_SSREFRACTION) &amp;&amp; (_EnableSSRefraction &gt; <span class="hljs-number">0</span>))<br>    &#123;<br>        <span class="hljs-comment">// 折射信息</span><br>        envLightData = FetchEnvLight(envLightStart, <span class="hljs-number">0</span>);<br>    &#125;<br>        <br>    <span class="hljs-comment">// 反射和折射探针。</span><br>    <span class="hljs-keyword">if</span> (featureFlags &amp; LIGHTFEATUREFLAGS_ENV)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;envLightCount;i++)<br>        &#123;<br>            uint v_envLightIdx = FetchIndex(envLightStart, i);<br>            EnvLightData s_envLightData = FetchEnvLight(v_envLightIdx);    <br>   			<span class="hljs-comment">// 处理环境光</span><br>        &#125;<br><br>        <span class="hljs-comment">// 使用天空纹理计算IBL</span><br>        <span class="hljs-keyword">if</span> ((featureFlags &amp; LIGHTFEATUREFLAGS_SKY) &amp;&amp; _EnvLightSkyEnabled)<br>        &#123;<br>            context.sampleReflection = SINGLE_PASS_CONTEXT_SAMPLE_SKY;<br>            EnvLightData envLightSky = InitSkyEnvLightData(<span class="hljs-number">0</span>);<br>			<span class="hljs-comment">// 处理envLightSky </span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h4><h5 id="需要通过Tile读取的灯光"><a href="#需要通过Tile读取的灯光" class="headerlink" title="需要通过Tile读取的灯光"></a>需要通过Tile读取的灯光</h5><p>#define LIGHTCATEGORY_PUNCTUAL (0)<br>#define LIGHTCATEGORY_AREA (1)<br>#define LIGHTCATEGORY_ENV (2)</p>
<h5 id="FetchLight"><a href="#FetchLight" class="headerlink" title="FetchLight"></a>FetchLight</h5><p>灯光就是直接从Buffer当中读取的，但是索引是要通过FPTL、Cluster、Big-Tile等方法读取的，下面是直接读取灯光信息：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">LightData <span class="hljs-title function_">FetchLight</span><span class="hljs-params">(uint start, uint i)</span><br>&#123;<br>    uint j = FetchIndex(start, i);<br><br>    <span class="hljs-keyword">return</span> _LightDatas[j];<br>&#125;<br><br>LightData <span class="hljs-title function_">FetchLight</span><span class="hljs-params">(uint index)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> _LightDatas[index];<br>&#125;<br><br>EnvLightData <span class="hljs-title function_">FetchEnvLight</span><span class="hljs-params">(uint start, uint i)</span><br>&#123;<br>    <span class="hljs-type">int</span> j = FetchIndex(start, i);<br><br>    <span class="hljs-keyword">return</span> _EnvLightDatas[j];<br>&#125;<br><br>EnvLightData <span class="hljs-title function_">FetchEnvLight</span><span class="hljs-params">(uint index)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> _EnvLightDatas[index];<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="FetchIndex"><a href="#FetchIndex" class="headerlink" title="FetchIndex"></a>FetchIndex</h5><p>具体的索引如何读取，就要看是否使用FPTL、Cluster、Big-Tile或者不用光照优化策略：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_FPTL_LIGHTLIST    <span class="hljs-comment">// 使用FPTL</span></span><br>uint <span class="hljs-title function_">FetchIndex</span><span class="hljs-params">(uint tileOffset, uint lightOffset)</span><br>&#123;<br>    <span class="hljs-type">const</span> uint lightOffsetPlusOne = lightOffset + <span class="hljs-number">1</span>; <span class="hljs-comment">// Add +1 as first slot is reserved to store number of light</span><br>    <span class="hljs-comment">// Light index are store on 16bit</span><br>    <span class="hljs-keyword">return</span> (g_vLightListGlobal[DWORD_PER_TILE * tileOffset + (lightOffsetPlusOne &gt;&gt; <span class="hljs-number">1</span>)] &gt;&gt; ((lightOffsetPlusOne &amp; <span class="hljs-number">1</span>) * DWORD_PER_TILE)) &amp; <span class="hljs-number">0xffff</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(USE_CLUSTERED_LIGHTLIST) <span class="hljs-comment">// 使用Cluster  例如：对于透明物体就用Cluster</span></span><br><br>uint <span class="hljs-title function_">FetchIndex</span><span class="hljs-params">(uint lightStart, uint lightOffset)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> g_vLightListGlobal[lightStart + lightOffset];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(USE_BIG_TILE_LIGHTLIST) <span class="hljs-comment">// 使用BigTile</span></span><br><br>uint <span class="hljs-title function_">FetchIndex</span><span class="hljs-params">(uint lightStart, uint lightOffset)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> g_vBigTileLightList[lightStart + lightOffset];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span>             <span class="hljs-comment">// 没有</span></span><br><span class="hljs-comment">// Fallback case (mainly for raytracing right now)</span><br>uint <span class="hljs-title function_">FetchIndex</span><span class="hljs-params">(uint lightStart, uint lightOffset)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// USE_FPTL_LIGHTLIST</span></span><br></code></pre></td></tr></table></figure>

<h5 id="GetCountAndStart"><a href="#GetCountAndStart" class="headerlink" title="GetCountAndStart"></a>GetCountAndStart</h5><p>获取灯光列表的起始索引和数量，同上。具体查看LightLoopDef.hlsl源文件。</p>

      
      <p align="right"><a class="morebtn" href="/2022/07/09/HDRPsource/new2.HDRPShader%E5%BC%80%E5%8F%91%E8%AF%B4%E6%98%8E/" title="Shader开发说明">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/HDRPsource/new1.HDRP%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%80%BB%E7%BB%93/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/HDRPsource/new1.HDRP%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%80%BB%E7%BB%93/" itemprop="url">Unity HDRP主要功能和渲染管线的介绍</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/HDRPSource/" itemprop="url" rel="index"><span itemprop="name">HDRPSource</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="Unity-HDRP主要功能和渲染管线的介绍"><a href="#Unity-HDRP主要功能和渲染管线的介绍" class="headerlink" title="Unity HDRP主要功能和渲染管线的介绍"></a>Unity HDRP主要功能和渲染管线的介绍</h1><h2 id="1-SRP和HDRP介绍"><a href="#1-SRP和HDRP介绍" class="headerlink" title="1. SRP和HDRP介绍"></a>1. SRP和HDRP介绍</h2><p>unity SRP可以让我们自己控制摄像机每一帧的渲染流程。他把渲染管线可以进行的操作都暴露给了用户，不再是一个封闭的引擎内置流程。</p>
<p>为了方便用户使用，Unity提供了两个已经实现好的SRP流程，分别针对不同的平台。</p>
<ul>
<li>Lightweight Render Pipeline (LWRP) ：支持手机平台和PC平台，目的是提供一个高性能的渲染，牺牲了引擎的表现效果。</li>
<li>High Definition Render Pipeline (HDRP) ：使用了基于物理的灯光技术以及基于Compute Shader的光照计算。针对高端的PC和主机平台。</li>
</ul>
<h2 id="2-HDRP渲染效果与材质类型"><a href="#2-HDRP渲染效果与材质类型" class="headerlink" title="2. HDRP渲染效果与材质类型"></a>2. HDRP渲染效果与材质类型</h2><p>Unity HDRP提供了更丰富的材质效果，包括：SSS效果、透光、Coat等。通过ShaderGraph和基础的LitShader都可以构建出支持这些效果的Shader。</p>
<p>在Lit Shader中可以通过Surface Options当中的Material Type来选择需要的材质效果。</p>
<p>Unity的说明文档:<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@6.7/manual/Material-Type.html">材质类型官网介绍</a>。</p>
<p>下面简要介绍这些材质效果主要的功能。</p>
<h3 id="2-1-Standard"><a href="#2-1-Standard" class="headerlink" title="2.1 Standard"></a>2.1 Standard</h3><p>Standard就是标准的光照模型。渲染流程如下：</p>
<ul>
<li>Gbuffer Pass ：填充GBuffer</li>
<li>Deferred Lighting Pass：Compute Shader计算光照。</li>
</ul>
<p>基础的输入参数：</p>
<ul>
<li>Diffuse贴图：表面颜色，同时支持用Color参数对其进行调整。Alpha通道在开启透明模式的时候，可以用作透明度。</li>
<li>Normal贴图：支持Object空间和Tangent空间，支持调节法线强度。</li>
<li>Mask贴图：R通道对应金属度，G通道对应平滑度，B通道对应细节贴图的区域，A通道对应平滑度，同时提供了多个滑块参数对金属度和平滑度进行调整。</li>
<li>BentNormal贴图：主要用于计算AO，比AO贴图准确。</li>
<li>DetialMap贴图：支持平铺的细节，可以给Diffuse、normal、smoothness调节细节，通过Mask贴图B通道控制区域。</li>
<li>Height贴图：开启Displacement Mode，可以使用高度贴图。</li>
<li>开启透明模式：支持扭曲、折射。</li>
<li>支持Clear Coat：效果。</li>
</ul>
<p>上面的效果Lit材质球默认支持，Lit的Inspector是一个专门为LitShader写的材质编辑器，通过开启选项可修改Lit的材质效果。</p>
<p>另外，可以看到Lit支持很多贴图输入，一般而言这样做开销很高，但是Lit Shader内部做了优化，如果不使用某一张贴图就不要给他赋值，它就不会对这个贴图进行采样。</p>
<h3 id="2-2-Specular"><a href="#2-2-Specular" class="headerlink" title="2.2 Specular"></a>2.2 Specular</h3><p>这个是和Standard（金属工作流）相对的高光工作流。区别只是金属度变成了高光颜色。其他计算没有区别。</p>
<h3 id="2-3-Anisotropy"><a href="#2-3-Anisotropy" class="headerlink" title="2.3 Anisotropy"></a>2.3 Anisotropy</h3><p>计算高光时使用各项异性的高光计算。和Standard区别只在于高光的计算，同时多出了一张各向异性贴图和强度控制。例如：拉丝金属。</p>
<h3 id="2-4-Iridescence"><a href="#2-4-Iridescence" class="headerlink" title="2.4 Iridescence"></a>2.4 Iridescence</h3><p>彩虹色是指：随着光照角度的变化光照颜色发生变化。例如：肥皂泡沫，昆虫翅膀。</p>
<p>和Standard的区别在于：光的颜色随光照角度发生变化。</p>
<h3 id="2-5-Translucent"><a href="#2-5-Translucent" class="headerlink" title="2.5 Translucent"></a>2.5 Translucent</h3><p>透光效果是指：在背光面可以看到光穿过物体的效果。主要用于半透明材质。例如：树叶。</p>
<p><strong>以上效果的开销没有太大区别，效果的差距只在于计算公式的不同，而渲染流程基本一致。</strong></p>
<h3 id="2-6-Surface-Scattering"><a href="#2-6-Surface-Scattering" class="headerlink" title="2.6 Surface Scattering"></a>2.6 Surface Scattering</h3><p>SSS效果用来描述光线在表面多次散射的效果。可以用来描述灯光和半透物体的交互过程。可以用来制作：玉、冰、皮肤等物体。</p>
<p>Surface Scattering的效果和上面几种效果不同，并且需要额外的计算。大致的渲染流程如下：</p>
<ul>
<li>Gbuffer Pass ：和Standard一样填充Gbuffer</li>
<li>Deferred Lighting Pass：计算光照</li>
<li>Convolution Pass：对需要SSS的部位进行卷积（通过Diffuse Profile）。</li>
<li>Combine Pass：计算好的SSS光和原始光融合。</li>
</ul>
<h3 id="2-7-Displacement-高度图"><a href="#2-7-Displacement-高度图" class="headerlink" title="2.7 Displacement,  高度图"></a>2.7 Displacement,  高度图</h3><p>Unity支持高度图计算。</p>
<p>所有的材质都可以使用高度图。</p>
<p>在Surface Options 当中选择Displacement Mode：</p>
<p>None：不使用高度图。</p>
<p>Vertex Displacement:  在Vertex阶段直接移动顶点，高度图作为移动距离。</p>
<p>Pixel displacement： 将高度图作为视差贴图。（POM）</p>
<p>当开启Pixel displacement时，视差贴图对应的参数就会开启。</p>
<p>官方说明：<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@6.7/manual/Displacement-Mode.html">Displacement Mode</a></p>
<h2 id="3-渲染流程介绍"><a href="#3-渲染流程介绍" class="headerlink" title="3. 渲染流程介绍"></a>3. 渲染流程介绍</h2><p>这里主要描述实现上述效果需要的基本渲染流程。</p>
<p>HDRP中Lit的渲染流程和Built-in Standard当中的延迟渲染基本一致，不透明物体流程如下：</p>
<ul>
<li>Gbuffer Pass  :填充Gbuffer，不过Gbuffer的内容和Built-in的内容有所区别。</li>
<li>Deferred Lighting Pass：进行光照计算。HDRP当中的光照计算放在了ComputeShader当中，计算效率更高。</li>
</ul>
<h3 id="3-1-Gbuffer结构"><a href="#3-1-Gbuffer结构" class="headerlink" title="3.1 Gbuffer结构"></a>3.1 Gbuffer结构</h3><p>下面是HDRP当中Gbuffer的结构类型。</p>
<table>
<thead>
<tr>
<th>G-Buffer Usage</th>
<th>Format</th>
<th>RGB</th>
<th>A</th>
</tr>
</thead>
<tbody><tr>
<td>GBuffer0</td>
<td>RGBA32</td>
<td>Albedo Color &#x2F;      SSS Color</td>
<td>Spacular Occlusiion &#x2F; SSS Parameter</td>
</tr>
<tr>
<td>GBuffer1</td>
<td>RGBA32</td>
<td>Packed Normal</td>
<td>Roughness</td>
</tr>
<tr>
<td>GBuffer2</td>
<td>RGBA32</td>
<td>BSDF Model Specific Parameters</td>
<td>Coat Mask + Material ID</td>
</tr>
<tr>
<td>GBuffer3</td>
<td>R11G11B10</td>
<td>GI + Emissive</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>GBuffer4 - Optional</td>
<td>RGBA32</td>
<td>R:&#x2F;             G:&#x2F;             B: AO</td>
<td>Light Layer</td>
</tr>
<tr>
<td>GBuffer5 - Optional</td>
<td>RGBA32</td>
<td>shadowmask0 - 2</td>
<td>shadowmask3</td>
</tr>
</tbody></table>
<p>其中Gbuffer0 、Gbuffer1、Gbuffer3的内容和Built-in的内容类型基本一致，主要是金属工作流需要的参数。</p>
<p>Gbuffer2和Gbuffer4当中保存了用于区分材质的标记，例如：</p>
<ul>
<li>Light Layer: 区分使用哪个Layer的光源。</li>
<li>Coat Mask：区分使用Coat效果的区域。</li>
<li>Material ID：区分材质类型。</li>
</ul>
<p>还有其他的参数可以在Shader当中查看具体使用方式。</p>
<h3 id="3-2-灯光列表"><a href="#3-2-灯光列表" class="headerlink" title="3.2 灯光列表"></a>3.2 灯光列表</h3><p>HDRP使用FPTL和Cluster策略，将灯光列表一次性传递到一个Pass当中完成计算。</p>
<p>Unity灯光计算就是（使用FPTL或Cluster策略）生成影响每一个Tile的灯光列表，在Compute Shader当中根据自己所在的Tile读取光照列表，然后一次性完成灯光计算。</p>
<h4 id="3-2-1-FPTL和Cluster"><a href="#3-2-1-FPTL和Cluster" class="headerlink" title="3.2.1 FPTL和Cluster"></a>3.2.1 FPTL和Cluster</h4><p>Unity有两种灯管列表的计算方式，FPTL的方式能够依赖深度区分需要使用的灯光是否能够作用在表面。透明物体没有深度，所以需要使用Cluster方式对灯管列表进行进一步的纵向划分。</p>
<p>Cluster将视锥体划分成多个体素块，在体素块中保存属于它的内容索引。体素块当中不止保存了灯光列表索引，还可以保存光照探针、Decal、Density Volume的内容。</p>
<p>FPTL目的是为了能够在一个pass当中读取所有的光照信息，这样就能够在一个Pass当中完成光照计算，节省了大量DrawCall。</p>
<p>如果要想查看灯光列表计算方式，查看LightLoops.cs源文件中的BuildGPULightListsCommon函数。</p>
<p><strong>下面简要介绍FPTL的计算过程和使用方式：</strong></p>
<ol start="0">
<li><p>首先需要场景中所有灯光，场景灯光是在CPU中统一收集的，记录了<strong>光照信息</strong>及其<strong>包围盒</strong>。</p>
</li>
<li><p>FPTL是基于屏幕坐标计算的所以需要将<strong>灯光转换到摄像机空间的矩阵（上一步已经完成）</strong>。</p>
<p><strong>这部分计算在函数LightLoop.cs:PrepareLightsForGPU当中。这部分主要是CPU计算。统计LightList,讲LightBounds转换到View空间</strong></p>
</li>
<li><p>生成剪裁空间的AABB包围盒：用于FPTL和Cluster。代码位于：Runtime&#x2F;Lighting&#x2F;LightLoop&#x2F;scrbound.compute</p>
</li>
</ol>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//scrbound.compute</span><br><span class="hljs-comment">// 读取光的AABB包围盒</span><br> SFiniteLightBound lgtDat = g_data[eyeAdjustedLgtIndex];<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">包围盒数据结构</span><br><span class="hljs-comment">    public struct SFiniteLightBound</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        public Vector3 boxAxisX;</span><br><span class="hljs-comment">        public Vector3 boxAxisY;</span><br><span class="hljs-comment">        public Vector3 boxAxisZ;</span><br><span class="hljs-comment">        public Vector3 center;        // a center in camera space inside the bounding volume of the light source.</span><br><span class="hljs-comment">        public Vector2 scaleXY;</span><br><span class="hljs-comment">        public float radius;</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">  */</span><br><br><span class="hljs-comment">// 包围盒的计算函数 LightingConvexHullUtils.hlsl</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">GetHullQuad</span><span class="hljs-params">(out float3 p0, out float3 p1, out float3 p2, out float3 p3, <span class="hljs-type">const</span> float3 boxX, <span class="hljs-type">const</span> float3 boxY, <span class="hljs-type">const</span> float3 boxZ, <span class="hljs-type">const</span> float3 center, <span class="hljs-type">const</span> float2 scaleXY, <span class="hljs-type">const</span> <span class="hljs-type">int</span> sideIndex)</span><br>&#123;<br>    <span class="hljs-comment">// 开启6个thread分别计算light的AABB的六个面在view空间的AABB凸包。因为线程每次提交8个所以两个thread被丢弃。</span><br>    ...<br>    GroupMemoryBarrierWithGroupSync();<br>    <span class="hljs-comment">// 保留6个thread中的第一个，组合成一个完整的AABB凸包。 计算在屏幕中的位置。其中包括了大量的优化计算。最终输出到g_vBoundsBuffer当中。这里面包括的z坐标。</span><br>    ...<br>    g_vBoundsBuffer[boundsIndices.min] = ...;<br>    g_vBoundsBuffer[boundsIndices.max] = ...;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>根据屏幕空间的AABB生成big-Tile：（enable coarse 2D pass on 64x64 tiles ）。目的是优化fptl和cluster的计算。</li>
</ol>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//lightlistbuild-bigtile.compute:BigTileLightListGen</span><br><span class="hljs-comment">//CPU提交时每一个big-tile提交一次。GPU每一次提交计算64个thread。</span><br><br>[numthreads(NR_THREADS, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-type">void</span> <span class="hljs-title function_">BigTileLightListGen</span><span class="hljs-params">(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID)</span><br>&#123;<br>    <span class="hljs-comment">// 首先64个thread同事计算所有光照列表，判断每一个光源的AABB是否在这个Tile当中。通过元操作进行累加和记录</span><br>    ...<br>	<span class="hljs-comment">// 在这个tile中，累加并返回uIndex当前值。</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> uInc = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> uIndex;<br>    InterlockedAdd(lightOffs, uInc, uIndex);<br>	<span class="hljs-comment">// 记录灯光索引</span><br>    <span class="hljs-keyword">if</span>(uIndex&lt;MAX_NR_BIGTILE_LIGHTS) lightsListLDS[uIndex] = l;     <span class="hljs-comment">// add to light list</span><br>    ...<br>    <span class="hljs-comment">// sort lights:对光源类型排序。</span><br>    SORTLIST(lightsListLDS, iNrCoarseLights, MAX_NR_BIG_TILE_LIGHTS_PLUS_ONE, t, NR_THREADS);<br>    ...<br>    <span class="hljs-comment">// 输出 :第一个放光源个数，后面是索引。</span><br> <span class="hljs-keyword">for</span>(i=t; i&lt;(iNrCoarseLights+<span class="hljs-number">1</span>); i+=NR_THREADS)<br>        g_vLightList[MAX_NR_BIG_TILE_LIGHTS_PLUS_ONE*offs + i] = i==<span class="hljs-number">0</span> ? iNrCoarseLights : lightsListLDS[max(i<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>)];<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>进行FPTL计算。参考相关论文或者Shader源代码。</li>
<li>进行Cluster计算，这里面不只包括了光照，还包括了环境光、Decal、DensityVolume。</li>
</ol>
<h3 id="3-3-光照计算"><a href="#3-3-光照计算" class="headerlink" title="3.3 光照计算"></a>3.3 光照计算</h3><p>​	完成光照计算和Gbuffer填充之后就可以进行最终的光照计算，HDRP的Gbuffer光照计算使用了Compute Shader。</p>
<p>Compute Shader源文件：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">HDRP/Runtime/Lighting/LightLoop: Deferred.compute.<br></code></pre></td></tr></table></figure>

<p>在lightloop函数当中读取了光照列表，使用BSDF函数计算最终的材质颜色。</p>
<h3 id="3-4-BSDF"><a href="#3-4-BSDF" class="headerlink" title="3.4 BSDF"></a>3.4 BSDF</h3><p>​		由于物体表面上有凹凸不平的微小表面，一道入射光线射到表面会产生光的散射现象，BSDF 用来表示这种散射现象（散射到各个方向的光的强度）。</p>
<p>Unity HDRP支持多种BSDF函数，例如：</p>
<p>Lit Shader的BSDF计算位于Lit.hlsl</p>
<p>Hair Shader的BSDF计算位于Hair.hlsl</p>
<h3 id="3-5-BSDF中PBR材质参数的意义"><a href="#3-5-BSDF中PBR材质参数的意义" class="headerlink" title="3.5 BSDF中PBR材质参数的意义"></a>3.5 BSDF中PBR材质参数的意义</h3><p>在光照计算当中除了光源的参数和BSDF函数以外，最重要的就是材质相关的参数，下面表格解释了基本的材质参数。结合了Unity人员的说明和Shader源代码总结了如下内容：</p>
<table>
<thead>
<tr>
<th align="left"><strong>Property</strong></th>
<th align="left"><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Base Color</strong></td>
<td align="left">表示物体颜色，不应该包含任何明暗、AO、阴影信息。除了基础颜色外，还可以包含一些偏色、或者色相的变化。</td>
</tr>
<tr>
<td align="left"><strong>Smoothness</strong></td>
<td align="left">平滑度，用来描述物体的粗糙程度。在Shader源代码中，Smoothness会转化成粗糙度进行计算。有两种粗糙度。PerceptualRoughness &#x3D; 1- smoothness。Roughness&#x3D; PerceptualRoughness * PerceptualRoughness；</td>
</tr>
<tr>
<td align="left">**Ambient Occlusion **</td>
<td align="left">AO贴图：unity人员说可以使用sRGB格式，也可以使用RGB格式，但是需要统一。主要用来控制环境光（间接光）的明暗，对于直接光照没有影响。AO用来表现物体的明暗层次。</td>
</tr>
<tr>
<td align="left"><strong>Mask Map</strong></td>
<td align="left">Assign a Texture that packs different Material maps into each of its RGBA channels. • <strong>Red</strong>: Stores the metallic map.  • <strong>Green</strong>: Stores the ambient occlusion map. • <strong>Blue</strong>: Stores the detail mask map. • <strong>Alpha</strong>: Stores the smoothness map.</td>
</tr>
<tr>
<td align="left">**Normal **</td>
<td align="left">法线，LitShader支持模型空间和切线空间的法线，使用模型空间法线，可以在LOD当中过度更好，使用切线空间法线，可以压缩纹理空间。</td>
</tr>
<tr>
<td align="left"><strong>Bent Normal</strong></td>
<td align="left">Bent normal实际上也是一个表面方向和Normal接近，主要用来优化AO效果，只对GI（lightmap&#x2F;lightprobe&#x2F;volume proxy）生效。shaer代码：builtinData.bakeDiffuseLighting &#x3D; SampleBakedGI(posInput.positionWS, bennormalWS, texCoord1.xy, texCoord2.xy);</td>
</tr>
<tr>
<td align="left"><strong>Coat Mask</strong></td>
<td align="left">Coat效果强弱，0-1之间</td>
</tr>
</tbody></table>
<h2 id="4-HDRP的其他渲染特性"><a href="#4-HDRP的其他渲染特性" class="headerlink" title="4. HDRP的其他渲染特性"></a>4. HDRP的其他渲染特性</h2><h3 id="4-1-StackLit"><a href="#4-1-StackLit" class="headerlink" title="4.1 StackLit"></a>4.1 StackLit</h3><p>Unity提供了ShaderGraph Package。能够实现LitShader当中的所有功能。但是无法修改光照计算。如果需要修改光照计算就需要手写Shader。默认的Shader Graph的Lit节点使用的是Deferred光照，所以能够支持的效果有限（由于Gbuffer容量限制）</p>
<p>为了实现更好的效果，<strong>Shader Graph提供了Forward模式的StackLit Master节点</strong>，它支持更加物理正确的Shading模型，提供了更多的渲染功能。</p>
<p>使用StackLit可以制作：包括头发、毛发、布料、皮肤等效果。但是<strong>Forward模式渲染开销非常大，所以不建议在游戏当中使用</strong>，但是可以在选人界面等简单场景使用。</p>
<h3 id="4-2-透明物体渲染"><a href="#4-2-透明物体渲染" class="headerlink" title="4.2 透明物体渲染"></a>4.2 透明物体渲染</h3><p>HDRP当中的所有透明物体都是在Forward下渲染的，所以渲染开销比较大。</p>
<p>除此之外透明物体还支持两个pass：TransparentDepthPrepas和TransparentDepthPostpass。下面是透明物体渲染部分的Pipeline代码和对应说明：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 渲染天空球 </span><br>RenderSky(hdCamera, cmd);<br><span class="hljs-comment">// 渲染透明物体的Prepass，用于处理透明物体之间的遮挡。</span><br>RenderTransparentDepthPrepass(cullingResults, hdCamera, renderContext, cmd);<br><br><br><span class="hljs-comment">// 渲染需要被折射的透明物体。RenderQueue:[2750-100,2750+100]</span><br>RenderForward(cullingResults, hdCamera, renderContext, cmd, ForwardPass.PreRefraction);<br><br><span class="hljs-comment">// 如果开启RoughRefraction，则生成ColorPyramid</span><br>&#123;<br>	...<br>    RenderColorPyramid(hdCamera, cmd, <span class="hljs-literal">true</span>);<br>&#125;<br><br>cmd.SetGlobalTexture(HDShaderIDs._ColorPyramidTexture, currentColorPyramid);<br><br><span class="hljs-comment">// 渲染所有其他透明物体。</span><br><span class="hljs-comment">// RenderQueue:[3000-100,3000+100]（没有开启LowResolutionTrans）</span><br><span class="hljs-comment">// RenderQueue:[3000-100,3400+100]（开启LowResolutionTrans）</span><br>RenderForward(cullingResults, hdCamera, renderContext, cmd, ForwardPass.Transparent);<br><br>...<br><br><span class="hljs-comment">// 渲染LowResTransparency。RenderQueue:[3400-100,3400+100]</span><br>DownsampleDepthForLowResTransparency(hdCamera, cmd);<br>RenderLowResTransparent(cullingResults, hdCamera, renderContext, cmd);<br>UpsampleTransparent(hdCamera, cmd);<br><br><span class="hljs-comment">// 渲染TransparentDepthPostpass，为了能够在需要深度的后处理效果中正确的处理透明物体  </span><br>RenderTransparentDepthPostpass(cullingResults, hdCamera, renderContext, cmd);<br><br><span class="hljs-comment">// 渲染颜色金字塔。</span><br>RenderColorPyramid(hdCamera, cmd, <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// 渲染扭曲效果。</span><br>AccumulateDistortion(cullingResults, hdCamera, renderContext, cmd);<br>RenderDistortion(hdCamera, cmd);<br></code></pre></td></tr></table></figure>

<p>上面提到了渲染LowResTransparency，如果要使用这个功能就需要在HDRPRenderPipelineAsset中开启LowResTransparency。</p>
<p>开启LowResTransparency后，材质中的LowRes属性生效。勾选这个属性，就会在低分辨率的RenderTarget上渲染这个透明物体，由于透明物体是Forward渲染。所以这样可以大幅提升效果。</p>
<p><strong>另外可以看到，代码是通过RenderQueue区分一个物体在什么时候被渲染的，所以不建议修改material的Queue，而是使用Priority。</strong>例如：在3200到3300这段区间的物体，如果HDRP设置中没有开启LowResTran选项，则永远不会被渲染。</p>
<h3 id="4-3-Decal"><a href="#4-3-Decal" class="headerlink" title="4.3 Decal"></a>4.3 Decal</h3><p>Unity HDRP提供了Decal的支持。原始Decal直接往Gbuffer写数据，而HDRP的Decal使用了Dbuffer先存储Decal的信息，然后在计算Gbuffer的过程中在合并到光照计算中。</p>
<p><strong>Decal有两种一种是Dbuffer Decal一种是ClusterDecal。</strong></p>
<p><strong>Dbuffer Decal：</strong>（Projector Decal就是一个方块，可以往Dbuffer（类似Gbuffer）写入Decal纹理）。</p>
<p><strong>Dbuffer 结构：</strong>类似Gbuffer结构，可以影响物体Diffuse，Normal，Emssive等，不需要GI信息（Dbuffer0,Dbuffer1,Dbuffer2）。</p>
<p>HDRenderPipelineAsset有设置:Metal &amp; Amitent Propterty，用来控制Decal是否影响金属度和AO，勾选以后就会多使用一张Dbuffer，增加开销。</p>
<p><strong>Emssive Decal：</strong>会多绘制一次。Emissive不能受光照影响。</p>
<p><strong>Mesh Decal：</strong>和透明物体很像，直接绘制到Debuffer当中。</p>
<p><strong>关于Decal物体的剪裁：</strong></p>
<p>Decal 参与Culling，所以在CPU上有消耗。我们可以仿照Decal的方式对我们自己管理的对象用Culling Group手动culling。</p>
<p><strong>ClusterDecal：</strong>HDRP支持透明物体的Decal，Dbuffer需要深度。不透明物体没有深度，所以不透明物体需要使用Cluster信息。与Cluster灯光原理一样。Decal 有Affect Transparent选项，开启后生效。</p>
<p><strong>不过LightList当中不光有Light信息，还有Reflection Probe ，Decal，Local Density Volume信息。</strong></p>
<p><strong>其他：</strong></p>
<p>视锥体内不依赖深度的简单物体都可以使用Cluster方式来做。这样就不用在CPU上做物体和物体的相交计算。通过记录索引可以让大部分物体进行合并。</p>
<p>例如：不是同一个Reflection Probe，可以Batch在一起。因为他们不依赖CPU来决定这次Batch使用哪一个Probe，而是通过LightList在GPU上实时计算。 然后通过Cluster当中的List查找信息。</p>
<p>Cluster Decal会被patch在一个大的纹理，一起传送给GPU，通过UV偏移来找。在Setting当中有decal相关选项：Atlas Weight和Atlas Height，这个选项直接影响占用显存的大小。</p>
<h3 id="4-4-体积光"><a href="#4-4-体积光" class="headerlink" title="4.4 体积光"></a>4.4 体积光</h3><p><strong>全局体积雾设置：</strong>场景当中的SceneSetting &#x2F;Volumetric Fog 是全局的体积光的设置。</p>
<p><strong>Density Volume局部的体积雾</strong>：只控制Abledo和浓度，其他的参数通过Global控制。</p>
<p><strong>基础原理：</strong></p>
<p>HDRP体积光不是屏幕空间的体积光（从屏幕空间 Reymarching），他是视锥体空间的3D体素纹理。有一个体素化的Pass，会把能看见的Density Volume体素化（Voxelization）到3D纹理里。Density Volume也是通过Cluster来记录的。体素化的时候通过ID知道是哪个Density Volume。</p>
<p><strong>Volumetric 参数：</strong></p>
<p>体积雾的颜色由大气散射决定（需要使用Precedual Sky），如果要用HDRISky，就需要自己计算大气散射颜色。</p>
<p>计算方式参考：Pre-compute Atemosphere Scattering相关文章。</p>
<p><strong>Phase Function（全局各向异性）：</strong>光线在各个方向的散射强度。类似BRDF函数。</p>
<p>不同的物体Phase Function不同，例如：冰晶（强透射和折射）、尘土（吸收阻挡光照）。Phase Function主要控制朝向光的时候亮，还是背向光的方向亮、已经高光环的形状。灰尘就是Phase Function（0）只有颜色，水就是越朝光看越亮，大晴天很少有所以一般做成0。</p>
<p><strong>相关设置：</strong>HDRenderPipelineAsset（涉及到资源分配的内容）当中可以设置精度（3D体素的分辨率）：Volumetric Hight Quality。</p>
<p>Hight Quality 是屏幕1&#x2F;4大小，slice是128.</p>
<p>Midum 是屏幕1&#x2F;8大小，深度slice是64.</p>
<p>PS4上测试：  屏幕1&#x2F;16 大小 , slice64耗时0.8毫秒。 优化时需要考虑：体素化、Volume数量。</p>
<p><strong>体积雾纵向切分方式：</strong></p>
<p>Slice Distribution Uniformition：Slice的分布，近处密集还是等距划分。</p>
<p>Depth Extrent：覆盖多远。</p>
<h2 id="5-HDRP与引擎自带模块"><a href="#5-HDRP与引擎自带模块" class="headerlink" title="5. HDRP与引擎自带模块"></a>5. HDRP与引擎自带模块</h2><p><strong>Culling 模块：</strong></p>
<p>我们可以定义自己的Custom数据，然后使用Unity的Culling Group，每帧收集数据转换成AABB让引擎Culling。HDRP的Volume、Decal都是使用的这种方式。</p>
<p><strong>Baking 模块：</strong></p>
<p>支持原始所有内容。</p>
<p>GI信息都是一个物体计算一次，在填充Gbuffer时计算。</p>
<p>小型物体推荐使用light probe。大物体推荐用Lightmap或者开启light probe volume。</p>
<h2 id="6-Package"><a href="#6-Package" class="headerlink" title="6. Package"></a>6. Package</h2><p><strong>Core Package：</strong></p>
<p>包含大量的基础c#渲染工具。</p>
<p>包含光照计算等基础的Shader函数。</p>
<p>包含重要的功能：Volume System。</p>
<p><strong>ShaderGraph：</strong></p>
<p><strong>基础功能：</strong>Lit和StackLit等自带master节点。</p>
<p><strong>扩展功能：</strong>ShaderGraph模板和Shader Custom Node。</p>
<p><strong>VFX：</strong></p>
<p>必须和HDRP一起用。需要Compute Shader，基于indrect Dispatch效率高。</p>
<p><strong>基础原理：</strong>将Compute buffer作为一个RWbuffer，放到compute Shader里面。在Compute Shader里面讲vertex buffer和index buffer动态生成好，然后把这个Compue buffer作为VB和IB传递到Graphic Pipeline里进行渲染。</p>
<p>LWRP不计划加入ComputeShader。</p>
<p><strong>扩展功能：</strong>VFX模板、自定义Shader、ShaderGraph（还不支持）</p>

      
      <p align="right"><a class="morebtn" href="/2022/07/09/HDRPsource/new1.HDRP%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%80%BB%E7%BB%93/" title="Unity HDRP主要功能和渲染管线的介绍">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://leinlin.github.io/2022/07/09/HDRPsource/new3.HDRP%20Shadow/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="leinlin">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="leinlin的小笔记">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2022/07/09/HDRPsource/new3.HDRP%20Shadow/" itemprop="url">new3.HDRP Shadow</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2022-07-09T12:00:14+08:00">2022-07-09 12:00:14</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/HDRPSource/" itemprop="url" rel="index"><span itemprop="name">HDRPSource</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="准备阴影Atlas："><a href="#准备阴影Atlas：" class="headerlink" title="准备阴影Atlas："></a>准备阴影Atlas：</h1><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在PrepareLightsForGPU当中分配阴影,PrepareLightsForGPU是用来CPU准备光照数据的</span><br><br><span class="hljs-comment">// 给阴影分配渲染请求，设置摄像机参数，阴影分辨率。</span><br>additionalData.ReserveShadows(camera, m_ShadowManager, m_ShadowInitParameters, cullResults, m_FrameSettings, lightIndex);<br><br>...<br><span class="hljs-comment">// Now that all the lights have requested a shadow resolution, we can layout them in the atlas</span><br><span class="hljs-comment">// And if needed rescale the whole atlas</span><br>m_ShadowManager.LayoutShadowMaps(debugDisplaySettings.data.lightingDebugSettings);<br></code></pre></td></tr></table></figure>

<p>当我设置多个方向光阴影的时候会报错，分配阴影贴图布局的方法：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-type">void</span> <span class="hljs-title function_">LayoutShadowMaps</span><span class="hljs-params">(LightingDebugSettings lightingDebugSettings)</span><br>&#123;<br>    m_Atlas.UpdateDebugSettings(lightingDebugSettings);<br><br>    <span class="hljs-keyword">if</span> (m_CascadeAtlas != null)<br>        m_CascadeAtlas.UpdateDebugSettings(lightingDebugSettings);<br><br>    m_AreaLightShadowAtlas.UpdateDebugSettings(lightingDebugSettings);<br><br>    <span class="hljs-keyword">if</span> (lightingDebugSettings.shadowResolutionScaleFactor != <span class="hljs-number">1.0f</span>)<br>    &#123;<br>        foreach (var shadowResolutionRequest in m_ShadowResolutionRequests)<br>        &#123;<br>            <span class="hljs-comment">// We don&#x27;t rescale the directional shadows with the global shadow scale factor</span><br>            <span class="hljs-comment">// because there is no dynamic atlas rescale when it overflow.</span><br>            <span class="hljs-keyword">if</span> (shadowResolutionRequest.shadowMapType != ShadowMapType.CascadedDirectional)<br>                shadowResolutionRequest.resolution *= lightingDebugSettings.shadowResolutionScaleFactor;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Assign a position to all the shadows in the atlas, and scale shadows if needed</span><br>    <span class="hljs-keyword">if</span> (m_CascadeAtlas != null &amp;&amp; !m_CascadeAtlas.Layout(<span class="hljs-literal">false</span>))<br>        Debug.LogError(<span class="hljs-string">&quot;Cascade Shadow atlasing has failed, only one directional light can cast shadows at a time&quot;</span>);<br>    m_Atlas.Layout();<br>    m_AreaLightShadowAtlas.Layout();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>渲染阴影的位置是在HDShadowAtlas类当中：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// HDShadowAtlas类</span><br><span class="hljs-comment">// 所有需要渲染阴影的灯光都会组织成一个HDShadowAtlas类。</span><br>public <span class="hljs-type">void</span> <span class="hljs-title function_">RenderShadows</span><span class="hljs-params">(ScriptableRenderContext renderContext, CommandBuffer cmd, ShadowDrawingSettings dss)</span><br>&#123;<br>    <span class="hljs-comment">// m_ShadowRequests是渲染阴影需要的所有的参数。</span><br>    <span class="hljs-keyword">if</span> (m_ShadowRequests.Count == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br>	<br>    <span class="hljs-comment">// shadow mask 纹理id</span><br>    cmd.SetRenderTarget(identifier);<br>    <span class="hljs-comment">// shadow 大小 </span><br>    cmd.SetGlobalVector(m_AtlasSizeShaderID, new Vector4(width, height, <span class="hljs-number">1.0f</span> / width, <span class="hljs-number">1.0f</span> / height));<br><br>    <span class="hljs-comment">// debug设置</span><br>    <span class="hljs-keyword">if</span> (m_LightingDebugSettings.clearShadowAtlas)<br>        CoreUtils.DrawFullScreen(cmd, m_ClearMaterial, null, <span class="hljs-number">0</span>);<br>	<br>    <span class="hljs-comment">// 渲染所以阴影请求，直线光渲染次数为级联阴影数。</span><br>    foreach (var shadowRequest in m_ShadowRequests)<br>    &#123;<br>        <span class="hljs-comment">// 设置渲染区域。</span><br>        cmd.SetViewport(shadowRequest.atlasViewport);<br>		<span class="hljs-comment">// 根据阴影设置是否启用zClip</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        zClip的设置：</span><br><span class="hljs-comment">        shadowRequest.zClip = (legacyLight.type != LightType.Directional);</span><br><span class="hljs-comment">        为什么关闭直线光的ZClip</span><br><span class="hljs-comment">        */</span><br>        cmd.SetGlobalFloat(HDShaderIDs._ZClip, shadowRequest.zClip ? <span class="hljs-number">1.0f</span> : <span class="hljs-number">0.0f</span>);<br>        <span class="hljs-keyword">if</span> (!m_LightingDebugSettings.clearShadowAtlas)<br>        &#123;<br>            CoreUtils.DrawFullScreen(cmd, m_ClearMaterial, null, <span class="hljs-number">0</span>);<br>        &#125;<br>		<br>        <span class="hljs-comment">// 读取灯光信息和剪裁信息</span><br>        dss.lightIndex = shadowRequest.lightIndex;<br>        dss.splitData = shadowRequest.splitData;<br><br>        <span class="hljs-comment">// 设置摄像机参数</span><br>        <span class="hljs-comment">// Setup matrices for shadow rendering:</span><br>        Matrix4x4 viewProjection = shadowRequest.deviceProjectionYFlip * shadowRequest.view;<br>        cmd.SetGlobalMatrix(HDShaderIDs._ViewMatrix, shadowRequest.view);<br>        cmd.SetGlobalMatrix(HDShaderIDs._InvViewMatrix, shadowRequest.view.inverse);<br>        cmd.SetGlobalMatrix(HDShaderIDs._ProjMatrix, shadowRequest.deviceProjectionYFlip);<br>        cmd.SetGlobalMatrix(HDShaderIDs._InvProjMatrix, shadowRequest.deviceProjectionYFlip.inverse);<br>        cmd.SetGlobalMatrix(HDShaderIDs._ViewProjMatrix, viewProjection);<br>        cmd.SetGlobalMatrix(HDShaderIDs._InvViewProjMatrix, viewProjection.inverse);<br>        cmd.SetGlobalVectorArray(HDShaderIDs._ShadowClipPlanes, shadowRequest.frustumPlanes);<br><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> remove this execute when DrawShadows will use a CommandBuffer</span><br>        <span class="hljs-comment">// 使用Command来绘制阴影，目前还没有实现？？</span><br>        renderContext.ExecuteCommandBuffer(cmd);<br>        cmd.Clear();<br><br>        renderContext.DrawShadows(ref dss);<br>    &#125;<br>	<br>    <span class="hljs-comment">// 设置Clip启用</span><br>    cmd.SetGlobalFloat(HDShaderIDs._ZClip, <span class="hljs-number">1.0f</span>);   <span class="hljs-comment">// Re-enable zclip globally</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p>HDShadowResolutionRequest表示一个灯光需要渲染阴影的次数。目前通过灯光类型，和shadow级联数决定，下面是所有相关的方法：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// =================HDAdditionalLightData:ReserveShadows====</span><br><span class="hljs-type">int</span> count = HDAdditionalLightData:GetShadowRequestCount();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = <span class="hljs-number">0</span>; index &lt; count; index++)<br>    m_ShadowRequestIndices[index] = shadowManager.ReserveShadowResolutions(viewportSize, shadowMapType);<br><br><span class="hljs-comment">// =================HDAdditionalLightData:GetShadowRequestCount====</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">GetShadowRequestCount</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (legacyLight.type == LightType.Point <br>            &amp;&amp; lightTypeExtent == LightTypeExtent.Punctual) ? <br>        	<span class="hljs-number">6</span> : <br>    		<span class="hljs-comment">// 如果是直线光，则渲染次数等于级联阴影数。</span><br>            (legacyLight.type == LightType.Directional) ? 				    m_ShadowSettings.cascadeShadowSplitCount.value : <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//==================HDShadowManager:ReserveShadowResolutions ======</span><br><span class="hljs-keyword">switch</span> (shadowMapType)<br>&#123;<br>    <span class="hljs-keyword">case</span> ShadowMapType.PunctualAtlas:<br>      m_Atlas.ReserveResolution(resolutionRequest);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ShadowMapType.AreaLightAtlas:<br>      m_AreaLightShadowAtlas.ReserveResolution(resolutionRequest);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ShadowMapType.CascadedDirectional:<br>      m_CascadeAtlas.ReserveResolution(resolutionRequest);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过级联数据和剪裁结果计算剪裁平面。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">cullResults.ComputeDirectionalShadowMatricesAndCullingPrimitives(lightIndex, (<span class="hljs-type">int</span>)cascadeIndex, cascadeCount, ratios, (<span class="hljs-type">int</span>)viewportSize.x, nearPlaneOffset, out view, out projection, out splitData);<br>           <br></code></pre></td></tr></table></figure>

<p>ShadowAtlas的纹理声明：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//	HDShadowManager:</span><br><span class="hljs-comment">// The cascade atlas will be allocated only if there is a directional light</span><br>m_Atlas = new HDShadowAtlas(renderPipelineResources, punctualLightAtlasInfo.shadowAtlasResolution, punctualLightAtlasInfo.shadowAtlasResolution, HDShaderIDs._ShadowAtlasSize, clearMaterial, <span class="hljs-literal">false</span>, depthBufferBits: punctualLightAtlasInfo.shadowAtlasDepthBits, name: <span class="hljs-string">&quot;Shadow Map Atlas&quot;</span>);<br><span class="hljs-comment">// Cascade atlas render texture will only be allocated if there is a shadow casting directional light</span><br><span class="hljs-type">bool</span> useMomentShadows = GetDirectionalShadowAlgorithm() == DirectionalShadowAlgorithm.IMS;<br>m_CascadeAtlas = new HDShadowAtlas(renderPipelineResources, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, HDShaderIDs._CascadeShadowAtlasSize, clearMaterial, useMomentShadows, depthBufferBits: directionalShadowDepthBits, name: <span class="hljs-string">&quot;Cascade Shadow Map Atlas&quot;</span>);<br><br>m_AreaLightShadowAtlas = new HDShadowAtlas(renderPipelineResources, areaLightAtlasInfo.shadowAtlasResolution, areaLightAtlasInfo.shadowAtlasResolution, HDShaderIDs._AreaShadowAtlasSize, clearMaterial, <span class="hljs-literal">false</span>, BlurredEVSM: <span class="hljs-literal">true</span>, depthBufferBits: areaLightAtlasInfo.shadowAtlasDepthBits, name: <span class="hljs-string">&quot;Area Light Shadow Map Atlas&quot;</span>);<br><br></code></pre></td></tr></table></figure>



<p>在HDRenderPipelineAsset当中可以设置每种Atlas的大小，以及每种纹理深度的精度。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// LightLoop</span><br><span class="hljs-comment">// 下面是阴影相关设置的使用位置。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitShadowSystem</span><span class="hljs-params">(HDRenderPipelineAsset hdAsset)</span><br>&#123;<br>    m_ShadowInitParameters = hdAsset.currentPlatformRenderPipelineSettings.hdShadowInitParams;<br>    m_ShadowManager = new HDShadowManager(<br>        hdAsset.renderPipelineResources,<br>        m_ShadowInitParameters.directionalShadowsDepthBits,<br>        m_ShadowInitParameters.punctualLightShadowAtlas,<br>        m_ShadowInitParameters.areaLightShadowAtlas,<br>        m_ShadowInitParameters.maxShadowRequests,<br>        hdAsset.renderPipelineResources.shaders.shadowClearPS<br>    );<br>&#125;<br></code></pre></td></tr></table></figure>



<p>Unity支持的Soft Shadow 类型：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-type">static</span> DirectionalShadowAlgorithm <span class="hljs-title function_">GetDirectionalShadowAlgorithm</span><span class="hljs-params">()</span><br>&#123;<br>    var hdAsset = (GraphicsSettings.renderPipelineAsset as HDRenderPipelineAsset);<br>    <span class="hljs-keyword">switch</span> (hdAsset.currentPlatformRenderPipelineSettings.hdShadowInitParams.shadowQuality)<br>    &#123;<br>        <span class="hljs-keyword">case</span> HDShadowQuality.Low:<br>            &#123;<br>                <span class="hljs-keyword">return</span> DirectionalShadowAlgorithm.PCF5x5;<br>            &#125;<br>        <span class="hljs-keyword">case</span> HDShadowQuality.Medium:<br>            &#123;<br>                <span class="hljs-keyword">return</span> DirectionalShadowAlgorithm.PCF7x7;<br>            &#125;<br>        <span class="hljs-keyword">case</span> HDShadowQuality.High:<br>            &#123;<br>                <span class="hljs-keyword">return</span> DirectionalShadowAlgorithm.PCSS;<br>            &#125;<br>        <span class="hljs-keyword">case</span> HDShadowQuality.VeryHigh:<br>            &#123;<br>                <span class="hljs-keyword">return</span> DirectionalShadowAlgorithm.IMS;<br>            &#125;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> DirectionalShadowAlgorithm.PCF5x5;<br>&#125;<br></code></pre></td></tr></table></figure>


      
      <p align="right"><a class="morebtn" href="/2022/07/09/HDRPsource/new3.HDRP%20Shadow/" title="new3.HDRP Shadow">阅读全文</a></p>
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fas fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/15/"><i class="fas fa-angle-right" aria-label="下一页"></i></a>
  </nav>
  
  
  

<div class="comments" id="comments">
  
  
  
</div>



  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control"/>
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/avatar.jpg" alt="leinlin">
  
  <h1 class="author-name">leinlin</h1>
  <h2 class="author-description"></h2>
  <div class="site-count">
    
    
    
    
    <div class="categories-count count-block">
      <div class="site-count-title">分类</div>
      <div><a href="/categories/">13</a></div>
    </div>
    
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    <hr>
    <div class="social-link sidebar-item">
      <div><i class="far fa-address-card"></i>社交链接</p></div>
      <ul>
        
        <li><i class="fab fa-github"></i><a href="https://leinlin.github.com/" target="_blank">GitHub</a></li>
        
      </ul>
    </div>
    
    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <button id="back-to-top"><i class="fas fa-angle-double-up" aria-label="回到顶部"></i></button>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">leinlin</span><span class="year"><i class="far fa-copyright"></i>2022</span>
        </div>
        
        <div class="busuanzi">
          <span id="busuanzi_container_site_pv"><i class="fas fa-eye" aria-label="站点点击量" aria-hidden="false"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user" aria-label="站点用户数" aria-hidden="false"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv" aria-label="页面点击量" aria-hidden="false"></span></span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
